Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_NEWLINE_optional _2_do_exprs_optional
Rule 2     _1_NEWLINE_optional -> NEWLINE
Rule 3     _1_NEWLINE_optional -> <empty>
Rule 4     _2_do_exprs_optional -> do_exprs
Rule 5     _2_do_exprs_optional -> <empty>
Rule 6     do_exprs -> expr _3_NEWLINE_optional
Rule 7     _3_NEWLINE_optional -> NEWLINE
Rule 8     _3_NEWLINE_optional -> <empty>
Rule 9     do_exprs -> expr NEWLINE do_exprs
Rule 10    expr -> ( expr )  [precedence=left, level=12]
Rule 11    expr -> str_inter
Rule 12    expr -> binary_op_def
Rule 13    expr -> unary_expr
Rule 14    expr -> str_literal
Rule 15    expr -> float_literal
Rule 16    expr -> int_literal
Rule 17    expr -> array
Rule 18    expr -> variant_call
Rule 19    expr -> identifier
Rule 20    expr -> let
Rule 21    expr -> call
Rule 22    expr -> case_of
Rule 23    expr -> binary_expr
Rule 24    expr -> if_expr
Rule 25    expr -> def_expr
Rule 26    expr -> do
Rule 27    expr -> external
Rule 28    expr -> enum
Rule 29    unary_expr -> + expr  [precedence=right, level=11]
Rule 30    unary_expr -> ! expr  [precedence=right, level=11]
Rule 31    unary_expr -> STRICT_NOT expr  [precedence=right, level=11]
Rule 32    unary_expr -> - expr  [precedence=right, level=11]
Rule 33    external -> EXTERNAL
Rule 34    binary_expr -> expr SOME_SUB expr  [precedence=right, level=7]
Rule 35    binary_expr -> expr SOME_CONCAT expr  [precedence=right, level=7]
Rule 36    binary_expr -> expr ARROW_BOTH expr  [precedence=left, level=6]
Rule 37    binary_expr -> expr ARROW_RIGHT expr  [precedence=left, level=6]
Rule 38    binary_expr -> expr ARROW_LEFT expr  [precedence=left, level=6]
Rule 39    binary_expr -> expr DOUBLE_ARROW_RIGHT expr  [precedence=left, level=6]
Rule 40    binary_expr -> expr DOUBLE_ARROW_LEFT expr  [precedence=left, level=6]
Rule 41    binary_expr -> expr BIT_SHIFT_RIGHT expr  [precedence=left, level=6]
Rule 42    binary_expr -> expr BIT_SHIFT_LEFT expr  [precedence=left, level=6]
Rule 43    binary_expr -> expr BIT_AND expr  [precedence=left, level=3]
Rule 44    binary_expr -> expr BIT_OR expr  [precedence=left, level=2]
Rule 45    binary_expr -> expr FLOAT_POW expr  [precedence=left, level=10]
Rule 46    binary_expr -> expr POW expr  [precedence=left, level=10]
Rule 47    binary_expr -> expr ARRAY_SUB expr  [precedence=right, level=7]
Rule 48    binary_expr -> expr ARRAY_CONCAT expr  [precedence=right, level=7]
Rule 49    binary_expr -> expr MORE_OR_EQ expr  [precedence=left, level=5]
Rule 50    binary_expr -> expr LESS_OR_EQ expr  [precedence=left, level=5]
Rule 51    binary_expr -> expr TEXT_MATCH expr  [precedence=left, level=4]
Rule 52    binary_expr -> expr STRICT_AND expr  [precedence=left, level=3]
Rule 53    binary_expr -> expr AND expr  [precedence=left, level=3]
Rule 54    binary_expr -> expr STRICT_OR expr  [precedence=left, level=2]
Rule 55    binary_expr -> expr OR expr  [precedence=left, level=2]
Rule 56    binary_expr -> expr EQUAL expr  [precedence=left, level=4]
Rule 57    binary_expr -> expr NOT_EQUAL expr  [precedence=left, level=4]
Rule 58    binary_expr -> expr > expr  [precedence=left, level=5]
Rule 59    binary_expr -> expr FLOAT_MUL expr  [precedence=left, level=9]
Rule 60    binary_expr -> expr FLOAT_DIV expr  [precedence=left, level=9]
Rule 61    binary_expr -> expr FLOAT_SUB expr  [precedence=left, level=8]
Rule 62    binary_expr -> expr FLOAT_SUM expr  [precedence=left, level=8]
Rule 63    binary_expr -> expr < expr  [precedence=left, level=5]
Rule 64    binary_expr -> expr * expr  [precedence=left, level=9]
Rule 65    binary_expr -> expr / expr  [precedence=left, level=9]
Rule 66    binary_expr -> expr - expr  [precedence=left, level=8]
Rule 67    binary_expr -> expr + expr  [precedence=left, level=8]
Rule 68    binary_expr -> expr CONCAT expr  [precedence=right, level=7]
Rule 69    binary_op -> SOME_SUB  [precedence=right, level=7]
Rule 70    binary_op -> SOME_CONCAT  [precedence=right, level=7]
Rule 71    binary_op -> ARROW_BOTH  [precedence=left, level=6]
Rule 72    binary_op -> ARROW_RIGHT  [precedence=left, level=6]
Rule 73    binary_op -> ARROW_LEFT  [precedence=left, level=6]
Rule 74    binary_op -> DOUBLE_ARROW_RIGHT  [precedence=left, level=6]
Rule 75    binary_op -> DOUBLE_ARROW_LEFT  [precedence=left, level=6]
Rule 76    binary_op -> BIT_SHIFT_RIGHT  [precedence=left, level=6]
Rule 77    binary_op -> BIT_SHIFT_LEFT  [precedence=left, level=6]
Rule 78    binary_op -> BIT_AND  [precedence=left, level=3]
Rule 79    binary_op -> BIT_OR  [precedence=left, level=2]
Rule 80    binary_op -> FLOAT_POW  [precedence=left, level=10]
Rule 81    binary_op -> POW  [precedence=left, level=10]
Rule 82    binary_op -> ARRAY_SUB  [precedence=right, level=7]
Rule 83    binary_op -> ARRAY_CONCAT  [precedence=right, level=7]
Rule 84    binary_op -> MORE_OR_EQ  [precedence=left, level=5]
Rule 85    binary_op -> LESS_OR_EQ  [precedence=left, level=5]
Rule 86    binary_op -> TEXT_MATCH  [precedence=left, level=4]
Rule 87    binary_op -> STRICT_AND  [precedence=left, level=3]
Rule 88    binary_op -> AND  [precedence=left, level=3]
Rule 89    binary_op -> STRICT_OR  [precedence=left, level=2]
Rule 90    binary_op -> OR  [precedence=left, level=2]
Rule 91    binary_op -> EQUAL  [precedence=left, level=4]
Rule 92    binary_op -> NOT_EQUAL  [precedence=left, level=4]
Rule 93    binary_op -> >  [precedence=left, level=5]
Rule 94    binary_op -> FLOAT_MUL  [precedence=left, level=9]
Rule 95    binary_op -> FLOAT_DIV  [precedence=left, level=9]
Rule 96    binary_op -> FLOAT_SUB  [precedence=left, level=8]
Rule 97    binary_op -> FLOAT_SUM  [precedence=left, level=8]
Rule 98    binary_op -> <  [precedence=left, level=5]
Rule 99    binary_op -> *  [precedence=left, level=9]
Rule 100   binary_op -> /  [precedence=left, level=9]
Rule 101   binary_op -> -  [precedence=left, level=8]
Rule 102   binary_op -> +  [precedence=left, level=8]
Rule 103   binary_op -> CONCAT  [precedence=right, level=7]
Rule 104   binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do  [precedence=left, level=12]
Rule 105   _4_NEWLINE_optional -> NEWLINE
Rule 106   _4_NEWLINE_optional -> <empty>
Rule 107   _5_NEWLINE_optional -> NEWLINE
Rule 108   _5_NEWLINE_optional -> <empty>
Rule 109   _6_NEWLINE_optional -> NEWLINE
Rule 110   _6_NEWLINE_optional -> <empty>
Rule 111   _7_0x3a_type_optional -> : type
Rule 112   _7_0x3a_type_optional -> <empty>
Rule 113   binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do  [precedence=left, level=12]
Rule 114   _8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items
Rule 115   _8_0x2c_type_identifier_repeat -> <empty>
Rule 116   _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item
Rule 117   _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item
Rule 118   _8_0x2c_type_identifier_item -> , type_identifier
Rule 119   _9_NEWLINE_optional -> NEWLINE
Rule 120   _9_NEWLINE_optional -> <empty>
Rule 121   _10_NEWLINE_optional -> NEWLINE
Rule 122   _10_NEWLINE_optional -> <empty>
Rule 123   _11_NEWLINE_optional -> NEWLINE
Rule 124   _11_NEWLINE_optional -> <empty>
Rule 125   _12_0x3a_type_optional -> : type
Rule 126   _12_0x3a_type_optional -> <empty>
Rule 127   do -> DO _13_0x3a_type_optional block_statement END
Rule 128   _13_0x3a_type_optional -> : type
Rule 129   _13_0x3a_type_optional -> <empty>
Rule 130   block_statement -> _14_NEWLINE_optional _15_do_exprs_optional
Rule 131   _14_NEWLINE_optional -> NEWLINE
Rule 132   _14_NEWLINE_optional -> <empty>
Rule 133   _15_do_exprs_optional -> do_exprs
Rule 134   _15_do_exprs_optional -> <empty>
Rule 135   def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do  [precedence=left, level=12]
Rule 136   _16_NEWLINE_optional -> NEWLINE
Rule 137   _16_NEWLINE_optional -> <empty>
Rule 138   _17_params_optional -> params
Rule 139   _17_params_optional -> <empty>
Rule 140   _18_0x3a_type_optional -> : type
Rule 141   _18_0x3a_type_optional -> <empty>
Rule 142   def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do  [precedence=left, level=12]
Rule 143   _19_0x2c_type_identifier_repeat -> _19_0x2c_type_identifier_items
Rule 144   _19_0x2c_type_identifier_repeat -> <empty>
Rule 145   _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item
Rule 146   _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_item
Rule 147   _19_0x2c_type_identifier_item -> , type_identifier
Rule 148   _20_NEWLINE_optional -> NEWLINE
Rule 149   _20_NEWLINE_optional -> <empty>
Rule 150   _21_params_optional -> params
Rule 151   _21_params_optional -> <empty>
Rule 152   _22_0x3a_type_optional -> : type
Rule 153   _22_0x3a_type_optional -> <empty>
Rule 154   params -> param _23_NEWLINE_optional
Rule 155   _23_NEWLINE_optional -> NEWLINE
Rule 156   _23_NEWLINE_optional -> <empty>
Rule 157   params -> params , _24_NEWLINE_optional param _25_NEWLINE_optional
Rule 158   _24_NEWLINE_optional -> NEWLINE
Rule 159   _24_NEWLINE_optional -> <empty>
Rule 160   _25_NEWLINE_optional -> NEWLINE
Rule 161   _25_NEWLINE_optional -> <empty>
Rule 162   type -> type_identifier < type _26_0x2c_type_repeat >  [precedence=left, level=5]
Rule 163   _26_0x2c_type_repeat -> _26_0x2c_type_items
Rule 164   _26_0x2c_type_repeat -> <empty>
Rule 165   _26_0x2c_type_items -> _26_0x2c_type_items _26_0x2c_type_item
Rule 166   _26_0x2c_type_items -> _26_0x2c_type_item
Rule 167   _26_0x2c_type_item -> , type
Rule 168   type -> type_identifier
Rule 169   enum -> TYPE type_identifier
Rule 170   enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional  [precedence=right, level=1]
Rule 171   _27_NEWLINE_optional -> NEWLINE
Rule 172   _27_NEWLINE_optional -> <empty>
Rule 173   _28_type_variants_optional -> type_variants
Rule 174   _28_type_variants_optional -> <empty>
Rule 175   enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
Rule 176   _29_0x2c_type_identifier_repeat -> _29_0x2c_type_identifier_items
Rule 177   _29_0x2c_type_identifier_repeat -> <empty>
Rule 178   _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item
Rule 179   _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_item
Rule 180   _29_0x2c_type_identifier_item -> , type_identifier
Rule 181   _30_NEWLINE_optional -> NEWLINE
Rule 182   _30_NEWLINE_optional -> <empty>
Rule 183   _31_type_variants_optional -> type_variants
Rule 184   _31_type_variants_optional -> <empty>
Rule 185   enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
Rule 186   _32_NEWLINE_optional -> NEWLINE
Rule 187   _32_NEWLINE_optional -> <empty>
Rule 188   _33_variants_optional -> variants
Rule 189   _33_variants_optional -> <empty>
Rule 190   enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
Rule 191   _34_0x2c_type_identifier_repeat -> _34_0x2c_type_identifier_items
Rule 192   _34_0x2c_type_identifier_repeat -> <empty>
Rule 193   _34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_items _34_0x2c_type_identifier_item
Rule 194   _34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_item
Rule 195   _34_0x2c_type_identifier_item -> , type_identifier
Rule 196   _35_NEWLINE_optional -> NEWLINE
Rule 197   _35_NEWLINE_optional -> <empty>
Rule 198   _36_variants_optional -> variants
Rule 199   _36_variants_optional -> <empty>
Rule 200   type_variants -> variant _37_NEWLINE_optional
Rule 201   _37_NEWLINE_optional -> NEWLINE
Rule 202   _37_NEWLINE_optional -> <empty>
Rule 203   type_variants -> type_variants LINE variant _38_NEWLINE_optional
Rule 204   _38_NEWLINE_optional -> NEWLINE
Rule 205   _38_NEWLINE_optional -> <empty>
Rule 206   variants -> variant _39_NEWLINE_optional
Rule 207   _39_NEWLINE_optional -> NEWLINE
Rule 208   _39_NEWLINE_optional -> <empty>
Rule 209   variants -> variants variant _40_NEWLINE_optional
Rule 210   _40_NEWLINE_optional -> NEWLINE
Rule 211   _40_NEWLINE_optional -> <empty>
Rule 212   variant -> type_identifier
Rule 213   variant -> type_identifier ( type _41_0x2c_type_repeat )  [precedence=left, level=12]
Rule 214   _41_0x2c_type_repeat -> _41_0x2c_type_items
Rule 215   _41_0x2c_type_repeat -> <empty>
Rule 216   _41_0x2c_type_items -> _41_0x2c_type_items _41_0x2c_type_item
Rule 217   _41_0x2c_type_items -> _41_0x2c_type_item
Rule 218   _41_0x2c_type_item -> , type
Rule 219   param -> identifier _42_0x3a_type_optional
Rule 220   _42_0x3a_type_optional -> : type
Rule 221   _42_0x3a_type_optional -> <empty>
Rule 222   if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
Rule 223   _43_0x3a_type_optional -> : type
Rule 224   _43_0x3a_type_optional -> <empty>
Rule 225   _44_or_else_optional -> or_else
Rule 226   _44_or_else_optional -> <empty>
Rule 227   or_else -> ELIF expr THEN block_statement _45_or_else_optional
Rule 228   _45_or_else_optional -> or_else
Rule 229   _45_or_else_optional -> <empty>
Rule 230   or_else -> ELSE block_statement
Rule 231   case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END
Rule 232   _46_NEWLINE_optional -> NEWLINE
Rule 233   _46_NEWLINE_optional -> <empty>
Rule 234   _47_cases_optional -> cases
Rule 235   _47_cases_optional -> <empty>
Rule 236   cases -> pattern do _48_NEWLINE_optional
Rule 237   _48_NEWLINE_optional -> NEWLINE
Rule 238   _48_NEWLINE_optional -> <empty>
Rule 239   cases -> cases pattern do _49_NEWLINE_optional
Rule 240   _49_NEWLINE_optional -> NEWLINE
Rule 241   _49_NEWLINE_optional -> <empty>
Rule 242   pattern -> match_variant
Rule 243   pattern -> match_as
Rule 244   match_as -> identifier
Rule 245   match_variant -> type_identifier
Rule 246   match_variant -> type_identifier ( _50_NEWLINE_optional _51_patterns_optional )  [precedence=left, level=12]
Rule 247   _50_NEWLINE_optional -> NEWLINE
Rule 248   _50_NEWLINE_optional -> <empty>
Rule 249   _51_patterns_optional -> patterns
Rule 250   _51_patterns_optional -> <empty>
Rule 251   patterns -> pattern _52_NEWLINE_optional
Rule 252   _52_NEWLINE_optional -> NEWLINE
Rule 253   _52_NEWLINE_optional -> <empty>
Rule 254   patterns -> patterns , _53_NEWLINE_optional pattern _54_NEWLINE_optional
Rule 255   _53_NEWLINE_optional -> NEWLINE
Rule 256   _53_NEWLINE_optional -> <empty>
Rule 257   _54_NEWLINE_optional -> NEWLINE
Rule 258   _54_NEWLINE_optional -> <empty>
Rule 259   array -> [ _55_NEWLINE_optional _56_exprs_optional ]
Rule 260   _55_NEWLINE_optional -> NEWLINE
Rule 261   _55_NEWLINE_optional -> <empty>
Rule 262   _56_exprs_optional -> exprs
Rule 263   _56_exprs_optional -> <empty>
Rule 264   call -> expr ( _57_NEWLINE_optional _58_exprs_optional )  [precedence=left, level=12]
Rule 265   _57_NEWLINE_optional -> NEWLINE
Rule 266   _57_NEWLINE_optional -> <empty>
Rule 267   _58_exprs_optional -> exprs
Rule 268   _58_exprs_optional -> <empty>
Rule 269   variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional )  [precedence=left, level=12]
Rule 270   _59_NEWLINE_optional -> NEWLINE
Rule 271   _59_NEWLINE_optional -> <empty>
Rule 272   _60_exprs_optional -> exprs
Rule 273   _60_exprs_optional -> <empty>
Rule 274   exprs -> expr _61_NEWLINE_optional
Rule 275   _61_NEWLINE_optional -> NEWLINE
Rule 276   _61_NEWLINE_optional -> <empty>
Rule 277   exprs -> exprs , _62_NEWLINE_optional expr _63_NEWLINE_optional
Rule 278   _62_NEWLINE_optional -> NEWLINE
Rule 279   _62_NEWLINE_optional -> <empty>
Rule 280   _63_NEWLINE_optional -> NEWLINE
Rule 281   _63_NEWLINE_optional -> <empty>
Rule 282   identifier -> IDENTIFIER
Rule 283   type_identifier -> TYPE_IDENTIFIER
Rule 284   let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr  [precedence=left, level=5]
Rule 285   _64_0x2c_type_repeat -> _64_0x2c_type_items
Rule 286   _64_0x2c_type_repeat -> <empty>
Rule 287   _64_0x2c_type_items -> _64_0x2c_type_items _64_0x2c_type_item
Rule 288   _64_0x2c_type_items -> _64_0x2c_type_item
Rule 289   _64_0x2c_type_item -> , type
Rule 290   let -> identifier _65_0x3a_type_optional = expr  [precedence=right, level=1]
Rule 291   _65_0x3a_type_optional -> : type
Rule 292   _65_0x3a_type_optional -> <empty>
Rule 293   int_literal -> INT
Rule 294   float_literal -> FLOAT
Rule 295   str_literal -> STRING
Rule 296   str_inter -> INTERPOLATION_LEFT expr inter_or_str
Rule 297   inter_or_str -> INTERPOLATION_BOTH expr inter_or_str
Rule 298   inter_or_str -> INTERPOLATION_RIGHT

Terminals, with rules where they appear:

!                    : 30
(                    : 10 104 113 135 142 213 246 264 269
)                    : 10 104 113 135 142 213 246 264 269
*                    : 64 99
+                    : 29 67 102
,                    : 104 113 118 147 157 167 180 195 218 254 277 289
-                    : 32 66 101
/                    : 65 100
:                    : 111 125 128 140 152 220 223 284 291
<                    : 63 98 113 142 162 175 190 284
=                    : 170 175 290
>                    : 58 93 113 142 162 175 190
AND                  : 53 88
ARRAY_CONCAT         : 48 83
ARRAY_SUB            : 47 82
ARROW_BOTH           : 36 71
ARROW_LEFT           : 38 73
ARROW_RIGHT          : 37 72
BIT_AND              : 43 78
BIT_OR               : 44 79
BIT_SHIFT_LEFT       : 42 77
BIT_SHIFT_RIGHT      : 41 76
CASE                 : 231
CONCAT               : 68 103
DEF                  : 104 113 135 142
DO                   : 127
DOUBLE_ARROW_LEFT    : 40 75
DOUBLE_ARROW_RIGHT   : 39 74
ELIF                 : 227
ELSE                 : 230
END                  : 127 222 231
ENUM                 : 185 190
EQUAL                : 56 91
EXTERNAL             : 33
FLOAT                : 294
FLOAT_DIV            : 60 95
FLOAT_MUL            : 59 94
FLOAT_POW            : 45 80
FLOAT_SUB            : 61 96
FLOAT_SUM            : 62 97
IDENTIFIER           : 282
IF                   : 222
INT                  : 293
INTERPOLATION_BOTH   : 297
INTERPOLATION_LEFT   : 296
INTERPOLATION_RIGHT  : 298
LESS_OR_EQ           : 50 85
LINE                 : 203
MORE_OR_EQ           : 49 84 284
NEWLINE              : 2 7 9 105 107 109 119 121 123 131 136 148 155 158 160 171 181 186 196 201 204 207 210 232 237 240 247 252 255 257 260 265 270 275 278 280
NOT_EQUAL            : 57 92
OF                   : 231
OR                   : 55 90
POW                  : 46 81
SOME_CONCAT          : 35 70
SOME_SUB             : 34 69
STRICT_AND           : 52 87
STRICT_NOT           : 31
STRICT_OR            : 54 89
STRING               : 295
TEXT_MATCH           : 51 86
THEN                 : 222 227
TYPE                 : 169 170 175
TYPE_IDENTIFIER      : 283
[                    : 259
]                    : 259
error                : 
{                    : 185 190
}                    : 175 185 190

Nonterminals, with rules where they appear:

_10_NEWLINE_optional : 113
_11_NEWLINE_optional : 113
_12_0x3a_type_optional : 113
_13_0x3a_type_optional : 127
_14_NEWLINE_optional : 130
_15_do_exprs_optional : 130
_16_NEWLINE_optional : 135
_17_params_optional  : 135
_18_0x3a_type_optional : 135
_19_0x2c_type_identifier_item : 145 146
_19_0x2c_type_identifier_items : 143 145
_19_0x2c_type_identifier_repeat : 142
_1_NEWLINE_optional  : 1
_20_NEWLINE_optional : 142
_21_params_optional  : 142
_22_0x3a_type_optional : 142
_23_NEWLINE_optional : 154
_24_NEWLINE_optional : 157
_25_NEWLINE_optional : 157
_26_0x2c_type_item   : 165 166
_26_0x2c_type_items  : 163 165
_26_0x2c_type_repeat : 162
_27_NEWLINE_optional : 170
_28_type_variants_optional : 170
_29_0x2c_type_identifier_item : 178 179
_29_0x2c_type_identifier_items : 176 178
_29_0x2c_type_identifier_repeat : 175
_2_do_exprs_optional : 1
_30_NEWLINE_optional : 175
_31_type_variants_optional : 175
_32_NEWLINE_optional : 185
_33_variants_optional : 185
_34_0x2c_type_identifier_item : 193 194
_34_0x2c_type_identifier_items : 191 193
_34_0x2c_type_identifier_repeat : 190
_35_NEWLINE_optional : 190
_36_variants_optional : 190
_37_NEWLINE_optional : 200
_38_NEWLINE_optional : 203
_39_NEWLINE_optional : 206
_3_NEWLINE_optional  : 6
_40_NEWLINE_optional : 209
_41_0x2c_type_item   : 216 217
_41_0x2c_type_items  : 214 216
_41_0x2c_type_repeat : 213
_42_0x3a_type_optional : 219
_43_0x3a_type_optional : 222
_44_or_else_optional : 222
_45_or_else_optional : 227
_46_NEWLINE_optional : 231
_47_cases_optional   : 231
_48_NEWLINE_optional : 236
_49_NEWLINE_optional : 239
_4_NEWLINE_optional  : 104
_50_NEWLINE_optional : 246
_51_patterns_optional : 246
_52_NEWLINE_optional : 251
_53_NEWLINE_optional : 254
_54_NEWLINE_optional : 254
_55_NEWLINE_optional : 259
_56_exprs_optional   : 259
_57_NEWLINE_optional : 264
_58_exprs_optional   : 264
_59_NEWLINE_optional : 269
_5_NEWLINE_optional  : 104
_60_exprs_optional   : 269
_61_NEWLINE_optional : 274
_62_NEWLINE_optional : 277
_63_NEWLINE_optional : 277
_64_0x2c_type_item   : 287 288
_64_0x2c_type_items  : 285 287
_64_0x2c_type_repeat : 284
_65_0x3a_type_optional : 290
_6_NEWLINE_optional  : 104
_7_0x3a_type_optional : 104
_8_0x2c_type_identifier_item : 116 117
_8_0x2c_type_identifier_items : 114 116
_8_0x2c_type_identifier_repeat : 113
_9_NEWLINE_optional  : 113
array                : 17
binary_expr          : 23
binary_op            : 104 113
binary_op_def        : 12
block_statement      : 127 222 227 230
call                 : 21
case_of              : 22
cases                : 234 239
def_expr             : 25
do                   : 26 104 113 135 142 236 239
do_exprs             : 4 9 133
enum                 : 28
expr                 : 6 9 10 29 30 31 32 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 222 227 231 264 274 277 284 290 296 297
exprs                : 262 267 272 277
external             : 27
float_literal        : 15
identifier           : 19 135 142 219 244 284 290
if_expr              : 24
int_literal          : 16
inter_or_str         : 296 297
let                  : 20
match_as             : 243
match_variant        : 242
or_else              : 225 228
param                : 104 104 113 113 154 157
params               : 138 150 157
pattern              : 236 239 251 254
patterns             : 249 254
program              : 0
str_inter            : 11
str_literal          : 14
type                 : 111 125 128 140 152 162 167 213 218 220 223 284 289 291
type_identifier      : 113 118 142 147 162 168 169 170 175 175 180 185 190 190 195 212 213 245 246 269 284
type_variants        : 173 183 203
unary_expr           : 13
variant              : 200 203 206 209
variant_call         : 18
variants             : 188 198 209


state 0

    (0) S' -> . program
    (1) program -> . _1_NEWLINE_optional _2_do_exprs_optional
    (2) _1_NEWLINE_optional -> . NEWLINE
    (3) _1_NEWLINE_optional -> .
    NEWLINE         shift and go to state 3
    (               reduce using rule 3 (_1_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 3 (_1_NEWLINE_optional -> .)
    DEF             reduce using rule 3 (_1_NEWLINE_optional -> .)
    +               reduce using rule 3 (_1_NEWLINE_optional -> .)
    !               reduce using rule 3 (_1_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 3 (_1_NEWLINE_optional -> .)
    -               reduce using rule 3 (_1_NEWLINE_optional -> .)
    STRING          reduce using rule 3 (_1_NEWLINE_optional -> .)
    FLOAT           reduce using rule 3 (_1_NEWLINE_optional -> .)
    INT             reduce using rule 3 (_1_NEWLINE_optional -> .)
    [               reduce using rule 3 (_1_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 3 (_1_NEWLINE_optional -> .)
    CASE            reduce using rule 3 (_1_NEWLINE_optional -> .)
    IF              reduce using rule 3 (_1_NEWLINE_optional -> .)
    DO              reduce using rule 3 (_1_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 3 (_1_NEWLINE_optional -> .)
    TYPE            reduce using rule 3 (_1_NEWLINE_optional -> .)
    ENUM            reduce using rule 3 (_1_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 3 (_1_NEWLINE_optional -> .)
    $end            reduce using rule 3 (_1_NEWLINE_optional -> .)

    program                        shift and go to state 1
    _1_NEWLINE_optional            shift and go to state 2

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_NEWLINE_optional . _2_do_exprs_optional
    (4) _2_do_exprs_optional -> . do_exprs
    (5) _2_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 5 (_2_do_exprs_optional -> .)
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    _2_do_exprs_optional           shift and go to state 4
    do_exprs                       shift and go to state 5
    expr                           shift and go to state 6
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 3

    (2) _1_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_LEFT reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    TYPE            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    $end            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)


state 4

    (1) program -> _1_NEWLINE_optional _2_do_exprs_optional .
    $end            reduce using rule 1 (program -> _1_NEWLINE_optional _2_do_exprs_optional .)


state 5

    (4) _2_do_exprs_optional -> do_exprs .
    $end            reduce using rule 4 (_2_do_exprs_optional -> do_exprs .)


state 6

    (6) do_exprs -> expr . _3_NEWLINE_optional
    (9) do_exprs -> expr . NEWLINE do_exprs
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    (7) _3_NEWLINE_optional -> . NEWLINE
    (8) _3_NEWLINE_optional -> .
    NEWLINE         shift and go to state 46
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82
    $end            reduce using rule 8 (_3_NEWLINE_optional -> .)
    END             reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELIF            reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELSE            reduce using rule 8 (_3_NEWLINE_optional -> .)

    _3_NEWLINE_optional            shift and go to state 45

state 7

    (10) expr -> ( . expr )
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 83
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 8

    (11) expr -> str_inter .
    NEWLINE         reduce using rule 11 (expr -> str_inter .)
    (               reduce using rule 11 (expr -> str_inter .)
    SOME_SUB        reduce using rule 11 (expr -> str_inter .)
    SOME_CONCAT     reduce using rule 11 (expr -> str_inter .)
    ARROW_BOTH      reduce using rule 11 (expr -> str_inter .)
    ARROW_RIGHT     reduce using rule 11 (expr -> str_inter .)
    ARROW_LEFT      reduce using rule 11 (expr -> str_inter .)
    DOUBLE_ARROW_RIGHT reduce using rule 11 (expr -> str_inter .)
    DOUBLE_ARROW_LEFT reduce using rule 11 (expr -> str_inter .)
    BIT_SHIFT_RIGHT reduce using rule 11 (expr -> str_inter .)
    BIT_SHIFT_LEFT  reduce using rule 11 (expr -> str_inter .)
    BIT_AND         reduce using rule 11 (expr -> str_inter .)
    BIT_OR          reduce using rule 11 (expr -> str_inter .)
    FLOAT_POW       reduce using rule 11 (expr -> str_inter .)
    POW             reduce using rule 11 (expr -> str_inter .)
    ARRAY_SUB       reduce using rule 11 (expr -> str_inter .)
    ARRAY_CONCAT    reduce using rule 11 (expr -> str_inter .)
    MORE_OR_EQ      reduce using rule 11 (expr -> str_inter .)
    LESS_OR_EQ      reduce using rule 11 (expr -> str_inter .)
    TEXT_MATCH      reduce using rule 11 (expr -> str_inter .)
    STRICT_AND      reduce using rule 11 (expr -> str_inter .)
    AND             reduce using rule 11 (expr -> str_inter .)
    STRICT_OR       reduce using rule 11 (expr -> str_inter .)
    OR              reduce using rule 11 (expr -> str_inter .)
    EQUAL           reduce using rule 11 (expr -> str_inter .)
    NOT_EQUAL       reduce using rule 11 (expr -> str_inter .)
    >               reduce using rule 11 (expr -> str_inter .)
    FLOAT_MUL       reduce using rule 11 (expr -> str_inter .)
    FLOAT_DIV       reduce using rule 11 (expr -> str_inter .)
    FLOAT_SUB       reduce using rule 11 (expr -> str_inter .)
    FLOAT_SUM       reduce using rule 11 (expr -> str_inter .)
    <               reduce using rule 11 (expr -> str_inter .)
    *               reduce using rule 11 (expr -> str_inter .)
    /               reduce using rule 11 (expr -> str_inter .)
    -               reduce using rule 11 (expr -> str_inter .)
    +               reduce using rule 11 (expr -> str_inter .)
    CONCAT          reduce using rule 11 (expr -> str_inter .)
    $end            reduce using rule 11 (expr -> str_inter .)
    )               reduce using rule 11 (expr -> str_inter .)
    INTERPOLATION_BOTH reduce using rule 11 (expr -> str_inter .)
    INTERPOLATION_RIGHT reduce using rule 11 (expr -> str_inter .)
    OF              reduce using rule 11 (expr -> str_inter .)
    THEN            reduce using rule 11 (expr -> str_inter .)
    END             reduce using rule 11 (expr -> str_inter .)
    ELIF            reduce using rule 11 (expr -> str_inter .)
    ELSE            reduce using rule 11 (expr -> str_inter .)
    ,               reduce using rule 11 (expr -> str_inter .)
    ]               reduce using rule 11 (expr -> str_inter .)


state 9

    (12) expr -> binary_op_def .
    NEWLINE         reduce using rule 12 (expr -> binary_op_def .)
    (               reduce using rule 12 (expr -> binary_op_def .)
    SOME_SUB        reduce using rule 12 (expr -> binary_op_def .)
    SOME_CONCAT     reduce using rule 12 (expr -> binary_op_def .)
    ARROW_BOTH      reduce using rule 12 (expr -> binary_op_def .)
    ARROW_RIGHT     reduce using rule 12 (expr -> binary_op_def .)
    ARROW_LEFT      reduce using rule 12 (expr -> binary_op_def .)
    DOUBLE_ARROW_RIGHT reduce using rule 12 (expr -> binary_op_def .)
    DOUBLE_ARROW_LEFT reduce using rule 12 (expr -> binary_op_def .)
    BIT_SHIFT_RIGHT reduce using rule 12 (expr -> binary_op_def .)
    BIT_SHIFT_LEFT  reduce using rule 12 (expr -> binary_op_def .)
    BIT_AND         reduce using rule 12 (expr -> binary_op_def .)
    BIT_OR          reduce using rule 12 (expr -> binary_op_def .)
    FLOAT_POW       reduce using rule 12 (expr -> binary_op_def .)
    POW             reduce using rule 12 (expr -> binary_op_def .)
    ARRAY_SUB       reduce using rule 12 (expr -> binary_op_def .)
    ARRAY_CONCAT    reduce using rule 12 (expr -> binary_op_def .)
    MORE_OR_EQ      reduce using rule 12 (expr -> binary_op_def .)
    LESS_OR_EQ      reduce using rule 12 (expr -> binary_op_def .)
    TEXT_MATCH      reduce using rule 12 (expr -> binary_op_def .)
    STRICT_AND      reduce using rule 12 (expr -> binary_op_def .)
    AND             reduce using rule 12 (expr -> binary_op_def .)
    STRICT_OR       reduce using rule 12 (expr -> binary_op_def .)
    OR              reduce using rule 12 (expr -> binary_op_def .)
    EQUAL           reduce using rule 12 (expr -> binary_op_def .)
    NOT_EQUAL       reduce using rule 12 (expr -> binary_op_def .)
    >               reduce using rule 12 (expr -> binary_op_def .)
    FLOAT_MUL       reduce using rule 12 (expr -> binary_op_def .)
    FLOAT_DIV       reduce using rule 12 (expr -> binary_op_def .)
    FLOAT_SUB       reduce using rule 12 (expr -> binary_op_def .)
    FLOAT_SUM       reduce using rule 12 (expr -> binary_op_def .)
    <               reduce using rule 12 (expr -> binary_op_def .)
    *               reduce using rule 12 (expr -> binary_op_def .)
    /               reduce using rule 12 (expr -> binary_op_def .)
    -               reduce using rule 12 (expr -> binary_op_def .)
    +               reduce using rule 12 (expr -> binary_op_def .)
    CONCAT          reduce using rule 12 (expr -> binary_op_def .)
    $end            reduce using rule 12 (expr -> binary_op_def .)
    )               reduce using rule 12 (expr -> binary_op_def .)
    INTERPOLATION_BOTH reduce using rule 12 (expr -> binary_op_def .)
    INTERPOLATION_RIGHT reduce using rule 12 (expr -> binary_op_def .)
    OF              reduce using rule 12 (expr -> binary_op_def .)
    THEN            reduce using rule 12 (expr -> binary_op_def .)
    END             reduce using rule 12 (expr -> binary_op_def .)
    ELIF            reduce using rule 12 (expr -> binary_op_def .)
    ELSE            reduce using rule 12 (expr -> binary_op_def .)
    ,               reduce using rule 12 (expr -> binary_op_def .)
    ]               reduce using rule 12 (expr -> binary_op_def .)


state 10

    (13) expr -> unary_expr .
    NEWLINE         reduce using rule 13 (expr -> unary_expr .)
    (               reduce using rule 13 (expr -> unary_expr .)
    SOME_SUB        reduce using rule 13 (expr -> unary_expr .)
    SOME_CONCAT     reduce using rule 13 (expr -> unary_expr .)
    ARROW_BOTH      reduce using rule 13 (expr -> unary_expr .)
    ARROW_RIGHT     reduce using rule 13 (expr -> unary_expr .)
    ARROW_LEFT      reduce using rule 13 (expr -> unary_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 13 (expr -> unary_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 13 (expr -> unary_expr .)
    BIT_SHIFT_RIGHT reduce using rule 13 (expr -> unary_expr .)
    BIT_SHIFT_LEFT  reduce using rule 13 (expr -> unary_expr .)
    BIT_AND         reduce using rule 13 (expr -> unary_expr .)
    BIT_OR          reduce using rule 13 (expr -> unary_expr .)
    FLOAT_POW       reduce using rule 13 (expr -> unary_expr .)
    POW             reduce using rule 13 (expr -> unary_expr .)
    ARRAY_SUB       reduce using rule 13 (expr -> unary_expr .)
    ARRAY_CONCAT    reduce using rule 13 (expr -> unary_expr .)
    MORE_OR_EQ      reduce using rule 13 (expr -> unary_expr .)
    LESS_OR_EQ      reduce using rule 13 (expr -> unary_expr .)
    TEXT_MATCH      reduce using rule 13 (expr -> unary_expr .)
    STRICT_AND      reduce using rule 13 (expr -> unary_expr .)
    AND             reduce using rule 13 (expr -> unary_expr .)
    STRICT_OR       reduce using rule 13 (expr -> unary_expr .)
    OR              reduce using rule 13 (expr -> unary_expr .)
    EQUAL           reduce using rule 13 (expr -> unary_expr .)
    NOT_EQUAL       reduce using rule 13 (expr -> unary_expr .)
    >               reduce using rule 13 (expr -> unary_expr .)
    FLOAT_MUL       reduce using rule 13 (expr -> unary_expr .)
    FLOAT_DIV       reduce using rule 13 (expr -> unary_expr .)
    FLOAT_SUB       reduce using rule 13 (expr -> unary_expr .)
    FLOAT_SUM       reduce using rule 13 (expr -> unary_expr .)
    <               reduce using rule 13 (expr -> unary_expr .)
    *               reduce using rule 13 (expr -> unary_expr .)
    /               reduce using rule 13 (expr -> unary_expr .)
    -               reduce using rule 13 (expr -> unary_expr .)
    +               reduce using rule 13 (expr -> unary_expr .)
    CONCAT          reduce using rule 13 (expr -> unary_expr .)
    $end            reduce using rule 13 (expr -> unary_expr .)
    )               reduce using rule 13 (expr -> unary_expr .)
    INTERPOLATION_BOTH reduce using rule 13 (expr -> unary_expr .)
    INTERPOLATION_RIGHT reduce using rule 13 (expr -> unary_expr .)
    OF              reduce using rule 13 (expr -> unary_expr .)
    THEN            reduce using rule 13 (expr -> unary_expr .)
    END             reduce using rule 13 (expr -> unary_expr .)
    ELIF            reduce using rule 13 (expr -> unary_expr .)
    ELSE            reduce using rule 13 (expr -> unary_expr .)
    ,               reduce using rule 13 (expr -> unary_expr .)
    ]               reduce using rule 13 (expr -> unary_expr .)


state 11

    (14) expr -> str_literal .
    NEWLINE         reduce using rule 14 (expr -> str_literal .)
    (               reduce using rule 14 (expr -> str_literal .)
    SOME_SUB        reduce using rule 14 (expr -> str_literal .)
    SOME_CONCAT     reduce using rule 14 (expr -> str_literal .)
    ARROW_BOTH      reduce using rule 14 (expr -> str_literal .)
    ARROW_RIGHT     reduce using rule 14 (expr -> str_literal .)
    ARROW_LEFT      reduce using rule 14 (expr -> str_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 14 (expr -> str_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 14 (expr -> str_literal .)
    BIT_SHIFT_RIGHT reduce using rule 14 (expr -> str_literal .)
    BIT_SHIFT_LEFT  reduce using rule 14 (expr -> str_literal .)
    BIT_AND         reduce using rule 14 (expr -> str_literal .)
    BIT_OR          reduce using rule 14 (expr -> str_literal .)
    FLOAT_POW       reduce using rule 14 (expr -> str_literal .)
    POW             reduce using rule 14 (expr -> str_literal .)
    ARRAY_SUB       reduce using rule 14 (expr -> str_literal .)
    ARRAY_CONCAT    reduce using rule 14 (expr -> str_literal .)
    MORE_OR_EQ      reduce using rule 14 (expr -> str_literal .)
    LESS_OR_EQ      reduce using rule 14 (expr -> str_literal .)
    TEXT_MATCH      reduce using rule 14 (expr -> str_literal .)
    STRICT_AND      reduce using rule 14 (expr -> str_literal .)
    AND             reduce using rule 14 (expr -> str_literal .)
    STRICT_OR       reduce using rule 14 (expr -> str_literal .)
    OR              reduce using rule 14 (expr -> str_literal .)
    EQUAL           reduce using rule 14 (expr -> str_literal .)
    NOT_EQUAL       reduce using rule 14 (expr -> str_literal .)
    >               reduce using rule 14 (expr -> str_literal .)
    FLOAT_MUL       reduce using rule 14 (expr -> str_literal .)
    FLOAT_DIV       reduce using rule 14 (expr -> str_literal .)
    FLOAT_SUB       reduce using rule 14 (expr -> str_literal .)
    FLOAT_SUM       reduce using rule 14 (expr -> str_literal .)
    <               reduce using rule 14 (expr -> str_literal .)
    *               reduce using rule 14 (expr -> str_literal .)
    /               reduce using rule 14 (expr -> str_literal .)
    -               reduce using rule 14 (expr -> str_literal .)
    +               reduce using rule 14 (expr -> str_literal .)
    CONCAT          reduce using rule 14 (expr -> str_literal .)
    $end            reduce using rule 14 (expr -> str_literal .)
    )               reduce using rule 14 (expr -> str_literal .)
    INTERPOLATION_BOTH reduce using rule 14 (expr -> str_literal .)
    INTERPOLATION_RIGHT reduce using rule 14 (expr -> str_literal .)
    OF              reduce using rule 14 (expr -> str_literal .)
    THEN            reduce using rule 14 (expr -> str_literal .)
    END             reduce using rule 14 (expr -> str_literal .)
    ELIF            reduce using rule 14 (expr -> str_literal .)
    ELSE            reduce using rule 14 (expr -> str_literal .)
    ,               reduce using rule 14 (expr -> str_literal .)
    ]               reduce using rule 14 (expr -> str_literal .)


state 12

    (15) expr -> float_literal .
    NEWLINE         reduce using rule 15 (expr -> float_literal .)
    (               reduce using rule 15 (expr -> float_literal .)
    SOME_SUB        reduce using rule 15 (expr -> float_literal .)
    SOME_CONCAT     reduce using rule 15 (expr -> float_literal .)
    ARROW_BOTH      reduce using rule 15 (expr -> float_literal .)
    ARROW_RIGHT     reduce using rule 15 (expr -> float_literal .)
    ARROW_LEFT      reduce using rule 15 (expr -> float_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 15 (expr -> float_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 15 (expr -> float_literal .)
    BIT_SHIFT_RIGHT reduce using rule 15 (expr -> float_literal .)
    BIT_SHIFT_LEFT  reduce using rule 15 (expr -> float_literal .)
    BIT_AND         reduce using rule 15 (expr -> float_literal .)
    BIT_OR          reduce using rule 15 (expr -> float_literal .)
    FLOAT_POW       reduce using rule 15 (expr -> float_literal .)
    POW             reduce using rule 15 (expr -> float_literal .)
    ARRAY_SUB       reduce using rule 15 (expr -> float_literal .)
    ARRAY_CONCAT    reduce using rule 15 (expr -> float_literal .)
    MORE_OR_EQ      reduce using rule 15 (expr -> float_literal .)
    LESS_OR_EQ      reduce using rule 15 (expr -> float_literal .)
    TEXT_MATCH      reduce using rule 15 (expr -> float_literal .)
    STRICT_AND      reduce using rule 15 (expr -> float_literal .)
    AND             reduce using rule 15 (expr -> float_literal .)
    STRICT_OR       reduce using rule 15 (expr -> float_literal .)
    OR              reduce using rule 15 (expr -> float_literal .)
    EQUAL           reduce using rule 15 (expr -> float_literal .)
    NOT_EQUAL       reduce using rule 15 (expr -> float_literal .)
    >               reduce using rule 15 (expr -> float_literal .)
    FLOAT_MUL       reduce using rule 15 (expr -> float_literal .)
    FLOAT_DIV       reduce using rule 15 (expr -> float_literal .)
    FLOAT_SUB       reduce using rule 15 (expr -> float_literal .)
    FLOAT_SUM       reduce using rule 15 (expr -> float_literal .)
    <               reduce using rule 15 (expr -> float_literal .)
    *               reduce using rule 15 (expr -> float_literal .)
    /               reduce using rule 15 (expr -> float_literal .)
    -               reduce using rule 15 (expr -> float_literal .)
    +               reduce using rule 15 (expr -> float_literal .)
    CONCAT          reduce using rule 15 (expr -> float_literal .)
    $end            reduce using rule 15 (expr -> float_literal .)
    )               reduce using rule 15 (expr -> float_literal .)
    INTERPOLATION_BOTH reduce using rule 15 (expr -> float_literal .)
    INTERPOLATION_RIGHT reduce using rule 15 (expr -> float_literal .)
    OF              reduce using rule 15 (expr -> float_literal .)
    THEN            reduce using rule 15 (expr -> float_literal .)
    END             reduce using rule 15 (expr -> float_literal .)
    ELIF            reduce using rule 15 (expr -> float_literal .)
    ELSE            reduce using rule 15 (expr -> float_literal .)
    ,               reduce using rule 15 (expr -> float_literal .)
    ]               reduce using rule 15 (expr -> float_literal .)


state 13

    (16) expr -> int_literal .
    NEWLINE         reduce using rule 16 (expr -> int_literal .)
    (               reduce using rule 16 (expr -> int_literal .)
    SOME_SUB        reduce using rule 16 (expr -> int_literal .)
    SOME_CONCAT     reduce using rule 16 (expr -> int_literal .)
    ARROW_BOTH      reduce using rule 16 (expr -> int_literal .)
    ARROW_RIGHT     reduce using rule 16 (expr -> int_literal .)
    ARROW_LEFT      reduce using rule 16 (expr -> int_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 16 (expr -> int_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 16 (expr -> int_literal .)
    BIT_SHIFT_RIGHT reduce using rule 16 (expr -> int_literal .)
    BIT_SHIFT_LEFT  reduce using rule 16 (expr -> int_literal .)
    BIT_AND         reduce using rule 16 (expr -> int_literal .)
    BIT_OR          reduce using rule 16 (expr -> int_literal .)
    FLOAT_POW       reduce using rule 16 (expr -> int_literal .)
    POW             reduce using rule 16 (expr -> int_literal .)
    ARRAY_SUB       reduce using rule 16 (expr -> int_literal .)
    ARRAY_CONCAT    reduce using rule 16 (expr -> int_literal .)
    MORE_OR_EQ      reduce using rule 16 (expr -> int_literal .)
    LESS_OR_EQ      reduce using rule 16 (expr -> int_literal .)
    TEXT_MATCH      reduce using rule 16 (expr -> int_literal .)
    STRICT_AND      reduce using rule 16 (expr -> int_literal .)
    AND             reduce using rule 16 (expr -> int_literal .)
    STRICT_OR       reduce using rule 16 (expr -> int_literal .)
    OR              reduce using rule 16 (expr -> int_literal .)
    EQUAL           reduce using rule 16 (expr -> int_literal .)
    NOT_EQUAL       reduce using rule 16 (expr -> int_literal .)
    >               reduce using rule 16 (expr -> int_literal .)
    FLOAT_MUL       reduce using rule 16 (expr -> int_literal .)
    FLOAT_DIV       reduce using rule 16 (expr -> int_literal .)
    FLOAT_SUB       reduce using rule 16 (expr -> int_literal .)
    FLOAT_SUM       reduce using rule 16 (expr -> int_literal .)
    <               reduce using rule 16 (expr -> int_literal .)
    *               reduce using rule 16 (expr -> int_literal .)
    /               reduce using rule 16 (expr -> int_literal .)
    -               reduce using rule 16 (expr -> int_literal .)
    +               reduce using rule 16 (expr -> int_literal .)
    CONCAT          reduce using rule 16 (expr -> int_literal .)
    $end            reduce using rule 16 (expr -> int_literal .)
    )               reduce using rule 16 (expr -> int_literal .)
    INTERPOLATION_BOTH reduce using rule 16 (expr -> int_literal .)
    INTERPOLATION_RIGHT reduce using rule 16 (expr -> int_literal .)
    OF              reduce using rule 16 (expr -> int_literal .)
    THEN            reduce using rule 16 (expr -> int_literal .)
    END             reduce using rule 16 (expr -> int_literal .)
    ELIF            reduce using rule 16 (expr -> int_literal .)
    ELSE            reduce using rule 16 (expr -> int_literal .)
    ,               reduce using rule 16 (expr -> int_literal .)
    ]               reduce using rule 16 (expr -> int_literal .)


state 14

    (17) expr -> array .
    NEWLINE         reduce using rule 17 (expr -> array .)
    (               reduce using rule 17 (expr -> array .)
    SOME_SUB        reduce using rule 17 (expr -> array .)
    SOME_CONCAT     reduce using rule 17 (expr -> array .)
    ARROW_BOTH      reduce using rule 17 (expr -> array .)
    ARROW_RIGHT     reduce using rule 17 (expr -> array .)
    ARROW_LEFT      reduce using rule 17 (expr -> array .)
    DOUBLE_ARROW_RIGHT reduce using rule 17 (expr -> array .)
    DOUBLE_ARROW_LEFT reduce using rule 17 (expr -> array .)
    BIT_SHIFT_RIGHT reduce using rule 17 (expr -> array .)
    BIT_SHIFT_LEFT  reduce using rule 17 (expr -> array .)
    BIT_AND         reduce using rule 17 (expr -> array .)
    BIT_OR          reduce using rule 17 (expr -> array .)
    FLOAT_POW       reduce using rule 17 (expr -> array .)
    POW             reduce using rule 17 (expr -> array .)
    ARRAY_SUB       reduce using rule 17 (expr -> array .)
    ARRAY_CONCAT    reduce using rule 17 (expr -> array .)
    MORE_OR_EQ      reduce using rule 17 (expr -> array .)
    LESS_OR_EQ      reduce using rule 17 (expr -> array .)
    TEXT_MATCH      reduce using rule 17 (expr -> array .)
    STRICT_AND      reduce using rule 17 (expr -> array .)
    AND             reduce using rule 17 (expr -> array .)
    STRICT_OR       reduce using rule 17 (expr -> array .)
    OR              reduce using rule 17 (expr -> array .)
    EQUAL           reduce using rule 17 (expr -> array .)
    NOT_EQUAL       reduce using rule 17 (expr -> array .)
    >               reduce using rule 17 (expr -> array .)
    FLOAT_MUL       reduce using rule 17 (expr -> array .)
    FLOAT_DIV       reduce using rule 17 (expr -> array .)
    FLOAT_SUB       reduce using rule 17 (expr -> array .)
    FLOAT_SUM       reduce using rule 17 (expr -> array .)
    <               reduce using rule 17 (expr -> array .)
    *               reduce using rule 17 (expr -> array .)
    /               reduce using rule 17 (expr -> array .)
    -               reduce using rule 17 (expr -> array .)
    +               reduce using rule 17 (expr -> array .)
    CONCAT          reduce using rule 17 (expr -> array .)
    $end            reduce using rule 17 (expr -> array .)
    )               reduce using rule 17 (expr -> array .)
    INTERPOLATION_BOTH reduce using rule 17 (expr -> array .)
    INTERPOLATION_RIGHT reduce using rule 17 (expr -> array .)
    OF              reduce using rule 17 (expr -> array .)
    THEN            reduce using rule 17 (expr -> array .)
    END             reduce using rule 17 (expr -> array .)
    ELIF            reduce using rule 17 (expr -> array .)
    ELSE            reduce using rule 17 (expr -> array .)
    ,               reduce using rule 17 (expr -> array .)
    ]               reduce using rule 17 (expr -> array .)


state 15

    (18) expr -> variant_call .
    NEWLINE         reduce using rule 18 (expr -> variant_call .)
    (               reduce using rule 18 (expr -> variant_call .)
    SOME_SUB        reduce using rule 18 (expr -> variant_call .)
    SOME_CONCAT     reduce using rule 18 (expr -> variant_call .)
    ARROW_BOTH      reduce using rule 18 (expr -> variant_call .)
    ARROW_RIGHT     reduce using rule 18 (expr -> variant_call .)
    ARROW_LEFT      reduce using rule 18 (expr -> variant_call .)
    DOUBLE_ARROW_RIGHT reduce using rule 18 (expr -> variant_call .)
    DOUBLE_ARROW_LEFT reduce using rule 18 (expr -> variant_call .)
    BIT_SHIFT_RIGHT reduce using rule 18 (expr -> variant_call .)
    BIT_SHIFT_LEFT  reduce using rule 18 (expr -> variant_call .)
    BIT_AND         reduce using rule 18 (expr -> variant_call .)
    BIT_OR          reduce using rule 18 (expr -> variant_call .)
    FLOAT_POW       reduce using rule 18 (expr -> variant_call .)
    POW             reduce using rule 18 (expr -> variant_call .)
    ARRAY_SUB       reduce using rule 18 (expr -> variant_call .)
    ARRAY_CONCAT    reduce using rule 18 (expr -> variant_call .)
    MORE_OR_EQ      reduce using rule 18 (expr -> variant_call .)
    LESS_OR_EQ      reduce using rule 18 (expr -> variant_call .)
    TEXT_MATCH      reduce using rule 18 (expr -> variant_call .)
    STRICT_AND      reduce using rule 18 (expr -> variant_call .)
    AND             reduce using rule 18 (expr -> variant_call .)
    STRICT_OR       reduce using rule 18 (expr -> variant_call .)
    OR              reduce using rule 18 (expr -> variant_call .)
    EQUAL           reduce using rule 18 (expr -> variant_call .)
    NOT_EQUAL       reduce using rule 18 (expr -> variant_call .)
    >               reduce using rule 18 (expr -> variant_call .)
    FLOAT_MUL       reduce using rule 18 (expr -> variant_call .)
    FLOAT_DIV       reduce using rule 18 (expr -> variant_call .)
    FLOAT_SUB       reduce using rule 18 (expr -> variant_call .)
    FLOAT_SUM       reduce using rule 18 (expr -> variant_call .)
    <               reduce using rule 18 (expr -> variant_call .)
    *               reduce using rule 18 (expr -> variant_call .)
    /               reduce using rule 18 (expr -> variant_call .)
    -               reduce using rule 18 (expr -> variant_call .)
    +               reduce using rule 18 (expr -> variant_call .)
    CONCAT          reduce using rule 18 (expr -> variant_call .)
    $end            reduce using rule 18 (expr -> variant_call .)
    )               reduce using rule 18 (expr -> variant_call .)
    INTERPOLATION_BOTH reduce using rule 18 (expr -> variant_call .)
    INTERPOLATION_RIGHT reduce using rule 18 (expr -> variant_call .)
    OF              reduce using rule 18 (expr -> variant_call .)
    THEN            reduce using rule 18 (expr -> variant_call .)
    END             reduce using rule 18 (expr -> variant_call .)
    ELIF            reduce using rule 18 (expr -> variant_call .)
    ELSE            reduce using rule 18 (expr -> variant_call .)
    ,               reduce using rule 18 (expr -> variant_call .)
    ]               reduce using rule 18 (expr -> variant_call .)


state 16

    (19) expr -> identifier .
    (284) let -> identifier . : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> identifier . _65_0x3a_type_optional = expr
    (291) _65_0x3a_type_optional -> . : type
    (292) _65_0x3a_type_optional -> .
    NEWLINE         reduce using rule 19 (expr -> identifier .)
    (               reduce using rule 19 (expr -> identifier .)
    SOME_SUB        reduce using rule 19 (expr -> identifier .)
    SOME_CONCAT     reduce using rule 19 (expr -> identifier .)
    ARROW_BOTH      reduce using rule 19 (expr -> identifier .)
    ARROW_RIGHT     reduce using rule 19 (expr -> identifier .)
    ARROW_LEFT      reduce using rule 19 (expr -> identifier .)
    DOUBLE_ARROW_RIGHT reduce using rule 19 (expr -> identifier .)
    DOUBLE_ARROW_LEFT reduce using rule 19 (expr -> identifier .)
    BIT_SHIFT_RIGHT reduce using rule 19 (expr -> identifier .)
    BIT_SHIFT_LEFT  reduce using rule 19 (expr -> identifier .)
    BIT_AND         reduce using rule 19 (expr -> identifier .)
    BIT_OR          reduce using rule 19 (expr -> identifier .)
    FLOAT_POW       reduce using rule 19 (expr -> identifier .)
    POW             reduce using rule 19 (expr -> identifier .)
    ARRAY_SUB       reduce using rule 19 (expr -> identifier .)
    ARRAY_CONCAT    reduce using rule 19 (expr -> identifier .)
    MORE_OR_EQ      reduce using rule 19 (expr -> identifier .)
    LESS_OR_EQ      reduce using rule 19 (expr -> identifier .)
    TEXT_MATCH      reduce using rule 19 (expr -> identifier .)
    STRICT_AND      reduce using rule 19 (expr -> identifier .)
    AND             reduce using rule 19 (expr -> identifier .)
    STRICT_OR       reduce using rule 19 (expr -> identifier .)
    OR              reduce using rule 19 (expr -> identifier .)
    EQUAL           reduce using rule 19 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 19 (expr -> identifier .)
    >               reduce using rule 19 (expr -> identifier .)
    FLOAT_MUL       reduce using rule 19 (expr -> identifier .)
    FLOAT_DIV       reduce using rule 19 (expr -> identifier .)
    FLOAT_SUB       reduce using rule 19 (expr -> identifier .)
    FLOAT_SUM       reduce using rule 19 (expr -> identifier .)
    <               reduce using rule 19 (expr -> identifier .)
    *               reduce using rule 19 (expr -> identifier .)
    /               reduce using rule 19 (expr -> identifier .)
    -               reduce using rule 19 (expr -> identifier .)
    +               reduce using rule 19 (expr -> identifier .)
    CONCAT          reduce using rule 19 (expr -> identifier .)
    $end            reduce using rule 19 (expr -> identifier .)
    )               reduce using rule 19 (expr -> identifier .)
    INTERPOLATION_BOTH reduce using rule 19 (expr -> identifier .)
    INTERPOLATION_RIGHT reduce using rule 19 (expr -> identifier .)
    OF              reduce using rule 19 (expr -> identifier .)
    THEN            reduce using rule 19 (expr -> identifier .)
    END             reduce using rule 19 (expr -> identifier .)
    ELIF            reduce using rule 19 (expr -> identifier .)
    ELSE            reduce using rule 19 (expr -> identifier .)
    ,               reduce using rule 19 (expr -> identifier .)
    ]               reduce using rule 19 (expr -> identifier .)
    :               shift and go to state 84
    =               reduce using rule 292 (_65_0x3a_type_optional -> .)

    _65_0x3a_type_optional         shift and go to state 85

state 17

    (20) expr -> let .
    NEWLINE         reduce using rule 20 (expr -> let .)
    (               reduce using rule 20 (expr -> let .)
    SOME_SUB        reduce using rule 20 (expr -> let .)
    SOME_CONCAT     reduce using rule 20 (expr -> let .)
    ARROW_BOTH      reduce using rule 20 (expr -> let .)
    ARROW_RIGHT     reduce using rule 20 (expr -> let .)
    ARROW_LEFT      reduce using rule 20 (expr -> let .)
    DOUBLE_ARROW_RIGHT reduce using rule 20 (expr -> let .)
    DOUBLE_ARROW_LEFT reduce using rule 20 (expr -> let .)
    BIT_SHIFT_RIGHT reduce using rule 20 (expr -> let .)
    BIT_SHIFT_LEFT  reduce using rule 20 (expr -> let .)
    BIT_AND         reduce using rule 20 (expr -> let .)
    BIT_OR          reduce using rule 20 (expr -> let .)
    FLOAT_POW       reduce using rule 20 (expr -> let .)
    POW             reduce using rule 20 (expr -> let .)
    ARRAY_SUB       reduce using rule 20 (expr -> let .)
    ARRAY_CONCAT    reduce using rule 20 (expr -> let .)
    MORE_OR_EQ      reduce using rule 20 (expr -> let .)
    LESS_OR_EQ      reduce using rule 20 (expr -> let .)
    TEXT_MATCH      reduce using rule 20 (expr -> let .)
    STRICT_AND      reduce using rule 20 (expr -> let .)
    AND             reduce using rule 20 (expr -> let .)
    STRICT_OR       reduce using rule 20 (expr -> let .)
    OR              reduce using rule 20 (expr -> let .)
    EQUAL           reduce using rule 20 (expr -> let .)
    NOT_EQUAL       reduce using rule 20 (expr -> let .)
    >               reduce using rule 20 (expr -> let .)
    FLOAT_MUL       reduce using rule 20 (expr -> let .)
    FLOAT_DIV       reduce using rule 20 (expr -> let .)
    FLOAT_SUB       reduce using rule 20 (expr -> let .)
    FLOAT_SUM       reduce using rule 20 (expr -> let .)
    <               reduce using rule 20 (expr -> let .)
    *               reduce using rule 20 (expr -> let .)
    /               reduce using rule 20 (expr -> let .)
    -               reduce using rule 20 (expr -> let .)
    +               reduce using rule 20 (expr -> let .)
    CONCAT          reduce using rule 20 (expr -> let .)
    $end            reduce using rule 20 (expr -> let .)
    )               reduce using rule 20 (expr -> let .)
    INTERPOLATION_BOTH reduce using rule 20 (expr -> let .)
    INTERPOLATION_RIGHT reduce using rule 20 (expr -> let .)
    OF              reduce using rule 20 (expr -> let .)
    THEN            reduce using rule 20 (expr -> let .)
    END             reduce using rule 20 (expr -> let .)
    ELIF            reduce using rule 20 (expr -> let .)
    ELSE            reduce using rule 20 (expr -> let .)
    ,               reduce using rule 20 (expr -> let .)
    ]               reduce using rule 20 (expr -> let .)


state 18

    (21) expr -> call .
    NEWLINE         reduce using rule 21 (expr -> call .)
    (               reduce using rule 21 (expr -> call .)
    SOME_SUB        reduce using rule 21 (expr -> call .)
    SOME_CONCAT     reduce using rule 21 (expr -> call .)
    ARROW_BOTH      reduce using rule 21 (expr -> call .)
    ARROW_RIGHT     reduce using rule 21 (expr -> call .)
    ARROW_LEFT      reduce using rule 21 (expr -> call .)
    DOUBLE_ARROW_RIGHT reduce using rule 21 (expr -> call .)
    DOUBLE_ARROW_LEFT reduce using rule 21 (expr -> call .)
    BIT_SHIFT_RIGHT reduce using rule 21 (expr -> call .)
    BIT_SHIFT_LEFT  reduce using rule 21 (expr -> call .)
    BIT_AND         reduce using rule 21 (expr -> call .)
    BIT_OR          reduce using rule 21 (expr -> call .)
    FLOAT_POW       reduce using rule 21 (expr -> call .)
    POW             reduce using rule 21 (expr -> call .)
    ARRAY_SUB       reduce using rule 21 (expr -> call .)
    ARRAY_CONCAT    reduce using rule 21 (expr -> call .)
    MORE_OR_EQ      reduce using rule 21 (expr -> call .)
    LESS_OR_EQ      reduce using rule 21 (expr -> call .)
    TEXT_MATCH      reduce using rule 21 (expr -> call .)
    STRICT_AND      reduce using rule 21 (expr -> call .)
    AND             reduce using rule 21 (expr -> call .)
    STRICT_OR       reduce using rule 21 (expr -> call .)
    OR              reduce using rule 21 (expr -> call .)
    EQUAL           reduce using rule 21 (expr -> call .)
    NOT_EQUAL       reduce using rule 21 (expr -> call .)
    >               reduce using rule 21 (expr -> call .)
    FLOAT_MUL       reduce using rule 21 (expr -> call .)
    FLOAT_DIV       reduce using rule 21 (expr -> call .)
    FLOAT_SUB       reduce using rule 21 (expr -> call .)
    FLOAT_SUM       reduce using rule 21 (expr -> call .)
    <               reduce using rule 21 (expr -> call .)
    *               reduce using rule 21 (expr -> call .)
    /               reduce using rule 21 (expr -> call .)
    -               reduce using rule 21 (expr -> call .)
    +               reduce using rule 21 (expr -> call .)
    CONCAT          reduce using rule 21 (expr -> call .)
    $end            reduce using rule 21 (expr -> call .)
    )               reduce using rule 21 (expr -> call .)
    INTERPOLATION_BOTH reduce using rule 21 (expr -> call .)
    INTERPOLATION_RIGHT reduce using rule 21 (expr -> call .)
    OF              reduce using rule 21 (expr -> call .)
    THEN            reduce using rule 21 (expr -> call .)
    END             reduce using rule 21 (expr -> call .)
    ELIF            reduce using rule 21 (expr -> call .)
    ELSE            reduce using rule 21 (expr -> call .)
    ,               reduce using rule 21 (expr -> call .)
    ]               reduce using rule 21 (expr -> call .)


state 19

    (22) expr -> case_of .
    NEWLINE         reduce using rule 22 (expr -> case_of .)
    (               reduce using rule 22 (expr -> case_of .)
    SOME_SUB        reduce using rule 22 (expr -> case_of .)
    SOME_CONCAT     reduce using rule 22 (expr -> case_of .)
    ARROW_BOTH      reduce using rule 22 (expr -> case_of .)
    ARROW_RIGHT     reduce using rule 22 (expr -> case_of .)
    ARROW_LEFT      reduce using rule 22 (expr -> case_of .)
    DOUBLE_ARROW_RIGHT reduce using rule 22 (expr -> case_of .)
    DOUBLE_ARROW_LEFT reduce using rule 22 (expr -> case_of .)
    BIT_SHIFT_RIGHT reduce using rule 22 (expr -> case_of .)
    BIT_SHIFT_LEFT  reduce using rule 22 (expr -> case_of .)
    BIT_AND         reduce using rule 22 (expr -> case_of .)
    BIT_OR          reduce using rule 22 (expr -> case_of .)
    FLOAT_POW       reduce using rule 22 (expr -> case_of .)
    POW             reduce using rule 22 (expr -> case_of .)
    ARRAY_SUB       reduce using rule 22 (expr -> case_of .)
    ARRAY_CONCAT    reduce using rule 22 (expr -> case_of .)
    MORE_OR_EQ      reduce using rule 22 (expr -> case_of .)
    LESS_OR_EQ      reduce using rule 22 (expr -> case_of .)
    TEXT_MATCH      reduce using rule 22 (expr -> case_of .)
    STRICT_AND      reduce using rule 22 (expr -> case_of .)
    AND             reduce using rule 22 (expr -> case_of .)
    STRICT_OR       reduce using rule 22 (expr -> case_of .)
    OR              reduce using rule 22 (expr -> case_of .)
    EQUAL           reduce using rule 22 (expr -> case_of .)
    NOT_EQUAL       reduce using rule 22 (expr -> case_of .)
    >               reduce using rule 22 (expr -> case_of .)
    FLOAT_MUL       reduce using rule 22 (expr -> case_of .)
    FLOAT_DIV       reduce using rule 22 (expr -> case_of .)
    FLOAT_SUB       reduce using rule 22 (expr -> case_of .)
    FLOAT_SUM       reduce using rule 22 (expr -> case_of .)
    <               reduce using rule 22 (expr -> case_of .)
    *               reduce using rule 22 (expr -> case_of .)
    /               reduce using rule 22 (expr -> case_of .)
    -               reduce using rule 22 (expr -> case_of .)
    +               reduce using rule 22 (expr -> case_of .)
    CONCAT          reduce using rule 22 (expr -> case_of .)
    $end            reduce using rule 22 (expr -> case_of .)
    )               reduce using rule 22 (expr -> case_of .)
    INTERPOLATION_BOTH reduce using rule 22 (expr -> case_of .)
    INTERPOLATION_RIGHT reduce using rule 22 (expr -> case_of .)
    OF              reduce using rule 22 (expr -> case_of .)
    THEN            reduce using rule 22 (expr -> case_of .)
    END             reduce using rule 22 (expr -> case_of .)
    ELIF            reduce using rule 22 (expr -> case_of .)
    ELSE            reduce using rule 22 (expr -> case_of .)
    ,               reduce using rule 22 (expr -> case_of .)
    ]               reduce using rule 22 (expr -> case_of .)


state 20

    (23) expr -> binary_expr .
    NEWLINE         reduce using rule 23 (expr -> binary_expr .)
    (               reduce using rule 23 (expr -> binary_expr .)
    SOME_SUB        reduce using rule 23 (expr -> binary_expr .)
    SOME_CONCAT     reduce using rule 23 (expr -> binary_expr .)
    ARROW_BOTH      reduce using rule 23 (expr -> binary_expr .)
    ARROW_RIGHT     reduce using rule 23 (expr -> binary_expr .)
    ARROW_LEFT      reduce using rule 23 (expr -> binary_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 23 (expr -> binary_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 23 (expr -> binary_expr .)
    BIT_SHIFT_RIGHT reduce using rule 23 (expr -> binary_expr .)
    BIT_SHIFT_LEFT  reduce using rule 23 (expr -> binary_expr .)
    BIT_AND         reduce using rule 23 (expr -> binary_expr .)
    BIT_OR          reduce using rule 23 (expr -> binary_expr .)
    FLOAT_POW       reduce using rule 23 (expr -> binary_expr .)
    POW             reduce using rule 23 (expr -> binary_expr .)
    ARRAY_SUB       reduce using rule 23 (expr -> binary_expr .)
    ARRAY_CONCAT    reduce using rule 23 (expr -> binary_expr .)
    MORE_OR_EQ      reduce using rule 23 (expr -> binary_expr .)
    LESS_OR_EQ      reduce using rule 23 (expr -> binary_expr .)
    TEXT_MATCH      reduce using rule 23 (expr -> binary_expr .)
    STRICT_AND      reduce using rule 23 (expr -> binary_expr .)
    AND             reduce using rule 23 (expr -> binary_expr .)
    STRICT_OR       reduce using rule 23 (expr -> binary_expr .)
    OR              reduce using rule 23 (expr -> binary_expr .)
    EQUAL           reduce using rule 23 (expr -> binary_expr .)
    NOT_EQUAL       reduce using rule 23 (expr -> binary_expr .)
    >               reduce using rule 23 (expr -> binary_expr .)
    FLOAT_MUL       reduce using rule 23 (expr -> binary_expr .)
    FLOAT_DIV       reduce using rule 23 (expr -> binary_expr .)
    FLOAT_SUB       reduce using rule 23 (expr -> binary_expr .)
    FLOAT_SUM       reduce using rule 23 (expr -> binary_expr .)
    <               reduce using rule 23 (expr -> binary_expr .)
    *               reduce using rule 23 (expr -> binary_expr .)
    /               reduce using rule 23 (expr -> binary_expr .)
    -               reduce using rule 23 (expr -> binary_expr .)
    +               reduce using rule 23 (expr -> binary_expr .)
    CONCAT          reduce using rule 23 (expr -> binary_expr .)
    $end            reduce using rule 23 (expr -> binary_expr .)
    )               reduce using rule 23 (expr -> binary_expr .)
    INTERPOLATION_BOTH reduce using rule 23 (expr -> binary_expr .)
    INTERPOLATION_RIGHT reduce using rule 23 (expr -> binary_expr .)
    OF              reduce using rule 23 (expr -> binary_expr .)
    THEN            reduce using rule 23 (expr -> binary_expr .)
    END             reduce using rule 23 (expr -> binary_expr .)
    ELIF            reduce using rule 23 (expr -> binary_expr .)
    ELSE            reduce using rule 23 (expr -> binary_expr .)
    ,               reduce using rule 23 (expr -> binary_expr .)
    ]               reduce using rule 23 (expr -> binary_expr .)


state 21

    (24) expr -> if_expr .
    NEWLINE         reduce using rule 24 (expr -> if_expr .)
    (               reduce using rule 24 (expr -> if_expr .)
    SOME_SUB        reduce using rule 24 (expr -> if_expr .)
    SOME_CONCAT     reduce using rule 24 (expr -> if_expr .)
    ARROW_BOTH      reduce using rule 24 (expr -> if_expr .)
    ARROW_RIGHT     reduce using rule 24 (expr -> if_expr .)
    ARROW_LEFT      reduce using rule 24 (expr -> if_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 24 (expr -> if_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 24 (expr -> if_expr .)
    BIT_SHIFT_RIGHT reduce using rule 24 (expr -> if_expr .)
    BIT_SHIFT_LEFT  reduce using rule 24 (expr -> if_expr .)
    BIT_AND         reduce using rule 24 (expr -> if_expr .)
    BIT_OR          reduce using rule 24 (expr -> if_expr .)
    FLOAT_POW       reduce using rule 24 (expr -> if_expr .)
    POW             reduce using rule 24 (expr -> if_expr .)
    ARRAY_SUB       reduce using rule 24 (expr -> if_expr .)
    ARRAY_CONCAT    reduce using rule 24 (expr -> if_expr .)
    MORE_OR_EQ      reduce using rule 24 (expr -> if_expr .)
    LESS_OR_EQ      reduce using rule 24 (expr -> if_expr .)
    TEXT_MATCH      reduce using rule 24 (expr -> if_expr .)
    STRICT_AND      reduce using rule 24 (expr -> if_expr .)
    AND             reduce using rule 24 (expr -> if_expr .)
    STRICT_OR       reduce using rule 24 (expr -> if_expr .)
    OR              reduce using rule 24 (expr -> if_expr .)
    EQUAL           reduce using rule 24 (expr -> if_expr .)
    NOT_EQUAL       reduce using rule 24 (expr -> if_expr .)
    >               reduce using rule 24 (expr -> if_expr .)
    FLOAT_MUL       reduce using rule 24 (expr -> if_expr .)
    FLOAT_DIV       reduce using rule 24 (expr -> if_expr .)
    FLOAT_SUB       reduce using rule 24 (expr -> if_expr .)
    FLOAT_SUM       reduce using rule 24 (expr -> if_expr .)
    <               reduce using rule 24 (expr -> if_expr .)
    *               reduce using rule 24 (expr -> if_expr .)
    /               reduce using rule 24 (expr -> if_expr .)
    -               reduce using rule 24 (expr -> if_expr .)
    +               reduce using rule 24 (expr -> if_expr .)
    CONCAT          reduce using rule 24 (expr -> if_expr .)
    $end            reduce using rule 24 (expr -> if_expr .)
    )               reduce using rule 24 (expr -> if_expr .)
    INTERPOLATION_BOTH reduce using rule 24 (expr -> if_expr .)
    INTERPOLATION_RIGHT reduce using rule 24 (expr -> if_expr .)
    OF              reduce using rule 24 (expr -> if_expr .)
    THEN            reduce using rule 24 (expr -> if_expr .)
    END             reduce using rule 24 (expr -> if_expr .)
    ELIF            reduce using rule 24 (expr -> if_expr .)
    ELSE            reduce using rule 24 (expr -> if_expr .)
    ,               reduce using rule 24 (expr -> if_expr .)
    ]               reduce using rule 24 (expr -> if_expr .)


state 22

    (25) expr -> def_expr .
    NEWLINE         reduce using rule 25 (expr -> def_expr .)
    (               reduce using rule 25 (expr -> def_expr .)
    SOME_SUB        reduce using rule 25 (expr -> def_expr .)
    SOME_CONCAT     reduce using rule 25 (expr -> def_expr .)
    ARROW_BOTH      reduce using rule 25 (expr -> def_expr .)
    ARROW_RIGHT     reduce using rule 25 (expr -> def_expr .)
    ARROW_LEFT      reduce using rule 25 (expr -> def_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 25 (expr -> def_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 25 (expr -> def_expr .)
    BIT_SHIFT_RIGHT reduce using rule 25 (expr -> def_expr .)
    BIT_SHIFT_LEFT  reduce using rule 25 (expr -> def_expr .)
    BIT_AND         reduce using rule 25 (expr -> def_expr .)
    BIT_OR          reduce using rule 25 (expr -> def_expr .)
    FLOAT_POW       reduce using rule 25 (expr -> def_expr .)
    POW             reduce using rule 25 (expr -> def_expr .)
    ARRAY_SUB       reduce using rule 25 (expr -> def_expr .)
    ARRAY_CONCAT    reduce using rule 25 (expr -> def_expr .)
    MORE_OR_EQ      reduce using rule 25 (expr -> def_expr .)
    LESS_OR_EQ      reduce using rule 25 (expr -> def_expr .)
    TEXT_MATCH      reduce using rule 25 (expr -> def_expr .)
    STRICT_AND      reduce using rule 25 (expr -> def_expr .)
    AND             reduce using rule 25 (expr -> def_expr .)
    STRICT_OR       reduce using rule 25 (expr -> def_expr .)
    OR              reduce using rule 25 (expr -> def_expr .)
    EQUAL           reduce using rule 25 (expr -> def_expr .)
    NOT_EQUAL       reduce using rule 25 (expr -> def_expr .)
    >               reduce using rule 25 (expr -> def_expr .)
    FLOAT_MUL       reduce using rule 25 (expr -> def_expr .)
    FLOAT_DIV       reduce using rule 25 (expr -> def_expr .)
    FLOAT_SUB       reduce using rule 25 (expr -> def_expr .)
    FLOAT_SUM       reduce using rule 25 (expr -> def_expr .)
    <               reduce using rule 25 (expr -> def_expr .)
    *               reduce using rule 25 (expr -> def_expr .)
    /               reduce using rule 25 (expr -> def_expr .)
    -               reduce using rule 25 (expr -> def_expr .)
    +               reduce using rule 25 (expr -> def_expr .)
    CONCAT          reduce using rule 25 (expr -> def_expr .)
    $end            reduce using rule 25 (expr -> def_expr .)
    )               reduce using rule 25 (expr -> def_expr .)
    INTERPOLATION_BOTH reduce using rule 25 (expr -> def_expr .)
    INTERPOLATION_RIGHT reduce using rule 25 (expr -> def_expr .)
    OF              reduce using rule 25 (expr -> def_expr .)
    THEN            reduce using rule 25 (expr -> def_expr .)
    END             reduce using rule 25 (expr -> def_expr .)
    ELIF            reduce using rule 25 (expr -> def_expr .)
    ELSE            reduce using rule 25 (expr -> def_expr .)
    ,               reduce using rule 25 (expr -> def_expr .)
    ]               reduce using rule 25 (expr -> def_expr .)


state 23

    (26) expr -> do .
    NEWLINE         reduce using rule 26 (expr -> do .)
    (               reduce using rule 26 (expr -> do .)
    SOME_SUB        reduce using rule 26 (expr -> do .)
    SOME_CONCAT     reduce using rule 26 (expr -> do .)
    ARROW_BOTH      reduce using rule 26 (expr -> do .)
    ARROW_RIGHT     reduce using rule 26 (expr -> do .)
    ARROW_LEFT      reduce using rule 26 (expr -> do .)
    DOUBLE_ARROW_RIGHT reduce using rule 26 (expr -> do .)
    DOUBLE_ARROW_LEFT reduce using rule 26 (expr -> do .)
    BIT_SHIFT_RIGHT reduce using rule 26 (expr -> do .)
    BIT_SHIFT_LEFT  reduce using rule 26 (expr -> do .)
    BIT_AND         reduce using rule 26 (expr -> do .)
    BIT_OR          reduce using rule 26 (expr -> do .)
    FLOAT_POW       reduce using rule 26 (expr -> do .)
    POW             reduce using rule 26 (expr -> do .)
    ARRAY_SUB       reduce using rule 26 (expr -> do .)
    ARRAY_CONCAT    reduce using rule 26 (expr -> do .)
    MORE_OR_EQ      reduce using rule 26 (expr -> do .)
    LESS_OR_EQ      reduce using rule 26 (expr -> do .)
    TEXT_MATCH      reduce using rule 26 (expr -> do .)
    STRICT_AND      reduce using rule 26 (expr -> do .)
    AND             reduce using rule 26 (expr -> do .)
    STRICT_OR       reduce using rule 26 (expr -> do .)
    OR              reduce using rule 26 (expr -> do .)
    EQUAL           reduce using rule 26 (expr -> do .)
    NOT_EQUAL       reduce using rule 26 (expr -> do .)
    >               reduce using rule 26 (expr -> do .)
    FLOAT_MUL       reduce using rule 26 (expr -> do .)
    FLOAT_DIV       reduce using rule 26 (expr -> do .)
    FLOAT_SUB       reduce using rule 26 (expr -> do .)
    FLOAT_SUM       reduce using rule 26 (expr -> do .)
    <               reduce using rule 26 (expr -> do .)
    *               reduce using rule 26 (expr -> do .)
    /               reduce using rule 26 (expr -> do .)
    -               reduce using rule 26 (expr -> do .)
    +               reduce using rule 26 (expr -> do .)
    CONCAT          reduce using rule 26 (expr -> do .)
    $end            reduce using rule 26 (expr -> do .)
    )               reduce using rule 26 (expr -> do .)
    INTERPOLATION_BOTH reduce using rule 26 (expr -> do .)
    INTERPOLATION_RIGHT reduce using rule 26 (expr -> do .)
    OF              reduce using rule 26 (expr -> do .)
    THEN            reduce using rule 26 (expr -> do .)
    END             reduce using rule 26 (expr -> do .)
    ELIF            reduce using rule 26 (expr -> do .)
    ELSE            reduce using rule 26 (expr -> do .)
    ,               reduce using rule 26 (expr -> do .)
    ]               reduce using rule 26 (expr -> do .)


state 24

    (27) expr -> external .
    NEWLINE         reduce using rule 27 (expr -> external .)
    (               reduce using rule 27 (expr -> external .)
    SOME_SUB        reduce using rule 27 (expr -> external .)
    SOME_CONCAT     reduce using rule 27 (expr -> external .)
    ARROW_BOTH      reduce using rule 27 (expr -> external .)
    ARROW_RIGHT     reduce using rule 27 (expr -> external .)
    ARROW_LEFT      reduce using rule 27 (expr -> external .)
    DOUBLE_ARROW_RIGHT reduce using rule 27 (expr -> external .)
    DOUBLE_ARROW_LEFT reduce using rule 27 (expr -> external .)
    BIT_SHIFT_RIGHT reduce using rule 27 (expr -> external .)
    BIT_SHIFT_LEFT  reduce using rule 27 (expr -> external .)
    BIT_AND         reduce using rule 27 (expr -> external .)
    BIT_OR          reduce using rule 27 (expr -> external .)
    FLOAT_POW       reduce using rule 27 (expr -> external .)
    POW             reduce using rule 27 (expr -> external .)
    ARRAY_SUB       reduce using rule 27 (expr -> external .)
    ARRAY_CONCAT    reduce using rule 27 (expr -> external .)
    MORE_OR_EQ      reduce using rule 27 (expr -> external .)
    LESS_OR_EQ      reduce using rule 27 (expr -> external .)
    TEXT_MATCH      reduce using rule 27 (expr -> external .)
    STRICT_AND      reduce using rule 27 (expr -> external .)
    AND             reduce using rule 27 (expr -> external .)
    STRICT_OR       reduce using rule 27 (expr -> external .)
    OR              reduce using rule 27 (expr -> external .)
    EQUAL           reduce using rule 27 (expr -> external .)
    NOT_EQUAL       reduce using rule 27 (expr -> external .)
    >               reduce using rule 27 (expr -> external .)
    FLOAT_MUL       reduce using rule 27 (expr -> external .)
    FLOAT_DIV       reduce using rule 27 (expr -> external .)
    FLOAT_SUB       reduce using rule 27 (expr -> external .)
    FLOAT_SUM       reduce using rule 27 (expr -> external .)
    <               reduce using rule 27 (expr -> external .)
    *               reduce using rule 27 (expr -> external .)
    /               reduce using rule 27 (expr -> external .)
    -               reduce using rule 27 (expr -> external .)
    +               reduce using rule 27 (expr -> external .)
    CONCAT          reduce using rule 27 (expr -> external .)
    $end            reduce using rule 27 (expr -> external .)
    )               reduce using rule 27 (expr -> external .)
    INTERPOLATION_BOTH reduce using rule 27 (expr -> external .)
    INTERPOLATION_RIGHT reduce using rule 27 (expr -> external .)
    OF              reduce using rule 27 (expr -> external .)
    THEN            reduce using rule 27 (expr -> external .)
    END             reduce using rule 27 (expr -> external .)
    ELIF            reduce using rule 27 (expr -> external .)
    ELSE            reduce using rule 27 (expr -> external .)
    ,               reduce using rule 27 (expr -> external .)
    ]               reduce using rule 27 (expr -> external .)


state 25

    (28) expr -> enum .
    NEWLINE         reduce using rule 28 (expr -> enum .)
    (               reduce using rule 28 (expr -> enum .)
    SOME_SUB        reduce using rule 28 (expr -> enum .)
    SOME_CONCAT     reduce using rule 28 (expr -> enum .)
    ARROW_BOTH      reduce using rule 28 (expr -> enum .)
    ARROW_RIGHT     reduce using rule 28 (expr -> enum .)
    ARROW_LEFT      reduce using rule 28 (expr -> enum .)
    DOUBLE_ARROW_RIGHT reduce using rule 28 (expr -> enum .)
    DOUBLE_ARROW_LEFT reduce using rule 28 (expr -> enum .)
    BIT_SHIFT_RIGHT reduce using rule 28 (expr -> enum .)
    BIT_SHIFT_LEFT  reduce using rule 28 (expr -> enum .)
    BIT_AND         reduce using rule 28 (expr -> enum .)
    BIT_OR          reduce using rule 28 (expr -> enum .)
    FLOAT_POW       reduce using rule 28 (expr -> enum .)
    POW             reduce using rule 28 (expr -> enum .)
    ARRAY_SUB       reduce using rule 28 (expr -> enum .)
    ARRAY_CONCAT    reduce using rule 28 (expr -> enum .)
    MORE_OR_EQ      reduce using rule 28 (expr -> enum .)
    LESS_OR_EQ      reduce using rule 28 (expr -> enum .)
    TEXT_MATCH      reduce using rule 28 (expr -> enum .)
    STRICT_AND      reduce using rule 28 (expr -> enum .)
    AND             reduce using rule 28 (expr -> enum .)
    STRICT_OR       reduce using rule 28 (expr -> enum .)
    OR              reduce using rule 28 (expr -> enum .)
    EQUAL           reduce using rule 28 (expr -> enum .)
    NOT_EQUAL       reduce using rule 28 (expr -> enum .)
    >               reduce using rule 28 (expr -> enum .)
    FLOAT_MUL       reduce using rule 28 (expr -> enum .)
    FLOAT_DIV       reduce using rule 28 (expr -> enum .)
    FLOAT_SUB       reduce using rule 28 (expr -> enum .)
    FLOAT_SUM       reduce using rule 28 (expr -> enum .)
    <               reduce using rule 28 (expr -> enum .)
    *               reduce using rule 28 (expr -> enum .)
    /               reduce using rule 28 (expr -> enum .)
    -               reduce using rule 28 (expr -> enum .)
    +               reduce using rule 28 (expr -> enum .)
    CONCAT          reduce using rule 28 (expr -> enum .)
    $end            reduce using rule 28 (expr -> enum .)
    )               reduce using rule 28 (expr -> enum .)
    INTERPOLATION_BOTH reduce using rule 28 (expr -> enum .)
    INTERPOLATION_RIGHT reduce using rule 28 (expr -> enum .)
    OF              reduce using rule 28 (expr -> enum .)
    THEN            reduce using rule 28 (expr -> enum .)
    END             reduce using rule 28 (expr -> enum .)
    ELIF            reduce using rule 28 (expr -> enum .)
    ELSE            reduce using rule 28 (expr -> enum .)
    ,               reduce using rule 28 (expr -> enum .)
    ]               reduce using rule 28 (expr -> enum .)


state 26

    (296) str_inter -> INTERPOLATION_LEFT . expr inter_or_str
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 86
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 27

    (104) binary_op_def -> DEF . binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> DEF . binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (135) def_expr -> DEF . identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> DEF . identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (69) binary_op -> . SOME_SUB
    (70) binary_op -> . SOME_CONCAT
    (71) binary_op -> . ARROW_BOTH
    (72) binary_op -> . ARROW_RIGHT
    (73) binary_op -> . ARROW_LEFT
    (74) binary_op -> . DOUBLE_ARROW_RIGHT
    (75) binary_op -> . DOUBLE_ARROW_LEFT
    (76) binary_op -> . BIT_SHIFT_RIGHT
    (77) binary_op -> . BIT_SHIFT_LEFT
    (78) binary_op -> . BIT_AND
    (79) binary_op -> . BIT_OR
    (80) binary_op -> . FLOAT_POW
    (81) binary_op -> . POW
    (82) binary_op -> . ARRAY_SUB
    (83) binary_op -> . ARRAY_CONCAT
    (84) binary_op -> . MORE_OR_EQ
    (85) binary_op -> . LESS_OR_EQ
    (86) binary_op -> . TEXT_MATCH
    (87) binary_op -> . STRICT_AND
    (88) binary_op -> . AND
    (89) binary_op -> . STRICT_OR
    (90) binary_op -> . OR
    (91) binary_op -> . EQUAL
    (92) binary_op -> . NOT_EQUAL
    (93) binary_op -> . >
    (94) binary_op -> . FLOAT_MUL
    (95) binary_op -> . FLOAT_DIV
    (96) binary_op -> . FLOAT_SUB
    (97) binary_op -> . FLOAT_SUM
    (98) binary_op -> . <
    (99) binary_op -> . *
    (100) binary_op -> . /
    (101) binary_op -> . -
    (102) binary_op -> . +
    (103) binary_op -> . CONCAT
    (282) identifier -> . IDENTIFIER
    SOME_SUB        shift and go to state 91
    SOME_CONCAT     shift and go to state 92
    ARROW_BOTH      shift and go to state 93
    ARROW_RIGHT     shift and go to state 94
    ARROW_LEFT      shift and go to state 95
    DOUBLE_ARROW_RIGHT shift and go to state 96
    DOUBLE_ARROW_LEFT shift and go to state 97
    BIT_SHIFT_RIGHT shift and go to state 98
    BIT_SHIFT_LEFT  shift and go to state 99
    BIT_AND         shift and go to state 100
    BIT_OR          shift and go to state 101
    FLOAT_POW       shift and go to state 102
    POW             shift and go to state 103
    ARRAY_SUB       shift and go to state 104
    ARRAY_CONCAT    shift and go to state 105
    MORE_OR_EQ      shift and go to state 106
    LESS_OR_EQ      shift and go to state 107
    TEXT_MATCH      shift and go to state 108
    STRICT_AND      shift and go to state 109
    AND             shift and go to state 110
    STRICT_OR       shift and go to state 111
    OR              shift and go to state 112
    EQUAL           shift and go to state 113
    NOT_EQUAL       shift and go to state 114
    >               shift and go to state 89
    FLOAT_MUL       shift and go to state 115
    FLOAT_DIV       shift and go to state 116
    FLOAT_SUB       shift and go to state 117
    FLOAT_SUM       shift and go to state 118
    <               shift and go to state 88
    *               shift and go to state 119
    /               shift and go to state 120
    -               shift and go to state 121
    +               shift and go to state 122
    CONCAT          shift and go to state 123
    IDENTIFIER      shift and go to state 37

    binary_op                      shift and go to state 87
    identifier                     shift and go to state 90

state 28

    (269) variant_call -> type_identifier . ( _59_NEWLINE_optional _60_exprs_optional )
    (               shift and go to state 124


state 29

    (29) unary_expr -> + . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 125
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 30

    (30) unary_expr -> ! . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 126
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 31

    (31) unary_expr -> STRICT_NOT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 127
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 32

    (32) unary_expr -> - . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 128
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 33

    (295) str_literal -> STRING .
    NEWLINE         reduce using rule 295 (str_literal -> STRING .)
    (               reduce using rule 295 (str_literal -> STRING .)
    SOME_SUB        reduce using rule 295 (str_literal -> STRING .)
    SOME_CONCAT     reduce using rule 295 (str_literal -> STRING .)
    ARROW_BOTH      reduce using rule 295 (str_literal -> STRING .)
    ARROW_RIGHT     reduce using rule 295 (str_literal -> STRING .)
    ARROW_LEFT      reduce using rule 295 (str_literal -> STRING .)
    DOUBLE_ARROW_RIGHT reduce using rule 295 (str_literal -> STRING .)
    DOUBLE_ARROW_LEFT reduce using rule 295 (str_literal -> STRING .)
    BIT_SHIFT_RIGHT reduce using rule 295 (str_literal -> STRING .)
    BIT_SHIFT_LEFT  reduce using rule 295 (str_literal -> STRING .)
    BIT_AND         reduce using rule 295 (str_literal -> STRING .)
    BIT_OR          reduce using rule 295 (str_literal -> STRING .)
    FLOAT_POW       reduce using rule 295 (str_literal -> STRING .)
    POW             reduce using rule 295 (str_literal -> STRING .)
    ARRAY_SUB       reduce using rule 295 (str_literal -> STRING .)
    ARRAY_CONCAT    reduce using rule 295 (str_literal -> STRING .)
    MORE_OR_EQ      reduce using rule 295 (str_literal -> STRING .)
    LESS_OR_EQ      reduce using rule 295 (str_literal -> STRING .)
    TEXT_MATCH      reduce using rule 295 (str_literal -> STRING .)
    STRICT_AND      reduce using rule 295 (str_literal -> STRING .)
    AND             reduce using rule 295 (str_literal -> STRING .)
    STRICT_OR       reduce using rule 295 (str_literal -> STRING .)
    OR              reduce using rule 295 (str_literal -> STRING .)
    EQUAL           reduce using rule 295 (str_literal -> STRING .)
    NOT_EQUAL       reduce using rule 295 (str_literal -> STRING .)
    >               reduce using rule 295 (str_literal -> STRING .)
    FLOAT_MUL       reduce using rule 295 (str_literal -> STRING .)
    FLOAT_DIV       reduce using rule 295 (str_literal -> STRING .)
    FLOAT_SUB       reduce using rule 295 (str_literal -> STRING .)
    FLOAT_SUM       reduce using rule 295 (str_literal -> STRING .)
    <               reduce using rule 295 (str_literal -> STRING .)
    *               reduce using rule 295 (str_literal -> STRING .)
    /               reduce using rule 295 (str_literal -> STRING .)
    -               reduce using rule 295 (str_literal -> STRING .)
    +               reduce using rule 295 (str_literal -> STRING .)
    CONCAT          reduce using rule 295 (str_literal -> STRING .)
    $end            reduce using rule 295 (str_literal -> STRING .)
    )               reduce using rule 295 (str_literal -> STRING .)
    INTERPOLATION_BOTH reduce using rule 295 (str_literal -> STRING .)
    INTERPOLATION_RIGHT reduce using rule 295 (str_literal -> STRING .)
    OF              reduce using rule 295 (str_literal -> STRING .)
    THEN            reduce using rule 295 (str_literal -> STRING .)
    END             reduce using rule 295 (str_literal -> STRING .)
    ELIF            reduce using rule 295 (str_literal -> STRING .)
    ELSE            reduce using rule 295 (str_literal -> STRING .)
    ,               reduce using rule 295 (str_literal -> STRING .)
    ]               reduce using rule 295 (str_literal -> STRING .)


state 34

    (294) float_literal -> FLOAT .
    NEWLINE         reduce using rule 294 (float_literal -> FLOAT .)
    (               reduce using rule 294 (float_literal -> FLOAT .)
    SOME_SUB        reduce using rule 294 (float_literal -> FLOAT .)
    SOME_CONCAT     reduce using rule 294 (float_literal -> FLOAT .)
    ARROW_BOTH      reduce using rule 294 (float_literal -> FLOAT .)
    ARROW_RIGHT     reduce using rule 294 (float_literal -> FLOAT .)
    ARROW_LEFT      reduce using rule 294 (float_literal -> FLOAT .)
    DOUBLE_ARROW_RIGHT reduce using rule 294 (float_literal -> FLOAT .)
    DOUBLE_ARROW_LEFT reduce using rule 294 (float_literal -> FLOAT .)
    BIT_SHIFT_RIGHT reduce using rule 294 (float_literal -> FLOAT .)
    BIT_SHIFT_LEFT  reduce using rule 294 (float_literal -> FLOAT .)
    BIT_AND         reduce using rule 294 (float_literal -> FLOAT .)
    BIT_OR          reduce using rule 294 (float_literal -> FLOAT .)
    FLOAT_POW       reduce using rule 294 (float_literal -> FLOAT .)
    POW             reduce using rule 294 (float_literal -> FLOAT .)
    ARRAY_SUB       reduce using rule 294 (float_literal -> FLOAT .)
    ARRAY_CONCAT    reduce using rule 294 (float_literal -> FLOAT .)
    MORE_OR_EQ      reduce using rule 294 (float_literal -> FLOAT .)
    LESS_OR_EQ      reduce using rule 294 (float_literal -> FLOAT .)
    TEXT_MATCH      reduce using rule 294 (float_literal -> FLOAT .)
    STRICT_AND      reduce using rule 294 (float_literal -> FLOAT .)
    AND             reduce using rule 294 (float_literal -> FLOAT .)
    STRICT_OR       reduce using rule 294 (float_literal -> FLOAT .)
    OR              reduce using rule 294 (float_literal -> FLOAT .)
    EQUAL           reduce using rule 294 (float_literal -> FLOAT .)
    NOT_EQUAL       reduce using rule 294 (float_literal -> FLOAT .)
    >               reduce using rule 294 (float_literal -> FLOAT .)
    FLOAT_MUL       reduce using rule 294 (float_literal -> FLOAT .)
    FLOAT_DIV       reduce using rule 294 (float_literal -> FLOAT .)
    FLOAT_SUB       reduce using rule 294 (float_literal -> FLOAT .)
    FLOAT_SUM       reduce using rule 294 (float_literal -> FLOAT .)
    <               reduce using rule 294 (float_literal -> FLOAT .)
    *               reduce using rule 294 (float_literal -> FLOAT .)
    /               reduce using rule 294 (float_literal -> FLOAT .)
    -               reduce using rule 294 (float_literal -> FLOAT .)
    +               reduce using rule 294 (float_literal -> FLOAT .)
    CONCAT          reduce using rule 294 (float_literal -> FLOAT .)
    $end            reduce using rule 294 (float_literal -> FLOAT .)
    )               reduce using rule 294 (float_literal -> FLOAT .)
    INTERPOLATION_BOTH reduce using rule 294 (float_literal -> FLOAT .)
    INTERPOLATION_RIGHT reduce using rule 294 (float_literal -> FLOAT .)
    OF              reduce using rule 294 (float_literal -> FLOAT .)
    THEN            reduce using rule 294 (float_literal -> FLOAT .)
    END             reduce using rule 294 (float_literal -> FLOAT .)
    ELIF            reduce using rule 294 (float_literal -> FLOAT .)
    ELSE            reduce using rule 294 (float_literal -> FLOAT .)
    ,               reduce using rule 294 (float_literal -> FLOAT .)
    ]               reduce using rule 294 (float_literal -> FLOAT .)


state 35

    (293) int_literal -> INT .
    NEWLINE         reduce using rule 293 (int_literal -> INT .)
    (               reduce using rule 293 (int_literal -> INT .)
    SOME_SUB        reduce using rule 293 (int_literal -> INT .)
    SOME_CONCAT     reduce using rule 293 (int_literal -> INT .)
    ARROW_BOTH      reduce using rule 293 (int_literal -> INT .)
    ARROW_RIGHT     reduce using rule 293 (int_literal -> INT .)
    ARROW_LEFT      reduce using rule 293 (int_literal -> INT .)
    DOUBLE_ARROW_RIGHT reduce using rule 293 (int_literal -> INT .)
    DOUBLE_ARROW_LEFT reduce using rule 293 (int_literal -> INT .)
    BIT_SHIFT_RIGHT reduce using rule 293 (int_literal -> INT .)
    BIT_SHIFT_LEFT  reduce using rule 293 (int_literal -> INT .)
    BIT_AND         reduce using rule 293 (int_literal -> INT .)
    BIT_OR          reduce using rule 293 (int_literal -> INT .)
    FLOAT_POW       reduce using rule 293 (int_literal -> INT .)
    POW             reduce using rule 293 (int_literal -> INT .)
    ARRAY_SUB       reduce using rule 293 (int_literal -> INT .)
    ARRAY_CONCAT    reduce using rule 293 (int_literal -> INT .)
    MORE_OR_EQ      reduce using rule 293 (int_literal -> INT .)
    LESS_OR_EQ      reduce using rule 293 (int_literal -> INT .)
    TEXT_MATCH      reduce using rule 293 (int_literal -> INT .)
    STRICT_AND      reduce using rule 293 (int_literal -> INT .)
    AND             reduce using rule 293 (int_literal -> INT .)
    STRICT_OR       reduce using rule 293 (int_literal -> INT .)
    OR              reduce using rule 293 (int_literal -> INT .)
    EQUAL           reduce using rule 293 (int_literal -> INT .)
    NOT_EQUAL       reduce using rule 293 (int_literal -> INT .)
    >               reduce using rule 293 (int_literal -> INT .)
    FLOAT_MUL       reduce using rule 293 (int_literal -> INT .)
    FLOAT_DIV       reduce using rule 293 (int_literal -> INT .)
    FLOAT_SUB       reduce using rule 293 (int_literal -> INT .)
    FLOAT_SUM       reduce using rule 293 (int_literal -> INT .)
    <               reduce using rule 293 (int_literal -> INT .)
    *               reduce using rule 293 (int_literal -> INT .)
    /               reduce using rule 293 (int_literal -> INT .)
    -               reduce using rule 293 (int_literal -> INT .)
    +               reduce using rule 293 (int_literal -> INT .)
    CONCAT          reduce using rule 293 (int_literal -> INT .)
    $end            reduce using rule 293 (int_literal -> INT .)
    )               reduce using rule 293 (int_literal -> INT .)
    INTERPOLATION_BOTH reduce using rule 293 (int_literal -> INT .)
    INTERPOLATION_RIGHT reduce using rule 293 (int_literal -> INT .)
    OF              reduce using rule 293 (int_literal -> INT .)
    THEN            reduce using rule 293 (int_literal -> INT .)
    END             reduce using rule 293 (int_literal -> INT .)
    ELIF            reduce using rule 293 (int_literal -> INT .)
    ELSE            reduce using rule 293 (int_literal -> INT .)
    ,               reduce using rule 293 (int_literal -> INT .)
    ]               reduce using rule 293 (int_literal -> INT .)


state 36

    (259) array -> [ . _55_NEWLINE_optional _56_exprs_optional ]
    (260) _55_NEWLINE_optional -> . NEWLINE
    (261) _55_NEWLINE_optional -> .
    NEWLINE         shift and go to state 130
    (               reduce using rule 261 (_55_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 261 (_55_NEWLINE_optional -> .)
    DEF             reduce using rule 261 (_55_NEWLINE_optional -> .)
    +               reduce using rule 261 (_55_NEWLINE_optional -> .)
    !               reduce using rule 261 (_55_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 261 (_55_NEWLINE_optional -> .)
    -               reduce using rule 261 (_55_NEWLINE_optional -> .)
    STRING          reduce using rule 261 (_55_NEWLINE_optional -> .)
    FLOAT           reduce using rule 261 (_55_NEWLINE_optional -> .)
    INT             reduce using rule 261 (_55_NEWLINE_optional -> .)
    [               reduce using rule 261 (_55_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 261 (_55_NEWLINE_optional -> .)
    CASE            reduce using rule 261 (_55_NEWLINE_optional -> .)
    IF              reduce using rule 261 (_55_NEWLINE_optional -> .)
    DO              reduce using rule 261 (_55_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 261 (_55_NEWLINE_optional -> .)
    TYPE            reduce using rule 261 (_55_NEWLINE_optional -> .)
    ENUM            reduce using rule 261 (_55_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 261 (_55_NEWLINE_optional -> .)
    ]               reduce using rule 261 (_55_NEWLINE_optional -> .)

    _55_NEWLINE_optional           shift and go to state 129

state 37

    (282) identifier -> IDENTIFIER .
    :               reduce using rule 282 (identifier -> IDENTIFIER .)
    =               reduce using rule 282 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 282 (identifier -> IDENTIFIER .)
    (               reduce using rule 282 (identifier -> IDENTIFIER .)
    SOME_SUB        reduce using rule 282 (identifier -> IDENTIFIER .)
    SOME_CONCAT     reduce using rule 282 (identifier -> IDENTIFIER .)
    ARROW_BOTH      reduce using rule 282 (identifier -> IDENTIFIER .)
    ARROW_RIGHT     reduce using rule 282 (identifier -> IDENTIFIER .)
    ARROW_LEFT      reduce using rule 282 (identifier -> IDENTIFIER .)
    DOUBLE_ARROW_RIGHT reduce using rule 282 (identifier -> IDENTIFIER .)
    DOUBLE_ARROW_LEFT reduce using rule 282 (identifier -> IDENTIFIER .)
    BIT_SHIFT_RIGHT reduce using rule 282 (identifier -> IDENTIFIER .)
    BIT_SHIFT_LEFT  reduce using rule 282 (identifier -> IDENTIFIER .)
    BIT_AND         reduce using rule 282 (identifier -> IDENTIFIER .)
    BIT_OR          reduce using rule 282 (identifier -> IDENTIFIER .)
    FLOAT_POW       reduce using rule 282 (identifier -> IDENTIFIER .)
    POW             reduce using rule 282 (identifier -> IDENTIFIER .)
    ARRAY_SUB       reduce using rule 282 (identifier -> IDENTIFIER .)
    ARRAY_CONCAT    reduce using rule 282 (identifier -> IDENTIFIER .)
    MORE_OR_EQ      reduce using rule 282 (identifier -> IDENTIFIER .)
    LESS_OR_EQ      reduce using rule 282 (identifier -> IDENTIFIER .)
    TEXT_MATCH      reduce using rule 282 (identifier -> IDENTIFIER .)
    STRICT_AND      reduce using rule 282 (identifier -> IDENTIFIER .)
    AND             reduce using rule 282 (identifier -> IDENTIFIER .)
    STRICT_OR       reduce using rule 282 (identifier -> IDENTIFIER .)
    OR              reduce using rule 282 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 282 (identifier -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 282 (identifier -> IDENTIFIER .)
    >               reduce using rule 282 (identifier -> IDENTIFIER .)
    FLOAT_MUL       reduce using rule 282 (identifier -> IDENTIFIER .)
    FLOAT_DIV       reduce using rule 282 (identifier -> IDENTIFIER .)
    FLOAT_SUB       reduce using rule 282 (identifier -> IDENTIFIER .)
    FLOAT_SUM       reduce using rule 282 (identifier -> IDENTIFIER .)
    <               reduce using rule 282 (identifier -> IDENTIFIER .)
    *               reduce using rule 282 (identifier -> IDENTIFIER .)
    /               reduce using rule 282 (identifier -> IDENTIFIER .)
    -               reduce using rule 282 (identifier -> IDENTIFIER .)
    +               reduce using rule 282 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 282 (identifier -> IDENTIFIER .)
    $end            reduce using rule 282 (identifier -> IDENTIFIER .)
    )               reduce using rule 282 (identifier -> IDENTIFIER .)
    INTERPOLATION_BOTH reduce using rule 282 (identifier -> IDENTIFIER .)
    INTERPOLATION_RIGHT reduce using rule 282 (identifier -> IDENTIFIER .)
    OF              reduce using rule 282 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 282 (identifier -> IDENTIFIER .)
    END             reduce using rule 282 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 282 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 282 (identifier -> IDENTIFIER .)
    ,               reduce using rule 282 (identifier -> IDENTIFIER .)
    ]               reduce using rule 282 (identifier -> IDENTIFIER .)
    DO              reduce using rule 282 (identifier -> IDENTIFIER .)


state 38

    (231) case_of -> CASE . expr OF _46_NEWLINE_optional _47_cases_optional END
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 131
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 39

    (222) if_expr -> IF . expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 132
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 40

    (127) do -> DO . _13_0x3a_type_optional block_statement END
    (128) _13_0x3a_type_optional -> . : type
    (129) _13_0x3a_type_optional -> .
    :               shift and go to state 134
    NEWLINE         reduce using rule 129 (_13_0x3a_type_optional -> .)
    END             reduce using rule 129 (_13_0x3a_type_optional -> .)
    (               reduce using rule 129 (_13_0x3a_type_optional -> .)
    INTERPOLATION_LEFT reduce using rule 129 (_13_0x3a_type_optional -> .)
    DEF             reduce using rule 129 (_13_0x3a_type_optional -> .)
    +               reduce using rule 129 (_13_0x3a_type_optional -> .)
    !               reduce using rule 129 (_13_0x3a_type_optional -> .)
    STRICT_NOT      reduce using rule 129 (_13_0x3a_type_optional -> .)
    -               reduce using rule 129 (_13_0x3a_type_optional -> .)
    STRING          reduce using rule 129 (_13_0x3a_type_optional -> .)
    FLOAT           reduce using rule 129 (_13_0x3a_type_optional -> .)
    INT             reduce using rule 129 (_13_0x3a_type_optional -> .)
    [               reduce using rule 129 (_13_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 129 (_13_0x3a_type_optional -> .)
    CASE            reduce using rule 129 (_13_0x3a_type_optional -> .)
    IF              reduce using rule 129 (_13_0x3a_type_optional -> .)
    DO              reduce using rule 129 (_13_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 129 (_13_0x3a_type_optional -> .)
    TYPE            reduce using rule 129 (_13_0x3a_type_optional -> .)
    ENUM            reduce using rule 129 (_13_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 129 (_13_0x3a_type_optional -> .)

    _13_0x3a_type_optional         shift and go to state 133

state 41

    (33) external -> EXTERNAL .
    NEWLINE         reduce using rule 33 (external -> EXTERNAL .)
    (               reduce using rule 33 (external -> EXTERNAL .)
    SOME_SUB        reduce using rule 33 (external -> EXTERNAL .)
    SOME_CONCAT     reduce using rule 33 (external -> EXTERNAL .)
    ARROW_BOTH      reduce using rule 33 (external -> EXTERNAL .)
    ARROW_RIGHT     reduce using rule 33 (external -> EXTERNAL .)
    ARROW_LEFT      reduce using rule 33 (external -> EXTERNAL .)
    DOUBLE_ARROW_RIGHT reduce using rule 33 (external -> EXTERNAL .)
    DOUBLE_ARROW_LEFT reduce using rule 33 (external -> EXTERNAL .)
    BIT_SHIFT_RIGHT reduce using rule 33 (external -> EXTERNAL .)
    BIT_SHIFT_LEFT  reduce using rule 33 (external -> EXTERNAL .)
    BIT_AND         reduce using rule 33 (external -> EXTERNAL .)
    BIT_OR          reduce using rule 33 (external -> EXTERNAL .)
    FLOAT_POW       reduce using rule 33 (external -> EXTERNAL .)
    POW             reduce using rule 33 (external -> EXTERNAL .)
    ARRAY_SUB       reduce using rule 33 (external -> EXTERNAL .)
    ARRAY_CONCAT    reduce using rule 33 (external -> EXTERNAL .)
    MORE_OR_EQ      reduce using rule 33 (external -> EXTERNAL .)
    LESS_OR_EQ      reduce using rule 33 (external -> EXTERNAL .)
    TEXT_MATCH      reduce using rule 33 (external -> EXTERNAL .)
    STRICT_AND      reduce using rule 33 (external -> EXTERNAL .)
    AND             reduce using rule 33 (external -> EXTERNAL .)
    STRICT_OR       reduce using rule 33 (external -> EXTERNAL .)
    OR              reduce using rule 33 (external -> EXTERNAL .)
    EQUAL           reduce using rule 33 (external -> EXTERNAL .)
    NOT_EQUAL       reduce using rule 33 (external -> EXTERNAL .)
    >               reduce using rule 33 (external -> EXTERNAL .)
    FLOAT_MUL       reduce using rule 33 (external -> EXTERNAL .)
    FLOAT_DIV       reduce using rule 33 (external -> EXTERNAL .)
    FLOAT_SUB       reduce using rule 33 (external -> EXTERNAL .)
    FLOAT_SUM       reduce using rule 33 (external -> EXTERNAL .)
    <               reduce using rule 33 (external -> EXTERNAL .)
    *               reduce using rule 33 (external -> EXTERNAL .)
    /               reduce using rule 33 (external -> EXTERNAL .)
    -               reduce using rule 33 (external -> EXTERNAL .)
    +               reduce using rule 33 (external -> EXTERNAL .)
    CONCAT          reduce using rule 33 (external -> EXTERNAL .)
    $end            reduce using rule 33 (external -> EXTERNAL .)
    )               reduce using rule 33 (external -> EXTERNAL .)
    INTERPOLATION_BOTH reduce using rule 33 (external -> EXTERNAL .)
    INTERPOLATION_RIGHT reduce using rule 33 (external -> EXTERNAL .)
    OF              reduce using rule 33 (external -> EXTERNAL .)
    THEN            reduce using rule 33 (external -> EXTERNAL .)
    END             reduce using rule 33 (external -> EXTERNAL .)
    ELIF            reduce using rule 33 (external -> EXTERNAL .)
    ELSE            reduce using rule 33 (external -> EXTERNAL .)
    ,               reduce using rule 33 (external -> EXTERNAL .)
    ]               reduce using rule 33 (external -> EXTERNAL .)


state 42

    (169) enum -> TYPE . type_identifier
    (170) enum -> TYPE . type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> TYPE . type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 135

state 43

    (185) enum -> ENUM . type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> ENUM . type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 136

state 44

    (283) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    SOME_SUB        reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    SOME_CONCAT     reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ARROW_BOTH      reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ARROW_RIGHT     reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ARROW_LEFT      reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    DOUBLE_ARROW_RIGHT reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    DOUBLE_ARROW_LEFT reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    BIT_SHIFT_RIGHT reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    BIT_SHIFT_LEFT  reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    BIT_AND         reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    BIT_OR          reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT_POW       reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    POW             reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ARRAY_SUB       reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ARRAY_CONCAT    reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    MORE_OR_EQ      reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    LESS_OR_EQ      reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    TEXT_MATCH      reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    STRICT_AND      reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    AND             reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    STRICT_OR       reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    OR              reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    EQUAL           reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    NOT_EQUAL       reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT_MUL       reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT_DIV       reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT_SUB       reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT_SUM       reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    *               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    /               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    +               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    CONCAT          reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    $end            reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    INTERPOLATION_BOTH reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    INTERPOLATION_RIGHT reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    OF              reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    THEN            reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ]               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    INTERPOLATION_LEFT reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    !               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    STRICT_NOT      reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT           reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    INT             reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE            reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    LINE            reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 283 (type_identifier -> TYPE_IDENTIFIER .)


state 45

    (6) do_exprs -> expr _3_NEWLINE_optional .
    $end            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    END             reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    ELIF            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    ELSE            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)


state 46

    (9) do_exprs -> expr NEWLINE . do_exprs
    (7) _3_NEWLINE_optional -> NEWLINE .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 6
    do_exprs                       shift and go to state 137
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 47

    (264) call -> expr ( . _57_NEWLINE_optional _58_exprs_optional )
    (265) _57_NEWLINE_optional -> . NEWLINE
    (266) _57_NEWLINE_optional -> .
    NEWLINE         shift and go to state 139
    (               reduce using rule 266 (_57_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 266 (_57_NEWLINE_optional -> .)
    DEF             reduce using rule 266 (_57_NEWLINE_optional -> .)
    +               reduce using rule 266 (_57_NEWLINE_optional -> .)
    !               reduce using rule 266 (_57_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 266 (_57_NEWLINE_optional -> .)
    -               reduce using rule 266 (_57_NEWLINE_optional -> .)
    STRING          reduce using rule 266 (_57_NEWLINE_optional -> .)
    FLOAT           reduce using rule 266 (_57_NEWLINE_optional -> .)
    INT             reduce using rule 266 (_57_NEWLINE_optional -> .)
    [               reduce using rule 266 (_57_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 266 (_57_NEWLINE_optional -> .)
    CASE            reduce using rule 266 (_57_NEWLINE_optional -> .)
    IF              reduce using rule 266 (_57_NEWLINE_optional -> .)
    DO              reduce using rule 266 (_57_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 266 (_57_NEWLINE_optional -> .)
    TYPE            reduce using rule 266 (_57_NEWLINE_optional -> .)
    ENUM            reduce using rule 266 (_57_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 266 (_57_NEWLINE_optional -> .)
    )               reduce using rule 266 (_57_NEWLINE_optional -> .)

    _57_NEWLINE_optional           shift and go to state 138

state 48

    (34) binary_expr -> expr SOME_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 140
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 49

    (35) binary_expr -> expr SOME_CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 141
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 50

    (36) binary_expr -> expr ARROW_BOTH . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 142
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 51

    (37) binary_expr -> expr ARROW_RIGHT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 143
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 52

    (38) binary_expr -> expr ARROW_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 144
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 53

    (39) binary_expr -> expr DOUBLE_ARROW_RIGHT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 145
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 54

    (40) binary_expr -> expr DOUBLE_ARROW_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 146
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 55

    (41) binary_expr -> expr BIT_SHIFT_RIGHT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 147
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 56

    (42) binary_expr -> expr BIT_SHIFT_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 148
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 57

    (43) binary_expr -> expr BIT_AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 149
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 58

    (44) binary_expr -> expr BIT_OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 150
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 59

    (45) binary_expr -> expr FLOAT_POW . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 151
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 60

    (46) binary_expr -> expr POW . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 152
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 61

    (47) binary_expr -> expr ARRAY_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 153
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 62

    (48) binary_expr -> expr ARRAY_CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 154
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 63

    (49) binary_expr -> expr MORE_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 155
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 64

    (50) binary_expr -> expr LESS_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 156
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 65

    (51) binary_expr -> expr TEXT_MATCH . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 157
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 66

    (52) binary_expr -> expr STRICT_AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 158
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 67

    (53) binary_expr -> expr AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 159
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 68

    (54) binary_expr -> expr STRICT_OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 160
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 69

    (55) binary_expr -> expr OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 161
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 70

    (56) binary_expr -> expr EQUAL . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 162
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 71

    (57) binary_expr -> expr NOT_EQUAL . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 163
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 72

    (58) binary_expr -> expr > . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 164
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 73

    (59) binary_expr -> expr FLOAT_MUL . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 165
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 74

    (60) binary_expr -> expr FLOAT_DIV . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 166
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 75

    (61) binary_expr -> expr FLOAT_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 167
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 76

    (62) binary_expr -> expr FLOAT_SUM . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 168
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 77

    (63) binary_expr -> expr < . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 169
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 78

    (64) binary_expr -> expr * . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 170
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 79

    (65) binary_expr -> expr / . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 171
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 80

    (66) binary_expr -> expr - . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 172
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 81

    (67) binary_expr -> expr + . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 173
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 82

    (68) binary_expr -> expr CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 174
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 83

    (10) expr -> ( expr . )
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    )               shift and go to state 175
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 84

    (284) let -> identifier : . type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (291) _65_0x3a_type_optional -> : . type
    (283) type_identifier -> . TYPE_IDENTIFIER
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 176
    type                           shift and go to state 177

state 85

    (290) let -> identifier _65_0x3a_type_optional . = expr
    =               shift and go to state 178


state 86

    (296) str_inter -> INTERPOLATION_LEFT expr . inter_or_str
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    (297) inter_or_str -> . INTERPOLATION_BOTH expr inter_or_str
    (298) inter_or_str -> . INTERPOLATION_RIGHT
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82
    INTERPOLATION_BOTH shift and go to state 180
    INTERPOLATION_RIGHT shift and go to state 181

    inter_or_str                   shift and go to state 179

state 87

    (104) binary_op_def -> DEF binary_op . ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> DEF binary_op . < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (               shift and go to state 182
    <               shift and go to state 183


state 88

    (98) binary_op -> < .
    (               reduce using rule 98 (binary_op -> < .)
    <               reduce using rule 98 (binary_op -> < .)


state 89

    (93) binary_op -> > .
    (               reduce using rule 93 (binary_op -> > .)
    <               reduce using rule 93 (binary_op -> > .)


state 90

    (135) def_expr -> DEF identifier . ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> DEF identifier . < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (               shift and go to state 184
    <               shift and go to state 185


state 91

    (69) binary_op -> SOME_SUB .
    (               reduce using rule 69 (binary_op -> SOME_SUB .)
    <               reduce using rule 69 (binary_op -> SOME_SUB .)


state 92

    (70) binary_op -> SOME_CONCAT .
    (               reduce using rule 70 (binary_op -> SOME_CONCAT .)
    <               reduce using rule 70 (binary_op -> SOME_CONCAT .)


state 93

    (71) binary_op -> ARROW_BOTH .
    (               reduce using rule 71 (binary_op -> ARROW_BOTH .)
    <               reduce using rule 71 (binary_op -> ARROW_BOTH .)


state 94

    (72) binary_op -> ARROW_RIGHT .
    (               reduce using rule 72 (binary_op -> ARROW_RIGHT .)
    <               reduce using rule 72 (binary_op -> ARROW_RIGHT .)


state 95

    (73) binary_op -> ARROW_LEFT .
    (               reduce using rule 73 (binary_op -> ARROW_LEFT .)
    <               reduce using rule 73 (binary_op -> ARROW_LEFT .)


state 96

    (74) binary_op -> DOUBLE_ARROW_RIGHT .
    (               reduce using rule 74 (binary_op -> DOUBLE_ARROW_RIGHT .)
    <               reduce using rule 74 (binary_op -> DOUBLE_ARROW_RIGHT .)


state 97

    (75) binary_op -> DOUBLE_ARROW_LEFT .
    (               reduce using rule 75 (binary_op -> DOUBLE_ARROW_LEFT .)
    <               reduce using rule 75 (binary_op -> DOUBLE_ARROW_LEFT .)


state 98

    (76) binary_op -> BIT_SHIFT_RIGHT .
    (               reduce using rule 76 (binary_op -> BIT_SHIFT_RIGHT .)
    <               reduce using rule 76 (binary_op -> BIT_SHIFT_RIGHT .)


state 99

    (77) binary_op -> BIT_SHIFT_LEFT .
    (               reduce using rule 77 (binary_op -> BIT_SHIFT_LEFT .)
    <               reduce using rule 77 (binary_op -> BIT_SHIFT_LEFT .)


state 100

    (78) binary_op -> BIT_AND .
    (               reduce using rule 78 (binary_op -> BIT_AND .)
    <               reduce using rule 78 (binary_op -> BIT_AND .)


state 101

    (79) binary_op -> BIT_OR .
    (               reduce using rule 79 (binary_op -> BIT_OR .)
    <               reduce using rule 79 (binary_op -> BIT_OR .)


state 102

    (80) binary_op -> FLOAT_POW .
    (               reduce using rule 80 (binary_op -> FLOAT_POW .)
    <               reduce using rule 80 (binary_op -> FLOAT_POW .)


state 103

    (81) binary_op -> POW .
    (               reduce using rule 81 (binary_op -> POW .)
    <               reduce using rule 81 (binary_op -> POW .)


state 104

    (82) binary_op -> ARRAY_SUB .
    (               reduce using rule 82 (binary_op -> ARRAY_SUB .)
    <               reduce using rule 82 (binary_op -> ARRAY_SUB .)


state 105

    (83) binary_op -> ARRAY_CONCAT .
    (               reduce using rule 83 (binary_op -> ARRAY_CONCAT .)
    <               reduce using rule 83 (binary_op -> ARRAY_CONCAT .)


state 106

    (84) binary_op -> MORE_OR_EQ .
    (               reduce using rule 84 (binary_op -> MORE_OR_EQ .)
    <               reduce using rule 84 (binary_op -> MORE_OR_EQ .)


state 107

    (85) binary_op -> LESS_OR_EQ .
    (               reduce using rule 85 (binary_op -> LESS_OR_EQ .)
    <               reduce using rule 85 (binary_op -> LESS_OR_EQ .)


state 108

    (86) binary_op -> TEXT_MATCH .
    (               reduce using rule 86 (binary_op -> TEXT_MATCH .)
    <               reduce using rule 86 (binary_op -> TEXT_MATCH .)


state 109

    (87) binary_op -> STRICT_AND .
    (               reduce using rule 87 (binary_op -> STRICT_AND .)
    <               reduce using rule 87 (binary_op -> STRICT_AND .)


state 110

    (88) binary_op -> AND .
    (               reduce using rule 88 (binary_op -> AND .)
    <               reduce using rule 88 (binary_op -> AND .)


state 111

    (89) binary_op -> STRICT_OR .
    (               reduce using rule 89 (binary_op -> STRICT_OR .)
    <               reduce using rule 89 (binary_op -> STRICT_OR .)


state 112

    (90) binary_op -> OR .
    (               reduce using rule 90 (binary_op -> OR .)
    <               reduce using rule 90 (binary_op -> OR .)


state 113

    (91) binary_op -> EQUAL .
    (               reduce using rule 91 (binary_op -> EQUAL .)
    <               reduce using rule 91 (binary_op -> EQUAL .)


state 114

    (92) binary_op -> NOT_EQUAL .
    (               reduce using rule 92 (binary_op -> NOT_EQUAL .)
    <               reduce using rule 92 (binary_op -> NOT_EQUAL .)


state 115

    (94) binary_op -> FLOAT_MUL .
    (               reduce using rule 94 (binary_op -> FLOAT_MUL .)
    <               reduce using rule 94 (binary_op -> FLOAT_MUL .)


state 116

    (95) binary_op -> FLOAT_DIV .
    (               reduce using rule 95 (binary_op -> FLOAT_DIV .)
    <               reduce using rule 95 (binary_op -> FLOAT_DIV .)


state 117

    (96) binary_op -> FLOAT_SUB .
    (               reduce using rule 96 (binary_op -> FLOAT_SUB .)
    <               reduce using rule 96 (binary_op -> FLOAT_SUB .)


state 118

    (97) binary_op -> FLOAT_SUM .
    (               reduce using rule 97 (binary_op -> FLOAT_SUM .)
    <               reduce using rule 97 (binary_op -> FLOAT_SUM .)


state 119

    (99) binary_op -> * .
    (               reduce using rule 99 (binary_op -> * .)
    <               reduce using rule 99 (binary_op -> * .)


state 120

    (100) binary_op -> / .
    (               reduce using rule 100 (binary_op -> / .)
    <               reduce using rule 100 (binary_op -> / .)


state 121

    (101) binary_op -> - .
    (               reduce using rule 101 (binary_op -> - .)
    <               reduce using rule 101 (binary_op -> - .)


state 122

    (102) binary_op -> + .
    (               reduce using rule 102 (binary_op -> + .)
    <               reduce using rule 102 (binary_op -> + .)


state 123

    (103) binary_op -> CONCAT .
    (               reduce using rule 103 (binary_op -> CONCAT .)
    <               reduce using rule 103 (binary_op -> CONCAT .)


state 124

    (269) variant_call -> type_identifier ( . _59_NEWLINE_optional _60_exprs_optional )
    (270) _59_NEWLINE_optional -> . NEWLINE
    (271) _59_NEWLINE_optional -> .
    NEWLINE         shift and go to state 187
    (               reduce using rule 271 (_59_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 271 (_59_NEWLINE_optional -> .)
    DEF             reduce using rule 271 (_59_NEWLINE_optional -> .)
    +               reduce using rule 271 (_59_NEWLINE_optional -> .)
    !               reduce using rule 271 (_59_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 271 (_59_NEWLINE_optional -> .)
    -               reduce using rule 271 (_59_NEWLINE_optional -> .)
    STRING          reduce using rule 271 (_59_NEWLINE_optional -> .)
    FLOAT           reduce using rule 271 (_59_NEWLINE_optional -> .)
    INT             reduce using rule 271 (_59_NEWLINE_optional -> .)
    [               reduce using rule 271 (_59_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 271 (_59_NEWLINE_optional -> .)
    CASE            reduce using rule 271 (_59_NEWLINE_optional -> .)
    IF              reduce using rule 271 (_59_NEWLINE_optional -> .)
    DO              reduce using rule 271 (_59_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 271 (_59_NEWLINE_optional -> .)
    TYPE            reduce using rule 271 (_59_NEWLINE_optional -> .)
    ENUM            reduce using rule 271 (_59_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 271 (_59_NEWLINE_optional -> .)
    )               reduce using rule 271 (_59_NEWLINE_optional -> .)

    _59_NEWLINE_optional           shift and go to state 186

state 125

    (29) unary_expr -> + expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 29 (unary_expr -> + expr .)
    SOME_SUB        reduce using rule 29 (unary_expr -> + expr .)
    SOME_CONCAT     reduce using rule 29 (unary_expr -> + expr .)
    ARROW_BOTH      reduce using rule 29 (unary_expr -> + expr .)
    ARROW_RIGHT     reduce using rule 29 (unary_expr -> + expr .)
    ARROW_LEFT      reduce using rule 29 (unary_expr -> + expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 29 (unary_expr -> + expr .)
    DOUBLE_ARROW_LEFT reduce using rule 29 (unary_expr -> + expr .)
    BIT_SHIFT_RIGHT reduce using rule 29 (unary_expr -> + expr .)
    BIT_SHIFT_LEFT  reduce using rule 29 (unary_expr -> + expr .)
    BIT_AND         reduce using rule 29 (unary_expr -> + expr .)
    BIT_OR          reduce using rule 29 (unary_expr -> + expr .)
    FLOAT_POW       reduce using rule 29 (unary_expr -> + expr .)
    POW             reduce using rule 29 (unary_expr -> + expr .)
    ARRAY_SUB       reduce using rule 29 (unary_expr -> + expr .)
    ARRAY_CONCAT    reduce using rule 29 (unary_expr -> + expr .)
    MORE_OR_EQ      reduce using rule 29 (unary_expr -> + expr .)
    LESS_OR_EQ      reduce using rule 29 (unary_expr -> + expr .)
    TEXT_MATCH      reduce using rule 29 (unary_expr -> + expr .)
    STRICT_AND      reduce using rule 29 (unary_expr -> + expr .)
    AND             reduce using rule 29 (unary_expr -> + expr .)
    STRICT_OR       reduce using rule 29 (unary_expr -> + expr .)
    OR              reduce using rule 29 (unary_expr -> + expr .)
    EQUAL           reduce using rule 29 (unary_expr -> + expr .)
    NOT_EQUAL       reduce using rule 29 (unary_expr -> + expr .)
    >               reduce using rule 29 (unary_expr -> + expr .)
    FLOAT_MUL       reduce using rule 29 (unary_expr -> + expr .)
    FLOAT_DIV       reduce using rule 29 (unary_expr -> + expr .)
    FLOAT_SUB       reduce using rule 29 (unary_expr -> + expr .)
    FLOAT_SUM       reduce using rule 29 (unary_expr -> + expr .)
    <               reduce using rule 29 (unary_expr -> + expr .)
    *               reduce using rule 29 (unary_expr -> + expr .)
    /               reduce using rule 29 (unary_expr -> + expr .)
    -               reduce using rule 29 (unary_expr -> + expr .)
    +               reduce using rule 29 (unary_expr -> + expr .)
    CONCAT          reduce using rule 29 (unary_expr -> + expr .)
    $end            reduce using rule 29 (unary_expr -> + expr .)
    )               reduce using rule 29 (unary_expr -> + expr .)
    INTERPOLATION_BOTH reduce using rule 29 (unary_expr -> + expr .)
    INTERPOLATION_RIGHT reduce using rule 29 (unary_expr -> + expr .)
    OF              reduce using rule 29 (unary_expr -> + expr .)
    THEN            reduce using rule 29 (unary_expr -> + expr .)
    END             reduce using rule 29 (unary_expr -> + expr .)
    ELIF            reduce using rule 29 (unary_expr -> + expr .)
    ELSE            reduce using rule 29 (unary_expr -> + expr .)
    ,               reduce using rule 29 (unary_expr -> + expr .)
    ]               reduce using rule 29 (unary_expr -> + expr .)
    (               shift and go to state 47


state 126

    (30) unary_expr -> ! expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 30 (unary_expr -> ! expr .)
    SOME_SUB        reduce using rule 30 (unary_expr -> ! expr .)
    SOME_CONCAT     reduce using rule 30 (unary_expr -> ! expr .)
    ARROW_BOTH      reduce using rule 30 (unary_expr -> ! expr .)
    ARROW_RIGHT     reduce using rule 30 (unary_expr -> ! expr .)
    ARROW_LEFT      reduce using rule 30 (unary_expr -> ! expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 30 (unary_expr -> ! expr .)
    DOUBLE_ARROW_LEFT reduce using rule 30 (unary_expr -> ! expr .)
    BIT_SHIFT_RIGHT reduce using rule 30 (unary_expr -> ! expr .)
    BIT_SHIFT_LEFT  reduce using rule 30 (unary_expr -> ! expr .)
    BIT_AND         reduce using rule 30 (unary_expr -> ! expr .)
    BIT_OR          reduce using rule 30 (unary_expr -> ! expr .)
    FLOAT_POW       reduce using rule 30 (unary_expr -> ! expr .)
    POW             reduce using rule 30 (unary_expr -> ! expr .)
    ARRAY_SUB       reduce using rule 30 (unary_expr -> ! expr .)
    ARRAY_CONCAT    reduce using rule 30 (unary_expr -> ! expr .)
    MORE_OR_EQ      reduce using rule 30 (unary_expr -> ! expr .)
    LESS_OR_EQ      reduce using rule 30 (unary_expr -> ! expr .)
    TEXT_MATCH      reduce using rule 30 (unary_expr -> ! expr .)
    STRICT_AND      reduce using rule 30 (unary_expr -> ! expr .)
    AND             reduce using rule 30 (unary_expr -> ! expr .)
    STRICT_OR       reduce using rule 30 (unary_expr -> ! expr .)
    OR              reduce using rule 30 (unary_expr -> ! expr .)
    EQUAL           reduce using rule 30 (unary_expr -> ! expr .)
    NOT_EQUAL       reduce using rule 30 (unary_expr -> ! expr .)
    >               reduce using rule 30 (unary_expr -> ! expr .)
    FLOAT_MUL       reduce using rule 30 (unary_expr -> ! expr .)
    FLOAT_DIV       reduce using rule 30 (unary_expr -> ! expr .)
    FLOAT_SUB       reduce using rule 30 (unary_expr -> ! expr .)
    FLOAT_SUM       reduce using rule 30 (unary_expr -> ! expr .)
    <               reduce using rule 30 (unary_expr -> ! expr .)
    *               reduce using rule 30 (unary_expr -> ! expr .)
    /               reduce using rule 30 (unary_expr -> ! expr .)
    -               reduce using rule 30 (unary_expr -> ! expr .)
    +               reduce using rule 30 (unary_expr -> ! expr .)
    CONCAT          reduce using rule 30 (unary_expr -> ! expr .)
    $end            reduce using rule 30 (unary_expr -> ! expr .)
    )               reduce using rule 30 (unary_expr -> ! expr .)
    INTERPOLATION_BOTH reduce using rule 30 (unary_expr -> ! expr .)
    INTERPOLATION_RIGHT reduce using rule 30 (unary_expr -> ! expr .)
    OF              reduce using rule 30 (unary_expr -> ! expr .)
    THEN            reduce using rule 30 (unary_expr -> ! expr .)
    END             reduce using rule 30 (unary_expr -> ! expr .)
    ELIF            reduce using rule 30 (unary_expr -> ! expr .)
    ELSE            reduce using rule 30 (unary_expr -> ! expr .)
    ,               reduce using rule 30 (unary_expr -> ! expr .)
    ]               reduce using rule 30 (unary_expr -> ! expr .)
    (               shift and go to state 47


state 127

    (31) unary_expr -> STRICT_NOT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    SOME_SUB        reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    SOME_CONCAT     reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ARROW_BOTH      reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ARROW_RIGHT     reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ARROW_LEFT      reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    BIT_SHIFT_RIGHT reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    BIT_SHIFT_LEFT  reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    BIT_AND         reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    BIT_OR          reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    FLOAT_POW       reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    POW             reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ARRAY_SUB       reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ARRAY_CONCAT    reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    MORE_OR_EQ      reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    LESS_OR_EQ      reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    TEXT_MATCH      reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    STRICT_AND      reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    AND             reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    STRICT_OR       reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    OR              reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    EQUAL           reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    NOT_EQUAL       reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    >               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    FLOAT_MUL       reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    FLOAT_DIV       reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    FLOAT_SUB       reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    FLOAT_SUM       reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    <               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    *               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    /               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    -               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    +               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    CONCAT          reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    $end            reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    )               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    INTERPOLATION_BOTH reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    INTERPOLATION_RIGHT reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    OF              reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    THEN            reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    END             reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ELIF            reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ELSE            reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ,               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    ]               reduce using rule 31 (unary_expr -> STRICT_NOT expr .)
    (               shift and go to state 47


state 128

    (32) unary_expr -> - expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 32 (unary_expr -> - expr .)
    SOME_SUB        reduce using rule 32 (unary_expr -> - expr .)
    SOME_CONCAT     reduce using rule 32 (unary_expr -> - expr .)
    ARROW_BOTH      reduce using rule 32 (unary_expr -> - expr .)
    ARROW_RIGHT     reduce using rule 32 (unary_expr -> - expr .)
    ARROW_LEFT      reduce using rule 32 (unary_expr -> - expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 32 (unary_expr -> - expr .)
    DOUBLE_ARROW_LEFT reduce using rule 32 (unary_expr -> - expr .)
    BIT_SHIFT_RIGHT reduce using rule 32 (unary_expr -> - expr .)
    BIT_SHIFT_LEFT  reduce using rule 32 (unary_expr -> - expr .)
    BIT_AND         reduce using rule 32 (unary_expr -> - expr .)
    BIT_OR          reduce using rule 32 (unary_expr -> - expr .)
    FLOAT_POW       reduce using rule 32 (unary_expr -> - expr .)
    POW             reduce using rule 32 (unary_expr -> - expr .)
    ARRAY_SUB       reduce using rule 32 (unary_expr -> - expr .)
    ARRAY_CONCAT    reduce using rule 32 (unary_expr -> - expr .)
    MORE_OR_EQ      reduce using rule 32 (unary_expr -> - expr .)
    LESS_OR_EQ      reduce using rule 32 (unary_expr -> - expr .)
    TEXT_MATCH      reduce using rule 32 (unary_expr -> - expr .)
    STRICT_AND      reduce using rule 32 (unary_expr -> - expr .)
    AND             reduce using rule 32 (unary_expr -> - expr .)
    STRICT_OR       reduce using rule 32 (unary_expr -> - expr .)
    OR              reduce using rule 32 (unary_expr -> - expr .)
    EQUAL           reduce using rule 32 (unary_expr -> - expr .)
    NOT_EQUAL       reduce using rule 32 (unary_expr -> - expr .)
    >               reduce using rule 32 (unary_expr -> - expr .)
    FLOAT_MUL       reduce using rule 32 (unary_expr -> - expr .)
    FLOAT_DIV       reduce using rule 32 (unary_expr -> - expr .)
    FLOAT_SUB       reduce using rule 32 (unary_expr -> - expr .)
    FLOAT_SUM       reduce using rule 32 (unary_expr -> - expr .)
    <               reduce using rule 32 (unary_expr -> - expr .)
    *               reduce using rule 32 (unary_expr -> - expr .)
    /               reduce using rule 32 (unary_expr -> - expr .)
    -               reduce using rule 32 (unary_expr -> - expr .)
    +               reduce using rule 32 (unary_expr -> - expr .)
    CONCAT          reduce using rule 32 (unary_expr -> - expr .)
    $end            reduce using rule 32 (unary_expr -> - expr .)
    )               reduce using rule 32 (unary_expr -> - expr .)
    INTERPOLATION_BOTH reduce using rule 32 (unary_expr -> - expr .)
    INTERPOLATION_RIGHT reduce using rule 32 (unary_expr -> - expr .)
    OF              reduce using rule 32 (unary_expr -> - expr .)
    THEN            reduce using rule 32 (unary_expr -> - expr .)
    END             reduce using rule 32 (unary_expr -> - expr .)
    ELIF            reduce using rule 32 (unary_expr -> - expr .)
    ELSE            reduce using rule 32 (unary_expr -> - expr .)
    ,               reduce using rule 32 (unary_expr -> - expr .)
    ]               reduce using rule 32 (unary_expr -> - expr .)
    (               shift and go to state 47


state 129

    (259) array -> [ _55_NEWLINE_optional . _56_exprs_optional ]
    (262) _56_exprs_optional -> . exprs
    (263) _56_exprs_optional -> .
    (274) exprs -> . expr _61_NEWLINE_optional
    (277) exprs -> . exprs , _62_NEWLINE_optional expr _63_NEWLINE_optional
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    ]               reduce using rule 263 (_56_exprs_optional -> .)
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    _56_exprs_optional             shift and go to state 188
    exprs                          shift and go to state 189
    expr                           shift and go to state 190
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 130

    (260) _55_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_LEFT reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    TYPE            reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 260 (_55_NEWLINE_optional -> NEWLINE .)


state 131

    (231) case_of -> CASE expr . OF _46_NEWLINE_optional _47_cases_optional END
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 191
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 132

    (222) if_expr -> IF expr . THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 192
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 133

    (127) do -> DO _13_0x3a_type_optional . block_statement END
    (130) block_statement -> . _14_NEWLINE_optional _15_do_exprs_optional
    (131) _14_NEWLINE_optional -> . NEWLINE
    (132) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 195
    (               reduce using rule 132 (_14_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 132 (_14_NEWLINE_optional -> .)
    DEF             reduce using rule 132 (_14_NEWLINE_optional -> .)
    +               reduce using rule 132 (_14_NEWLINE_optional -> .)
    !               reduce using rule 132 (_14_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 132 (_14_NEWLINE_optional -> .)
    -               reduce using rule 132 (_14_NEWLINE_optional -> .)
    STRING          reduce using rule 132 (_14_NEWLINE_optional -> .)
    FLOAT           reduce using rule 132 (_14_NEWLINE_optional -> .)
    INT             reduce using rule 132 (_14_NEWLINE_optional -> .)
    [               reduce using rule 132 (_14_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 132 (_14_NEWLINE_optional -> .)
    CASE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    IF              reduce using rule 132 (_14_NEWLINE_optional -> .)
    DO              reduce using rule 132 (_14_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 132 (_14_NEWLINE_optional -> .)
    TYPE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    ENUM            reduce using rule 132 (_14_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 132 (_14_NEWLINE_optional -> .)
    END             reduce using rule 132 (_14_NEWLINE_optional -> .)

    block_statement                shift and go to state 193
    _14_NEWLINE_optional           shift and go to state 194

state 134

    (128) _13_0x3a_type_optional -> : . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 196
    type_identifier                shift and go to state 197

state 135

    (169) enum -> TYPE type_identifier .
    (170) enum -> TYPE type_identifier . = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> TYPE type_identifier . < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
  ! shift/reduce conflict for < resolved as shift
    NEWLINE         reduce using rule 169 (enum -> TYPE type_identifier .)
    (               reduce using rule 169 (enum -> TYPE type_identifier .)
    SOME_SUB        reduce using rule 169 (enum -> TYPE type_identifier .)
    SOME_CONCAT     reduce using rule 169 (enum -> TYPE type_identifier .)
    ARROW_BOTH      reduce using rule 169 (enum -> TYPE type_identifier .)
    ARROW_RIGHT     reduce using rule 169 (enum -> TYPE type_identifier .)
    ARROW_LEFT      reduce using rule 169 (enum -> TYPE type_identifier .)
    DOUBLE_ARROW_RIGHT reduce using rule 169 (enum -> TYPE type_identifier .)
    DOUBLE_ARROW_LEFT reduce using rule 169 (enum -> TYPE type_identifier .)
    BIT_SHIFT_RIGHT reduce using rule 169 (enum -> TYPE type_identifier .)
    BIT_SHIFT_LEFT  reduce using rule 169 (enum -> TYPE type_identifier .)
    BIT_AND         reduce using rule 169 (enum -> TYPE type_identifier .)
    BIT_OR          reduce using rule 169 (enum -> TYPE type_identifier .)
    FLOAT_POW       reduce using rule 169 (enum -> TYPE type_identifier .)
    POW             reduce using rule 169 (enum -> TYPE type_identifier .)
    ARRAY_SUB       reduce using rule 169 (enum -> TYPE type_identifier .)
    ARRAY_CONCAT    reduce using rule 169 (enum -> TYPE type_identifier .)
    MORE_OR_EQ      reduce using rule 169 (enum -> TYPE type_identifier .)
    LESS_OR_EQ      reduce using rule 169 (enum -> TYPE type_identifier .)
    TEXT_MATCH      reduce using rule 169 (enum -> TYPE type_identifier .)
    STRICT_AND      reduce using rule 169 (enum -> TYPE type_identifier .)
    AND             reduce using rule 169 (enum -> TYPE type_identifier .)
    STRICT_OR       reduce using rule 169 (enum -> TYPE type_identifier .)
    OR              reduce using rule 169 (enum -> TYPE type_identifier .)
    EQUAL           reduce using rule 169 (enum -> TYPE type_identifier .)
    NOT_EQUAL       reduce using rule 169 (enum -> TYPE type_identifier .)
    >               reduce using rule 169 (enum -> TYPE type_identifier .)
    FLOAT_MUL       reduce using rule 169 (enum -> TYPE type_identifier .)
    FLOAT_DIV       reduce using rule 169 (enum -> TYPE type_identifier .)
    FLOAT_SUB       reduce using rule 169 (enum -> TYPE type_identifier .)
    FLOAT_SUM       reduce using rule 169 (enum -> TYPE type_identifier .)
    *               reduce using rule 169 (enum -> TYPE type_identifier .)
    /               reduce using rule 169 (enum -> TYPE type_identifier .)
    -               reduce using rule 169 (enum -> TYPE type_identifier .)
    +               reduce using rule 169 (enum -> TYPE type_identifier .)
    CONCAT          reduce using rule 169 (enum -> TYPE type_identifier .)
    $end            reduce using rule 169 (enum -> TYPE type_identifier .)
    )               reduce using rule 169 (enum -> TYPE type_identifier .)
    INTERPOLATION_BOTH reduce using rule 169 (enum -> TYPE type_identifier .)
    INTERPOLATION_RIGHT reduce using rule 169 (enum -> TYPE type_identifier .)
    OF              reduce using rule 169 (enum -> TYPE type_identifier .)
    THEN            reduce using rule 169 (enum -> TYPE type_identifier .)
    END             reduce using rule 169 (enum -> TYPE type_identifier .)
    ELIF            reduce using rule 169 (enum -> TYPE type_identifier .)
    ELSE            reduce using rule 169 (enum -> TYPE type_identifier .)
    ,               reduce using rule 169 (enum -> TYPE type_identifier .)
    ]               reduce using rule 169 (enum -> TYPE type_identifier .)
    =               shift and go to state 198
    <               shift and go to state 199


state 136

    (185) enum -> ENUM type_identifier . { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> ENUM type_identifier . < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    {               shift and go to state 200
    <               shift and go to state 201


state 137

    (9) do_exprs -> expr NEWLINE do_exprs .
    $end            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    END             reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELIF            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELSE            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)


state 138

    (264) call -> expr ( _57_NEWLINE_optional . _58_exprs_optional )
    (267) _58_exprs_optional -> . exprs
    (268) _58_exprs_optional -> .
    (274) exprs -> . expr _61_NEWLINE_optional
    (277) exprs -> . exprs , _62_NEWLINE_optional expr _63_NEWLINE_optional
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 268 (_58_exprs_optional -> .)
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 190
    _58_exprs_optional             shift and go to state 202
    exprs                          shift and go to state 203
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 139

    (265) _57_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_LEFT reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    TYPE            reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 265 (_57_NEWLINE_optional -> NEWLINE .)


state 140

    (34) binary_expr -> expr SOME_SUB expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    ARROW_BOTH      reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    ARROW_RIGHT     reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    ARROW_LEFT      reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    BIT_SHIFT_RIGHT reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    BIT_AND         reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    BIT_OR          reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    MORE_OR_EQ      reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    LESS_OR_EQ      reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    TEXT_MATCH      reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    STRICT_AND      reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    AND             reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    STRICT_OR       reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    OR              reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    EQUAL           reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    NOT_EQUAL       reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    >               reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    <               reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    $end            reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    )               reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    INTERPOLATION_BOTH reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    INTERPOLATION_RIGHT reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    OF              reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    THEN            reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    END             reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    ,               reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    ]               reduce using rule 34 (binary_expr -> expr SOME_SUB expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 141

    (35) binary_expr -> expr SOME_CONCAT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_BOTH      reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_RIGHT     reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_LEFT      reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_SHIFT_RIGHT reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_AND         reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_OR          reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    MORE_OR_EQ      reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    LESS_OR_EQ      reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    TEXT_MATCH      reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    STRICT_AND      reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    AND             reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    STRICT_OR       reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    OR              reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    EQUAL           reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    NOT_EQUAL       reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    >               reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    <               reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    $end            reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    )               reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    INTERPOLATION_BOTH reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    INTERPOLATION_RIGHT reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    OF              reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    THEN            reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    END             reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    ,               reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    ]               reduce using rule 35 (binary_expr -> expr SOME_CONCAT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 142

    (36) binary_expr -> expr ARROW_BOTH expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_BOTH      reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_RIGHT     reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_LEFT      reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    DOUBLE_ARROW_LEFT reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_SHIFT_RIGHT reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_SHIFT_LEFT  reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_AND         reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_OR          reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    MORE_OR_EQ      reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    LESS_OR_EQ      reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    TEXT_MATCH      reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    STRICT_AND      reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    AND             reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    STRICT_OR       reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    OR              reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    EQUAL           reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    NOT_EQUAL       reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    >               reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    <               reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    $end            reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    )               reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    INTERPOLATION_BOTH reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    INTERPOLATION_RIGHT reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    OF              reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    THEN            reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    END             reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    ELIF            reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    ELSE            reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    ,               reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    ]               reduce using rule 36 (binary_expr -> expr ARROW_BOTH expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 143

    (37) binary_expr -> expr ARROW_RIGHT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_BOTH      reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_RIGHT     reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_LEFT      reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_SHIFT_RIGHT reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_SHIFT_LEFT  reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_AND         reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_OR          reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    MORE_OR_EQ      reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    LESS_OR_EQ      reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    TEXT_MATCH      reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    STRICT_AND      reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    AND             reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    STRICT_OR       reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    OR              reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    EQUAL           reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    NOT_EQUAL       reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    >               reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    <               reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    $end            reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    )               reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    INTERPOLATION_BOTH reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    INTERPOLATION_RIGHT reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    OF              reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    THEN            reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    END             reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    ELIF            reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    ELSE            reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    ,               reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    ]               reduce using rule 37 (binary_expr -> expr ARROW_RIGHT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 144

    (38) binary_expr -> expr ARROW_LEFT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_BOTH      reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_RIGHT     reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_LEFT      reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_SHIFT_RIGHT reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_AND         reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_OR          reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    MORE_OR_EQ      reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    LESS_OR_EQ      reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    TEXT_MATCH      reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    STRICT_AND      reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    AND             reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    STRICT_OR       reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    OR              reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    EQUAL           reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    NOT_EQUAL       reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    >               reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    <               reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    $end            reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    )               reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    INTERPOLATION_BOTH reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    INTERPOLATION_RIGHT reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    OF              reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    THEN            reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    END             reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    ELIF            reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    ELSE            reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    ,               reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    ]               reduce using rule 38 (binary_expr -> expr ARROW_LEFT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 145

    (39) binary_expr -> expr DOUBLE_ARROW_RIGHT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_BOTH      reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_RIGHT     reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_LEFT      reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_SHIFT_RIGHT reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_SHIFT_LEFT  reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_AND         reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_OR          reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    MORE_OR_EQ      reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    LESS_OR_EQ      reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    TEXT_MATCH      reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    STRICT_AND      reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    AND             reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    STRICT_OR       reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    OR              reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    EQUAL           reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    NOT_EQUAL       reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    >               reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    <               reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    $end            reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    )               reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    INTERPOLATION_BOTH reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    INTERPOLATION_RIGHT reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    OF              reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    THEN            reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    END             reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ELIF            reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ELSE            reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ,               reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ]               reduce using rule 39 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 146

    (40) binary_expr -> expr DOUBLE_ARROW_LEFT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_BOTH      reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_RIGHT     reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_LEFT      reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_SHIFT_RIGHT reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_AND         reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_OR          reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    MORE_OR_EQ      reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    LESS_OR_EQ      reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    TEXT_MATCH      reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    STRICT_AND      reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    AND             reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    STRICT_OR       reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    OR              reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    EQUAL           reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    NOT_EQUAL       reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    >               reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    <               reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    $end            reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    )               reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    INTERPOLATION_BOTH reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    INTERPOLATION_RIGHT reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    OF              reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    THEN            reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    END             reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ELIF            reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ELSE            reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ,               reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ]               reduce using rule 40 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 147

    (41) binary_expr -> expr BIT_SHIFT_RIGHT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    ARROW_BOTH      reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    ARROW_RIGHT     reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    ARROW_LEFT      reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    BIT_SHIFT_RIGHT reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    BIT_SHIFT_LEFT  reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    BIT_AND         reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    BIT_OR          reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    MORE_OR_EQ      reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    LESS_OR_EQ      reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    TEXT_MATCH      reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    STRICT_AND      reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    AND             reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    STRICT_OR       reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    OR              reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    EQUAL           reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    NOT_EQUAL       reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    >               reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    <               reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    $end            reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    )               reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    INTERPOLATION_BOTH reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    INTERPOLATION_RIGHT reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    OF              reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    THEN            reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    END             reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    ELIF            reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    ELSE            reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    ,               reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    ]               reduce using rule 41 (binary_expr -> expr BIT_SHIFT_RIGHT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 148

    (42) binary_expr -> expr BIT_SHIFT_LEFT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_BOTH      reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_RIGHT     reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_LEFT      reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_SHIFT_RIGHT reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_AND         reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_OR          reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    MORE_OR_EQ      reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    LESS_OR_EQ      reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    TEXT_MATCH      reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    STRICT_AND      reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    AND             reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    STRICT_OR       reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    OR              reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    EQUAL           reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    NOT_EQUAL       reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    >               reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    <               reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    $end            reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    )               reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    INTERPOLATION_BOTH reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    INTERPOLATION_RIGHT reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    OF              reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    THEN            reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    END             reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ELIF            reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ELSE            reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ,               reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ]               reduce using rule 42 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 149

    (43) binary_expr -> expr BIT_AND expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    BIT_AND         reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    BIT_OR          reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    STRICT_AND      reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    AND             reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    STRICT_OR       reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    OR              reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    $end            reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    )               reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    INTERPOLATION_BOTH reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    INTERPOLATION_RIGHT reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    OF              reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    THEN            reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    END             reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    ELIF            reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    ELSE            reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    ,               reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    ]               reduce using rule 43 (binary_expr -> expr BIT_AND expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 150

    (44) binary_expr -> expr BIT_OR expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    BIT_OR          reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    STRICT_OR       reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    OR              reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    $end            reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    )               reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    INTERPOLATION_BOTH reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    INTERPOLATION_RIGHT reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    OF              reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    THEN            reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    END             reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    ELIF            reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    ELSE            reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    ,               reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    ]               reduce using rule 44 (binary_expr -> expr BIT_OR expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 151

    (45) binary_expr -> expr FLOAT_POW expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    SOME_SUB        reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    SOME_CONCAT     reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_BOTH      reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_RIGHT     reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_LEFT      reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    DOUBLE_ARROW_LEFT reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    BIT_SHIFT_RIGHT reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    BIT_SHIFT_LEFT  reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    BIT_AND         reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    BIT_OR          reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_POW       reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    POW             reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ARRAY_SUB       reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ARRAY_CONCAT    reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    MORE_OR_EQ      reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    LESS_OR_EQ      reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    TEXT_MATCH      reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    STRICT_AND      reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    AND             reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    STRICT_OR       reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    OR              reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    EQUAL           reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    NOT_EQUAL       reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    >               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_MUL       reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_DIV       reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_SUB       reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_SUM       reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    <               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    *               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    /               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    -               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    +               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    CONCAT          reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    $end            reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    )               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    INTERPOLATION_BOTH reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    INTERPOLATION_RIGHT reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    OF              reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    THEN            reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    END             reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ELIF            reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ELSE            reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ,               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    ]               reduce using rule 45 (binary_expr -> expr FLOAT_POW expr .)
    (               shift and go to state 47


state 152

    (46) binary_expr -> expr POW expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 46 (binary_expr -> expr POW expr .)
    SOME_SUB        reduce using rule 46 (binary_expr -> expr POW expr .)
    SOME_CONCAT     reduce using rule 46 (binary_expr -> expr POW expr .)
    ARROW_BOTH      reduce using rule 46 (binary_expr -> expr POW expr .)
    ARROW_RIGHT     reduce using rule 46 (binary_expr -> expr POW expr .)
    ARROW_LEFT      reduce using rule 46 (binary_expr -> expr POW expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 46 (binary_expr -> expr POW expr .)
    DOUBLE_ARROW_LEFT reduce using rule 46 (binary_expr -> expr POW expr .)
    BIT_SHIFT_RIGHT reduce using rule 46 (binary_expr -> expr POW expr .)
    BIT_SHIFT_LEFT  reduce using rule 46 (binary_expr -> expr POW expr .)
    BIT_AND         reduce using rule 46 (binary_expr -> expr POW expr .)
    BIT_OR          reduce using rule 46 (binary_expr -> expr POW expr .)
    FLOAT_POW       reduce using rule 46 (binary_expr -> expr POW expr .)
    POW             reduce using rule 46 (binary_expr -> expr POW expr .)
    ARRAY_SUB       reduce using rule 46 (binary_expr -> expr POW expr .)
    ARRAY_CONCAT    reduce using rule 46 (binary_expr -> expr POW expr .)
    MORE_OR_EQ      reduce using rule 46 (binary_expr -> expr POW expr .)
    LESS_OR_EQ      reduce using rule 46 (binary_expr -> expr POW expr .)
    TEXT_MATCH      reduce using rule 46 (binary_expr -> expr POW expr .)
    STRICT_AND      reduce using rule 46 (binary_expr -> expr POW expr .)
    AND             reduce using rule 46 (binary_expr -> expr POW expr .)
    STRICT_OR       reduce using rule 46 (binary_expr -> expr POW expr .)
    OR              reduce using rule 46 (binary_expr -> expr POW expr .)
    EQUAL           reduce using rule 46 (binary_expr -> expr POW expr .)
    NOT_EQUAL       reduce using rule 46 (binary_expr -> expr POW expr .)
    >               reduce using rule 46 (binary_expr -> expr POW expr .)
    FLOAT_MUL       reduce using rule 46 (binary_expr -> expr POW expr .)
    FLOAT_DIV       reduce using rule 46 (binary_expr -> expr POW expr .)
    FLOAT_SUB       reduce using rule 46 (binary_expr -> expr POW expr .)
    FLOAT_SUM       reduce using rule 46 (binary_expr -> expr POW expr .)
    <               reduce using rule 46 (binary_expr -> expr POW expr .)
    *               reduce using rule 46 (binary_expr -> expr POW expr .)
    /               reduce using rule 46 (binary_expr -> expr POW expr .)
    -               reduce using rule 46 (binary_expr -> expr POW expr .)
    +               reduce using rule 46 (binary_expr -> expr POW expr .)
    CONCAT          reduce using rule 46 (binary_expr -> expr POW expr .)
    $end            reduce using rule 46 (binary_expr -> expr POW expr .)
    )               reduce using rule 46 (binary_expr -> expr POW expr .)
    INTERPOLATION_BOTH reduce using rule 46 (binary_expr -> expr POW expr .)
    INTERPOLATION_RIGHT reduce using rule 46 (binary_expr -> expr POW expr .)
    OF              reduce using rule 46 (binary_expr -> expr POW expr .)
    THEN            reduce using rule 46 (binary_expr -> expr POW expr .)
    END             reduce using rule 46 (binary_expr -> expr POW expr .)
    ELIF            reduce using rule 46 (binary_expr -> expr POW expr .)
    ELSE            reduce using rule 46 (binary_expr -> expr POW expr .)
    ,               reduce using rule 46 (binary_expr -> expr POW expr .)
    ]               reduce using rule 46 (binary_expr -> expr POW expr .)
    (               shift and go to state 47


state 153

    (47) binary_expr -> expr ARRAY_SUB expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_BOTH      reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_RIGHT     reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_LEFT      reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_SHIFT_RIGHT reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_AND         reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_OR          reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    MORE_OR_EQ      reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    LESS_OR_EQ      reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    TEXT_MATCH      reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    STRICT_AND      reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    AND             reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    STRICT_OR       reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    OR              reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    EQUAL           reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    NOT_EQUAL       reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    >               reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    <               reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    $end            reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    )               reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    INTERPOLATION_BOTH reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    INTERPOLATION_RIGHT reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    OF              reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    THEN            reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    END             reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    ELIF            reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    ELSE            reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    ,               reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    ]               reduce using rule 47 (binary_expr -> expr ARRAY_SUB expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 154

    (48) binary_expr -> expr ARRAY_CONCAT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_BOTH      reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_RIGHT     reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_LEFT      reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_SHIFT_RIGHT reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_AND         reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_OR          reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    MORE_OR_EQ      reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    LESS_OR_EQ      reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    TEXT_MATCH      reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    STRICT_AND      reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    AND             reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    STRICT_OR       reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    OR              reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    EQUAL           reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    NOT_EQUAL       reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    >               reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    <               reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    $end            reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    )               reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    INTERPOLATION_BOTH reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    INTERPOLATION_RIGHT reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    OF              reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    THEN            reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    END             reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    ELIF            reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    ELSE            reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    ,               reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    ]               reduce using rule 48 (binary_expr -> expr ARRAY_CONCAT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 155

    (49) binary_expr -> expr MORE_OR_EQ expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    BIT_AND         reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    BIT_OR          reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    STRICT_AND      reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    AND             reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    STRICT_OR       reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    OR              reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    EQUAL           reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    >               reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    <               reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    $end            reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    )               reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    INTERPOLATION_BOTH reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    INTERPOLATION_RIGHT reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    OF              reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    THEN            reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    END             reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    ELIF            reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    ELSE            reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    ,               reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    ]               reduce using rule 49 (binary_expr -> expr MORE_OR_EQ expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 156

    (50) binary_expr -> expr LESS_OR_EQ expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    BIT_AND         reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    BIT_OR          reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    STRICT_AND      reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    AND             reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    STRICT_OR       reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    OR              reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    EQUAL           reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    >               reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    <               reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    $end            reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    )               reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    INTERPOLATION_BOTH reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    INTERPOLATION_RIGHT reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    OF              reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    THEN            reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    END             reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    ELIF            reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    ELSE            reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    ,               reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    ]               reduce using rule 50 (binary_expr -> expr LESS_OR_EQ expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 157

    (51) binary_expr -> expr TEXT_MATCH expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    BIT_AND         reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    BIT_OR          reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    TEXT_MATCH      reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    STRICT_AND      reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    AND             reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    STRICT_OR       reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    OR              reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    EQUAL           reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    NOT_EQUAL       reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    $end            reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    )               reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    INTERPOLATION_BOTH reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    INTERPOLATION_RIGHT reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    OF              reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    THEN            reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    END             reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    ELIF            reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    ELSE            reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    ,               reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    ]               reduce using rule 51 (binary_expr -> expr TEXT_MATCH expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 158

    (52) binary_expr -> expr STRICT_AND expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    BIT_AND         reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    BIT_OR          reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    STRICT_AND      reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    AND             reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    STRICT_OR       reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    OR              reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    $end            reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    )               reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    INTERPOLATION_BOTH reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    INTERPOLATION_RIGHT reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    OF              reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    THEN            reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    END             reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    ELIF            reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    ELSE            reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    ,               reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    ]               reduce using rule 52 (binary_expr -> expr STRICT_AND expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 159

    (53) binary_expr -> expr AND expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 53 (binary_expr -> expr AND expr .)
    BIT_AND         reduce using rule 53 (binary_expr -> expr AND expr .)
    BIT_OR          reduce using rule 53 (binary_expr -> expr AND expr .)
    STRICT_AND      reduce using rule 53 (binary_expr -> expr AND expr .)
    AND             reduce using rule 53 (binary_expr -> expr AND expr .)
    STRICT_OR       reduce using rule 53 (binary_expr -> expr AND expr .)
    OR              reduce using rule 53 (binary_expr -> expr AND expr .)
    $end            reduce using rule 53 (binary_expr -> expr AND expr .)
    )               reduce using rule 53 (binary_expr -> expr AND expr .)
    INTERPOLATION_BOTH reduce using rule 53 (binary_expr -> expr AND expr .)
    INTERPOLATION_RIGHT reduce using rule 53 (binary_expr -> expr AND expr .)
    OF              reduce using rule 53 (binary_expr -> expr AND expr .)
    THEN            reduce using rule 53 (binary_expr -> expr AND expr .)
    END             reduce using rule 53 (binary_expr -> expr AND expr .)
    ELIF            reduce using rule 53 (binary_expr -> expr AND expr .)
    ELSE            reduce using rule 53 (binary_expr -> expr AND expr .)
    ,               reduce using rule 53 (binary_expr -> expr AND expr .)
    ]               reduce using rule 53 (binary_expr -> expr AND expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 160

    (54) binary_expr -> expr STRICT_OR expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    BIT_OR          reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    STRICT_OR       reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    OR              reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    $end            reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    )               reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    INTERPOLATION_BOTH reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    INTERPOLATION_RIGHT reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    OF              reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    THEN            reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    END             reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    ELIF            reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    ELSE            reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    ,               reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    ]               reduce using rule 54 (binary_expr -> expr STRICT_OR expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 161

    (55) binary_expr -> expr OR expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 55 (binary_expr -> expr OR expr .)
    BIT_OR          reduce using rule 55 (binary_expr -> expr OR expr .)
    STRICT_OR       reduce using rule 55 (binary_expr -> expr OR expr .)
    OR              reduce using rule 55 (binary_expr -> expr OR expr .)
    $end            reduce using rule 55 (binary_expr -> expr OR expr .)
    )               reduce using rule 55 (binary_expr -> expr OR expr .)
    INTERPOLATION_BOTH reduce using rule 55 (binary_expr -> expr OR expr .)
    INTERPOLATION_RIGHT reduce using rule 55 (binary_expr -> expr OR expr .)
    OF              reduce using rule 55 (binary_expr -> expr OR expr .)
    THEN            reduce using rule 55 (binary_expr -> expr OR expr .)
    END             reduce using rule 55 (binary_expr -> expr OR expr .)
    ELIF            reduce using rule 55 (binary_expr -> expr OR expr .)
    ELSE            reduce using rule 55 (binary_expr -> expr OR expr .)
    ,               reduce using rule 55 (binary_expr -> expr OR expr .)
    ]               reduce using rule 55 (binary_expr -> expr OR expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 162

    (56) binary_expr -> expr EQUAL expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    BIT_AND         reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    BIT_OR          reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    TEXT_MATCH      reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    STRICT_AND      reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    AND             reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    STRICT_OR       reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    OR              reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    $end            reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    )               reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    INTERPOLATION_BOTH reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    INTERPOLATION_RIGHT reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    OF              reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    THEN            reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    END             reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    ELIF            reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    ELSE            reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    ,               reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    ]               reduce using rule 56 (binary_expr -> expr EQUAL expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 163

    (57) binary_expr -> expr NOT_EQUAL expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    BIT_AND         reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    BIT_OR          reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    TEXT_MATCH      reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    STRICT_AND      reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    AND             reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    STRICT_OR       reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    OR              reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    INTERPOLATION_BOTH reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    INTERPOLATION_RIGHT reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    END             reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    ELIF            reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    ]               reduce using rule 57 (binary_expr -> expr NOT_EQUAL expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 164

    (58) binary_expr -> expr > expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 58 (binary_expr -> expr > expr .)
    BIT_AND         reduce using rule 58 (binary_expr -> expr > expr .)
    BIT_OR          reduce using rule 58 (binary_expr -> expr > expr .)
    MORE_OR_EQ      reduce using rule 58 (binary_expr -> expr > expr .)
    LESS_OR_EQ      reduce using rule 58 (binary_expr -> expr > expr .)
    TEXT_MATCH      reduce using rule 58 (binary_expr -> expr > expr .)
    STRICT_AND      reduce using rule 58 (binary_expr -> expr > expr .)
    AND             reduce using rule 58 (binary_expr -> expr > expr .)
    STRICT_OR       reduce using rule 58 (binary_expr -> expr > expr .)
    OR              reduce using rule 58 (binary_expr -> expr > expr .)
    EQUAL           reduce using rule 58 (binary_expr -> expr > expr .)
    NOT_EQUAL       reduce using rule 58 (binary_expr -> expr > expr .)
    >               reduce using rule 58 (binary_expr -> expr > expr .)
    <               reduce using rule 58 (binary_expr -> expr > expr .)
    $end            reduce using rule 58 (binary_expr -> expr > expr .)
    )               reduce using rule 58 (binary_expr -> expr > expr .)
    INTERPOLATION_BOTH reduce using rule 58 (binary_expr -> expr > expr .)
    INTERPOLATION_RIGHT reduce using rule 58 (binary_expr -> expr > expr .)
    OF              reduce using rule 58 (binary_expr -> expr > expr .)
    THEN            reduce using rule 58 (binary_expr -> expr > expr .)
    END             reduce using rule 58 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 58 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 58 (binary_expr -> expr > expr .)
    ,               reduce using rule 58 (binary_expr -> expr > expr .)
    ]               reduce using rule 58 (binary_expr -> expr > expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 165

    (59) binary_expr -> expr FLOAT_MUL expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    SOME_SUB        reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    SOME_CONCAT     reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_BOTH      reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_RIGHT     reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_LEFT      reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    DOUBLE_ARROW_LEFT reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_SHIFT_RIGHT reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_SHIFT_LEFT  reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_AND         reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_OR          reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ARRAY_SUB       reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ARRAY_CONCAT    reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    MORE_OR_EQ      reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    LESS_OR_EQ      reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    TEXT_MATCH      reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    STRICT_AND      reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    AND             reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    STRICT_OR       reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    OR              reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    EQUAL           reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    NOT_EQUAL       reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    >               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_MUL       reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_DIV       reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_SUB       reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_SUM       reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    <               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    *               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    /               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    -               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    +               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    CONCAT          reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    $end            reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    )               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    INTERPOLATION_BOTH reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    INTERPOLATION_RIGHT reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    OF              reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    THEN            reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    END             reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ELIF            reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ELSE            reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ,               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    ]               reduce using rule 59 (binary_expr -> expr FLOAT_MUL expr .)
    (               shift and go to state 47
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60


state 166

    (60) binary_expr -> expr FLOAT_DIV expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    SOME_SUB        reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    SOME_CONCAT     reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_BOTH      reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_RIGHT     reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_LEFT      reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    DOUBLE_ARROW_LEFT reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_SHIFT_RIGHT reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_SHIFT_LEFT  reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_AND         reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_OR          reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ARRAY_SUB       reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ARRAY_CONCAT    reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    MORE_OR_EQ      reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    LESS_OR_EQ      reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    TEXT_MATCH      reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    STRICT_AND      reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    AND             reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    STRICT_OR       reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    OR              reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    EQUAL           reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    NOT_EQUAL       reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    >               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_MUL       reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_DIV       reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_SUB       reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_SUM       reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    <               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    *               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    /               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    -               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    +               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    CONCAT          reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    $end            reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    )               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    INTERPOLATION_BOTH reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    INTERPOLATION_RIGHT reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    OF              reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    THEN            reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    END             reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ELIF            reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ELSE            reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ,               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    ]               reduce using rule 60 (binary_expr -> expr FLOAT_DIV expr .)
    (               shift and go to state 47
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60


state 167

    (61) binary_expr -> expr FLOAT_SUB expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    SOME_SUB        reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    SOME_CONCAT     reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_BOTH      reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_RIGHT     reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_LEFT      reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_SHIFT_RIGHT reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_AND         reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_OR          reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ARRAY_SUB       reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ARRAY_CONCAT    reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    MORE_OR_EQ      reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    LESS_OR_EQ      reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    TEXT_MATCH      reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    STRICT_AND      reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    AND             reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    STRICT_OR       reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    OR              reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    EQUAL           reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    NOT_EQUAL       reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    >               reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_SUB       reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_SUM       reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    <               reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    -               reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    +               reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    CONCAT          reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    $end            reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    )               reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    INTERPOLATION_BOTH reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    INTERPOLATION_RIGHT reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    OF              reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    THEN            reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    END             reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ELIF            reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ELSE            reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ,               reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    ]               reduce using rule 61 (binary_expr -> expr FLOAT_SUB expr .)
    (               shift and go to state 47
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    *               shift and go to state 78
    /               shift and go to state 79


state 168

    (62) binary_expr -> expr FLOAT_SUM expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    SOME_SUB        reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    SOME_CONCAT     reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_BOTH      reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_RIGHT     reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_LEFT      reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    DOUBLE_ARROW_LEFT reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_SHIFT_RIGHT reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_SHIFT_LEFT  reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_AND         reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_OR          reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ARRAY_SUB       reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ARRAY_CONCAT    reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    MORE_OR_EQ      reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    LESS_OR_EQ      reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    TEXT_MATCH      reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    STRICT_AND      reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    AND             reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    STRICT_OR       reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    OR              reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    EQUAL           reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    NOT_EQUAL       reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    >               reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_SUB       reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_SUM       reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    <               reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    -               reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    +               reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    CONCAT          reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    $end            reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    )               reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    INTERPOLATION_BOTH reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    INTERPOLATION_RIGHT reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    OF              reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    THEN            reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    END             reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ELIF            reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ELSE            reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ,               reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    ]               reduce using rule 62 (binary_expr -> expr FLOAT_SUM expr .)
    (               shift and go to state 47
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    *               shift and go to state 78
    /               shift and go to state 79


state 169

    (63) binary_expr -> expr < expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 63 (binary_expr -> expr < expr .)
    BIT_AND         reduce using rule 63 (binary_expr -> expr < expr .)
    BIT_OR          reduce using rule 63 (binary_expr -> expr < expr .)
    MORE_OR_EQ      reduce using rule 63 (binary_expr -> expr < expr .)
    LESS_OR_EQ      reduce using rule 63 (binary_expr -> expr < expr .)
    TEXT_MATCH      reduce using rule 63 (binary_expr -> expr < expr .)
    STRICT_AND      reduce using rule 63 (binary_expr -> expr < expr .)
    AND             reduce using rule 63 (binary_expr -> expr < expr .)
    STRICT_OR       reduce using rule 63 (binary_expr -> expr < expr .)
    OR              reduce using rule 63 (binary_expr -> expr < expr .)
    EQUAL           reduce using rule 63 (binary_expr -> expr < expr .)
    NOT_EQUAL       reduce using rule 63 (binary_expr -> expr < expr .)
    >               reduce using rule 63 (binary_expr -> expr < expr .)
    <               reduce using rule 63 (binary_expr -> expr < expr .)
    $end            reduce using rule 63 (binary_expr -> expr < expr .)
    )               reduce using rule 63 (binary_expr -> expr < expr .)
    INTERPOLATION_BOTH reduce using rule 63 (binary_expr -> expr < expr .)
    INTERPOLATION_RIGHT reduce using rule 63 (binary_expr -> expr < expr .)
    OF              reduce using rule 63 (binary_expr -> expr < expr .)
    THEN            reduce using rule 63 (binary_expr -> expr < expr .)
    END             reduce using rule 63 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 63 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 63 (binary_expr -> expr < expr .)
    ,               reduce using rule 63 (binary_expr -> expr < expr .)
    ]               reduce using rule 63 (binary_expr -> expr < expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 170

    (64) binary_expr -> expr * expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 64 (binary_expr -> expr * expr .)
    SOME_SUB        reduce using rule 64 (binary_expr -> expr * expr .)
    SOME_CONCAT     reduce using rule 64 (binary_expr -> expr * expr .)
    ARROW_BOTH      reduce using rule 64 (binary_expr -> expr * expr .)
    ARROW_RIGHT     reduce using rule 64 (binary_expr -> expr * expr .)
    ARROW_LEFT      reduce using rule 64 (binary_expr -> expr * expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 64 (binary_expr -> expr * expr .)
    DOUBLE_ARROW_LEFT reduce using rule 64 (binary_expr -> expr * expr .)
    BIT_SHIFT_RIGHT reduce using rule 64 (binary_expr -> expr * expr .)
    BIT_SHIFT_LEFT  reduce using rule 64 (binary_expr -> expr * expr .)
    BIT_AND         reduce using rule 64 (binary_expr -> expr * expr .)
    BIT_OR          reduce using rule 64 (binary_expr -> expr * expr .)
    ARRAY_SUB       reduce using rule 64 (binary_expr -> expr * expr .)
    ARRAY_CONCAT    reduce using rule 64 (binary_expr -> expr * expr .)
    MORE_OR_EQ      reduce using rule 64 (binary_expr -> expr * expr .)
    LESS_OR_EQ      reduce using rule 64 (binary_expr -> expr * expr .)
    TEXT_MATCH      reduce using rule 64 (binary_expr -> expr * expr .)
    STRICT_AND      reduce using rule 64 (binary_expr -> expr * expr .)
    AND             reduce using rule 64 (binary_expr -> expr * expr .)
    STRICT_OR       reduce using rule 64 (binary_expr -> expr * expr .)
    OR              reduce using rule 64 (binary_expr -> expr * expr .)
    EQUAL           reduce using rule 64 (binary_expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 64 (binary_expr -> expr * expr .)
    >               reduce using rule 64 (binary_expr -> expr * expr .)
    FLOAT_MUL       reduce using rule 64 (binary_expr -> expr * expr .)
    FLOAT_DIV       reduce using rule 64 (binary_expr -> expr * expr .)
    FLOAT_SUB       reduce using rule 64 (binary_expr -> expr * expr .)
    FLOAT_SUM       reduce using rule 64 (binary_expr -> expr * expr .)
    <               reduce using rule 64 (binary_expr -> expr * expr .)
    *               reduce using rule 64 (binary_expr -> expr * expr .)
    /               reduce using rule 64 (binary_expr -> expr * expr .)
    -               reduce using rule 64 (binary_expr -> expr * expr .)
    +               reduce using rule 64 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 64 (binary_expr -> expr * expr .)
    $end            reduce using rule 64 (binary_expr -> expr * expr .)
    )               reduce using rule 64 (binary_expr -> expr * expr .)
    INTERPOLATION_BOTH reduce using rule 64 (binary_expr -> expr * expr .)
    INTERPOLATION_RIGHT reduce using rule 64 (binary_expr -> expr * expr .)
    OF              reduce using rule 64 (binary_expr -> expr * expr .)
    THEN            reduce using rule 64 (binary_expr -> expr * expr .)
    END             reduce using rule 64 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 64 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 64 (binary_expr -> expr * expr .)
    ,               reduce using rule 64 (binary_expr -> expr * expr .)
    ]               reduce using rule 64 (binary_expr -> expr * expr .)
    (               shift and go to state 47
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60


state 171

    (65) binary_expr -> expr / expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 65 (binary_expr -> expr / expr .)
    SOME_SUB        reduce using rule 65 (binary_expr -> expr / expr .)
    SOME_CONCAT     reduce using rule 65 (binary_expr -> expr / expr .)
    ARROW_BOTH      reduce using rule 65 (binary_expr -> expr / expr .)
    ARROW_RIGHT     reduce using rule 65 (binary_expr -> expr / expr .)
    ARROW_LEFT      reduce using rule 65 (binary_expr -> expr / expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 65 (binary_expr -> expr / expr .)
    DOUBLE_ARROW_LEFT reduce using rule 65 (binary_expr -> expr / expr .)
    BIT_SHIFT_RIGHT reduce using rule 65 (binary_expr -> expr / expr .)
    BIT_SHIFT_LEFT  reduce using rule 65 (binary_expr -> expr / expr .)
    BIT_AND         reduce using rule 65 (binary_expr -> expr / expr .)
    BIT_OR          reduce using rule 65 (binary_expr -> expr / expr .)
    ARRAY_SUB       reduce using rule 65 (binary_expr -> expr / expr .)
    ARRAY_CONCAT    reduce using rule 65 (binary_expr -> expr / expr .)
    MORE_OR_EQ      reduce using rule 65 (binary_expr -> expr / expr .)
    LESS_OR_EQ      reduce using rule 65 (binary_expr -> expr / expr .)
    TEXT_MATCH      reduce using rule 65 (binary_expr -> expr / expr .)
    STRICT_AND      reduce using rule 65 (binary_expr -> expr / expr .)
    AND             reduce using rule 65 (binary_expr -> expr / expr .)
    STRICT_OR       reduce using rule 65 (binary_expr -> expr / expr .)
    OR              reduce using rule 65 (binary_expr -> expr / expr .)
    EQUAL           reduce using rule 65 (binary_expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 65 (binary_expr -> expr / expr .)
    >               reduce using rule 65 (binary_expr -> expr / expr .)
    FLOAT_MUL       reduce using rule 65 (binary_expr -> expr / expr .)
    FLOAT_DIV       reduce using rule 65 (binary_expr -> expr / expr .)
    FLOAT_SUB       reduce using rule 65 (binary_expr -> expr / expr .)
    FLOAT_SUM       reduce using rule 65 (binary_expr -> expr / expr .)
    <               reduce using rule 65 (binary_expr -> expr / expr .)
    *               reduce using rule 65 (binary_expr -> expr / expr .)
    /               reduce using rule 65 (binary_expr -> expr / expr .)
    -               reduce using rule 65 (binary_expr -> expr / expr .)
    +               reduce using rule 65 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 65 (binary_expr -> expr / expr .)
    $end            reduce using rule 65 (binary_expr -> expr / expr .)
    )               reduce using rule 65 (binary_expr -> expr / expr .)
    INTERPOLATION_BOTH reduce using rule 65 (binary_expr -> expr / expr .)
    INTERPOLATION_RIGHT reduce using rule 65 (binary_expr -> expr / expr .)
    OF              reduce using rule 65 (binary_expr -> expr / expr .)
    THEN            reduce using rule 65 (binary_expr -> expr / expr .)
    END             reduce using rule 65 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 65 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 65 (binary_expr -> expr / expr .)
    ,               reduce using rule 65 (binary_expr -> expr / expr .)
    ]               reduce using rule 65 (binary_expr -> expr / expr .)
    (               shift and go to state 47
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60


state 172

    (66) binary_expr -> expr - expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 66 (binary_expr -> expr - expr .)
    SOME_SUB        reduce using rule 66 (binary_expr -> expr - expr .)
    SOME_CONCAT     reduce using rule 66 (binary_expr -> expr - expr .)
    ARROW_BOTH      reduce using rule 66 (binary_expr -> expr - expr .)
    ARROW_RIGHT     reduce using rule 66 (binary_expr -> expr - expr .)
    ARROW_LEFT      reduce using rule 66 (binary_expr -> expr - expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 66 (binary_expr -> expr - expr .)
    DOUBLE_ARROW_LEFT reduce using rule 66 (binary_expr -> expr - expr .)
    BIT_SHIFT_RIGHT reduce using rule 66 (binary_expr -> expr - expr .)
    BIT_SHIFT_LEFT  reduce using rule 66 (binary_expr -> expr - expr .)
    BIT_AND         reduce using rule 66 (binary_expr -> expr - expr .)
    BIT_OR          reduce using rule 66 (binary_expr -> expr - expr .)
    ARRAY_SUB       reduce using rule 66 (binary_expr -> expr - expr .)
    ARRAY_CONCAT    reduce using rule 66 (binary_expr -> expr - expr .)
    MORE_OR_EQ      reduce using rule 66 (binary_expr -> expr - expr .)
    LESS_OR_EQ      reduce using rule 66 (binary_expr -> expr - expr .)
    TEXT_MATCH      reduce using rule 66 (binary_expr -> expr - expr .)
    STRICT_AND      reduce using rule 66 (binary_expr -> expr - expr .)
    AND             reduce using rule 66 (binary_expr -> expr - expr .)
    STRICT_OR       reduce using rule 66 (binary_expr -> expr - expr .)
    OR              reduce using rule 66 (binary_expr -> expr - expr .)
    EQUAL           reduce using rule 66 (binary_expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 66 (binary_expr -> expr - expr .)
    >               reduce using rule 66 (binary_expr -> expr - expr .)
    FLOAT_SUB       reduce using rule 66 (binary_expr -> expr - expr .)
    FLOAT_SUM       reduce using rule 66 (binary_expr -> expr - expr .)
    <               reduce using rule 66 (binary_expr -> expr - expr .)
    -               reduce using rule 66 (binary_expr -> expr - expr .)
    +               reduce using rule 66 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 66 (binary_expr -> expr - expr .)
    $end            reduce using rule 66 (binary_expr -> expr - expr .)
    )               reduce using rule 66 (binary_expr -> expr - expr .)
    INTERPOLATION_BOTH reduce using rule 66 (binary_expr -> expr - expr .)
    INTERPOLATION_RIGHT reduce using rule 66 (binary_expr -> expr - expr .)
    OF              reduce using rule 66 (binary_expr -> expr - expr .)
    THEN            reduce using rule 66 (binary_expr -> expr - expr .)
    END             reduce using rule 66 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 66 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 66 (binary_expr -> expr - expr .)
    ,               reduce using rule 66 (binary_expr -> expr - expr .)
    ]               reduce using rule 66 (binary_expr -> expr - expr .)
    (               shift and go to state 47
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    *               shift and go to state 78
    /               shift and go to state 79


state 173

    (67) binary_expr -> expr + expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 67 (binary_expr -> expr + expr .)
    SOME_SUB        reduce using rule 67 (binary_expr -> expr + expr .)
    SOME_CONCAT     reduce using rule 67 (binary_expr -> expr + expr .)
    ARROW_BOTH      reduce using rule 67 (binary_expr -> expr + expr .)
    ARROW_RIGHT     reduce using rule 67 (binary_expr -> expr + expr .)
    ARROW_LEFT      reduce using rule 67 (binary_expr -> expr + expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 67 (binary_expr -> expr + expr .)
    DOUBLE_ARROW_LEFT reduce using rule 67 (binary_expr -> expr + expr .)
    BIT_SHIFT_RIGHT reduce using rule 67 (binary_expr -> expr + expr .)
    BIT_SHIFT_LEFT  reduce using rule 67 (binary_expr -> expr + expr .)
    BIT_AND         reduce using rule 67 (binary_expr -> expr + expr .)
    BIT_OR          reduce using rule 67 (binary_expr -> expr + expr .)
    ARRAY_SUB       reduce using rule 67 (binary_expr -> expr + expr .)
    ARRAY_CONCAT    reduce using rule 67 (binary_expr -> expr + expr .)
    MORE_OR_EQ      reduce using rule 67 (binary_expr -> expr + expr .)
    LESS_OR_EQ      reduce using rule 67 (binary_expr -> expr + expr .)
    TEXT_MATCH      reduce using rule 67 (binary_expr -> expr + expr .)
    STRICT_AND      reduce using rule 67 (binary_expr -> expr + expr .)
    AND             reduce using rule 67 (binary_expr -> expr + expr .)
    STRICT_OR       reduce using rule 67 (binary_expr -> expr + expr .)
    OR              reduce using rule 67 (binary_expr -> expr + expr .)
    EQUAL           reduce using rule 67 (binary_expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 67 (binary_expr -> expr + expr .)
    >               reduce using rule 67 (binary_expr -> expr + expr .)
    FLOAT_SUB       reduce using rule 67 (binary_expr -> expr + expr .)
    FLOAT_SUM       reduce using rule 67 (binary_expr -> expr + expr .)
    <               reduce using rule 67 (binary_expr -> expr + expr .)
    -               reduce using rule 67 (binary_expr -> expr + expr .)
    +               reduce using rule 67 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 67 (binary_expr -> expr + expr .)
    $end            reduce using rule 67 (binary_expr -> expr + expr .)
    )               reduce using rule 67 (binary_expr -> expr + expr .)
    INTERPOLATION_BOTH reduce using rule 67 (binary_expr -> expr + expr .)
    INTERPOLATION_RIGHT reduce using rule 67 (binary_expr -> expr + expr .)
    OF              reduce using rule 67 (binary_expr -> expr + expr .)
    THEN            reduce using rule 67 (binary_expr -> expr + expr .)
    END             reduce using rule 67 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 67 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 67 (binary_expr -> expr + expr .)
    ,               reduce using rule 67 (binary_expr -> expr + expr .)
    ]               reduce using rule 67 (binary_expr -> expr + expr .)
    (               shift and go to state 47
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    *               shift and go to state 78
    /               shift and go to state 79


state 174

    (68) binary_expr -> expr CONCAT expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    ARROW_BOTH      reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    ARROW_RIGHT     reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    ARROW_LEFT      reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    BIT_SHIFT_RIGHT reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    BIT_AND         reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    BIT_OR          reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    MORE_OR_EQ      reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    LESS_OR_EQ      reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    TEXT_MATCH      reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    STRICT_AND      reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    AND             reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    STRICT_OR       reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    OR              reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    EQUAL           reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    NOT_EQUAL       reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    INTERPOLATION_BOTH reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    INTERPOLATION_RIGHT reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 68 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 175

    (10) expr -> ( expr ) .
    NEWLINE         reduce using rule 10 (expr -> ( expr ) .)
    (               reduce using rule 10 (expr -> ( expr ) .)
    SOME_SUB        reduce using rule 10 (expr -> ( expr ) .)
    SOME_CONCAT     reduce using rule 10 (expr -> ( expr ) .)
    ARROW_BOTH      reduce using rule 10 (expr -> ( expr ) .)
    ARROW_RIGHT     reduce using rule 10 (expr -> ( expr ) .)
    ARROW_LEFT      reduce using rule 10 (expr -> ( expr ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 10 (expr -> ( expr ) .)
    DOUBLE_ARROW_LEFT reduce using rule 10 (expr -> ( expr ) .)
    BIT_SHIFT_RIGHT reduce using rule 10 (expr -> ( expr ) .)
    BIT_SHIFT_LEFT  reduce using rule 10 (expr -> ( expr ) .)
    BIT_AND         reduce using rule 10 (expr -> ( expr ) .)
    BIT_OR          reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_POW       reduce using rule 10 (expr -> ( expr ) .)
    POW             reduce using rule 10 (expr -> ( expr ) .)
    ARRAY_SUB       reduce using rule 10 (expr -> ( expr ) .)
    ARRAY_CONCAT    reduce using rule 10 (expr -> ( expr ) .)
    MORE_OR_EQ      reduce using rule 10 (expr -> ( expr ) .)
    LESS_OR_EQ      reduce using rule 10 (expr -> ( expr ) .)
    TEXT_MATCH      reduce using rule 10 (expr -> ( expr ) .)
    STRICT_AND      reduce using rule 10 (expr -> ( expr ) .)
    AND             reduce using rule 10 (expr -> ( expr ) .)
    STRICT_OR       reduce using rule 10 (expr -> ( expr ) .)
    OR              reduce using rule 10 (expr -> ( expr ) .)
    EQUAL           reduce using rule 10 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 10 (expr -> ( expr ) .)
    >               reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_MUL       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_DIV       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_SUB       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_SUM       reduce using rule 10 (expr -> ( expr ) .)
    <               reduce using rule 10 (expr -> ( expr ) .)
    *               reduce using rule 10 (expr -> ( expr ) .)
    /               reduce using rule 10 (expr -> ( expr ) .)
    -               reduce using rule 10 (expr -> ( expr ) .)
    +               reduce using rule 10 (expr -> ( expr ) .)
    CONCAT          reduce using rule 10 (expr -> ( expr ) .)
    $end            reduce using rule 10 (expr -> ( expr ) .)
    )               reduce using rule 10 (expr -> ( expr ) .)
    INTERPOLATION_BOTH reduce using rule 10 (expr -> ( expr ) .)
    INTERPOLATION_RIGHT reduce using rule 10 (expr -> ( expr ) .)
    OF              reduce using rule 10 (expr -> ( expr ) .)
    THEN            reduce using rule 10 (expr -> ( expr ) .)
    END             reduce using rule 10 (expr -> ( expr ) .)
    ELIF            reduce using rule 10 (expr -> ( expr ) .)
    ELSE            reduce using rule 10 (expr -> ( expr ) .)
    ,               reduce using rule 10 (expr -> ( expr ) .)
    ]               reduce using rule 10 (expr -> ( expr ) .)


state 176

    (284) let -> identifier : type_identifier . < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (162) type -> type_identifier . < type _26_0x2c_type_repeat >
    (168) type -> type_identifier .
    <               shift and go to state 204
    =               reduce using rule 168 (type -> type_identifier .)


state 177

    (291) _65_0x3a_type_optional -> : type .
    =               reduce using rule 291 (_65_0x3a_type_optional -> : type .)


state 178

    (290) let -> identifier _65_0x3a_type_optional = . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    identifier                     shift and go to state 16
    expr                           shift and go to state 205
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 179

    (296) str_inter -> INTERPOLATION_LEFT expr inter_or_str .
    NEWLINE         reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    (               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    SOME_SUB        reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    SOME_CONCAT     reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ARROW_BOTH      reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ARROW_RIGHT     reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ARROW_LEFT      reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    DOUBLE_ARROW_RIGHT reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    DOUBLE_ARROW_LEFT reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    BIT_SHIFT_RIGHT reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    BIT_SHIFT_LEFT  reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    BIT_AND         reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    BIT_OR          reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    FLOAT_POW       reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    POW             reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ARRAY_SUB       reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ARRAY_CONCAT    reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    MORE_OR_EQ      reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    LESS_OR_EQ      reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    TEXT_MATCH      reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    STRICT_AND      reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    AND             reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    STRICT_OR       reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    OR              reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    EQUAL           reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    NOT_EQUAL       reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    >               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    FLOAT_MUL       reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    FLOAT_DIV       reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    FLOAT_SUB       reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    FLOAT_SUM       reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    <               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    *               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    /               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    -               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    +               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    CONCAT          reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    $end            reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    )               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    INTERPOLATION_BOTH reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    INTERPOLATION_RIGHT reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    OF              reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    THEN            reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    END             reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ELIF            reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ELSE            reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ,               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)
    ]               reduce using rule 296 (str_inter -> INTERPOLATION_LEFT expr inter_or_str .)


state 180

    (297) inter_or_str -> INTERPOLATION_BOTH . expr inter_or_str
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 206
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 181

    (298) inter_or_str -> INTERPOLATION_RIGHT .
    NEWLINE         reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    (               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    SOME_SUB        reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    SOME_CONCAT     reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ARROW_BOTH      reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ARROW_RIGHT     reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ARROW_LEFT      reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    DOUBLE_ARROW_RIGHT reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    DOUBLE_ARROW_LEFT reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    BIT_SHIFT_RIGHT reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    BIT_SHIFT_LEFT  reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    BIT_AND         reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    BIT_OR          reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    FLOAT_POW       reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    POW             reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ARRAY_SUB       reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ARRAY_CONCAT    reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    MORE_OR_EQ      reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    LESS_OR_EQ      reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    TEXT_MATCH      reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    STRICT_AND      reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    AND             reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    STRICT_OR       reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    OR              reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    EQUAL           reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    NOT_EQUAL       reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    >               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    FLOAT_MUL       reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    FLOAT_DIV       reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    FLOAT_SUB       reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    FLOAT_SUM       reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    <               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    *               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    /               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    -               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    +               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    CONCAT          reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    $end            reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    )               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    INTERPOLATION_BOTH reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    INTERPOLATION_RIGHT reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    OF              reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    THEN            reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    END             reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ELIF            reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ELSE            reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ,               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)
    ]               reduce using rule 298 (inter_or_str -> INTERPOLATION_RIGHT .)


state 182

    (104) binary_op_def -> DEF binary_op ( . _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (105) _4_NEWLINE_optional -> . NEWLINE
    (106) _4_NEWLINE_optional -> .
    NEWLINE         shift and go to state 208
    IDENTIFIER      reduce using rule 106 (_4_NEWLINE_optional -> .)

    _4_NEWLINE_optional            shift and go to state 207

state 183

    (113) binary_op_def -> DEF binary_op < . type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 209

state 184

    (135) def_expr -> DEF identifier ( . _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (136) _16_NEWLINE_optional -> . NEWLINE
    (137) _16_NEWLINE_optional -> .
    NEWLINE         shift and go to state 211
    IDENTIFIER      reduce using rule 137 (_16_NEWLINE_optional -> .)
    )               reduce using rule 137 (_16_NEWLINE_optional -> .)

    _16_NEWLINE_optional           shift and go to state 210

state 185

    (142) def_expr -> DEF identifier < . type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 212

state 186

    (269) variant_call -> type_identifier ( _59_NEWLINE_optional . _60_exprs_optional )
    (272) _60_exprs_optional -> . exprs
    (273) _60_exprs_optional -> .
    (274) exprs -> . expr _61_NEWLINE_optional
    (277) exprs -> . exprs , _62_NEWLINE_optional expr _63_NEWLINE_optional
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 273 (_60_exprs_optional -> .)
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 28
    _60_exprs_optional             shift and go to state 213
    exprs                          shift and go to state 214
    expr                           shift and go to state 190
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25

state 187

    (270) _59_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_LEFT reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    TYPE            reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 270 (_59_NEWLINE_optional -> NEWLINE .)


state 188

    (259) array -> [ _55_NEWLINE_optional _56_exprs_optional . ]
    ]               shift and go to state 215


state 189

    (262) _56_exprs_optional -> exprs .
    (277) exprs -> exprs . , _62_NEWLINE_optional expr _63_NEWLINE_optional
    ]               reduce using rule 262 (_56_exprs_optional -> exprs .)
    ,               shift and go to state 216


state 190

    (274) exprs -> expr . _61_NEWLINE_optional
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    (275) _61_NEWLINE_optional -> . NEWLINE
    (276) _61_NEWLINE_optional -> .
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82
    NEWLINE         shift and go to state 218
    ,               reduce using rule 276 (_61_NEWLINE_optional -> .)
    ]               reduce using rule 276 (_61_NEWLINE_optional -> .)
    )               reduce using rule 276 (_61_NEWLINE_optional -> .)

    _61_NEWLINE_optional           shift and go to state 217

state 191

    (231) case_of -> CASE expr OF . _46_NEWLINE_optional _47_cases_optional END
    (232) _46_NEWLINE_optional -> . NEWLINE
    (233) _46_NEWLINE_optional -> .
    NEWLINE         shift and go to state 220
    TYPE_IDENTIFIER reduce using rule 233 (_46_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 233 (_46_NEWLINE_optional -> .)
    END             reduce using rule 233 (_46_NEWLINE_optional -> .)

    _46_NEWLINE_optional           shift and go to state 219

state 192

    (222) if_expr -> IF expr THEN . _43_0x3a_type_optional block_statement _44_or_else_optional END
    (223) _43_0x3a_type_optional -> . : type
    (224) _43_0x3a_type_optional -> .
    :               shift and go to state 222
    NEWLINE         reduce using rule 224 (_43_0x3a_type_optional -> .)
    ELIF            reduce using rule 224 (_43_0x3a_type_optional -> .)
    ELSE            reduce using rule 224 (_43_0x3a_type_optional -> .)
    END             reduce using rule 224 (_43_0x3a_type_optional -> .)
    (               reduce using rule 224 (_43_0x3a_type_optional -> .)
    INTERPOLATION_LEFT reduce using rule 224 (_43_0x3a_type_optional -> .)
    DEF             reduce using rule 224 (_43_0x3a_type_optional -> .)
    +               reduce using rule 224 (_43_0x3a_type_optional -> .)
    !               reduce using rule 224 (_43_0x3a_type_optional -> .)
    STRICT_NOT      reduce using rule 224 (_43_0x3a_type_optional -> .)
    -               reduce using rule 224 (_43_0x3a_type_optional -> .)
    STRING          reduce using rule 224 (_43_0x3a_type_optional -> .)
    FLOAT           reduce using rule 224 (_43_0x3a_type_optional -> .)
    INT             reduce using rule 224 (_43_0x3a_type_optional -> .)
    [               reduce using rule 224 (_43_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 224 (_43_0x3a_type_optional -> .)
    CASE            reduce using rule 224 (_43_0x3a_type_optional -> .)
    IF              reduce using rule 224 (_43_0x3a_type_optional -> .)
    DO              reduce using rule 224 (_43_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 224 (_43_0x3a_type_optional -> .)
    TYPE            reduce using rule 224 (_43_0x3a_type_optional -> .)
    ENUM            reduce using rule 224 (_43_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 224 (_43_0x3a_type_optional -> .)

    _43_0x3a_type_optional         shift and go to state 221

state 193

    (127) do -> DO _13_0x3a_type_optional block_statement . END
    END             shift and go to state 223


state 194

    (130) block_statement -> _14_NEWLINE_optional . _15_do_exprs_optional
    (133) _15_do_exprs_optional -> . do_exprs
    (134) _15_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 134 (_15_do_exprs_optional -> .)
    ELIF            reduce using rule 134 (_15_do_exprs_optional -> .)
    ELSE            reduce using rule 134 (_15_do_exprs_optional -> .)
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    _15_do_exprs_optional          shift and go to state 224
    do_exprs                       shift and go to state 225
    expr                           shift and go to state 6
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 195

    (131) _14_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_LEFT reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    TYPE            reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 131 (_14_NEWLINE_optional -> NEWLINE .)


state 196

    (128) _13_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    END             reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    (               reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    INTERPOLATION_LEFT reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    DEF             reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    +               reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    !               reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    STRICT_NOT      reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    -               reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    STRING          reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    FLOAT           reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    INT             reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    [               reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    CASE            reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    IF              reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    DO              reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    TYPE            reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 128 (_13_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 128 (_13_0x3a_type_optional -> : type .)


state 197

    (162) type -> type_identifier . < type _26_0x2c_type_repeat >
    (168) type -> type_identifier .
    <               shift and go to state 226
    NEWLINE         reduce using rule 168 (type -> type_identifier .)
    END             reduce using rule 168 (type -> type_identifier .)
    (               reduce using rule 168 (type -> type_identifier .)
    INTERPOLATION_LEFT reduce using rule 168 (type -> type_identifier .)
    DEF             reduce using rule 168 (type -> type_identifier .)
    +               reduce using rule 168 (type -> type_identifier .)
    !               reduce using rule 168 (type -> type_identifier .)
    STRICT_NOT      reduce using rule 168 (type -> type_identifier .)
    -               reduce using rule 168 (type -> type_identifier .)
    STRING          reduce using rule 168 (type -> type_identifier .)
    FLOAT           reduce using rule 168 (type -> type_identifier .)
    INT             reduce using rule 168 (type -> type_identifier .)
    [               reduce using rule 168 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 168 (type -> type_identifier .)
    CASE            reduce using rule 168 (type -> type_identifier .)
    IF              reduce using rule 168 (type -> type_identifier .)
    DO              reduce using rule 168 (type -> type_identifier .)
    EXTERNAL        reduce using rule 168 (type -> type_identifier .)
    TYPE            reduce using rule 168 (type -> type_identifier .)
    ENUM            reduce using rule 168 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 168 (type -> type_identifier .)
    ,               reduce using rule 168 (type -> type_identifier .)
    MORE_OR_EQ      reduce using rule 168 (type -> type_identifier .)
    >               reduce using rule 168 (type -> type_identifier .)
    ELIF            reduce using rule 168 (type -> type_identifier .)
    ELSE            reduce using rule 168 (type -> type_identifier .)
    )               reduce using rule 168 (type -> type_identifier .)


state 198

    (170) enum -> TYPE type_identifier = . _27_NEWLINE_optional _28_type_variants_optional
    (171) _27_NEWLINE_optional -> . NEWLINE
    (172) _27_NEWLINE_optional -> .
  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 228
    TYPE_IDENTIFIER reduce using rule 172 (_27_NEWLINE_optional -> .)
    (               reduce using rule 172 (_27_NEWLINE_optional -> .)
    SOME_SUB        reduce using rule 172 (_27_NEWLINE_optional -> .)
    SOME_CONCAT     reduce using rule 172 (_27_NEWLINE_optional -> .)
    ARROW_BOTH      reduce using rule 172 (_27_NEWLINE_optional -> .)
    ARROW_RIGHT     reduce using rule 172 (_27_NEWLINE_optional -> .)
    ARROW_LEFT      reduce using rule 172 (_27_NEWLINE_optional -> .)
    DOUBLE_ARROW_RIGHT reduce using rule 172 (_27_NEWLINE_optional -> .)
    DOUBLE_ARROW_LEFT reduce using rule 172 (_27_NEWLINE_optional -> .)
    BIT_SHIFT_RIGHT reduce using rule 172 (_27_NEWLINE_optional -> .)
    BIT_SHIFT_LEFT  reduce using rule 172 (_27_NEWLINE_optional -> .)
    BIT_AND         reduce using rule 172 (_27_NEWLINE_optional -> .)
    BIT_OR          reduce using rule 172 (_27_NEWLINE_optional -> .)
    FLOAT_POW       reduce using rule 172 (_27_NEWLINE_optional -> .)
    POW             reduce using rule 172 (_27_NEWLINE_optional -> .)
    ARRAY_SUB       reduce using rule 172 (_27_NEWLINE_optional -> .)
    ARRAY_CONCAT    reduce using rule 172 (_27_NEWLINE_optional -> .)
    MORE_OR_EQ      reduce using rule 172 (_27_NEWLINE_optional -> .)
    LESS_OR_EQ      reduce using rule 172 (_27_NEWLINE_optional -> .)
    TEXT_MATCH      reduce using rule 172 (_27_NEWLINE_optional -> .)
    STRICT_AND      reduce using rule 172 (_27_NEWLINE_optional -> .)
    AND             reduce using rule 172 (_27_NEWLINE_optional -> .)
    STRICT_OR       reduce using rule 172 (_27_NEWLINE_optional -> .)
    OR              reduce using rule 172 (_27_NEWLINE_optional -> .)
    EQUAL           reduce using rule 172 (_27_NEWLINE_optional -> .)
    NOT_EQUAL       reduce using rule 172 (_27_NEWLINE_optional -> .)
    >               reduce using rule 172 (_27_NEWLINE_optional -> .)
    FLOAT_MUL       reduce using rule 172 (_27_NEWLINE_optional -> .)
    FLOAT_DIV       reduce using rule 172 (_27_NEWLINE_optional -> .)
    FLOAT_SUB       reduce using rule 172 (_27_NEWLINE_optional -> .)
    FLOAT_SUM       reduce using rule 172 (_27_NEWLINE_optional -> .)
    <               reduce using rule 172 (_27_NEWLINE_optional -> .)
    *               reduce using rule 172 (_27_NEWLINE_optional -> .)
    /               reduce using rule 172 (_27_NEWLINE_optional -> .)
    -               reduce using rule 172 (_27_NEWLINE_optional -> .)
    +               reduce using rule 172 (_27_NEWLINE_optional -> .)
    CONCAT          reduce using rule 172 (_27_NEWLINE_optional -> .)
    $end            reduce using rule 172 (_27_NEWLINE_optional -> .)
    )               reduce using rule 172 (_27_NEWLINE_optional -> .)
    INTERPOLATION_BOTH reduce using rule 172 (_27_NEWLINE_optional -> .)
    INTERPOLATION_RIGHT reduce using rule 172 (_27_NEWLINE_optional -> .)
    OF              reduce using rule 172 (_27_NEWLINE_optional -> .)
    THEN            reduce using rule 172 (_27_NEWLINE_optional -> .)
    END             reduce using rule 172 (_27_NEWLINE_optional -> .)
    ELIF            reduce using rule 172 (_27_NEWLINE_optional -> .)
    ELSE            reduce using rule 172 (_27_NEWLINE_optional -> .)
    ,               reduce using rule 172 (_27_NEWLINE_optional -> .)
    ]               reduce using rule 172 (_27_NEWLINE_optional -> .)

    _27_NEWLINE_optional           shift and go to state 227

state 199

    (175) enum -> TYPE type_identifier < . type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 229

state 200

    (185) enum -> ENUM type_identifier { . _32_NEWLINE_optional _33_variants_optional }
    (186) _32_NEWLINE_optional -> . NEWLINE
    (187) _32_NEWLINE_optional -> .
    NEWLINE         shift and go to state 231
    TYPE_IDENTIFIER reduce using rule 187 (_32_NEWLINE_optional -> .)
    }               reduce using rule 187 (_32_NEWLINE_optional -> .)

    _32_NEWLINE_optional           shift and go to state 230

state 201

    (190) enum -> ENUM type_identifier < . type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 232

state 202

    (264) call -> expr ( _57_NEWLINE_optional _58_exprs_optional . )
    )               shift and go to state 233


state 203

    (267) _58_exprs_optional -> exprs .
    (277) exprs -> exprs . , _62_NEWLINE_optional expr _63_NEWLINE_optional
    )               reduce using rule 267 (_58_exprs_optional -> exprs .)
    ,               shift and go to state 216


state 204

    (284) let -> identifier : type_identifier < . type _64_0x2c_type_repeat MORE_OR_EQ expr
    (162) type -> type_identifier < . type _26_0x2c_type_repeat >
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 197
    type                           shift and go to state 234

state 205

    (290) let -> identifier _65_0x3a_type_optional = expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    $end            reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    )               reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    INTERPOLATION_BOTH reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    INTERPOLATION_RIGHT reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    OF              reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    THEN            reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    END             reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    ELIF            reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    ELSE            reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    ,               reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    ]               reduce using rule 290 (let -> identifier _65_0x3a_type_optional = expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 206

    (297) inter_or_str -> INTERPOLATION_BOTH expr . inter_or_str
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    (297) inter_or_str -> . INTERPOLATION_BOTH expr inter_or_str
    (298) inter_or_str -> . INTERPOLATION_RIGHT
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82
    INTERPOLATION_BOTH shift and go to state 180
    INTERPOLATION_RIGHT shift and go to state 181

    inter_or_str                   shift and go to state 235

state 207

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional . param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (219) param -> . identifier _42_0x3a_type_optional
    (282) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 37

    param                          shift and go to state 236
    identifier                     shift and go to state 237

state 208

    (105) _4_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 105 (_4_NEWLINE_optional -> NEWLINE .)


state 209

    (113) binary_op_def -> DEF binary_op < type_identifier . _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (114) _8_0x2c_type_identifier_repeat -> . _8_0x2c_type_identifier_items
    (115) _8_0x2c_type_identifier_repeat -> .
    (116) _8_0x2c_type_identifier_items -> . _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item
    (117) _8_0x2c_type_identifier_items -> . _8_0x2c_type_identifier_item
    (118) _8_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 115 (_8_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 239

    _8_0x2c_type_identifier_repeat shift and go to state 238
    _8_0x2c_type_identifier_items  shift and go to state 240
    _8_0x2c_type_identifier_item   shift and go to state 241

state 210

    (135) def_expr -> DEF identifier ( _16_NEWLINE_optional . _17_params_optional ) _18_0x3a_type_optional do
    (138) _17_params_optional -> . params
    (139) _17_params_optional -> .
    (154) params -> . param _23_NEWLINE_optional
    (157) params -> . params , _24_NEWLINE_optional param _25_NEWLINE_optional
    (219) param -> . identifier _42_0x3a_type_optional
    (282) identifier -> . IDENTIFIER
    )               reduce using rule 139 (_17_params_optional -> .)
    IDENTIFIER      shift and go to state 37

    identifier                     shift and go to state 237
    _17_params_optional            shift and go to state 242
    params                         shift and go to state 243
    param                          shift and go to state 244

state 211

    (136) _16_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 136 (_16_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 136 (_16_NEWLINE_optional -> NEWLINE .)


state 212

    (142) def_expr -> DEF identifier < type_identifier . _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (143) _19_0x2c_type_identifier_repeat -> . _19_0x2c_type_identifier_items
    (144) _19_0x2c_type_identifier_repeat -> .
    (145) _19_0x2c_type_identifier_items -> . _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item
    (146) _19_0x2c_type_identifier_items -> . _19_0x2c_type_identifier_item
    (147) _19_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 144 (_19_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 248

    _19_0x2c_type_identifier_repeat shift and go to state 245
    _19_0x2c_type_identifier_items shift and go to state 246
    _19_0x2c_type_identifier_item  shift and go to state 247

state 213

    (269) variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional . )
    )               shift and go to state 249


state 214

    (272) _60_exprs_optional -> exprs .
    (277) exprs -> exprs . , _62_NEWLINE_optional expr _63_NEWLINE_optional
    )               reduce using rule 272 (_60_exprs_optional -> exprs .)
    ,               shift and go to state 216


state 215

    (259) array -> [ _55_NEWLINE_optional _56_exprs_optional ] .
    NEWLINE         reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    (               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    SOME_SUB        reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    SOME_CONCAT     reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ARROW_BOTH      reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ARROW_RIGHT     reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ARROW_LEFT      reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    DOUBLE_ARROW_RIGHT reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    DOUBLE_ARROW_LEFT reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    BIT_SHIFT_RIGHT reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    BIT_SHIFT_LEFT  reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    BIT_AND         reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    BIT_OR          reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    FLOAT_POW       reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    POW             reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ARRAY_SUB       reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ARRAY_CONCAT    reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    MORE_OR_EQ      reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    LESS_OR_EQ      reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    TEXT_MATCH      reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    STRICT_AND      reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    AND             reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    STRICT_OR       reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    OR              reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    EQUAL           reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    NOT_EQUAL       reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    >               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    FLOAT_MUL       reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    FLOAT_DIV       reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    FLOAT_SUB       reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    FLOAT_SUM       reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    <               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    *               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    /               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    -               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    +               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    CONCAT          reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    $end            reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    )               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    INTERPOLATION_BOTH reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    INTERPOLATION_RIGHT reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    OF              reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    THEN            reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    END             reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ELIF            reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ELSE            reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ,               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)
    ]               reduce using rule 259 (array -> [ _55_NEWLINE_optional _56_exprs_optional ] .)


state 216

    (277) exprs -> exprs , . _62_NEWLINE_optional expr _63_NEWLINE_optional
    (278) _62_NEWLINE_optional -> . NEWLINE
    (279) _62_NEWLINE_optional -> .
    NEWLINE         shift and go to state 251
    (               reduce using rule 279 (_62_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 279 (_62_NEWLINE_optional -> .)
    DEF             reduce using rule 279 (_62_NEWLINE_optional -> .)
    +               reduce using rule 279 (_62_NEWLINE_optional -> .)
    !               reduce using rule 279 (_62_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 279 (_62_NEWLINE_optional -> .)
    -               reduce using rule 279 (_62_NEWLINE_optional -> .)
    STRING          reduce using rule 279 (_62_NEWLINE_optional -> .)
    FLOAT           reduce using rule 279 (_62_NEWLINE_optional -> .)
    INT             reduce using rule 279 (_62_NEWLINE_optional -> .)
    [               reduce using rule 279 (_62_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 279 (_62_NEWLINE_optional -> .)
    CASE            reduce using rule 279 (_62_NEWLINE_optional -> .)
    IF              reduce using rule 279 (_62_NEWLINE_optional -> .)
    DO              reduce using rule 279 (_62_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 279 (_62_NEWLINE_optional -> .)
    TYPE            reduce using rule 279 (_62_NEWLINE_optional -> .)
    ENUM            reduce using rule 279 (_62_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 279 (_62_NEWLINE_optional -> .)

    _62_NEWLINE_optional           shift and go to state 250

state 217

    (274) exprs -> expr _61_NEWLINE_optional .
    ,               reduce using rule 274 (exprs -> expr _61_NEWLINE_optional .)
    ]               reduce using rule 274 (exprs -> expr _61_NEWLINE_optional .)
    )               reduce using rule 274 (exprs -> expr _61_NEWLINE_optional .)


state 218

    (275) _61_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 275 (_61_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 275 (_61_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 275 (_61_NEWLINE_optional -> NEWLINE .)


state 219

    (231) case_of -> CASE expr OF _46_NEWLINE_optional . _47_cases_optional END
    (234) _47_cases_optional -> . cases
    (235) _47_cases_optional -> .
    (236) cases -> . pattern do _48_NEWLINE_optional
    (239) cases -> . cases pattern do _49_NEWLINE_optional
    (242) pattern -> . match_variant
    (243) pattern -> . match_as
    (245) match_variant -> . type_identifier
    (246) match_variant -> . type_identifier ( _50_NEWLINE_optional _51_patterns_optional )
    (244) match_as -> . identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    (282) identifier -> . IDENTIFIER
    END             reduce using rule 235 (_47_cases_optional -> .)
    TYPE_IDENTIFIER shift and go to state 44
    IDENTIFIER      shift and go to state 37

    _47_cases_optional             shift and go to state 252
    cases                          shift and go to state 253
    pattern                        shift and go to state 254
    match_variant                  shift and go to state 255
    match_as                       shift and go to state 256
    type_identifier                shift and go to state 257
    identifier                     shift and go to state 258

state 220

    (232) _46_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 232 (_46_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 232 (_46_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 232 (_46_NEWLINE_optional -> NEWLINE .)


state 221

    (222) if_expr -> IF expr THEN _43_0x3a_type_optional . block_statement _44_or_else_optional END
    (130) block_statement -> . _14_NEWLINE_optional _15_do_exprs_optional
    (131) _14_NEWLINE_optional -> . NEWLINE
    (132) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 195
    (               reduce using rule 132 (_14_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 132 (_14_NEWLINE_optional -> .)
    DEF             reduce using rule 132 (_14_NEWLINE_optional -> .)
    +               reduce using rule 132 (_14_NEWLINE_optional -> .)
    !               reduce using rule 132 (_14_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 132 (_14_NEWLINE_optional -> .)
    -               reduce using rule 132 (_14_NEWLINE_optional -> .)
    STRING          reduce using rule 132 (_14_NEWLINE_optional -> .)
    FLOAT           reduce using rule 132 (_14_NEWLINE_optional -> .)
    INT             reduce using rule 132 (_14_NEWLINE_optional -> .)
    [               reduce using rule 132 (_14_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 132 (_14_NEWLINE_optional -> .)
    CASE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    IF              reduce using rule 132 (_14_NEWLINE_optional -> .)
    DO              reduce using rule 132 (_14_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 132 (_14_NEWLINE_optional -> .)
    TYPE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    ENUM            reduce using rule 132 (_14_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 132 (_14_NEWLINE_optional -> .)
    ELIF            reduce using rule 132 (_14_NEWLINE_optional -> .)
    ELSE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    END             reduce using rule 132 (_14_NEWLINE_optional -> .)

    block_statement                shift and go to state 259
    _14_NEWLINE_optional           shift and go to state 194

state 222

    (223) _43_0x3a_type_optional -> : . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 260
    type_identifier                shift and go to state 197

state 223

    (127) do -> DO _13_0x3a_type_optional block_statement END .
    NEWLINE         reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    (               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    SOME_SUB        reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    SOME_CONCAT     reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARROW_BOTH      reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARROW_RIGHT     reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARROW_LEFT      reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    DOUBLE_ARROW_RIGHT reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    DOUBLE_ARROW_LEFT reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    BIT_SHIFT_RIGHT reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    BIT_SHIFT_LEFT  reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    BIT_AND         reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    BIT_OR          reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_POW       reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    POW             reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARRAY_SUB       reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARRAY_CONCAT    reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    MORE_OR_EQ      reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    LESS_OR_EQ      reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    TEXT_MATCH      reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    STRICT_AND      reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    AND             reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    STRICT_OR       reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    OR              reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    EQUAL           reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    NOT_EQUAL       reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    >               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_MUL       reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_DIV       reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_SUB       reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_SUM       reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    <               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    *               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    /               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    -               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    +               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    CONCAT          reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    $end            reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    )               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    INTERPOLATION_BOTH reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    INTERPOLATION_RIGHT reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    OF              reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    THEN            reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    END             reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ELIF            reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ELSE            reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ,               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    ]               reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    TYPE_IDENTIFIER reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)
    IDENTIFIER      reduce using rule 127 (do -> DO _13_0x3a_type_optional block_statement END .)


state 224

    (130) block_statement -> _14_NEWLINE_optional _15_do_exprs_optional .
    END             reduce using rule 130 (block_statement -> _14_NEWLINE_optional _15_do_exprs_optional .)
    ELIF            reduce using rule 130 (block_statement -> _14_NEWLINE_optional _15_do_exprs_optional .)
    ELSE            reduce using rule 130 (block_statement -> _14_NEWLINE_optional _15_do_exprs_optional .)


state 225

    (133) _15_do_exprs_optional -> do_exprs .
    END             reduce using rule 133 (_15_do_exprs_optional -> do_exprs .)
    ELIF            reduce using rule 133 (_15_do_exprs_optional -> do_exprs .)
    ELSE            reduce using rule 133 (_15_do_exprs_optional -> do_exprs .)


state 226

    (162) type -> type_identifier < . type _26_0x2c_type_repeat >
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 197
    type                           shift and go to state 261

state 227

    (170) enum -> TYPE type_identifier = _27_NEWLINE_optional . _28_type_variants_optional
    (173) _28_type_variants_optional -> . type_variants
    (174) _28_type_variants_optional -> .
    (200) type_variants -> . variant _37_NEWLINE_optional
    (203) type_variants -> . type_variants LINE variant _38_NEWLINE_optional
    (212) variant -> . type_identifier
    (213) variant -> . type_identifier ( type _41_0x2c_type_repeat )
    (283) type_identifier -> . TYPE_IDENTIFIER
    NEWLINE         reduce using rule 174 (_28_type_variants_optional -> .)
    (               reduce using rule 174 (_28_type_variants_optional -> .)
    SOME_SUB        reduce using rule 174 (_28_type_variants_optional -> .)
    SOME_CONCAT     reduce using rule 174 (_28_type_variants_optional -> .)
    ARROW_BOTH      reduce using rule 174 (_28_type_variants_optional -> .)
    ARROW_RIGHT     reduce using rule 174 (_28_type_variants_optional -> .)
    ARROW_LEFT      reduce using rule 174 (_28_type_variants_optional -> .)
    DOUBLE_ARROW_RIGHT reduce using rule 174 (_28_type_variants_optional -> .)
    DOUBLE_ARROW_LEFT reduce using rule 174 (_28_type_variants_optional -> .)
    BIT_SHIFT_RIGHT reduce using rule 174 (_28_type_variants_optional -> .)
    BIT_SHIFT_LEFT  reduce using rule 174 (_28_type_variants_optional -> .)
    BIT_AND         reduce using rule 174 (_28_type_variants_optional -> .)
    BIT_OR          reduce using rule 174 (_28_type_variants_optional -> .)
    FLOAT_POW       reduce using rule 174 (_28_type_variants_optional -> .)
    POW             reduce using rule 174 (_28_type_variants_optional -> .)
    ARRAY_SUB       reduce using rule 174 (_28_type_variants_optional -> .)
    ARRAY_CONCAT    reduce using rule 174 (_28_type_variants_optional -> .)
    MORE_OR_EQ      reduce using rule 174 (_28_type_variants_optional -> .)
    LESS_OR_EQ      reduce using rule 174 (_28_type_variants_optional -> .)
    TEXT_MATCH      reduce using rule 174 (_28_type_variants_optional -> .)
    STRICT_AND      reduce using rule 174 (_28_type_variants_optional -> .)
    AND             reduce using rule 174 (_28_type_variants_optional -> .)
    STRICT_OR       reduce using rule 174 (_28_type_variants_optional -> .)
    OR              reduce using rule 174 (_28_type_variants_optional -> .)
    EQUAL           reduce using rule 174 (_28_type_variants_optional -> .)
    NOT_EQUAL       reduce using rule 174 (_28_type_variants_optional -> .)
    >               reduce using rule 174 (_28_type_variants_optional -> .)
    FLOAT_MUL       reduce using rule 174 (_28_type_variants_optional -> .)
    FLOAT_DIV       reduce using rule 174 (_28_type_variants_optional -> .)
    FLOAT_SUB       reduce using rule 174 (_28_type_variants_optional -> .)
    FLOAT_SUM       reduce using rule 174 (_28_type_variants_optional -> .)
    <               reduce using rule 174 (_28_type_variants_optional -> .)
    *               reduce using rule 174 (_28_type_variants_optional -> .)
    /               reduce using rule 174 (_28_type_variants_optional -> .)
    -               reduce using rule 174 (_28_type_variants_optional -> .)
    +               reduce using rule 174 (_28_type_variants_optional -> .)
    CONCAT          reduce using rule 174 (_28_type_variants_optional -> .)
    $end            reduce using rule 174 (_28_type_variants_optional -> .)
    )               reduce using rule 174 (_28_type_variants_optional -> .)
    INTERPOLATION_BOTH reduce using rule 174 (_28_type_variants_optional -> .)
    INTERPOLATION_RIGHT reduce using rule 174 (_28_type_variants_optional -> .)
    OF              reduce using rule 174 (_28_type_variants_optional -> .)
    THEN            reduce using rule 174 (_28_type_variants_optional -> .)
    END             reduce using rule 174 (_28_type_variants_optional -> .)
    ELIF            reduce using rule 174 (_28_type_variants_optional -> .)
    ELSE            reduce using rule 174 (_28_type_variants_optional -> .)
    ,               reduce using rule 174 (_28_type_variants_optional -> .)
    ]               reduce using rule 174 (_28_type_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 262
    _28_type_variants_optional     shift and go to state 263
    type_variants                  shift and go to state 264
    variant                        shift and go to state 265

state 228

    (171) _27_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    NEWLINE         reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    SOME_SUB        reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    SOME_CONCAT     reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ARROW_BOTH      reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ARROW_RIGHT     reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ARROW_LEFT      reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    DOUBLE_ARROW_RIGHT reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    DOUBLE_ARROW_LEFT reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    BIT_SHIFT_RIGHT reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    BIT_SHIFT_LEFT  reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    BIT_AND         reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    BIT_OR          reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    FLOAT_POW       reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    POW             reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ARRAY_SUB       reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ARRAY_CONCAT    reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    MORE_OR_EQ      reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    LESS_OR_EQ      reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    TEXT_MATCH      reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    STRICT_AND      reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    AND             reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    STRICT_OR       reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    OR              reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    EQUAL           reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    NOT_EQUAL       reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    >               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    FLOAT_MUL       reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    FLOAT_DIV       reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    FLOAT_SUB       reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    FLOAT_SUM       reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    <               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    *               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    /               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    CONCAT          reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    $end            reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_BOTH reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_RIGHT reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    OF              reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    THEN            reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ,               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 171 (_27_NEWLINE_optional -> NEWLINE .)


state 229

    (175) enum -> TYPE type_identifier < type_identifier . _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (176) _29_0x2c_type_identifier_repeat -> . _29_0x2c_type_identifier_items
    (177) _29_0x2c_type_identifier_repeat -> .
    (178) _29_0x2c_type_identifier_items -> . _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item
    (179) _29_0x2c_type_identifier_items -> . _29_0x2c_type_identifier_item
    (180) _29_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 177 (_29_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 269

    _29_0x2c_type_identifier_repeat shift and go to state 266
    _29_0x2c_type_identifier_items shift and go to state 267
    _29_0x2c_type_identifier_item  shift and go to state 268

state 230

    (185) enum -> ENUM type_identifier { _32_NEWLINE_optional . _33_variants_optional }
    (188) _33_variants_optional -> . variants
    (189) _33_variants_optional -> .
    (206) variants -> . variant _39_NEWLINE_optional
    (209) variants -> . variants variant _40_NEWLINE_optional
    (212) variant -> . type_identifier
    (213) variant -> . type_identifier ( type _41_0x2c_type_repeat )
    (283) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 189 (_33_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 262
    _33_variants_optional          shift and go to state 270
    variants                       shift and go to state 271
    variant                        shift and go to state 272

state 231

    (186) _32_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 186 (_32_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 186 (_32_NEWLINE_optional -> NEWLINE .)


state 232

    (190) enum -> ENUM type_identifier < type_identifier . _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (191) _34_0x2c_type_identifier_repeat -> . _34_0x2c_type_identifier_items
    (192) _34_0x2c_type_identifier_repeat -> .
    (193) _34_0x2c_type_identifier_items -> . _34_0x2c_type_identifier_items _34_0x2c_type_identifier_item
    (194) _34_0x2c_type_identifier_items -> . _34_0x2c_type_identifier_item
    (195) _34_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 192 (_34_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 276

    _34_0x2c_type_identifier_repeat shift and go to state 273
    _34_0x2c_type_identifier_items shift and go to state 274
    _34_0x2c_type_identifier_item  shift and go to state 275

state 233

    (264) call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .
    NEWLINE         reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    (               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    SOME_SUB        reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    SOME_CONCAT     reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ARROW_BOTH      reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ARROW_RIGHT     reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ARROW_LEFT      reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    DOUBLE_ARROW_LEFT reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    BIT_SHIFT_RIGHT reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    BIT_SHIFT_LEFT  reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    BIT_AND         reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    BIT_OR          reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    FLOAT_POW       reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    POW             reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ARRAY_SUB       reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ARRAY_CONCAT    reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    MORE_OR_EQ      reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    LESS_OR_EQ      reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    TEXT_MATCH      reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    STRICT_AND      reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    AND             reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    STRICT_OR       reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    OR              reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    EQUAL           reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    >               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    FLOAT_MUL       reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    FLOAT_DIV       reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    FLOAT_SUB       reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    FLOAT_SUM       reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    <               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    *               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    /               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    -               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    +               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    CONCAT          reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    $end            reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    )               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    INTERPOLATION_BOTH reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    INTERPOLATION_RIGHT reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    OF              reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    THEN            reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    END             reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ELIF            reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ELSE            reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ,               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)
    ]               reduce using rule 264 (call -> expr ( _57_NEWLINE_optional _58_exprs_optional ) .)


state 234

    (284) let -> identifier : type_identifier < type . _64_0x2c_type_repeat MORE_OR_EQ expr
    (162) type -> type_identifier < type . _26_0x2c_type_repeat >
    (285) _64_0x2c_type_repeat -> . _64_0x2c_type_items
    (286) _64_0x2c_type_repeat -> .
    (163) _26_0x2c_type_repeat -> . _26_0x2c_type_items
    (164) _26_0x2c_type_repeat -> .
    (287) _64_0x2c_type_items -> . _64_0x2c_type_items _64_0x2c_type_item
    (288) _64_0x2c_type_items -> . _64_0x2c_type_item
    (165) _26_0x2c_type_items -> . _26_0x2c_type_items _26_0x2c_type_item
    (166) _26_0x2c_type_items -> . _26_0x2c_type_item
    (289) _64_0x2c_type_item -> . , type
    (167) _26_0x2c_type_item -> . , type
    MORE_OR_EQ      reduce using rule 286 (_64_0x2c_type_repeat -> .)
    >               reduce using rule 164 (_26_0x2c_type_repeat -> .)
    ,               shift and go to state 283

    _64_0x2c_type_repeat           shift and go to state 277
    _26_0x2c_type_repeat           shift and go to state 278
    _64_0x2c_type_items            shift and go to state 279
    _26_0x2c_type_items            shift and go to state 280
    _64_0x2c_type_item             shift and go to state 281
    _26_0x2c_type_item             shift and go to state 282

state 235

    (297) inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .
    NEWLINE         reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    (               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    SOME_SUB        reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    SOME_CONCAT     reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ARROW_BOTH      reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ARROW_RIGHT     reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ARROW_LEFT      reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    DOUBLE_ARROW_RIGHT reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    DOUBLE_ARROW_LEFT reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    BIT_SHIFT_RIGHT reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    BIT_SHIFT_LEFT  reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    BIT_AND         reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    BIT_OR          reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    FLOAT_POW       reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    POW             reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ARRAY_SUB       reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ARRAY_CONCAT    reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    MORE_OR_EQ      reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    LESS_OR_EQ      reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    TEXT_MATCH      reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    STRICT_AND      reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    AND             reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    STRICT_OR       reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    OR              reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    EQUAL           reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    NOT_EQUAL       reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    >               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    FLOAT_MUL       reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    FLOAT_DIV       reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    FLOAT_SUB       reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    FLOAT_SUM       reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    <               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    *               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    /               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    -               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    +               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    CONCAT          reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    $end            reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    )               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    INTERPOLATION_BOTH reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    INTERPOLATION_RIGHT reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    OF              reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    THEN            reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    END             reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ELIF            reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ELSE            reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ,               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)
    ]               reduce using rule 297 (inter_or_str -> INTERPOLATION_BOTH expr inter_or_str .)


state 236

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param . , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    ,               shift and go to state 284


state 237

    (219) param -> identifier . _42_0x3a_type_optional
    (220) _42_0x3a_type_optional -> . : type
    (221) _42_0x3a_type_optional -> .
    :               shift and go to state 286
    ,               reduce using rule 221 (_42_0x3a_type_optional -> .)
    NEWLINE         reduce using rule 221 (_42_0x3a_type_optional -> .)
    )               reduce using rule 221 (_42_0x3a_type_optional -> .)

    _42_0x3a_type_optional         shift and go to state 285

state 238

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat . > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    >               shift and go to state 287


state 239

    (118) _8_0x2c_type_identifier_item -> , . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 288

state 240

    (114) _8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items .
    (116) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items . _8_0x2c_type_identifier_item
    (118) _8_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 114 (_8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items .)
    ,               shift and go to state 239

    _8_0x2c_type_identifier_item   shift and go to state 289

state 241

    (117) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .
    ,               reduce using rule 117 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .)
    >               reduce using rule 117 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .)


state 242

    (135) def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional . ) _18_0x3a_type_optional do
    )               shift and go to state 290


state 243

    (138) _17_params_optional -> params .
    (157) params -> params . , _24_NEWLINE_optional param _25_NEWLINE_optional
    )               reduce using rule 138 (_17_params_optional -> params .)
    ,               shift and go to state 291


state 244

    (154) params -> param . _23_NEWLINE_optional
    (155) _23_NEWLINE_optional -> . NEWLINE
    (156) _23_NEWLINE_optional -> .
    NEWLINE         shift and go to state 293
    ,               reduce using rule 156 (_23_NEWLINE_optional -> .)
    )               reduce using rule 156 (_23_NEWLINE_optional -> .)

    _23_NEWLINE_optional           shift and go to state 292

state 245

    (142) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat . > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    >               shift and go to state 294


state 246

    (143) _19_0x2c_type_identifier_repeat -> _19_0x2c_type_identifier_items .
    (145) _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items . _19_0x2c_type_identifier_item
    (147) _19_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 143 (_19_0x2c_type_identifier_repeat -> _19_0x2c_type_identifier_items .)
    ,               shift and go to state 248

    _19_0x2c_type_identifier_item  shift and go to state 295

state 247

    (146) _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_item .
    ,               reduce using rule 146 (_19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_item .)
    >               reduce using rule 146 (_19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_item .)


state 248

    (147) _19_0x2c_type_identifier_item -> , . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 296

state 249

    (269) variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .
    NEWLINE         reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    (               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    SOME_SUB        reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    SOME_CONCAT     reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ARROW_BOTH      reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ARROW_RIGHT     reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ARROW_LEFT      reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    DOUBLE_ARROW_LEFT reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    BIT_SHIFT_RIGHT reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    BIT_SHIFT_LEFT  reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    BIT_AND         reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    BIT_OR          reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    FLOAT_POW       reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    POW             reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ARRAY_SUB       reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ARRAY_CONCAT    reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    MORE_OR_EQ      reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    LESS_OR_EQ      reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    TEXT_MATCH      reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    STRICT_AND      reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    AND             reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    STRICT_OR       reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    OR              reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    EQUAL           reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    >               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    FLOAT_MUL       reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    FLOAT_DIV       reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    FLOAT_SUB       reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    FLOAT_SUM       reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    <               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    *               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    /               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    -               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    +               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    CONCAT          reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    $end            reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    )               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    INTERPOLATION_BOTH reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    INTERPOLATION_RIGHT reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    OF              reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    THEN            reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    END             reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ELIF            reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ELSE            reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ,               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)
    ]               reduce using rule 269 (variant_call -> type_identifier ( _59_NEWLINE_optional _60_exprs_optional ) .)


state 250

    (277) exprs -> exprs , _62_NEWLINE_optional . expr _63_NEWLINE_optional
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 297
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 251

    (278) _62_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_LEFT reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    TYPE            reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 278 (_62_NEWLINE_optional -> NEWLINE .)


state 252

    (231) case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional . END
    END             shift and go to state 298


state 253

    (234) _47_cases_optional -> cases .
    (239) cases -> cases . pattern do _49_NEWLINE_optional
    (242) pattern -> . match_variant
    (243) pattern -> . match_as
    (245) match_variant -> . type_identifier
    (246) match_variant -> . type_identifier ( _50_NEWLINE_optional _51_patterns_optional )
    (244) match_as -> . identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    (282) identifier -> . IDENTIFIER
    END             reduce using rule 234 (_47_cases_optional -> cases .)
    TYPE_IDENTIFIER shift and go to state 44
    IDENTIFIER      shift and go to state 37

    pattern                        shift and go to state 299
    match_variant                  shift and go to state 255
    match_as                       shift and go to state 256
    type_identifier                shift and go to state 257
    identifier                     shift and go to state 258

state 254

    (236) cases -> pattern . do _48_NEWLINE_optional
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 40

    do                             shift and go to state 300

state 255

    (242) pattern -> match_variant .
    DO              reduce using rule 242 (pattern -> match_variant .)
    NEWLINE         reduce using rule 242 (pattern -> match_variant .)
    ,               reduce using rule 242 (pattern -> match_variant .)
    )               reduce using rule 242 (pattern -> match_variant .)


state 256

    (243) pattern -> match_as .
    DO              reduce using rule 243 (pattern -> match_as .)
    NEWLINE         reduce using rule 243 (pattern -> match_as .)
    ,               reduce using rule 243 (pattern -> match_as .)
    )               reduce using rule 243 (pattern -> match_as .)


state 257

    (245) match_variant -> type_identifier .
    (246) match_variant -> type_identifier . ( _50_NEWLINE_optional _51_patterns_optional )
    DO              reduce using rule 245 (match_variant -> type_identifier .)
    NEWLINE         reduce using rule 245 (match_variant -> type_identifier .)
    ,               reduce using rule 245 (match_variant -> type_identifier .)
    )               reduce using rule 245 (match_variant -> type_identifier .)
    (               shift and go to state 301


state 258

    (244) match_as -> identifier .
    DO              reduce using rule 244 (match_as -> identifier .)
    NEWLINE         reduce using rule 244 (match_as -> identifier .)
    ,               reduce using rule 244 (match_as -> identifier .)
    )               reduce using rule 244 (match_as -> identifier .)


state 259

    (222) if_expr -> IF expr THEN _43_0x3a_type_optional block_statement . _44_or_else_optional END
    (225) _44_or_else_optional -> . or_else
    (226) _44_or_else_optional -> .
    (227) or_else -> . ELIF expr THEN block_statement _45_or_else_optional
    (230) or_else -> . ELSE block_statement
    END             reduce using rule 226 (_44_or_else_optional -> .)
    ELIF            shift and go to state 304
    ELSE            shift and go to state 305

    _44_or_else_optional           shift and go to state 302
    or_else                        shift and go to state 303

state 260

    (223) _43_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    ELIF            reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    ELSE            reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    END             reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    (               reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    INTERPOLATION_LEFT reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    DEF             reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    +               reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    !               reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    STRICT_NOT      reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    -               reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    STRING          reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    FLOAT           reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    INT             reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    [               reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    CASE            reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    IF              reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    DO              reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    TYPE            reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 223 (_43_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 223 (_43_0x3a_type_optional -> : type .)


state 261

    (162) type -> type_identifier < type . _26_0x2c_type_repeat >
    (163) _26_0x2c_type_repeat -> . _26_0x2c_type_items
    (164) _26_0x2c_type_repeat -> .
    (165) _26_0x2c_type_items -> . _26_0x2c_type_items _26_0x2c_type_item
    (166) _26_0x2c_type_items -> . _26_0x2c_type_item
    (167) _26_0x2c_type_item -> . , type
    >               reduce using rule 164 (_26_0x2c_type_repeat -> .)
    ,               shift and go to state 306

    _26_0x2c_type_repeat           shift and go to state 278
    _26_0x2c_type_items            shift and go to state 280
    _26_0x2c_type_item             shift and go to state 282

state 262

    (212) variant -> type_identifier .
    (213) variant -> type_identifier . ( type _41_0x2c_type_repeat )
  ! shift/reduce conflict for ( resolved as shift
    NEWLINE         reduce using rule 212 (variant -> type_identifier .)
    LINE            reduce using rule 212 (variant -> type_identifier .)
    SOME_SUB        reduce using rule 212 (variant -> type_identifier .)
    SOME_CONCAT     reduce using rule 212 (variant -> type_identifier .)
    ARROW_BOTH      reduce using rule 212 (variant -> type_identifier .)
    ARROW_RIGHT     reduce using rule 212 (variant -> type_identifier .)
    ARROW_LEFT      reduce using rule 212 (variant -> type_identifier .)
    DOUBLE_ARROW_RIGHT reduce using rule 212 (variant -> type_identifier .)
    DOUBLE_ARROW_LEFT reduce using rule 212 (variant -> type_identifier .)
    BIT_SHIFT_RIGHT reduce using rule 212 (variant -> type_identifier .)
    BIT_SHIFT_LEFT  reduce using rule 212 (variant -> type_identifier .)
    BIT_AND         reduce using rule 212 (variant -> type_identifier .)
    BIT_OR          reduce using rule 212 (variant -> type_identifier .)
    FLOAT_POW       reduce using rule 212 (variant -> type_identifier .)
    POW             reduce using rule 212 (variant -> type_identifier .)
    ARRAY_SUB       reduce using rule 212 (variant -> type_identifier .)
    ARRAY_CONCAT    reduce using rule 212 (variant -> type_identifier .)
    MORE_OR_EQ      reduce using rule 212 (variant -> type_identifier .)
    LESS_OR_EQ      reduce using rule 212 (variant -> type_identifier .)
    TEXT_MATCH      reduce using rule 212 (variant -> type_identifier .)
    STRICT_AND      reduce using rule 212 (variant -> type_identifier .)
    AND             reduce using rule 212 (variant -> type_identifier .)
    STRICT_OR       reduce using rule 212 (variant -> type_identifier .)
    OR              reduce using rule 212 (variant -> type_identifier .)
    EQUAL           reduce using rule 212 (variant -> type_identifier .)
    NOT_EQUAL       reduce using rule 212 (variant -> type_identifier .)
    >               reduce using rule 212 (variant -> type_identifier .)
    FLOAT_MUL       reduce using rule 212 (variant -> type_identifier .)
    FLOAT_DIV       reduce using rule 212 (variant -> type_identifier .)
    FLOAT_SUB       reduce using rule 212 (variant -> type_identifier .)
    FLOAT_SUM       reduce using rule 212 (variant -> type_identifier .)
    <               reduce using rule 212 (variant -> type_identifier .)
    *               reduce using rule 212 (variant -> type_identifier .)
    /               reduce using rule 212 (variant -> type_identifier .)
    -               reduce using rule 212 (variant -> type_identifier .)
    +               reduce using rule 212 (variant -> type_identifier .)
    CONCAT          reduce using rule 212 (variant -> type_identifier .)
    $end            reduce using rule 212 (variant -> type_identifier .)
    )               reduce using rule 212 (variant -> type_identifier .)
    INTERPOLATION_BOTH reduce using rule 212 (variant -> type_identifier .)
    INTERPOLATION_RIGHT reduce using rule 212 (variant -> type_identifier .)
    OF              reduce using rule 212 (variant -> type_identifier .)
    THEN            reduce using rule 212 (variant -> type_identifier .)
    END             reduce using rule 212 (variant -> type_identifier .)
    ELIF            reduce using rule 212 (variant -> type_identifier .)
    ELSE            reduce using rule 212 (variant -> type_identifier .)
    ,               reduce using rule 212 (variant -> type_identifier .)
    ]               reduce using rule 212 (variant -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 212 (variant -> type_identifier .)
    }               reduce using rule 212 (variant -> type_identifier .)
    (               shift and go to state 307


state 263

    (170) enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .
    NEWLINE         reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    (               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    SOME_SUB        reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    SOME_CONCAT     reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ARROW_BOTH      reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ARROW_RIGHT     reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ARROW_LEFT      reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    DOUBLE_ARROW_RIGHT reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    DOUBLE_ARROW_LEFT reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    BIT_SHIFT_RIGHT reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    BIT_SHIFT_LEFT  reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    BIT_AND         reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    BIT_OR          reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    FLOAT_POW       reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    POW             reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ARRAY_SUB       reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ARRAY_CONCAT    reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    MORE_OR_EQ      reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    LESS_OR_EQ      reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    TEXT_MATCH      reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    STRICT_AND      reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    AND             reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    STRICT_OR       reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    OR              reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    EQUAL           reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    NOT_EQUAL       reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    >               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    FLOAT_MUL       reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    FLOAT_DIV       reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    FLOAT_SUB       reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    FLOAT_SUM       reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    <               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    *               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    /               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    -               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    +               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    CONCAT          reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    $end            reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    )               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    INTERPOLATION_BOTH reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    INTERPOLATION_RIGHT reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    OF              reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    THEN            reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    END             reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ELIF            reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ELSE            reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ,               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)
    ]               reduce using rule 170 (enum -> TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional .)


state 264

    (173) _28_type_variants_optional -> type_variants .
    (203) type_variants -> type_variants . LINE variant _38_NEWLINE_optional
    NEWLINE         reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    (               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    SOME_SUB        reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    SOME_CONCAT     reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ARROW_BOTH      reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ARROW_RIGHT     reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ARROW_LEFT      reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    DOUBLE_ARROW_RIGHT reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    DOUBLE_ARROW_LEFT reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    BIT_SHIFT_RIGHT reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    BIT_SHIFT_LEFT  reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    BIT_AND         reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    BIT_OR          reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    FLOAT_POW       reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    POW             reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ARRAY_SUB       reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ARRAY_CONCAT    reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    MORE_OR_EQ      reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    LESS_OR_EQ      reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    TEXT_MATCH      reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    STRICT_AND      reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    AND             reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    STRICT_OR       reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    OR              reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    EQUAL           reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    NOT_EQUAL       reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    >               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    FLOAT_MUL       reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    FLOAT_DIV       reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    FLOAT_SUB       reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    FLOAT_SUM       reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    <               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    *               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    /               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    -               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    +               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    CONCAT          reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    $end            reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    )               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    INTERPOLATION_BOTH reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    INTERPOLATION_RIGHT reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    OF              reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    THEN            reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    END             reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ELIF            reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ELSE            reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ,               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    ]               reduce using rule 173 (_28_type_variants_optional -> type_variants .)
    LINE            shift and go to state 308


state 265

    (200) type_variants -> variant . _37_NEWLINE_optional
    (201) _37_NEWLINE_optional -> . NEWLINE
    (202) _37_NEWLINE_optional -> .
  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 310
    LINE            reduce using rule 202 (_37_NEWLINE_optional -> .)
    (               reduce using rule 202 (_37_NEWLINE_optional -> .)
    SOME_SUB        reduce using rule 202 (_37_NEWLINE_optional -> .)
    SOME_CONCAT     reduce using rule 202 (_37_NEWLINE_optional -> .)
    ARROW_BOTH      reduce using rule 202 (_37_NEWLINE_optional -> .)
    ARROW_RIGHT     reduce using rule 202 (_37_NEWLINE_optional -> .)
    ARROW_LEFT      reduce using rule 202 (_37_NEWLINE_optional -> .)
    DOUBLE_ARROW_RIGHT reduce using rule 202 (_37_NEWLINE_optional -> .)
    DOUBLE_ARROW_LEFT reduce using rule 202 (_37_NEWLINE_optional -> .)
    BIT_SHIFT_RIGHT reduce using rule 202 (_37_NEWLINE_optional -> .)
    BIT_SHIFT_LEFT  reduce using rule 202 (_37_NEWLINE_optional -> .)
    BIT_AND         reduce using rule 202 (_37_NEWLINE_optional -> .)
    BIT_OR          reduce using rule 202 (_37_NEWLINE_optional -> .)
    FLOAT_POW       reduce using rule 202 (_37_NEWLINE_optional -> .)
    POW             reduce using rule 202 (_37_NEWLINE_optional -> .)
    ARRAY_SUB       reduce using rule 202 (_37_NEWLINE_optional -> .)
    ARRAY_CONCAT    reduce using rule 202 (_37_NEWLINE_optional -> .)
    MORE_OR_EQ      reduce using rule 202 (_37_NEWLINE_optional -> .)
    LESS_OR_EQ      reduce using rule 202 (_37_NEWLINE_optional -> .)
    TEXT_MATCH      reduce using rule 202 (_37_NEWLINE_optional -> .)
    STRICT_AND      reduce using rule 202 (_37_NEWLINE_optional -> .)
    AND             reduce using rule 202 (_37_NEWLINE_optional -> .)
    STRICT_OR       reduce using rule 202 (_37_NEWLINE_optional -> .)
    OR              reduce using rule 202 (_37_NEWLINE_optional -> .)
    EQUAL           reduce using rule 202 (_37_NEWLINE_optional -> .)
    NOT_EQUAL       reduce using rule 202 (_37_NEWLINE_optional -> .)
    >               reduce using rule 202 (_37_NEWLINE_optional -> .)
    FLOAT_MUL       reduce using rule 202 (_37_NEWLINE_optional -> .)
    FLOAT_DIV       reduce using rule 202 (_37_NEWLINE_optional -> .)
    FLOAT_SUB       reduce using rule 202 (_37_NEWLINE_optional -> .)
    FLOAT_SUM       reduce using rule 202 (_37_NEWLINE_optional -> .)
    <               reduce using rule 202 (_37_NEWLINE_optional -> .)
    *               reduce using rule 202 (_37_NEWLINE_optional -> .)
    /               reduce using rule 202 (_37_NEWLINE_optional -> .)
    -               reduce using rule 202 (_37_NEWLINE_optional -> .)
    +               reduce using rule 202 (_37_NEWLINE_optional -> .)
    CONCAT          reduce using rule 202 (_37_NEWLINE_optional -> .)
    $end            reduce using rule 202 (_37_NEWLINE_optional -> .)
    )               reduce using rule 202 (_37_NEWLINE_optional -> .)
    INTERPOLATION_BOTH reduce using rule 202 (_37_NEWLINE_optional -> .)
    INTERPOLATION_RIGHT reduce using rule 202 (_37_NEWLINE_optional -> .)
    OF              reduce using rule 202 (_37_NEWLINE_optional -> .)
    THEN            reduce using rule 202 (_37_NEWLINE_optional -> .)
    END             reduce using rule 202 (_37_NEWLINE_optional -> .)
    ELIF            reduce using rule 202 (_37_NEWLINE_optional -> .)
    ELSE            reduce using rule 202 (_37_NEWLINE_optional -> .)
    ,               reduce using rule 202 (_37_NEWLINE_optional -> .)
    ]               reduce using rule 202 (_37_NEWLINE_optional -> .)
    }               reduce using rule 202 (_37_NEWLINE_optional -> .)

    _37_NEWLINE_optional           shift and go to state 309

state 266

    (175) enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat . > = _30_NEWLINE_optional _31_type_variants_optional }
    >               shift and go to state 311


state 267

    (176) _29_0x2c_type_identifier_repeat -> _29_0x2c_type_identifier_items .
    (178) _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items . _29_0x2c_type_identifier_item
    (180) _29_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 176 (_29_0x2c_type_identifier_repeat -> _29_0x2c_type_identifier_items .)
    ,               shift and go to state 269

    _29_0x2c_type_identifier_item  shift and go to state 312

state 268

    (179) _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_item .
    ,               reduce using rule 179 (_29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_item .)
    >               reduce using rule 179 (_29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_item .)


state 269

    (180) _29_0x2c_type_identifier_item -> , . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 313

state 270

    (185) enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional . }
    }               shift and go to state 314


state 271

    (188) _33_variants_optional -> variants .
    (209) variants -> variants . variant _40_NEWLINE_optional
    (212) variant -> . type_identifier
    (213) variant -> . type_identifier ( type _41_0x2c_type_repeat )
    (283) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 188 (_33_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 44

    variant                        shift and go to state 315
    type_identifier                shift and go to state 262

state 272

    (206) variants -> variant . _39_NEWLINE_optional
    (207) _39_NEWLINE_optional -> . NEWLINE
    (208) _39_NEWLINE_optional -> .
    NEWLINE         shift and go to state 317
    TYPE_IDENTIFIER reduce using rule 208 (_39_NEWLINE_optional -> .)
    }               reduce using rule 208 (_39_NEWLINE_optional -> .)

    _39_NEWLINE_optional           shift and go to state 316

state 273

    (190) enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat . > { _35_NEWLINE_optional _36_variants_optional }
    >               shift and go to state 318


state 274

    (191) _34_0x2c_type_identifier_repeat -> _34_0x2c_type_identifier_items .
    (193) _34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_items . _34_0x2c_type_identifier_item
    (195) _34_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 191 (_34_0x2c_type_identifier_repeat -> _34_0x2c_type_identifier_items .)
    ,               shift and go to state 276

    _34_0x2c_type_identifier_item  shift and go to state 319

state 275

    (194) _34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_item .
    ,               reduce using rule 194 (_34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_item .)
    >               reduce using rule 194 (_34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_item .)


state 276

    (195) _34_0x2c_type_identifier_item -> , . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 320

state 277

    (284) let -> identifier : type_identifier < type _64_0x2c_type_repeat . MORE_OR_EQ expr
    MORE_OR_EQ      shift and go to state 321


state 278

    (162) type -> type_identifier < type _26_0x2c_type_repeat . >
    >               shift and go to state 322


state 279

    (285) _64_0x2c_type_repeat -> _64_0x2c_type_items .
    (287) _64_0x2c_type_items -> _64_0x2c_type_items . _64_0x2c_type_item
    (289) _64_0x2c_type_item -> . , type
    MORE_OR_EQ      reduce using rule 285 (_64_0x2c_type_repeat -> _64_0x2c_type_items .)
    ,               shift and go to state 324

    _64_0x2c_type_item             shift and go to state 323

state 280

    (163) _26_0x2c_type_repeat -> _26_0x2c_type_items .
    (165) _26_0x2c_type_items -> _26_0x2c_type_items . _26_0x2c_type_item
    (167) _26_0x2c_type_item -> . , type
    >               reduce using rule 163 (_26_0x2c_type_repeat -> _26_0x2c_type_items .)
    ,               shift and go to state 306

    _26_0x2c_type_item             shift and go to state 325

state 281

    (288) _64_0x2c_type_items -> _64_0x2c_type_item .
    ,               reduce using rule 288 (_64_0x2c_type_items -> _64_0x2c_type_item .)
    MORE_OR_EQ      reduce using rule 288 (_64_0x2c_type_items -> _64_0x2c_type_item .)


state 282

    (166) _26_0x2c_type_items -> _26_0x2c_type_item .
    ,               reduce using rule 166 (_26_0x2c_type_items -> _26_0x2c_type_item .)
    >               reduce using rule 166 (_26_0x2c_type_items -> _26_0x2c_type_item .)


state 283

    (289) _64_0x2c_type_item -> , . type
    (167) _26_0x2c_type_item -> , . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 326
    type_identifier                shift and go to state 197

state 284

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , . _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (107) _5_NEWLINE_optional -> . NEWLINE
    (108) _5_NEWLINE_optional -> .
    NEWLINE         shift and go to state 328
    IDENTIFIER      reduce using rule 108 (_5_NEWLINE_optional -> .)

    _5_NEWLINE_optional            shift and go to state 327

state 285

    (219) param -> identifier _42_0x3a_type_optional .
    ,               reduce using rule 219 (param -> identifier _42_0x3a_type_optional .)
    NEWLINE         reduce using rule 219 (param -> identifier _42_0x3a_type_optional .)
    )               reduce using rule 219 (param -> identifier _42_0x3a_type_optional .)


state 286

    (220) _42_0x3a_type_optional -> : . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 329
    type_identifier                shift and go to state 197

state 287

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > . ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (               shift and go to state 330


state 288

    (118) _8_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 118 (_8_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 118 (_8_0x2c_type_identifier_item -> , type_identifier .)


state 289

    (116) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .
    ,               reduce using rule 116 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .)
    >               reduce using rule 116 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .)


state 290

    (135) def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) . _18_0x3a_type_optional do
    (140) _18_0x3a_type_optional -> . : type
    (141) _18_0x3a_type_optional -> .
    :               shift and go to state 332
    DO              reduce using rule 141 (_18_0x3a_type_optional -> .)

    _18_0x3a_type_optional         shift and go to state 331

state 291

    (157) params -> params , . _24_NEWLINE_optional param _25_NEWLINE_optional
    (158) _24_NEWLINE_optional -> . NEWLINE
    (159) _24_NEWLINE_optional -> .
    NEWLINE         shift and go to state 334
    IDENTIFIER      reduce using rule 159 (_24_NEWLINE_optional -> .)

    _24_NEWLINE_optional           shift and go to state 333

state 292

    (154) params -> param _23_NEWLINE_optional .
    ,               reduce using rule 154 (params -> param _23_NEWLINE_optional .)
    )               reduce using rule 154 (params -> param _23_NEWLINE_optional .)


state 293

    (155) _23_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 155 (_23_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 155 (_23_NEWLINE_optional -> NEWLINE .)


state 294

    (142) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > . ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (               shift and go to state 335


state 295

    (145) _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item .
    ,               reduce using rule 145 (_19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item .)
    >               reduce using rule 145 (_19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item .)


state 296

    (147) _19_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 147 (_19_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 147 (_19_0x2c_type_identifier_item -> , type_identifier .)


state 297

    (277) exprs -> exprs , _62_NEWLINE_optional expr . _63_NEWLINE_optional
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    (280) _63_NEWLINE_optional -> . NEWLINE
    (281) _63_NEWLINE_optional -> .
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82
    NEWLINE         shift and go to state 337
    ,               reduce using rule 281 (_63_NEWLINE_optional -> .)
    ]               reduce using rule 281 (_63_NEWLINE_optional -> .)
    )               reduce using rule 281 (_63_NEWLINE_optional -> .)

    _63_NEWLINE_optional           shift and go to state 336

state 298

    (231) case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .
    NEWLINE         reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    (               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    SOME_SUB        reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    SOME_CONCAT     reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ARROW_BOTH      reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ARROW_RIGHT     reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ARROW_LEFT      reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    DOUBLE_ARROW_RIGHT reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    DOUBLE_ARROW_LEFT reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    BIT_SHIFT_RIGHT reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    BIT_SHIFT_LEFT  reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    BIT_AND         reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    BIT_OR          reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    FLOAT_POW       reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    POW             reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ARRAY_SUB       reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ARRAY_CONCAT    reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    MORE_OR_EQ      reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    LESS_OR_EQ      reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    TEXT_MATCH      reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    STRICT_AND      reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    AND             reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    STRICT_OR       reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    OR              reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    EQUAL           reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    NOT_EQUAL       reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    >               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    FLOAT_MUL       reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    FLOAT_DIV       reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    FLOAT_SUB       reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    FLOAT_SUM       reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    <               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    *               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    /               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    -               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    +               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    CONCAT          reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    $end            reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    )               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    INTERPOLATION_BOTH reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    INTERPOLATION_RIGHT reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    OF              reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    THEN            reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    END             reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ELIF            reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ELSE            reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ,               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)
    ]               reduce using rule 231 (case_of -> CASE expr OF _46_NEWLINE_optional _47_cases_optional END .)


state 299

    (239) cases -> cases pattern . do _49_NEWLINE_optional
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 40

    do                             shift and go to state 338

state 300

    (236) cases -> pattern do . _48_NEWLINE_optional
    (237) _48_NEWLINE_optional -> . NEWLINE
    (238) _48_NEWLINE_optional -> .
    NEWLINE         shift and go to state 340
    TYPE_IDENTIFIER reduce using rule 238 (_48_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 238 (_48_NEWLINE_optional -> .)
    END             reduce using rule 238 (_48_NEWLINE_optional -> .)

    _48_NEWLINE_optional           shift and go to state 339

state 301

    (246) match_variant -> type_identifier ( . _50_NEWLINE_optional _51_patterns_optional )
    (247) _50_NEWLINE_optional -> . NEWLINE
    (248) _50_NEWLINE_optional -> .
    NEWLINE         shift and go to state 342
    TYPE_IDENTIFIER reduce using rule 248 (_50_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 248 (_50_NEWLINE_optional -> .)
    )               reduce using rule 248 (_50_NEWLINE_optional -> .)

    _50_NEWLINE_optional           shift and go to state 341

state 302

    (222) if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional . END
    END             shift and go to state 343


state 303

    (225) _44_or_else_optional -> or_else .
    END             reduce using rule 225 (_44_or_else_optional -> or_else .)


state 304

    (227) or_else -> ELIF . expr THEN block_statement _45_or_else_optional
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    expr                           shift and go to state 344
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    identifier                     shift and go to state 16
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25
    type_identifier                shift and go to state 28

state 305

    (230) or_else -> ELSE . block_statement
    (130) block_statement -> . _14_NEWLINE_optional _15_do_exprs_optional
    (131) _14_NEWLINE_optional -> . NEWLINE
    (132) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 195
    (               reduce using rule 132 (_14_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 132 (_14_NEWLINE_optional -> .)
    DEF             reduce using rule 132 (_14_NEWLINE_optional -> .)
    +               reduce using rule 132 (_14_NEWLINE_optional -> .)
    !               reduce using rule 132 (_14_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 132 (_14_NEWLINE_optional -> .)
    -               reduce using rule 132 (_14_NEWLINE_optional -> .)
    STRING          reduce using rule 132 (_14_NEWLINE_optional -> .)
    FLOAT           reduce using rule 132 (_14_NEWLINE_optional -> .)
    INT             reduce using rule 132 (_14_NEWLINE_optional -> .)
    [               reduce using rule 132 (_14_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 132 (_14_NEWLINE_optional -> .)
    CASE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    IF              reduce using rule 132 (_14_NEWLINE_optional -> .)
    DO              reduce using rule 132 (_14_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 132 (_14_NEWLINE_optional -> .)
    TYPE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    ENUM            reduce using rule 132 (_14_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 132 (_14_NEWLINE_optional -> .)
    END             reduce using rule 132 (_14_NEWLINE_optional -> .)

    block_statement                shift and go to state 345
    _14_NEWLINE_optional           shift and go to state 194

state 306

    (167) _26_0x2c_type_item -> , . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 346
    type_identifier                shift and go to state 197

state 307

    (213) variant -> type_identifier ( . type _41_0x2c_type_repeat )
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 197
    type                           shift and go to state 347

state 308

    (203) type_variants -> type_variants LINE . variant _38_NEWLINE_optional
    (212) variant -> . type_identifier
    (213) variant -> . type_identifier ( type _41_0x2c_type_repeat )
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    variant                        shift and go to state 348
    type_identifier                shift and go to state 262

state 309

    (200) type_variants -> variant _37_NEWLINE_optional .
    LINE            reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    NEWLINE         reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    (               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    SOME_SUB        reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    SOME_CONCAT     reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ARROW_BOTH      reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ARROW_RIGHT     reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ARROW_LEFT      reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    DOUBLE_ARROW_RIGHT reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    DOUBLE_ARROW_LEFT reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    BIT_SHIFT_RIGHT reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    BIT_SHIFT_LEFT  reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    BIT_AND         reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    BIT_OR          reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    FLOAT_POW       reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    POW             reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ARRAY_SUB       reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ARRAY_CONCAT    reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    MORE_OR_EQ      reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    LESS_OR_EQ      reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    TEXT_MATCH      reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    STRICT_AND      reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    AND             reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    STRICT_OR       reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    OR              reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    EQUAL           reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    NOT_EQUAL       reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    >               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    FLOAT_MUL       reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    FLOAT_DIV       reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    FLOAT_SUB       reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    FLOAT_SUM       reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    <               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    *               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    /               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    -               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    +               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    CONCAT          reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    $end            reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    )               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    INTERPOLATION_BOTH reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    INTERPOLATION_RIGHT reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    OF              reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    THEN            reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    END             reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ELIF            reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ELSE            reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ,               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    ]               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)
    }               reduce using rule 200 (type_variants -> variant _37_NEWLINE_optional .)


state 310

    (201) _37_NEWLINE_optional -> NEWLINE .
    LINE            reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    NEWLINE         reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    SOME_SUB        reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    SOME_CONCAT     reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ARROW_BOTH      reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ARROW_RIGHT     reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ARROW_LEFT      reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    DOUBLE_ARROW_RIGHT reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    DOUBLE_ARROW_LEFT reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    BIT_SHIFT_RIGHT reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    BIT_SHIFT_LEFT  reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    BIT_AND         reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    BIT_OR          reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    FLOAT_POW       reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    POW             reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ARRAY_SUB       reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ARRAY_CONCAT    reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    MORE_OR_EQ      reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    LESS_OR_EQ      reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    TEXT_MATCH      reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    STRICT_AND      reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    AND             reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    STRICT_OR       reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    OR              reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    EQUAL           reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    NOT_EQUAL       reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    >               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    FLOAT_MUL       reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    FLOAT_DIV       reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    FLOAT_SUB       reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    FLOAT_SUM       reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    <               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    *               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    /               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    CONCAT          reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    $end            reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_BOTH reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_RIGHT reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    OF              reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    THEN            reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ,               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 201 (_37_NEWLINE_optional -> NEWLINE .)


state 311

    (175) enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > . = _30_NEWLINE_optional _31_type_variants_optional }
    =               shift and go to state 349


state 312

    (178) _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item .
    ,               reduce using rule 178 (_29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item .)
    >               reduce using rule 178 (_29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item .)


state 313

    (180) _29_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 180 (_29_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 180 (_29_0x2c_type_identifier_item -> , type_identifier .)


state 314

    (185) enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .
    NEWLINE         reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    (               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    SOME_SUB        reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    SOME_CONCAT     reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ARROW_BOTH      reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ARROW_RIGHT     reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ARROW_LEFT      reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    DOUBLE_ARROW_RIGHT reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    DOUBLE_ARROW_LEFT reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    BIT_SHIFT_RIGHT reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    BIT_SHIFT_LEFT  reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    BIT_AND         reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    BIT_OR          reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    FLOAT_POW       reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    POW             reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ARRAY_SUB       reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ARRAY_CONCAT    reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    MORE_OR_EQ      reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    LESS_OR_EQ      reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    TEXT_MATCH      reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    STRICT_AND      reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    AND             reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    STRICT_OR       reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    OR              reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    EQUAL           reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    NOT_EQUAL       reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    >               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    FLOAT_MUL       reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    FLOAT_DIV       reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    FLOAT_SUB       reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    FLOAT_SUM       reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    <               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    *               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    /               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    -               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    +               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    CONCAT          reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    $end            reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    )               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    INTERPOLATION_BOTH reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    INTERPOLATION_RIGHT reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    OF              reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    THEN            reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    END             reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ELIF            reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ELSE            reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ,               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)
    ]               reduce using rule 185 (enum -> ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional } .)


state 315

    (209) variants -> variants variant . _40_NEWLINE_optional
    (210) _40_NEWLINE_optional -> . NEWLINE
    (211) _40_NEWLINE_optional -> .
    NEWLINE         shift and go to state 351
    TYPE_IDENTIFIER reduce using rule 211 (_40_NEWLINE_optional -> .)
    }               reduce using rule 211 (_40_NEWLINE_optional -> .)

    _40_NEWLINE_optional           shift and go to state 350

state 316

    (206) variants -> variant _39_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 206 (variants -> variant _39_NEWLINE_optional .)
    }               reduce using rule 206 (variants -> variant _39_NEWLINE_optional .)


state 317

    (207) _39_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 207 (_39_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 207 (_39_NEWLINE_optional -> NEWLINE .)


state 318

    (190) enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > . { _35_NEWLINE_optional _36_variants_optional }
    {               shift and go to state 352


state 319

    (193) _34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_items _34_0x2c_type_identifier_item .
    ,               reduce using rule 193 (_34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_items _34_0x2c_type_identifier_item .)
    >               reduce using rule 193 (_34_0x2c_type_identifier_items -> _34_0x2c_type_identifier_items _34_0x2c_type_identifier_item .)


state 320

    (195) _34_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 195 (_34_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 195 (_34_0x2c_type_identifier_item -> , type_identifier .)


state 321

    (284) let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . str_inter
    (12) expr -> . binary_op_def
    (13) expr -> . unary_expr
    (14) expr -> . str_literal
    (15) expr -> . float_literal
    (16) expr -> . int_literal
    (17) expr -> . array
    (18) expr -> . variant_call
    (19) expr -> . identifier
    (20) expr -> . let
    (21) expr -> . call
    (22) expr -> . case_of
    (23) expr -> . binary_expr
    (24) expr -> . if_expr
    (25) expr -> . def_expr
    (26) expr -> . do
    (27) expr -> . external
    (28) expr -> . enum
    (296) str_inter -> . INTERPOLATION_LEFT expr inter_or_str
    (104) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (113) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (29) unary_expr -> . + expr
    (30) unary_expr -> . ! expr
    (31) unary_expr -> . STRICT_NOT expr
    (32) unary_expr -> . - expr
    (295) str_literal -> . STRING
    (294) float_literal -> . FLOAT
    (293) int_literal -> . INT
    (259) array -> . [ _55_NEWLINE_optional _56_exprs_optional ]
    (269) variant_call -> . type_identifier ( _59_NEWLINE_optional _60_exprs_optional )
    (282) identifier -> . IDENTIFIER
    (284) let -> . identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr
    (290) let -> . identifier _65_0x3a_type_optional = expr
    (264) call -> . expr ( _57_NEWLINE_optional _58_exprs_optional )
    (231) case_of -> . CASE expr OF _46_NEWLINE_optional _47_cases_optional END
    (34) binary_expr -> . expr SOME_SUB expr
    (35) binary_expr -> . expr SOME_CONCAT expr
    (36) binary_expr -> . expr ARROW_BOTH expr
    (37) binary_expr -> . expr ARROW_RIGHT expr
    (38) binary_expr -> . expr ARROW_LEFT expr
    (39) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> . expr BIT_SHIFT_RIGHT expr
    (42) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (43) binary_expr -> . expr BIT_AND expr
    (44) binary_expr -> . expr BIT_OR expr
    (45) binary_expr -> . expr FLOAT_POW expr
    (46) binary_expr -> . expr POW expr
    (47) binary_expr -> . expr ARRAY_SUB expr
    (48) binary_expr -> . expr ARRAY_CONCAT expr
    (49) binary_expr -> . expr MORE_OR_EQ expr
    (50) binary_expr -> . expr LESS_OR_EQ expr
    (51) binary_expr -> . expr TEXT_MATCH expr
    (52) binary_expr -> . expr STRICT_AND expr
    (53) binary_expr -> . expr AND expr
    (54) binary_expr -> . expr STRICT_OR expr
    (55) binary_expr -> . expr OR expr
    (56) binary_expr -> . expr EQUAL expr
    (57) binary_expr -> . expr NOT_EQUAL expr
    (58) binary_expr -> . expr > expr
    (59) binary_expr -> . expr FLOAT_MUL expr
    (60) binary_expr -> . expr FLOAT_DIV expr
    (61) binary_expr -> . expr FLOAT_SUB expr
    (62) binary_expr -> . expr FLOAT_SUM expr
    (63) binary_expr -> . expr < expr
    (64) binary_expr -> . expr * expr
    (65) binary_expr -> . expr / expr
    (66) binary_expr -> . expr - expr
    (67) binary_expr -> . expr + expr
    (68) binary_expr -> . expr CONCAT expr
    (222) if_expr -> . IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END
    (135) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (142) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    (33) external -> . EXTERNAL
    (169) enum -> . TYPE type_identifier
    (170) enum -> . TYPE type_identifier = _27_NEWLINE_optional _28_type_variants_optional
    (175) enum -> . TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
    (185) enum -> . ENUM type_identifier { _32_NEWLINE_optional _33_variants_optional }
    (190) enum -> . ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional }
    (283) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    INTERPOLATION_LEFT shift and go to state 26
    DEF             shift and go to state 27
    +               shift and go to state 29
    !               shift and go to state 30
    STRICT_NOT      shift and go to state 31
    -               shift and go to state 32
    STRING          shift and go to state 33
    FLOAT           shift and go to state 34
    INT             shift and go to state 35
    [               shift and go to state 36
    IDENTIFIER      shift and go to state 37
    CASE            shift and go to state 38
    IF              shift and go to state 39
    DO              shift and go to state 40
    EXTERNAL        shift and go to state 41
    TYPE            shift and go to state 42
    ENUM            shift and go to state 43
    TYPE_IDENTIFIER shift and go to state 44

    identifier                     shift and go to state 16
    type_identifier                shift and go to state 28
    expr                           shift and go to state 353
    str_inter                      shift and go to state 8
    binary_op_def                  shift and go to state 9
    unary_expr                     shift and go to state 10
    str_literal                    shift and go to state 11
    float_literal                  shift and go to state 12
    int_literal                    shift and go to state 13
    array                          shift and go to state 14
    variant_call                   shift and go to state 15
    let                            shift and go to state 17
    call                           shift and go to state 18
    case_of                        shift and go to state 19
    binary_expr                    shift and go to state 20
    if_expr                        shift and go to state 21
    def_expr                       shift and go to state 22
    do                             shift and go to state 23
    external                       shift and go to state 24
    enum                           shift and go to state 25

state 322

    (162) type -> type_identifier < type _26_0x2c_type_repeat > .
    =               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    NEWLINE         reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    END             reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    (               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    INTERPOLATION_LEFT reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    DEF             reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    +               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    !               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    STRICT_NOT      reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    -               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    STRING          reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    FLOAT           reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    INT             reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    [               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    IDENTIFIER      reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    CASE            reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    IF              reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    DO              reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    EXTERNAL        reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    TYPE            reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    ENUM            reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    TYPE_IDENTIFIER reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    ,               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    MORE_OR_EQ      reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    >               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    ELIF            reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    ELSE            reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    )               reduce using rule 162 (type -> type_identifier < type _26_0x2c_type_repeat > .)


state 323

    (287) _64_0x2c_type_items -> _64_0x2c_type_items _64_0x2c_type_item .
    ,               reduce using rule 287 (_64_0x2c_type_items -> _64_0x2c_type_items _64_0x2c_type_item .)
    MORE_OR_EQ      reduce using rule 287 (_64_0x2c_type_items -> _64_0x2c_type_items _64_0x2c_type_item .)


state 324

    (289) _64_0x2c_type_item -> , . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 354
    type_identifier                shift and go to state 197

state 325

    (165) _26_0x2c_type_items -> _26_0x2c_type_items _26_0x2c_type_item .
    ,               reduce using rule 165 (_26_0x2c_type_items -> _26_0x2c_type_items _26_0x2c_type_item .)
    >               reduce using rule 165 (_26_0x2c_type_items -> _26_0x2c_type_items _26_0x2c_type_item .)


state 326

    (289) _64_0x2c_type_item -> , type .
    (167) _26_0x2c_type_item -> , type .
  ! reduce/reduce conflict for , resolved using rule 289 (_64_0x2c_type_item -> , type .)
    ,               reduce using rule 289 (_64_0x2c_type_item -> , type .)
    MORE_OR_EQ      reduce using rule 289 (_64_0x2c_type_item -> , type .)
    >               reduce using rule 167 (_26_0x2c_type_item -> , type .)


state 327

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional . param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (219) param -> . identifier _42_0x3a_type_optional
    (282) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 37

    param                          shift and go to state 355
    identifier                     shift and go to state 237

state 328

    (107) _5_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 107 (_5_NEWLINE_optional -> NEWLINE .)


state 329

    (220) _42_0x3a_type_optional -> : type .
    ,               reduce using rule 220 (_42_0x3a_type_optional -> : type .)
    NEWLINE         reduce using rule 220 (_42_0x3a_type_optional -> : type .)
    )               reduce using rule 220 (_42_0x3a_type_optional -> : type .)


state 330

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( . _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (119) _9_NEWLINE_optional -> . NEWLINE
    (120) _9_NEWLINE_optional -> .
    NEWLINE         shift and go to state 357
    IDENTIFIER      reduce using rule 120 (_9_NEWLINE_optional -> .)

    _9_NEWLINE_optional            shift and go to state 356

state 331

    (135) def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional . do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 40

    do                             shift and go to state 358

state 332

    (140) _18_0x3a_type_optional -> : . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 359
    type_identifier                shift and go to state 197

state 333

    (157) params -> params , _24_NEWLINE_optional . param _25_NEWLINE_optional
    (219) param -> . identifier _42_0x3a_type_optional
    (282) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 37

    param                          shift and go to state 360
    identifier                     shift and go to state 237

state 334

    (158) _24_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 158 (_24_NEWLINE_optional -> NEWLINE .)


state 335

    (142) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( . _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (148) _20_NEWLINE_optional -> . NEWLINE
    (149) _20_NEWLINE_optional -> .
    NEWLINE         shift and go to state 362
    IDENTIFIER      reduce using rule 149 (_20_NEWLINE_optional -> .)
    )               reduce using rule 149 (_20_NEWLINE_optional -> .)

    _20_NEWLINE_optional           shift and go to state 361

state 336

    (277) exprs -> exprs , _62_NEWLINE_optional expr _63_NEWLINE_optional .
    ,               reduce using rule 277 (exprs -> exprs , _62_NEWLINE_optional expr _63_NEWLINE_optional .)
    ]               reduce using rule 277 (exprs -> exprs , _62_NEWLINE_optional expr _63_NEWLINE_optional .)
    )               reduce using rule 277 (exprs -> exprs , _62_NEWLINE_optional expr _63_NEWLINE_optional .)


state 337

    (280) _63_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 280 (_63_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 280 (_63_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 280 (_63_NEWLINE_optional -> NEWLINE .)


state 338

    (239) cases -> cases pattern do . _49_NEWLINE_optional
    (240) _49_NEWLINE_optional -> . NEWLINE
    (241) _49_NEWLINE_optional -> .
    NEWLINE         shift and go to state 364
    TYPE_IDENTIFIER reduce using rule 241 (_49_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 241 (_49_NEWLINE_optional -> .)
    END             reduce using rule 241 (_49_NEWLINE_optional -> .)

    _49_NEWLINE_optional           shift and go to state 363

state 339

    (236) cases -> pattern do _48_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 236 (cases -> pattern do _48_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 236 (cases -> pattern do _48_NEWLINE_optional .)
    END             reduce using rule 236 (cases -> pattern do _48_NEWLINE_optional .)


state 340

    (237) _48_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 237 (_48_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 237 (_48_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 237 (_48_NEWLINE_optional -> NEWLINE .)


state 341

    (246) match_variant -> type_identifier ( _50_NEWLINE_optional . _51_patterns_optional )
    (249) _51_patterns_optional -> . patterns
    (250) _51_patterns_optional -> .
    (251) patterns -> . pattern _52_NEWLINE_optional
    (254) patterns -> . patterns , _53_NEWLINE_optional pattern _54_NEWLINE_optional
    (242) pattern -> . match_variant
    (243) pattern -> . match_as
    (245) match_variant -> . type_identifier
    (246) match_variant -> . type_identifier ( _50_NEWLINE_optional _51_patterns_optional )
    (244) match_as -> . identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    (282) identifier -> . IDENTIFIER
    )               reduce using rule 250 (_51_patterns_optional -> .)
    TYPE_IDENTIFIER shift and go to state 44
    IDENTIFIER      shift and go to state 37

    type_identifier                shift and go to state 257
    _51_patterns_optional          shift and go to state 365
    patterns                       shift and go to state 366
    pattern                        shift and go to state 367
    match_variant                  shift and go to state 255
    match_as                       shift and go to state 256
    identifier                     shift and go to state 258

state 342

    (247) _50_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 247 (_50_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 247 (_50_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 247 (_50_NEWLINE_optional -> NEWLINE .)


state 343

    (222) if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .
    NEWLINE         reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    (               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    SOME_SUB        reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    SOME_CONCAT     reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ARROW_BOTH      reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ARROW_RIGHT     reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ARROW_LEFT      reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    DOUBLE_ARROW_RIGHT reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    DOUBLE_ARROW_LEFT reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    BIT_SHIFT_RIGHT reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    BIT_SHIFT_LEFT  reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    BIT_AND         reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    BIT_OR          reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    FLOAT_POW       reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    POW             reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ARRAY_SUB       reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ARRAY_CONCAT    reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    MORE_OR_EQ      reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    LESS_OR_EQ      reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    TEXT_MATCH      reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    STRICT_AND      reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    AND             reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    STRICT_OR       reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    OR              reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    EQUAL           reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    NOT_EQUAL       reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    >               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    FLOAT_MUL       reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    FLOAT_DIV       reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    FLOAT_SUB       reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    FLOAT_SUM       reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    <               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    *               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    /               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    -               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    +               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    CONCAT          reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    $end            reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    )               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    INTERPOLATION_BOTH reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    INTERPOLATION_RIGHT reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    OF              reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    THEN            reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    END             reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ELIF            reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ELSE            reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ,               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)
    ]               reduce using rule 222 (if_expr -> IF expr THEN _43_0x3a_type_optional block_statement _44_or_else_optional END .)


state 344

    (227) or_else -> ELIF expr . THEN block_statement _45_or_else_optional
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 368
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 345

    (230) or_else -> ELSE block_statement .
    END             reduce using rule 230 (or_else -> ELSE block_statement .)


state 346

    (167) _26_0x2c_type_item -> , type .
    ,               reduce using rule 167 (_26_0x2c_type_item -> , type .)
    >               reduce using rule 167 (_26_0x2c_type_item -> , type .)


state 347

    (213) variant -> type_identifier ( type . _41_0x2c_type_repeat )
    (214) _41_0x2c_type_repeat -> . _41_0x2c_type_items
    (215) _41_0x2c_type_repeat -> .
    (216) _41_0x2c_type_items -> . _41_0x2c_type_items _41_0x2c_type_item
    (217) _41_0x2c_type_items -> . _41_0x2c_type_item
    (218) _41_0x2c_type_item -> . , type
    )               reduce using rule 215 (_41_0x2c_type_repeat -> .)
    ,               shift and go to state 372

    _41_0x2c_type_repeat           shift and go to state 369
    _41_0x2c_type_items            shift and go to state 370
    _41_0x2c_type_item             shift and go to state 371

state 348

    (203) type_variants -> type_variants LINE variant . _38_NEWLINE_optional
    (204) _38_NEWLINE_optional -> . NEWLINE
    (205) _38_NEWLINE_optional -> .
  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 374
    LINE            reduce using rule 205 (_38_NEWLINE_optional -> .)
    (               reduce using rule 205 (_38_NEWLINE_optional -> .)
    SOME_SUB        reduce using rule 205 (_38_NEWLINE_optional -> .)
    SOME_CONCAT     reduce using rule 205 (_38_NEWLINE_optional -> .)
    ARROW_BOTH      reduce using rule 205 (_38_NEWLINE_optional -> .)
    ARROW_RIGHT     reduce using rule 205 (_38_NEWLINE_optional -> .)
    ARROW_LEFT      reduce using rule 205 (_38_NEWLINE_optional -> .)
    DOUBLE_ARROW_RIGHT reduce using rule 205 (_38_NEWLINE_optional -> .)
    DOUBLE_ARROW_LEFT reduce using rule 205 (_38_NEWLINE_optional -> .)
    BIT_SHIFT_RIGHT reduce using rule 205 (_38_NEWLINE_optional -> .)
    BIT_SHIFT_LEFT  reduce using rule 205 (_38_NEWLINE_optional -> .)
    BIT_AND         reduce using rule 205 (_38_NEWLINE_optional -> .)
    BIT_OR          reduce using rule 205 (_38_NEWLINE_optional -> .)
    FLOAT_POW       reduce using rule 205 (_38_NEWLINE_optional -> .)
    POW             reduce using rule 205 (_38_NEWLINE_optional -> .)
    ARRAY_SUB       reduce using rule 205 (_38_NEWLINE_optional -> .)
    ARRAY_CONCAT    reduce using rule 205 (_38_NEWLINE_optional -> .)
    MORE_OR_EQ      reduce using rule 205 (_38_NEWLINE_optional -> .)
    LESS_OR_EQ      reduce using rule 205 (_38_NEWLINE_optional -> .)
    TEXT_MATCH      reduce using rule 205 (_38_NEWLINE_optional -> .)
    STRICT_AND      reduce using rule 205 (_38_NEWLINE_optional -> .)
    AND             reduce using rule 205 (_38_NEWLINE_optional -> .)
    STRICT_OR       reduce using rule 205 (_38_NEWLINE_optional -> .)
    OR              reduce using rule 205 (_38_NEWLINE_optional -> .)
    EQUAL           reduce using rule 205 (_38_NEWLINE_optional -> .)
    NOT_EQUAL       reduce using rule 205 (_38_NEWLINE_optional -> .)
    >               reduce using rule 205 (_38_NEWLINE_optional -> .)
    FLOAT_MUL       reduce using rule 205 (_38_NEWLINE_optional -> .)
    FLOAT_DIV       reduce using rule 205 (_38_NEWLINE_optional -> .)
    FLOAT_SUB       reduce using rule 205 (_38_NEWLINE_optional -> .)
    FLOAT_SUM       reduce using rule 205 (_38_NEWLINE_optional -> .)
    <               reduce using rule 205 (_38_NEWLINE_optional -> .)
    *               reduce using rule 205 (_38_NEWLINE_optional -> .)
    /               reduce using rule 205 (_38_NEWLINE_optional -> .)
    -               reduce using rule 205 (_38_NEWLINE_optional -> .)
    +               reduce using rule 205 (_38_NEWLINE_optional -> .)
    CONCAT          reduce using rule 205 (_38_NEWLINE_optional -> .)
    $end            reduce using rule 205 (_38_NEWLINE_optional -> .)
    )               reduce using rule 205 (_38_NEWLINE_optional -> .)
    INTERPOLATION_BOTH reduce using rule 205 (_38_NEWLINE_optional -> .)
    INTERPOLATION_RIGHT reduce using rule 205 (_38_NEWLINE_optional -> .)
    OF              reduce using rule 205 (_38_NEWLINE_optional -> .)
    THEN            reduce using rule 205 (_38_NEWLINE_optional -> .)
    END             reduce using rule 205 (_38_NEWLINE_optional -> .)
    ELIF            reduce using rule 205 (_38_NEWLINE_optional -> .)
    ELSE            reduce using rule 205 (_38_NEWLINE_optional -> .)
    ,               reduce using rule 205 (_38_NEWLINE_optional -> .)
    ]               reduce using rule 205 (_38_NEWLINE_optional -> .)
    }               reduce using rule 205 (_38_NEWLINE_optional -> .)

    _38_NEWLINE_optional           shift and go to state 373

state 349

    (175) enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = . _30_NEWLINE_optional _31_type_variants_optional }
    (181) _30_NEWLINE_optional -> . NEWLINE
    (182) _30_NEWLINE_optional -> .
    NEWLINE         shift and go to state 376
    TYPE_IDENTIFIER reduce using rule 182 (_30_NEWLINE_optional -> .)
    }               reduce using rule 182 (_30_NEWLINE_optional -> .)

    _30_NEWLINE_optional           shift and go to state 375

state 350

    (209) variants -> variants variant _40_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 209 (variants -> variants variant _40_NEWLINE_optional .)
    }               reduce using rule 209 (variants -> variants variant _40_NEWLINE_optional .)


state 351

    (210) _40_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 210 (_40_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 210 (_40_NEWLINE_optional -> NEWLINE .)


state 352

    (190) enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { . _35_NEWLINE_optional _36_variants_optional }
    (196) _35_NEWLINE_optional -> . NEWLINE
    (197) _35_NEWLINE_optional -> .
    NEWLINE         shift and go to state 378
    TYPE_IDENTIFIER reduce using rule 197 (_35_NEWLINE_optional -> .)
    }               reduce using rule 197 (_35_NEWLINE_optional -> .)

    _35_NEWLINE_optional           shift and go to state 377

state 353

    (284) let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .
    (264) call -> expr . ( _57_NEWLINE_optional _58_exprs_optional )
    (34) binary_expr -> expr . SOME_SUB expr
    (35) binary_expr -> expr . SOME_CONCAT expr
    (36) binary_expr -> expr . ARROW_BOTH expr
    (37) binary_expr -> expr . ARROW_RIGHT expr
    (38) binary_expr -> expr . ARROW_LEFT expr
    (39) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (40) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (41) binary_expr -> expr . BIT_SHIFT_RIGHT expr
    (42) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (43) binary_expr -> expr . BIT_AND expr
    (44) binary_expr -> expr . BIT_OR expr
    (45) binary_expr -> expr . FLOAT_POW expr
    (46) binary_expr -> expr . POW expr
    (47) binary_expr -> expr . ARRAY_SUB expr
    (48) binary_expr -> expr . ARRAY_CONCAT expr
    (49) binary_expr -> expr . MORE_OR_EQ expr
    (50) binary_expr -> expr . LESS_OR_EQ expr
    (51) binary_expr -> expr . TEXT_MATCH expr
    (52) binary_expr -> expr . STRICT_AND expr
    (53) binary_expr -> expr . AND expr
    (54) binary_expr -> expr . STRICT_OR expr
    (55) binary_expr -> expr . OR expr
    (56) binary_expr -> expr . EQUAL expr
    (57) binary_expr -> expr . NOT_EQUAL expr
    (58) binary_expr -> expr . > expr
    (59) binary_expr -> expr . FLOAT_MUL expr
    (60) binary_expr -> expr . FLOAT_DIV expr
    (61) binary_expr -> expr . FLOAT_SUB expr
    (62) binary_expr -> expr . FLOAT_SUM expr
    (63) binary_expr -> expr . < expr
    (64) binary_expr -> expr . * expr
    (65) binary_expr -> expr . / expr
    (66) binary_expr -> expr . - expr
    (67) binary_expr -> expr . + expr
    (68) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    BIT_AND         reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    BIT_OR          reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    STRICT_AND      reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    AND             reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    STRICT_OR       reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    OR              reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    EQUAL           reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    >               reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    <               reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    $end            reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    )               reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    INTERPOLATION_BOTH reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    INTERPOLATION_RIGHT reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    OF              reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    THEN            reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    END             reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    ELIF            reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    ELSE            reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    ,               reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    ]               reduce using rule 284 (let -> identifier : type_identifier < type _64_0x2c_type_repeat MORE_OR_EQ expr .)
    (               shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_RIGHT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 354

    (289) _64_0x2c_type_item -> , type .
    ,               reduce using rule 289 (_64_0x2c_type_item -> , type .)
    MORE_OR_EQ      reduce using rule 289 (_64_0x2c_type_item -> , type .)


state 355

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param . _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (109) _6_NEWLINE_optional -> . NEWLINE
    (110) _6_NEWLINE_optional -> .
    NEWLINE         shift and go to state 380
    )               reduce using rule 110 (_6_NEWLINE_optional -> .)

    _6_NEWLINE_optional            shift and go to state 379

state 356

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional . param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (219) param -> . identifier _42_0x3a_type_optional
    (282) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 37

    param                          shift and go to state 381
    identifier                     shift and go to state 237

state 357

    (119) _9_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 119 (_9_NEWLINE_optional -> NEWLINE .)


state 358

    (135) def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .
    NEWLINE         reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    (               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    SOME_SUB        reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    SOME_CONCAT     reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARROW_BOTH      reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARROW_RIGHT     reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARROW_LEFT      reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    BIT_SHIFT_RIGHT reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    BIT_AND         reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    BIT_OR          reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_POW       reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    POW             reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARRAY_SUB       reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARRAY_CONCAT    reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    MORE_OR_EQ      reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    LESS_OR_EQ      reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    TEXT_MATCH      reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    STRICT_AND      reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    AND             reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    STRICT_OR       reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    OR              reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    EQUAL           reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    >               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_MUL       reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_DIV       reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_SUB       reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_SUM       reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    <               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    *               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    /               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    -               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    +               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    CONCAT          reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    $end            reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    )               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    INTERPOLATION_BOTH reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    INTERPOLATION_RIGHT reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    OF              reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    THEN            reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    END             reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ELIF            reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ELSE            reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ,               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ]               reduce using rule 135 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)


state 359

    (140) _18_0x3a_type_optional -> : type .
    DO              reduce using rule 140 (_18_0x3a_type_optional -> : type .)


state 360

    (157) params -> params , _24_NEWLINE_optional param . _25_NEWLINE_optional
    (160) _25_NEWLINE_optional -> . NEWLINE
    (161) _25_NEWLINE_optional -> .
    NEWLINE         shift and go to state 383
    ,               reduce using rule 161 (_25_NEWLINE_optional -> .)
    )               reduce using rule 161 (_25_NEWLINE_optional -> .)

    _25_NEWLINE_optional           shift and go to state 382

state 361

    (142) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional . _21_params_optional ) _22_0x3a_type_optional do
    (150) _21_params_optional -> . params
    (151) _21_params_optional -> .
    (154) params -> . param _23_NEWLINE_optional
    (157) params -> . params , _24_NEWLINE_optional param _25_NEWLINE_optional
    (219) param -> . identifier _42_0x3a_type_optional
    (282) identifier -> . IDENTIFIER
    )               reduce using rule 151 (_21_params_optional -> .)
    IDENTIFIER      shift and go to state 37

    identifier                     shift and go to state 237
    _21_params_optional            shift and go to state 384
    params                         shift and go to state 385
    param                          shift and go to state 244

state 362

    (148) _20_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 148 (_20_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 148 (_20_NEWLINE_optional -> NEWLINE .)


state 363

    (239) cases -> cases pattern do _49_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 239 (cases -> cases pattern do _49_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 239 (cases -> cases pattern do _49_NEWLINE_optional .)
    END             reduce using rule 239 (cases -> cases pattern do _49_NEWLINE_optional .)


state 364

    (240) _49_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 240 (_49_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 240 (_49_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 240 (_49_NEWLINE_optional -> NEWLINE .)


state 365

    (246) match_variant -> type_identifier ( _50_NEWLINE_optional _51_patterns_optional . )
    )               shift and go to state 386


state 366

    (249) _51_patterns_optional -> patterns .
    (254) patterns -> patterns . , _53_NEWLINE_optional pattern _54_NEWLINE_optional
    )               reduce using rule 249 (_51_patterns_optional -> patterns .)
    ,               shift and go to state 387


state 367

    (251) patterns -> pattern . _52_NEWLINE_optional
    (252) _52_NEWLINE_optional -> . NEWLINE
    (253) _52_NEWLINE_optional -> .
    NEWLINE         shift and go to state 389
    ,               reduce using rule 253 (_52_NEWLINE_optional -> .)
    )               reduce using rule 253 (_52_NEWLINE_optional -> .)

    _52_NEWLINE_optional           shift and go to state 388

state 368

    (227) or_else -> ELIF expr THEN . block_statement _45_or_else_optional
    (130) block_statement -> . _14_NEWLINE_optional _15_do_exprs_optional
    (131) _14_NEWLINE_optional -> . NEWLINE
    (132) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 195
    (               reduce using rule 132 (_14_NEWLINE_optional -> .)
    INTERPOLATION_LEFT reduce using rule 132 (_14_NEWLINE_optional -> .)
    DEF             reduce using rule 132 (_14_NEWLINE_optional -> .)
    +               reduce using rule 132 (_14_NEWLINE_optional -> .)
    !               reduce using rule 132 (_14_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 132 (_14_NEWLINE_optional -> .)
    -               reduce using rule 132 (_14_NEWLINE_optional -> .)
    STRING          reduce using rule 132 (_14_NEWLINE_optional -> .)
    FLOAT           reduce using rule 132 (_14_NEWLINE_optional -> .)
    INT             reduce using rule 132 (_14_NEWLINE_optional -> .)
    [               reduce using rule 132 (_14_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 132 (_14_NEWLINE_optional -> .)
    CASE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    IF              reduce using rule 132 (_14_NEWLINE_optional -> .)
    DO              reduce using rule 132 (_14_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 132 (_14_NEWLINE_optional -> .)
    TYPE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    ENUM            reduce using rule 132 (_14_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 132 (_14_NEWLINE_optional -> .)
    ELIF            reduce using rule 132 (_14_NEWLINE_optional -> .)
    ELSE            reduce using rule 132 (_14_NEWLINE_optional -> .)
    END             reduce using rule 132 (_14_NEWLINE_optional -> .)

    block_statement                shift and go to state 390
    _14_NEWLINE_optional           shift and go to state 194

state 369

    (213) variant -> type_identifier ( type _41_0x2c_type_repeat . )
    )               shift and go to state 391


state 370

    (214) _41_0x2c_type_repeat -> _41_0x2c_type_items .
    (216) _41_0x2c_type_items -> _41_0x2c_type_items . _41_0x2c_type_item
    (218) _41_0x2c_type_item -> . , type
    )               reduce using rule 214 (_41_0x2c_type_repeat -> _41_0x2c_type_items .)
    ,               shift and go to state 372

    _41_0x2c_type_item             shift and go to state 392

state 371

    (217) _41_0x2c_type_items -> _41_0x2c_type_item .
    ,               reduce using rule 217 (_41_0x2c_type_items -> _41_0x2c_type_item .)
    )               reduce using rule 217 (_41_0x2c_type_items -> _41_0x2c_type_item .)


state 372

    (218) _41_0x2c_type_item -> , . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 393
    type_identifier                shift and go to state 197

state 373

    (203) type_variants -> type_variants LINE variant _38_NEWLINE_optional .
    LINE            reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    NEWLINE         reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    (               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    SOME_SUB        reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    SOME_CONCAT     reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ARROW_BOTH      reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ARROW_RIGHT     reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ARROW_LEFT      reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    DOUBLE_ARROW_RIGHT reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    DOUBLE_ARROW_LEFT reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    BIT_SHIFT_RIGHT reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    BIT_SHIFT_LEFT  reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    BIT_AND         reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    BIT_OR          reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    FLOAT_POW       reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    POW             reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ARRAY_SUB       reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ARRAY_CONCAT    reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    MORE_OR_EQ      reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    LESS_OR_EQ      reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    TEXT_MATCH      reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    STRICT_AND      reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    AND             reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    STRICT_OR       reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    OR              reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    EQUAL           reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    NOT_EQUAL       reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    >               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    FLOAT_MUL       reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    FLOAT_DIV       reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    FLOAT_SUB       reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    FLOAT_SUM       reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    <               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    *               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    /               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    -               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    +               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    CONCAT          reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    $end            reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    )               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    INTERPOLATION_BOTH reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    INTERPOLATION_RIGHT reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    OF              reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    THEN            reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    END             reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ELIF            reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ELSE            reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ,               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    ]               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)
    }               reduce using rule 203 (type_variants -> type_variants LINE variant _38_NEWLINE_optional .)


state 374

    (204) _38_NEWLINE_optional -> NEWLINE .
    LINE            reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    NEWLINE         reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    SOME_SUB        reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    SOME_CONCAT     reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ARROW_BOTH      reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ARROW_RIGHT     reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ARROW_LEFT      reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    DOUBLE_ARROW_RIGHT reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    DOUBLE_ARROW_LEFT reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    BIT_SHIFT_RIGHT reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    BIT_SHIFT_LEFT  reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    BIT_AND         reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    BIT_OR          reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    FLOAT_POW       reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    POW             reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ARRAY_SUB       reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ARRAY_CONCAT    reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    MORE_OR_EQ      reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    LESS_OR_EQ      reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    TEXT_MATCH      reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    STRICT_AND      reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    AND             reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    STRICT_OR       reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    OR              reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    EQUAL           reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    NOT_EQUAL       reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    >               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    FLOAT_MUL       reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    FLOAT_DIV       reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    FLOAT_SUB       reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    FLOAT_SUM       reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    <               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    *               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    /               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    CONCAT          reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    $end            reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_BOTH reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    INTERPOLATION_RIGHT reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    OF              reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    THEN            reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ,               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 204 (_38_NEWLINE_optional -> NEWLINE .)


state 375

    (175) enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional . _31_type_variants_optional }
    (183) _31_type_variants_optional -> . type_variants
    (184) _31_type_variants_optional -> .
    (200) type_variants -> . variant _37_NEWLINE_optional
    (203) type_variants -> . type_variants LINE variant _38_NEWLINE_optional
    (212) variant -> . type_identifier
    (213) variant -> . type_identifier ( type _41_0x2c_type_repeat )
    (283) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 184 (_31_type_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 262
    _31_type_variants_optional     shift and go to state 394
    type_variants                  shift and go to state 395
    variant                        shift and go to state 265

state 376

    (181) _30_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 181 (_30_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 181 (_30_NEWLINE_optional -> NEWLINE .)


state 377

    (190) enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional . _36_variants_optional }
    (198) _36_variants_optional -> . variants
    (199) _36_variants_optional -> .
    (206) variants -> . variant _39_NEWLINE_optional
    (209) variants -> . variants variant _40_NEWLINE_optional
    (212) variant -> . type_identifier
    (213) variant -> . type_identifier ( type _41_0x2c_type_repeat )
    (283) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 199 (_36_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 44

    type_identifier                shift and go to state 262
    _36_variants_optional          shift and go to state 396
    variants                       shift and go to state 397
    variant                        shift and go to state 272

state 378

    (196) _35_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 196 (_35_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 196 (_35_NEWLINE_optional -> NEWLINE .)


state 379

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional . ) _7_0x3a_type_optional do
    )               shift and go to state 398


state 380

    (109) _6_NEWLINE_optional -> NEWLINE .
    )               reduce using rule 109 (_6_NEWLINE_optional -> NEWLINE .)


state 381

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param . , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    ,               shift and go to state 399


state 382

    (157) params -> params , _24_NEWLINE_optional param _25_NEWLINE_optional .
    ,               reduce using rule 157 (params -> params , _24_NEWLINE_optional param _25_NEWLINE_optional .)
    )               reduce using rule 157 (params -> params , _24_NEWLINE_optional param _25_NEWLINE_optional .)


state 383

    (160) _25_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 160 (_25_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 160 (_25_NEWLINE_optional -> NEWLINE .)


state 384

    (142) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional . ) _22_0x3a_type_optional do
    )               shift and go to state 400


state 385

    (150) _21_params_optional -> params .
    (157) params -> params . , _24_NEWLINE_optional param _25_NEWLINE_optional
    )               reduce using rule 150 (_21_params_optional -> params .)
    ,               shift and go to state 291


state 386

    (246) match_variant -> type_identifier ( _50_NEWLINE_optional _51_patterns_optional ) .
    DO              reduce using rule 246 (match_variant -> type_identifier ( _50_NEWLINE_optional _51_patterns_optional ) .)
    NEWLINE         reduce using rule 246 (match_variant -> type_identifier ( _50_NEWLINE_optional _51_patterns_optional ) .)
    ,               reduce using rule 246 (match_variant -> type_identifier ( _50_NEWLINE_optional _51_patterns_optional ) .)
    )               reduce using rule 246 (match_variant -> type_identifier ( _50_NEWLINE_optional _51_patterns_optional ) .)


state 387

    (254) patterns -> patterns , . _53_NEWLINE_optional pattern _54_NEWLINE_optional
    (255) _53_NEWLINE_optional -> . NEWLINE
    (256) _53_NEWLINE_optional -> .
    NEWLINE         shift and go to state 402
    TYPE_IDENTIFIER reduce using rule 256 (_53_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 256 (_53_NEWLINE_optional -> .)

    _53_NEWLINE_optional           shift and go to state 401

state 388

    (251) patterns -> pattern _52_NEWLINE_optional .
    ,               reduce using rule 251 (patterns -> pattern _52_NEWLINE_optional .)
    )               reduce using rule 251 (patterns -> pattern _52_NEWLINE_optional .)


state 389

    (252) _52_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 252 (_52_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 252 (_52_NEWLINE_optional -> NEWLINE .)


state 390

    (227) or_else -> ELIF expr THEN block_statement . _45_or_else_optional
    (228) _45_or_else_optional -> . or_else
    (229) _45_or_else_optional -> .
    (227) or_else -> . ELIF expr THEN block_statement _45_or_else_optional
    (230) or_else -> . ELSE block_statement
    END             reduce using rule 229 (_45_or_else_optional -> .)
    ELIF            shift and go to state 304
    ELSE            shift and go to state 305

    _45_or_else_optional           shift and go to state 403
    or_else                        shift and go to state 404

state 391

    (213) variant -> type_identifier ( type _41_0x2c_type_repeat ) .
    NEWLINE         reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    LINE            reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    (               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    SOME_SUB        reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    SOME_CONCAT     reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ARROW_BOTH      reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ARROW_RIGHT     reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ARROW_LEFT      reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    DOUBLE_ARROW_LEFT reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    BIT_SHIFT_RIGHT reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    BIT_SHIFT_LEFT  reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    BIT_AND         reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    BIT_OR          reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    FLOAT_POW       reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    POW             reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ARRAY_SUB       reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ARRAY_CONCAT    reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    MORE_OR_EQ      reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    LESS_OR_EQ      reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    TEXT_MATCH      reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    STRICT_AND      reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    AND             reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    STRICT_OR       reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    OR              reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    EQUAL           reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    NOT_EQUAL       reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    >               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    FLOAT_MUL       reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    FLOAT_DIV       reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    FLOAT_SUB       reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    FLOAT_SUM       reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    <               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    *               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    /               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    -               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    +               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    CONCAT          reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    $end            reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    )               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    INTERPOLATION_BOTH reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    INTERPOLATION_RIGHT reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    OF              reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    THEN            reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    END             reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ELIF            reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ELSE            reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ,               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    ]               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)
    }               reduce using rule 213 (variant -> type_identifier ( type _41_0x2c_type_repeat ) .)


state 392

    (216) _41_0x2c_type_items -> _41_0x2c_type_items _41_0x2c_type_item .
    ,               reduce using rule 216 (_41_0x2c_type_items -> _41_0x2c_type_items _41_0x2c_type_item .)
    )               reduce using rule 216 (_41_0x2c_type_items -> _41_0x2c_type_items _41_0x2c_type_item .)


state 393

    (218) _41_0x2c_type_item -> , type .
    ,               reduce using rule 218 (_41_0x2c_type_item -> , type .)
    )               reduce using rule 218 (_41_0x2c_type_item -> , type .)


state 394

    (175) enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional . }
    }               shift and go to state 405


state 395

    (183) _31_type_variants_optional -> type_variants .
    (203) type_variants -> type_variants . LINE variant _38_NEWLINE_optional
    }               reduce using rule 183 (_31_type_variants_optional -> type_variants .)
    LINE            shift and go to state 308


state 396

    (190) enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional . }
    }               shift and go to state 406


state 397

    (198) _36_variants_optional -> variants .
    (209) variants -> variants . variant _40_NEWLINE_optional
    (212) variant -> . type_identifier
    (213) variant -> . type_identifier ( type _41_0x2c_type_repeat )
    (283) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 198 (_36_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 44

    variant                        shift and go to state 315
    type_identifier                shift and go to state 262

state 398

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) . _7_0x3a_type_optional do
    (111) _7_0x3a_type_optional -> . : type
    (112) _7_0x3a_type_optional -> .
    :               shift and go to state 408
    DO              reduce using rule 112 (_7_0x3a_type_optional -> .)

    _7_0x3a_type_optional          shift and go to state 407

state 399

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , . _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (121) _10_NEWLINE_optional -> . NEWLINE
    (122) _10_NEWLINE_optional -> .
    NEWLINE         shift and go to state 410
    IDENTIFIER      reduce using rule 122 (_10_NEWLINE_optional -> .)

    _10_NEWLINE_optional           shift and go to state 409

state 400

    (142) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) . _22_0x3a_type_optional do
    (152) _22_0x3a_type_optional -> . : type
    (153) _22_0x3a_type_optional -> .
    :               shift and go to state 412
    DO              reduce using rule 153 (_22_0x3a_type_optional -> .)

    _22_0x3a_type_optional         shift and go to state 411

state 401

    (254) patterns -> patterns , _53_NEWLINE_optional . pattern _54_NEWLINE_optional
    (242) pattern -> . match_variant
    (243) pattern -> . match_as
    (245) match_variant -> . type_identifier
    (246) match_variant -> . type_identifier ( _50_NEWLINE_optional _51_patterns_optional )
    (244) match_as -> . identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    (282) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44
    IDENTIFIER      shift and go to state 37

    pattern                        shift and go to state 413
    match_variant                  shift and go to state 255
    match_as                       shift and go to state 256
    type_identifier                shift and go to state 257
    identifier                     shift and go to state 258

state 402

    (255) _53_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 255 (_53_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 255 (_53_NEWLINE_optional -> NEWLINE .)


state 403

    (227) or_else -> ELIF expr THEN block_statement _45_or_else_optional .
    END             reduce using rule 227 (or_else -> ELIF expr THEN block_statement _45_or_else_optional .)


state 404

    (228) _45_or_else_optional -> or_else .
    END             reduce using rule 228 (_45_or_else_optional -> or_else .)


state 405

    (175) enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .
    NEWLINE         reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    (               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    SOME_SUB        reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    SOME_CONCAT     reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ARROW_BOTH      reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ARROW_RIGHT     reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ARROW_LEFT      reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    DOUBLE_ARROW_RIGHT reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    DOUBLE_ARROW_LEFT reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    BIT_SHIFT_RIGHT reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    BIT_SHIFT_LEFT  reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    BIT_AND         reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    BIT_OR          reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    FLOAT_POW       reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    POW             reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ARRAY_SUB       reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ARRAY_CONCAT    reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    MORE_OR_EQ      reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    LESS_OR_EQ      reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    TEXT_MATCH      reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    STRICT_AND      reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    AND             reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    STRICT_OR       reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    OR              reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    EQUAL           reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    NOT_EQUAL       reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    >               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    FLOAT_MUL       reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    FLOAT_DIV       reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    FLOAT_SUB       reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    FLOAT_SUM       reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    <               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    *               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    /               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    -               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    +               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    CONCAT          reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    $end            reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    )               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    INTERPOLATION_BOTH reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    INTERPOLATION_RIGHT reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    OF              reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    THEN            reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    END             reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ELIF            reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ELSE            reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ,               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)
    ]               reduce using rule 175 (enum -> TYPE type_identifier < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional } .)


state 406

    (190) enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .
    NEWLINE         reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    (               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    SOME_SUB        reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    SOME_CONCAT     reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ARROW_BOTH      reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ARROW_RIGHT     reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ARROW_LEFT      reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    DOUBLE_ARROW_RIGHT reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    DOUBLE_ARROW_LEFT reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    BIT_SHIFT_RIGHT reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    BIT_SHIFT_LEFT  reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    BIT_AND         reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    BIT_OR          reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    FLOAT_POW       reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    POW             reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ARRAY_SUB       reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ARRAY_CONCAT    reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    MORE_OR_EQ      reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    LESS_OR_EQ      reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    TEXT_MATCH      reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    STRICT_AND      reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    AND             reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    STRICT_OR       reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    OR              reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    EQUAL           reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    NOT_EQUAL       reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    >               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    FLOAT_MUL       reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    FLOAT_DIV       reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    FLOAT_SUB       reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    FLOAT_SUM       reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    <               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    *               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    /               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    -               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    +               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    CONCAT          reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    $end            reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    )               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    INTERPOLATION_BOTH reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    INTERPOLATION_RIGHT reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    OF              reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    THEN            reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    END             reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ELIF            reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ELSE            reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ,               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)
    ]               reduce using rule 190 (enum -> ENUM type_identifier < type_identifier _34_0x2c_type_identifier_repeat > { _35_NEWLINE_optional _36_variants_optional } .)


state 407

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional . do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 40

    do                             shift and go to state 414

state 408

    (111) _7_0x3a_type_optional -> : . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 415
    type_identifier                shift and go to state 197

state 409

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional . param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (219) param -> . identifier _42_0x3a_type_optional
    (282) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 37

    param                          shift and go to state 416
    identifier                     shift and go to state 237

state 410

    (121) _10_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 121 (_10_NEWLINE_optional -> NEWLINE .)


state 411

    (142) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional . do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 40

    do                             shift and go to state 417

state 412

    (152) _22_0x3a_type_optional -> : . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 418
    type_identifier                shift and go to state 197

state 413

    (254) patterns -> patterns , _53_NEWLINE_optional pattern . _54_NEWLINE_optional
    (257) _54_NEWLINE_optional -> . NEWLINE
    (258) _54_NEWLINE_optional -> .
    NEWLINE         shift and go to state 420
    ,               reduce using rule 258 (_54_NEWLINE_optional -> .)
    )               reduce using rule 258 (_54_NEWLINE_optional -> .)

    _54_NEWLINE_optional           shift and go to state 419

state 414

    (104) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .
    NEWLINE         reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    (               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    SOME_SUB        reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    SOME_CONCAT     reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARROW_BOTH      reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARROW_RIGHT     reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARROW_LEFT      reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    BIT_SHIFT_RIGHT reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    BIT_AND         reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    BIT_OR          reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_POW       reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    POW             reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARRAY_SUB       reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARRAY_CONCAT    reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    MORE_OR_EQ      reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    LESS_OR_EQ      reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    TEXT_MATCH      reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    STRICT_AND      reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    AND             reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    STRICT_OR       reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    OR              reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    EQUAL           reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    >               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_MUL       reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_DIV       reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_SUB       reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_SUM       reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    <               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    *               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    /               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    -               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    +               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    CONCAT          reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    $end            reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    )               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    INTERPOLATION_BOTH reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    INTERPOLATION_RIGHT reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    OF              reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    THEN            reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    END             reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ELIF            reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ELSE            reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ,               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ]               reduce using rule 104 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)


state 415

    (111) _7_0x3a_type_optional -> : type .
    DO              reduce using rule 111 (_7_0x3a_type_optional -> : type .)


state 416

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param . _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (123) _11_NEWLINE_optional -> . NEWLINE
    (124) _11_NEWLINE_optional -> .
    NEWLINE         shift and go to state 422
    )               reduce using rule 124 (_11_NEWLINE_optional -> .)

    _11_NEWLINE_optional           shift and go to state 421

state 417

    (142) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .
    NEWLINE         reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    (               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    SOME_SUB        reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    SOME_CONCAT     reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARROW_BOTH      reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARROW_RIGHT     reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARROW_LEFT      reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    BIT_SHIFT_RIGHT reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    BIT_AND         reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    BIT_OR          reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_POW       reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    POW             reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARRAY_SUB       reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARRAY_CONCAT    reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    MORE_OR_EQ      reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    LESS_OR_EQ      reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    TEXT_MATCH      reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    STRICT_AND      reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    AND             reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    STRICT_OR       reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    OR              reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    EQUAL           reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    >               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_MUL       reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_DIV       reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_SUB       reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_SUM       reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    <               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    *               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    /               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    -               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    +               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    CONCAT          reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    $end            reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    )               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    INTERPOLATION_BOTH reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    INTERPOLATION_RIGHT reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    OF              reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    THEN            reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    END             reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ELIF            reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ELSE            reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ,               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ]               reduce using rule 142 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)


state 418

    (152) _22_0x3a_type_optional -> : type .
    DO              reduce using rule 152 (_22_0x3a_type_optional -> : type .)


state 419

    (254) patterns -> patterns , _53_NEWLINE_optional pattern _54_NEWLINE_optional .
    ,               reduce using rule 254 (patterns -> patterns , _53_NEWLINE_optional pattern _54_NEWLINE_optional .)
    )               reduce using rule 254 (patterns -> patterns , _53_NEWLINE_optional pattern _54_NEWLINE_optional .)


state 420

    (257) _54_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 257 (_54_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 257 (_54_NEWLINE_optional -> NEWLINE .)


state 421

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional . ) _12_0x3a_type_optional do
    )               shift and go to state 423


state 422

    (123) _11_NEWLINE_optional -> NEWLINE .
    )               reduce using rule 123 (_11_NEWLINE_optional -> NEWLINE .)


state 423

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) . _12_0x3a_type_optional do
    (125) _12_0x3a_type_optional -> . : type
    (126) _12_0x3a_type_optional -> .
    :               shift and go to state 425
    DO              reduce using rule 126 (_12_0x3a_type_optional -> .)

    _12_0x3a_type_optional         shift and go to state 424

state 424

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional . do
    (127) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 40

    do                             shift and go to state 426

state 425

    (125) _12_0x3a_type_optional -> : . type
    (162) type -> . type_identifier < type _26_0x2c_type_repeat >
    (168) type -> . type_identifier
    (283) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 44

    type                           shift and go to state 427
    type_identifier                shift and go to state 197

state 426

    (113) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .
    NEWLINE         reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    (               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    SOME_SUB        reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    SOME_CONCAT     reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARROW_BOTH      reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARROW_RIGHT     reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARROW_LEFT      reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    BIT_SHIFT_RIGHT reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    BIT_AND         reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    BIT_OR          reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_POW       reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    POW             reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARRAY_SUB       reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARRAY_CONCAT    reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    MORE_OR_EQ      reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    LESS_OR_EQ      reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    TEXT_MATCH      reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    STRICT_AND      reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    AND             reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    STRICT_OR       reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    OR              reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    EQUAL           reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    >               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_MUL       reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_DIV       reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_SUB       reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_SUM       reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    <               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    *               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    /               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    -               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    +               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    CONCAT          reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    $end            reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    )               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    INTERPOLATION_BOTH reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    INTERPOLATION_RIGHT reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    OF              reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    THEN            reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    END             reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ELIF            reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ELSE            reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ,               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ]               reduce using rule 113 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)


state 427

    (125) _12_0x3a_type_optional -> : type .
    DO              reduce using rule 125 (_12_0x3a_type_optional -> : type .)


Conflicts:

shift/reduce conflict for < in state 135 resolved as shift
   shift using rule enum -> TYPE type_identifier . < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
   ╭╴
   │ TYPE type_identifier ♦ < type_identifier _29_0x2c_type_identifier_repeat > = _30_NEWLINE_optional _31_type_variants_optional }
   │ ╰enum────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

   reduce using rule enum -> TYPE type_identifier .
   ╭╴
   │ TYPE type_identifier ♦ < expr
   │ ╰enum────────────────╯
   │ ╰expr────────────────╯
   │ ╰binary_expr────────────────╯
   ╰╴

shift/reduce conflict for NEWLINE in state 198 resolved as shift
   shift using rule _27_NEWLINE_optional -> . NEWLINE
   ╭╴
   │ TYPE type_identifier = ♦ NEWLINE              _28_type_variants_optional
   │                        ╰_27_NEWLINE_optional╯
   │ ╰enum──────────────────────────────────────────────────────────────────╯
   ├╴
   │ exprs , _62_NEWLINE_optional TYPE type_identifier = ♦ NEWLINE              _28_type_variants_optional _63_NEWLINE_optional
   │                                                     ╰_27_NEWLINE_optional╯
   │                              ╰enum──────────────────────────────────────────────────────────────────╯
   │                              ╰expr──────────────────────────────────────────────────────────────────╯
   │ ╰exprs───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

   reduce using rule _27_NEWLINE_optional -> .
   ╭╴
   │ TYPE type_identifier = ♦                                                   NEWLINE
   │                        ╰_27_NEWLINE_optional╯ ╰_28_type_variants_optional╯ ╰_3_NEWLINE_optional╯
   │ ╰enum────────────────────────────────────────────────────────────────────╯
   │ ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰do_exprs──────────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ TYPE type_identifier = ♦                                                   NEWLINE do_exprs
   │                        ╰_27_NEWLINE_optional╯ ╰_28_type_variants_optional╯
   │ ╰enum────────────────────────────────────────────────────────────────────╯
   │ ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰do_exprs─────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ TYPE type_identifier = ♦                                                   NEWLINE
   │                        ╰_27_NEWLINE_optional╯ ╰_28_type_variants_optional╯ ╰_61_NEWLINE_optional╯
   │ ╰enum────────────────────────────────────────────────────────────────────╯
   │ ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰exprs──────────────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ exprs , _62_NEWLINE_optional TYPE type_identifier = ♦                                                   NEWLINE
   │                                                     ╰_27_NEWLINE_optional╯ ╰_28_type_variants_optional╯ ╰_63_NEWLINE_optional╯
   │                              ╰enum────────────────────────────────────────────────────────────────────╯
   │                              ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰exprs───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

shift/reduce conflict for ( in state 262 resolved as shift
   shift using rule variant -> type_identifier . ( type _41_0x2c_type_repeat )
   ╭╴
   │ TYPE type_identifier = _27_NEWLINE_optional type_identifier ♦ ( type _41_0x2c_type_repeat ) _37_NEWLINE_optional
   │                                             ╰variant──────────────────────────────────────╯
   │                                             ╰type_variants─────────────────────────────────────────────────────╯
   │                                             ╰_28_type_variants_optional────────────────────────────────────────╯
   │ ╰enum──────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

   reduce using rule variant -> type_identifier .
   ╭╴
   │ TYPE type_identifier = _27_NEWLINE_optional type_identifier ♦                        ( _57_NEWLINE_optional _58_exprs_optional )
   │                                             ╰variant────────╯ ╰_37_NEWLINE_optional╯
   │                                             ╰type_variants─────────────────────────╯
   │                                             ╰_28_type_variants_optional────────────╯
   │ ╰enum──────────────────────────────────────────────────────────────────────────────╯
   │ ╰expr──────────────────────────────────────────────────────────────────────────────╯
   │ ╰call──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

shift/reduce conflict for NEWLINE in state 265 resolved as shift
   shift using rule _37_NEWLINE_optional -> . NEWLINE
   ╭╴
   │ TYPE type_identifier = _27_NEWLINE_optional variant ♦ NEWLINE
   │                                                     ╰_37_NEWLINE_optional╯
   │                                             ╰type_variants───────────────╯
   │                                             ╰_28_type_variants_optional──╯
   │ ╰enum────────────────────────────────────────────────────────────────────╯
   ├╴
   │ exprs , _62_NEWLINE_optional TYPE type_identifier = _27_NEWLINE_optional variant ♦ NEWLINE              _63_NEWLINE_optional
   │                                                                                  ╰_37_NEWLINE_optional╯
   │                                                                          ╰type_variants───────────────╯
   │                                                                          ╰_28_type_variants_optional──╯
   │                              ╰enum────────────────────────────────────────────────────────────────────╯
   │                              ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰exprs─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

   reduce using rule _37_NEWLINE_optional -> .
   ╭╴
   │ TYPE type_identifier = _27_NEWLINE_optional variant ♦                      NEWLINE
   │                                                     ╰_37_NEWLINE_optional╯ ╰_3_NEWLINE_optional╯
   │                                             ╰type_variants───────────────╯
   │                                             ╰_28_type_variants_optional──╯
   │ ╰enum────────────────────────────────────────────────────────────────────╯
   │ ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰do_exprs──────────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ TYPE type_identifier = _27_NEWLINE_optional variant ♦                      NEWLINE do_exprs
   │                                                     ╰_37_NEWLINE_optional╯
   │                                             ╰type_variants───────────────╯
   │                                             ╰_28_type_variants_optional──╯
   │ ╰enum────────────────────────────────────────────────────────────────────╯
   │ ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰do_exprs─────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ TYPE type_identifier = _27_NEWLINE_optional variant ♦                      NEWLINE
   │                                                     ╰_37_NEWLINE_optional╯ ╰_61_NEWLINE_optional╯
   │                                             ╰type_variants───────────────╯
   │                                             ╰_28_type_variants_optional──╯
   │ ╰enum────────────────────────────────────────────────────────────────────╯
   │ ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰exprs──────────────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ exprs , _62_NEWLINE_optional TYPE type_identifier = _27_NEWLINE_optional variant ♦                      NEWLINE
   │                                                                                  ╰_37_NEWLINE_optional╯ ╰_63_NEWLINE_optional╯
   │                                                                          ╰type_variants───────────────╯
   │                                                                          ╰_28_type_variants_optional──╯
   │                              ╰enum────────────────────────────────────────────────────────────────────╯
   │                              ╰expr────────────────────────────────────────────────────────────────────╯
   │ ╰exprs───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

shift/reduce conflict for NEWLINE in state 348 resolved as shift
   shift using rule _38_NEWLINE_optional -> . NEWLINE
   ╭╴
   │ TYPE type_identifier = _27_NEWLINE_optional type_variants LINE variant ♦ NEWLINE
   │                                                                        ╰_38_NEWLINE_optional╯
   │                                             ╰type_variants──────────────────────────────────╯
   │                                             ╰_28_type_variants_optional─────────────────────╯
   │ ╰enum───────────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ exprs , _62_NEWLINE_optional TYPE type_identifier = _27_NEWLINE_optional type_variants LINE variant ♦ NEWLINE              _63_NEWLINE_optional
   │                                                                                                     ╰_38_NEWLINE_optional╯
   │                                                                          ╰type_variants──────────────────────────────────╯
   │                                                                          ╰_28_type_variants_optional─────────────────────╯
   │                              ╰enum───────────────────────────────────────────────────────────────────────────────────────╯
   │                              ╰expr───────────────────────────────────────────────────────────────────────────────────────╯
   │ ╰exprs────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

   reduce using rule _38_NEWLINE_optional -> .
   ╭╴
   │ TYPE type_identifier = _27_NEWLINE_optional type_variants LINE variant ♦                      NEWLINE
   │                                                                        ╰_38_NEWLINE_optional╯ ╰_3_NEWLINE_optional╯
   │                                             ╰type_variants──────────────────────────────────╯
   │                                             ╰_28_type_variants_optional─────────────────────╯
   │ ╰enum───────────────────────────────────────────────────────────────────────────────────────╯
   │ ╰expr───────────────────────────────────────────────────────────────────────────────────────╯
   │ ╰do_exprs─────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ TYPE type_identifier = _27_NEWLINE_optional type_variants LINE variant ♦                      NEWLINE do_exprs
   │                                                                        ╰_38_NEWLINE_optional╯
   │                                             ╰type_variants──────────────────────────────────╯
   │                                             ╰_28_type_variants_optional─────────────────────╯
   │ ╰enum───────────────────────────────────────────────────────────────────────────────────────╯
   │ ╰expr───────────────────────────────────────────────────────────────────────────────────────╯
   │ ╰do_exprs────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ TYPE type_identifier = _27_NEWLINE_optional type_variants LINE variant ♦                      NEWLINE
   │                                                                        ╰_38_NEWLINE_optional╯ ╰_61_NEWLINE_optional╯
   │                                             ╰type_variants──────────────────────────────────╯
   │                                             ╰_28_type_variants_optional─────────────────────╯
   │ ╰enum───────────────────────────────────────────────────────────────────────────────────────╯
   │ ╰expr───────────────────────────────────────────────────────────────────────────────────────╯
   │ ╰exprs─────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ├╴
   │ exprs , _62_NEWLINE_optional TYPE type_identifier = _27_NEWLINE_optional type_variants LINE variant ♦                      NEWLINE
   │                                                                                                     ╰_38_NEWLINE_optional╯ ╰_63_NEWLINE_optional╯
   │                                                                          ╰type_variants──────────────────────────────────╯
   │                                                                          ╰_28_type_variants_optional─────────────────────╯
   │                              ╰enum───────────────────────────────────────────────────────────────────────────────────────╯
   │                              ╰expr───────────────────────────────────────────────────────────────────────────────────────╯
   │ ╰exprs──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
   ╰╴

reduce/reduce conflict for , in state 326 resolved using rule _64_0x2c_type_item -> , type
rejected rule (_26_0x2c_type_item -> , type) in state 326
   reduce using _64_0x2c_type_item -> , type with lookahead ,
   ╭╴
   │ , type ♦              , type
   │ ╰_64_0x2c_type_item╯  ╰_64_0x2c_type_item╯
   │ ╰_64_0x2c_type_items╯
   │ ╰_64_0x2c_type_items─────────────────────╯
   ╰╴

   reduce using _26_0x2c_type_item -> , type with lookahead ,
   ╭╴
   │ , type ♦              , type
   │ ╰_26_0x2c_type_item╯  ╰_26_0x2c_type_item╯
   │ ╰_26_0x2c_type_items╯
   │ ╰_26_0x2c_type_items─────────────────────╯
   ╰╴
