Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_optional _2_repeat
Rule 2     _1_optional -> stmt
Rule 3     _1_optional -> <empty>
Rule 4     _2_repeat -> _2_items
Rule 5     _2_repeat -> <empty>
Rule 6     _2_items -> _2_items _2_item
Rule 7     _2_items -> _2_item
Rule 8     _2_item -> NEWLINE stmt
Rule 9     stmt -> enum
Rule 10    stmt -> struct
Rule 11    stmt -> expr
Rule 12    expr -> ( expr )
Rule 13    expr -> - expr  [precedence=right, level=7]
Rule 14    expr -> tuple
Rule 15    expr -> array
Rule 16    expr -> binary_expr
Rule 17    expr -> type_identifier
Rule 18    expr -> identifier
Rule 19    expr -> variable_declaration
Rule 20    expr -> case_of
Rule 21    expr -> call
Rule 22    expr -> if_expr
Rule 23    expr -> def_expr
Rule 24    expr -> literal
Rule 25    expr -> do
Rule 26    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 27    binary_expr -> expr NOT_MORE expr  [precedence=left, level=2]
Rule 28    binary_expr -> expr NOT_LESS expr  [precedence=left, level=2]
Rule 29    binary_expr -> expr > expr  [precedence=left, level=2]
Rule 30    binary_expr -> expr < expr  [precedence=left, level=2]
Rule 31    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 32    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 33    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 34    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 35    binary_expr -> expr CONCAT expr  [precedence=left, level=3]
Rule 36    do -> DO _3_optional _4_optional _5_repeat END
Rule 37    _3_optional -> : type
Rule 38    _3_optional -> <empty>
Rule 39    _4_optional -> expr
Rule 40    _4_optional -> <empty>
Rule 41    _5_repeat -> _5_items
Rule 42    _5_repeat -> <empty>
Rule 43    _5_items -> _5_items _5_item
Rule 44    _5_items -> _5_item
Rule 45    _5_item -> NEWLINE expr
Rule 46    block_statement -> _6_optional _7_repeat
Rule 47    _6_optional -> expr
Rule 48    _6_optional -> <empty>
Rule 49    _7_repeat -> _7_items
Rule 50    _7_repeat -> <empty>
Rule 51    _7_items -> _7_items _7_item
Rule 52    _7_items -> _7_item
Rule 53    _7_item -> NEWLINE expr
Rule 54    def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do
Rule 55    _8_optional -> param
Rule 56    _8_optional -> <empty>
Rule 57    _9_repeat -> _9_items
Rule 58    _9_repeat -> <empty>
Rule 59    _9_items -> _9_items _9_item
Rule 60    _9_items -> _9_item
Rule 61    _9_item -> , param
Rule 62    _10_optional -> : type
Rule 63    _10_optional -> <empty>
Rule 64    type -> type_identifier _11_optional
Rule 65    _11_optional -> < type _12_repeat >  [precedence=left, level=2]
Rule 66    _12_repeat -> _12_items
Rule 67    _12_repeat -> <empty>
Rule 68    _12_items -> _12_items _12_item
Rule 69    _12_items -> _12_item
Rule 70    _12_item -> , type
Rule 71    _11_optional -> <empty>
Rule 72    struct -> STRUCT type_identifier _13_optional { _15_repeat }
Rule 73    _13_optional -> < identifier _14_repeat >  [precedence=left, level=2]
Rule 74    _14_repeat -> _14_items
Rule 75    _14_repeat -> <empty>
Rule 76    _14_items -> _14_items _14_item
Rule 77    _14_items -> _14_item
Rule 78    _14_item -> , identifier
Rule 79    _13_optional -> <empty>
Rule 80    _15_repeat -> _15_items
Rule 81    _15_repeat -> <empty>
Rule 82    _15_items -> _15_items _15_item
Rule 83    _15_items -> _15_item
Rule 84    _15_item -> identifier : type
Rule 85    enum -> ENUM type_identifier _16_optional { _17_repeat }
Rule 86    _16_optional -> < fields_unnamed >  [precedence=left, level=2]
Rule 87    _16_optional -> <empty>
Rule 88    _17_repeat -> _17_items
Rule 89    _17_repeat -> <empty>
Rule 90    _17_items -> _17_items _17_item
Rule 91    _17_items -> _17_item
Rule 92    _17_item -> variant
Rule 93    variant -> type_identifier _18_optional
Rule 94    _18_optional -> ( fields_unnamed )
Rule 95    _18_optional -> <empty>
Rule 96    fields_unnamed -> identifier _19_repeat
Rule 97    _19_repeat -> _19_items
Rule 98    _19_repeat -> <empty>
Rule 99    _19_items -> _19_items _19_item
Rule 100   _19_items -> _19_item
Rule 101   _19_item -> , identifier
Rule 102   param -> identifier _20_optional
Rule 103   _20_optional -> : type
Rule 104   _20_optional -> <empty>
Rule 105   if_expr -> IF expr THEN _21_optional block_statement _22_optional END
Rule 106   _21_optional -> : type
Rule 107   _21_optional -> <empty>
Rule 108   _22_optional -> or_else
Rule 109   _22_optional -> <empty>
Rule 110   or_else -> ELIF expr THEN block_statement _23_optional
Rule 111   _23_optional -> or_else
Rule 112   _23_optional -> <empty>
Rule 113   or_else -> ELSE block_statement
Rule 114   case_of -> CASE expr OF case _24_repeat END
Rule 115   _24_repeat -> _24_items
Rule 116   _24_repeat -> <empty>
Rule 117   _24_items -> _24_items _24_item
Rule 118   _24_items -> _24_item
Rule 119   _24_item -> case
Rule 120   case -> pattern do
Rule 121   pattern -> array_pattern
Rule 122   pattern -> tuple_pattern
Rule 123   pattern -> enum_pattern
Rule 124   pattern -> param_pattern
Rule 125   param_pattern -> identifier
Rule 126   array_pattern -> [ _25_optional _26_repeat ]
Rule 127   _25_optional -> pattern
Rule 128   _25_optional -> <empty>
Rule 129   _26_repeat -> _26_items
Rule 130   _26_repeat -> <empty>
Rule 131   _26_items -> _26_items _26_item
Rule 132   _26_items -> _26_item
Rule 133   _26_item -> , pattern
Rule 134   tuple_pattern -> { _27_optional _28_repeat }
Rule 135   _27_optional -> pattern
Rule 136   _27_optional -> <empty>
Rule 137   _28_repeat -> _28_items
Rule 138   _28_repeat -> <empty>
Rule 139   _28_items -> _28_items _28_item
Rule 140   _28_items -> _28_item
Rule 141   _28_item -> , pattern
Rule 142   enum_pattern -> type_identifier ( _29_optional _30_repeat )
Rule 143   _29_optional -> pattern
Rule 144   _29_optional -> <empty>
Rule 145   _30_repeat -> _30_items
Rule 146   _30_repeat -> <empty>
Rule 147   _30_items -> _30_items _30_item
Rule 148   _30_items -> _30_item
Rule 149   _30_item -> , pattern
Rule 150   type_identifier -> TYPE_IDENTIFIER
Rule 151   array -> [ _31_optional _32_repeat ]
Rule 152   _31_optional -> expr
Rule 153   _31_optional -> <empty>
Rule 154   _32_repeat -> _32_items
Rule 155   _32_repeat -> <empty>
Rule 156   _32_items -> _32_items _32_item
Rule 157   _32_items -> _32_item
Rule 158   _32_item -> , expr
Rule 159   tuple -> { _33_optional _34_repeat }
Rule 160   _33_optional -> expr
Rule 161   _33_optional -> <empty>
Rule 162   _34_repeat -> _34_items
Rule 163   _34_repeat -> <empty>
Rule 164   _34_items -> _34_items _34_item
Rule 165   _34_items -> _34_item
Rule 166   _34_item -> , expr
Rule 167   call -> expr ( _35_optional _36_repeat )
Rule 168   _35_optional -> expr
Rule 169   _35_optional -> <empty>
Rule 170   _36_repeat -> _36_items
Rule 171   _36_repeat -> <empty>
Rule 172   _36_items -> _36_items _36_item
Rule 173   _36_items -> _36_item
Rule 174   _36_item -> , expr
Rule 175   identifier -> IDENTIFIER
Rule 176   variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr  [precedence=left, level=2]
Rule 177   _37_repeat -> _37_items
Rule 178   _37_repeat -> <empty>
Rule 179   _37_items -> _37_items _37_item
Rule 180   _37_items -> _37_item
Rule 181   _37_item -> , type
Rule 182   variable_declaration -> identifier _38_optional = expr  [precedence=left, level=1]
Rule 183   _38_optional -> : type
Rule 184   _38_optional -> <empty>
Rule 185   literal -> STRING
Rule 186   literal -> NUMBER

Terminals, with rules where they appear:

(                    : 12 54 94 142 167
)                    : 12 54 94 142 167
*                    : 31
+                    : 34
,                    : 61 70 78 101 133 141 149 158 166 174 181
-                    : 13 33
/                    : 32
:                    : 37 62 84 103 106 176 183
<                    : 30 65 73 86 176
=                    : 182
>                    : 29 65 73 86
CASE                 : 114
CONCAT               : 35
DEF                  : 54
DO                   : 36
ELIF                 : 110
ELSE                 : 113
END                  : 36 105 114
ENUM                 : 85
IDENTIFIER           : 175
IF                   : 105
INT_DIV              : 26
NEWLINE              : 8 45 53
NOT_LESS             : 28 176
NOT_MORE             : 27
NUMBER               : 186
OF                   : 114
STRING               : 185
STRUCT               : 72
THEN                 : 105 110
TYPE_IDENTIFIER      : 150
[                    : 126 151
]                    : 126 151
error                : 
{                    : 72 85 134 159
}                    : 72 85 134 159

Nonterminals, with rules where they appear:

_10_optional         : 54
_11_optional         : 64
_12_item             : 68 69
_12_items            : 66 68
_12_repeat           : 65
_13_optional         : 72
_14_item             : 76 77
_14_items            : 74 76
_14_repeat           : 73
_15_item             : 82 83
_15_items            : 80 82
_15_repeat           : 72
_16_optional         : 85
_17_item             : 90 91
_17_items            : 88 90
_17_repeat           : 85
_18_optional         : 93
_19_item             : 99 100
_19_items            : 97 99
_19_repeat           : 96
_1_optional          : 1
_20_optional         : 102
_21_optional         : 105
_22_optional         : 105
_23_optional         : 110
_24_item             : 117 118
_24_items            : 115 117
_24_repeat           : 114
_25_optional         : 126
_26_item             : 131 132
_26_items            : 129 131
_26_repeat           : 126
_27_optional         : 134
_28_item             : 139 140
_28_items            : 137 139
_28_repeat           : 134
_29_optional         : 142
_2_item              : 6 7
_2_items             : 4 6
_2_repeat            : 1
_30_item             : 147 148
_30_items            : 145 147
_30_repeat           : 142
_31_optional         : 151
_32_item             : 156 157
_32_items            : 154 156
_32_repeat           : 151
_33_optional         : 159
_34_item             : 164 165
_34_items            : 162 164
_34_repeat           : 159
_35_optional         : 167
_36_item             : 172 173
_36_items            : 170 172
_36_repeat           : 167
_37_item             : 179 180
_37_items            : 177 179
_37_repeat           : 176
_38_optional         : 182
_3_optional          : 36
_4_optional          : 36
_5_item              : 43 44
_5_items             : 41 43
_5_repeat            : 36
_6_optional          : 46
_7_item              : 51 52
_7_items             : 49 51
_7_repeat            : 46
_8_optional          : 54
_9_item              : 59 60
_9_items             : 57 59
_9_repeat            : 54
array                : 15
array_pattern        : 121
binary_expr          : 16
block_statement      : 105 110 113
call                 : 21
case                 : 114 119
case_of              : 20
def_expr             : 23
do                   : 25 54 120
enum                 : 9
enum_pattern         : 123
expr                 : 11 12 13 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 39 45 47 53 105 110 114 152 158 160 166 167 168 174 176 182
fields_unnamed       : 86 94
identifier           : 18 54 73 78 84 96 101 102 125 176 182
if_expr              : 22
literal              : 24
or_else              : 108 111
param                : 55 61
param_pattern        : 124
pattern              : 120 127 133 135 141 143 149
program              : 0
stmt                 : 2 8
struct               : 10
tuple                : 14
tuple_pattern        : 122
type                 : 37 62 65 70 84 103 106 176 181 183
type_identifier      : 17 64 72 85 93 142 176
variable_declaration : 19
variant              : 92


state 0

    (0) S' -> . program
    (1) program -> . _1_optional _2_repeat
    (2) _1_optional -> . stmt
    (3) _1_optional -> .
    (9) stmt -> . enum
    (10) stmt -> . struct
    (11) stmt -> . expr
    (85) enum -> . ENUM type_identifier _16_optional { _17_repeat }
    (72) struct -> . STRUCT type_identifier _13_optional { _15_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    NEWLINE         reduce using rule 3 (_1_optional -> .)
    $end            reduce using rule 3 (_1_optional -> .)
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    program                        shift and go to state 1
    _1_optional                    shift and go to state 2
    stmt                           shift and go to state 3
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    type_identifier                shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_optional . _2_repeat
    (4) _2_repeat -> . _2_items
    (5) _2_repeat -> .
    (6) _2_items -> . _2_items _2_item
    (7) _2_items -> . _2_item
    (8) _2_item -> . NEWLINE stmt
    $end            reduce using rule 5 (_2_repeat -> .)
    NEWLINE         shift and go to state 36

    _2_repeat                      shift and go to state 33
    _2_items                       shift and go to state 34
    _2_item                        shift and go to state 35

state 3

    (2) _1_optional -> stmt .
    NEWLINE         reduce using rule 2 (_1_optional -> stmt .)
    $end            reduce using rule 2 (_1_optional -> stmt .)


state 4

    (9) stmt -> enum .
    NEWLINE         reduce using rule 9 (stmt -> enum .)
    $end            reduce using rule 9 (stmt -> enum .)


state 5

    (10) stmt -> struct .
    NEWLINE         reduce using rule 10 (stmt -> struct .)
    $end            reduce using rule 10 (stmt -> struct .)


state 6

    (11) stmt -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NEWLINE         reduce using rule 11 (stmt -> expr .)
    $end            reduce using rule 11 (stmt -> expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 7

    (85) enum -> ENUM . type_identifier _16_optional { _17_repeat }
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 48

state 8

    (17) expr -> type_identifier .
    INT_DIV         reduce using rule 17 (expr -> type_identifier .)
    NOT_MORE        reduce using rule 17 (expr -> type_identifier .)
    NOT_LESS        reduce using rule 17 (expr -> type_identifier .)
    >               reduce using rule 17 (expr -> type_identifier .)
    <               reduce using rule 17 (expr -> type_identifier .)
    *               reduce using rule 17 (expr -> type_identifier .)
    /               reduce using rule 17 (expr -> type_identifier .)
    -               reduce using rule 17 (expr -> type_identifier .)
    +               reduce using rule 17 (expr -> type_identifier .)
    CONCAT          reduce using rule 17 (expr -> type_identifier .)
    (               reduce using rule 17 (expr -> type_identifier .)
    NEWLINE         reduce using rule 17 (expr -> type_identifier .)
    $end            reduce using rule 17 (expr -> type_identifier .)
    ,               reduce using rule 17 (expr -> type_identifier .)
    }               reduce using rule 17 (expr -> type_identifier .)
    )               reduce using rule 17 (expr -> type_identifier .)
    ]               reduce using rule 17 (expr -> type_identifier .)
    OF              reduce using rule 17 (expr -> type_identifier .)
    THEN            reduce using rule 17 (expr -> type_identifier .)
    END             reduce using rule 17 (expr -> type_identifier .)
    ELIF            reduce using rule 17 (expr -> type_identifier .)
    ELSE            reduce using rule 17 (expr -> type_identifier .)


state 9

    (159) tuple -> { . _33_optional _34_repeat }
    (160) _33_optional -> . expr
    (161) _33_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    ,               reduce using rule 161 (_33_optional -> .)
    }               reduce using rule 161 (_33_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    _33_optional                   shift and go to state 49
    expr                           shift and go to state 50
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 10

    (72) struct -> STRUCT . type_identifier _13_optional { _15_repeat }
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 51

state 11

    (12) expr -> ( . expr )
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 52
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 12

    (13) expr -> - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 53
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 13

    (14) expr -> tuple .
    INT_DIV         reduce using rule 14 (expr -> tuple .)
    NOT_MORE        reduce using rule 14 (expr -> tuple .)
    NOT_LESS        reduce using rule 14 (expr -> tuple .)
    >               reduce using rule 14 (expr -> tuple .)
    <               reduce using rule 14 (expr -> tuple .)
    *               reduce using rule 14 (expr -> tuple .)
    /               reduce using rule 14 (expr -> tuple .)
    -               reduce using rule 14 (expr -> tuple .)
    +               reduce using rule 14 (expr -> tuple .)
    CONCAT          reduce using rule 14 (expr -> tuple .)
    (               reduce using rule 14 (expr -> tuple .)
    NEWLINE         reduce using rule 14 (expr -> tuple .)
    $end            reduce using rule 14 (expr -> tuple .)
    ,               reduce using rule 14 (expr -> tuple .)
    }               reduce using rule 14 (expr -> tuple .)
    )               reduce using rule 14 (expr -> tuple .)
    ]               reduce using rule 14 (expr -> tuple .)
    OF              reduce using rule 14 (expr -> tuple .)
    THEN            reduce using rule 14 (expr -> tuple .)
    END             reduce using rule 14 (expr -> tuple .)
    ELIF            reduce using rule 14 (expr -> tuple .)
    ELSE            reduce using rule 14 (expr -> tuple .)


state 14

    (15) expr -> array .
    INT_DIV         reduce using rule 15 (expr -> array .)
    NOT_MORE        reduce using rule 15 (expr -> array .)
    NOT_LESS        reduce using rule 15 (expr -> array .)
    >               reduce using rule 15 (expr -> array .)
    <               reduce using rule 15 (expr -> array .)
    *               reduce using rule 15 (expr -> array .)
    /               reduce using rule 15 (expr -> array .)
    -               reduce using rule 15 (expr -> array .)
    +               reduce using rule 15 (expr -> array .)
    CONCAT          reduce using rule 15 (expr -> array .)
    (               reduce using rule 15 (expr -> array .)
    NEWLINE         reduce using rule 15 (expr -> array .)
    $end            reduce using rule 15 (expr -> array .)
    ,               reduce using rule 15 (expr -> array .)
    }               reduce using rule 15 (expr -> array .)
    )               reduce using rule 15 (expr -> array .)
    ]               reduce using rule 15 (expr -> array .)
    OF              reduce using rule 15 (expr -> array .)
    THEN            reduce using rule 15 (expr -> array .)
    END             reduce using rule 15 (expr -> array .)
    ELIF            reduce using rule 15 (expr -> array .)
    ELSE            reduce using rule 15 (expr -> array .)


state 15

    (16) expr -> binary_expr .
    INT_DIV         reduce using rule 16 (expr -> binary_expr .)
    NOT_MORE        reduce using rule 16 (expr -> binary_expr .)
    NOT_LESS        reduce using rule 16 (expr -> binary_expr .)
    >               reduce using rule 16 (expr -> binary_expr .)
    <               reduce using rule 16 (expr -> binary_expr .)
    *               reduce using rule 16 (expr -> binary_expr .)
    /               reduce using rule 16 (expr -> binary_expr .)
    -               reduce using rule 16 (expr -> binary_expr .)
    +               reduce using rule 16 (expr -> binary_expr .)
    CONCAT          reduce using rule 16 (expr -> binary_expr .)
    (               reduce using rule 16 (expr -> binary_expr .)
    NEWLINE         reduce using rule 16 (expr -> binary_expr .)
    $end            reduce using rule 16 (expr -> binary_expr .)
    ,               reduce using rule 16 (expr -> binary_expr .)
    }               reduce using rule 16 (expr -> binary_expr .)
    )               reduce using rule 16 (expr -> binary_expr .)
    ]               reduce using rule 16 (expr -> binary_expr .)
    OF              reduce using rule 16 (expr -> binary_expr .)
    THEN            reduce using rule 16 (expr -> binary_expr .)
    END             reduce using rule 16 (expr -> binary_expr .)
    ELIF            reduce using rule 16 (expr -> binary_expr .)
    ELSE            reduce using rule 16 (expr -> binary_expr .)


state 16

    (18) expr -> identifier .
    (176) variable_declaration -> identifier . : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> identifier . _38_optional = expr
    (183) _38_optional -> . : type
    (184) _38_optional -> .
    INT_DIV         reduce using rule 18 (expr -> identifier .)
    NOT_MORE        reduce using rule 18 (expr -> identifier .)
    NOT_LESS        reduce using rule 18 (expr -> identifier .)
    >               reduce using rule 18 (expr -> identifier .)
    <               reduce using rule 18 (expr -> identifier .)
    *               reduce using rule 18 (expr -> identifier .)
    /               reduce using rule 18 (expr -> identifier .)
    -               reduce using rule 18 (expr -> identifier .)
    +               reduce using rule 18 (expr -> identifier .)
    CONCAT          reduce using rule 18 (expr -> identifier .)
    (               reduce using rule 18 (expr -> identifier .)
    NEWLINE         reduce using rule 18 (expr -> identifier .)
    $end            reduce using rule 18 (expr -> identifier .)
    ,               reduce using rule 18 (expr -> identifier .)
    }               reduce using rule 18 (expr -> identifier .)
    )               reduce using rule 18 (expr -> identifier .)
    ]               reduce using rule 18 (expr -> identifier .)
    OF              reduce using rule 18 (expr -> identifier .)
    THEN            reduce using rule 18 (expr -> identifier .)
    END             reduce using rule 18 (expr -> identifier .)
    ELIF            reduce using rule 18 (expr -> identifier .)
    ELSE            reduce using rule 18 (expr -> identifier .)
    :               shift and go to state 54
    =               reduce using rule 184 (_38_optional -> .)

    _38_optional                   shift and go to state 55

state 17

    (19) expr -> variable_declaration .
    INT_DIV         reduce using rule 19 (expr -> variable_declaration .)
    NOT_MORE        reduce using rule 19 (expr -> variable_declaration .)
    NOT_LESS        reduce using rule 19 (expr -> variable_declaration .)
    >               reduce using rule 19 (expr -> variable_declaration .)
    <               reduce using rule 19 (expr -> variable_declaration .)
    *               reduce using rule 19 (expr -> variable_declaration .)
    /               reduce using rule 19 (expr -> variable_declaration .)
    -               reduce using rule 19 (expr -> variable_declaration .)
    +               reduce using rule 19 (expr -> variable_declaration .)
    CONCAT          reduce using rule 19 (expr -> variable_declaration .)
    (               reduce using rule 19 (expr -> variable_declaration .)
    NEWLINE         reduce using rule 19 (expr -> variable_declaration .)
    $end            reduce using rule 19 (expr -> variable_declaration .)
    ,               reduce using rule 19 (expr -> variable_declaration .)
    }               reduce using rule 19 (expr -> variable_declaration .)
    )               reduce using rule 19 (expr -> variable_declaration .)
    ]               reduce using rule 19 (expr -> variable_declaration .)
    OF              reduce using rule 19 (expr -> variable_declaration .)
    THEN            reduce using rule 19 (expr -> variable_declaration .)
    END             reduce using rule 19 (expr -> variable_declaration .)
    ELIF            reduce using rule 19 (expr -> variable_declaration .)
    ELSE            reduce using rule 19 (expr -> variable_declaration .)


state 18

    (20) expr -> case_of .
    INT_DIV         reduce using rule 20 (expr -> case_of .)
    NOT_MORE        reduce using rule 20 (expr -> case_of .)
    NOT_LESS        reduce using rule 20 (expr -> case_of .)
    >               reduce using rule 20 (expr -> case_of .)
    <               reduce using rule 20 (expr -> case_of .)
    *               reduce using rule 20 (expr -> case_of .)
    /               reduce using rule 20 (expr -> case_of .)
    -               reduce using rule 20 (expr -> case_of .)
    +               reduce using rule 20 (expr -> case_of .)
    CONCAT          reduce using rule 20 (expr -> case_of .)
    (               reduce using rule 20 (expr -> case_of .)
    NEWLINE         reduce using rule 20 (expr -> case_of .)
    $end            reduce using rule 20 (expr -> case_of .)
    ,               reduce using rule 20 (expr -> case_of .)
    }               reduce using rule 20 (expr -> case_of .)
    )               reduce using rule 20 (expr -> case_of .)
    ]               reduce using rule 20 (expr -> case_of .)
    OF              reduce using rule 20 (expr -> case_of .)
    THEN            reduce using rule 20 (expr -> case_of .)
    END             reduce using rule 20 (expr -> case_of .)
    ELIF            reduce using rule 20 (expr -> case_of .)
    ELSE            reduce using rule 20 (expr -> case_of .)


state 19

    (21) expr -> call .
    INT_DIV         reduce using rule 21 (expr -> call .)
    NOT_MORE        reduce using rule 21 (expr -> call .)
    NOT_LESS        reduce using rule 21 (expr -> call .)
    >               reduce using rule 21 (expr -> call .)
    <               reduce using rule 21 (expr -> call .)
    *               reduce using rule 21 (expr -> call .)
    /               reduce using rule 21 (expr -> call .)
    -               reduce using rule 21 (expr -> call .)
    +               reduce using rule 21 (expr -> call .)
    CONCAT          reduce using rule 21 (expr -> call .)
    (               reduce using rule 21 (expr -> call .)
    NEWLINE         reduce using rule 21 (expr -> call .)
    $end            reduce using rule 21 (expr -> call .)
    ,               reduce using rule 21 (expr -> call .)
    }               reduce using rule 21 (expr -> call .)
    )               reduce using rule 21 (expr -> call .)
    ]               reduce using rule 21 (expr -> call .)
    OF              reduce using rule 21 (expr -> call .)
    THEN            reduce using rule 21 (expr -> call .)
    END             reduce using rule 21 (expr -> call .)
    ELIF            reduce using rule 21 (expr -> call .)
    ELSE            reduce using rule 21 (expr -> call .)


state 20

    (22) expr -> if_expr .
    INT_DIV         reduce using rule 22 (expr -> if_expr .)
    NOT_MORE        reduce using rule 22 (expr -> if_expr .)
    NOT_LESS        reduce using rule 22 (expr -> if_expr .)
    >               reduce using rule 22 (expr -> if_expr .)
    <               reduce using rule 22 (expr -> if_expr .)
    *               reduce using rule 22 (expr -> if_expr .)
    /               reduce using rule 22 (expr -> if_expr .)
    -               reduce using rule 22 (expr -> if_expr .)
    +               reduce using rule 22 (expr -> if_expr .)
    CONCAT          reduce using rule 22 (expr -> if_expr .)
    (               reduce using rule 22 (expr -> if_expr .)
    NEWLINE         reduce using rule 22 (expr -> if_expr .)
    $end            reduce using rule 22 (expr -> if_expr .)
    ,               reduce using rule 22 (expr -> if_expr .)
    }               reduce using rule 22 (expr -> if_expr .)
    )               reduce using rule 22 (expr -> if_expr .)
    ]               reduce using rule 22 (expr -> if_expr .)
    OF              reduce using rule 22 (expr -> if_expr .)
    THEN            reduce using rule 22 (expr -> if_expr .)
    END             reduce using rule 22 (expr -> if_expr .)
    ELIF            reduce using rule 22 (expr -> if_expr .)
    ELSE            reduce using rule 22 (expr -> if_expr .)


state 21

    (23) expr -> def_expr .
    INT_DIV         reduce using rule 23 (expr -> def_expr .)
    NOT_MORE        reduce using rule 23 (expr -> def_expr .)
    NOT_LESS        reduce using rule 23 (expr -> def_expr .)
    >               reduce using rule 23 (expr -> def_expr .)
    <               reduce using rule 23 (expr -> def_expr .)
    *               reduce using rule 23 (expr -> def_expr .)
    /               reduce using rule 23 (expr -> def_expr .)
    -               reduce using rule 23 (expr -> def_expr .)
    +               reduce using rule 23 (expr -> def_expr .)
    CONCAT          reduce using rule 23 (expr -> def_expr .)
    (               reduce using rule 23 (expr -> def_expr .)
    NEWLINE         reduce using rule 23 (expr -> def_expr .)
    $end            reduce using rule 23 (expr -> def_expr .)
    ,               reduce using rule 23 (expr -> def_expr .)
    }               reduce using rule 23 (expr -> def_expr .)
    )               reduce using rule 23 (expr -> def_expr .)
    ]               reduce using rule 23 (expr -> def_expr .)
    OF              reduce using rule 23 (expr -> def_expr .)
    THEN            reduce using rule 23 (expr -> def_expr .)
    END             reduce using rule 23 (expr -> def_expr .)
    ELIF            reduce using rule 23 (expr -> def_expr .)
    ELSE            reduce using rule 23 (expr -> def_expr .)


state 22

    (24) expr -> literal .
    INT_DIV         reduce using rule 24 (expr -> literal .)
    NOT_MORE        reduce using rule 24 (expr -> literal .)
    NOT_LESS        reduce using rule 24 (expr -> literal .)
    >               reduce using rule 24 (expr -> literal .)
    <               reduce using rule 24 (expr -> literal .)
    *               reduce using rule 24 (expr -> literal .)
    /               reduce using rule 24 (expr -> literal .)
    -               reduce using rule 24 (expr -> literal .)
    +               reduce using rule 24 (expr -> literal .)
    CONCAT          reduce using rule 24 (expr -> literal .)
    (               reduce using rule 24 (expr -> literal .)
    NEWLINE         reduce using rule 24 (expr -> literal .)
    $end            reduce using rule 24 (expr -> literal .)
    ,               reduce using rule 24 (expr -> literal .)
    }               reduce using rule 24 (expr -> literal .)
    )               reduce using rule 24 (expr -> literal .)
    ]               reduce using rule 24 (expr -> literal .)
    OF              reduce using rule 24 (expr -> literal .)
    THEN            reduce using rule 24 (expr -> literal .)
    END             reduce using rule 24 (expr -> literal .)
    ELIF            reduce using rule 24 (expr -> literal .)
    ELSE            reduce using rule 24 (expr -> literal .)


state 23

    (25) expr -> do .
    INT_DIV         reduce using rule 25 (expr -> do .)
    NOT_MORE        reduce using rule 25 (expr -> do .)
    NOT_LESS        reduce using rule 25 (expr -> do .)
    >               reduce using rule 25 (expr -> do .)
    <               reduce using rule 25 (expr -> do .)
    *               reduce using rule 25 (expr -> do .)
    /               reduce using rule 25 (expr -> do .)
    -               reduce using rule 25 (expr -> do .)
    +               reduce using rule 25 (expr -> do .)
    CONCAT          reduce using rule 25 (expr -> do .)
    (               reduce using rule 25 (expr -> do .)
    NEWLINE         reduce using rule 25 (expr -> do .)
    $end            reduce using rule 25 (expr -> do .)
    ,               reduce using rule 25 (expr -> do .)
    }               reduce using rule 25 (expr -> do .)
    )               reduce using rule 25 (expr -> do .)
    ]               reduce using rule 25 (expr -> do .)
    OF              reduce using rule 25 (expr -> do .)
    THEN            reduce using rule 25 (expr -> do .)
    END             reduce using rule 25 (expr -> do .)
    ELIF            reduce using rule 25 (expr -> do .)
    ELSE            reduce using rule 25 (expr -> do .)


state 24

    (151) array -> [ . _31_optional _32_repeat ]
    (152) _31_optional -> . expr
    (153) _31_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    ,               reduce using rule 153 (_31_optional -> .)
    ]               reduce using rule 153 (_31_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    _31_optional                   shift and go to state 56
    expr                           shift and go to state 57
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 25

    (150) type_identifier -> TYPE_IDENTIFIER .
    INT_DIV         reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    NOT_MORE        reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    NOT_LESS        reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    *               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    /               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    +               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    CONCAT          reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    (               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    $end            reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    ]               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    OF              reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    THEN            reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 150 (type_identifier -> TYPE_IDENTIFIER .)


state 26

    (175) identifier -> IDENTIFIER .
    :               reduce using rule 175 (identifier -> IDENTIFIER .)
    =               reduce using rule 175 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 175 (identifier -> IDENTIFIER .)
    NOT_MORE        reduce using rule 175 (identifier -> IDENTIFIER .)
    NOT_LESS        reduce using rule 175 (identifier -> IDENTIFIER .)
    >               reduce using rule 175 (identifier -> IDENTIFIER .)
    <               reduce using rule 175 (identifier -> IDENTIFIER .)
    *               reduce using rule 175 (identifier -> IDENTIFIER .)
    /               reduce using rule 175 (identifier -> IDENTIFIER .)
    -               reduce using rule 175 (identifier -> IDENTIFIER .)
    +               reduce using rule 175 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 175 (identifier -> IDENTIFIER .)
    (               reduce using rule 175 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 175 (identifier -> IDENTIFIER .)
    $end            reduce using rule 175 (identifier -> IDENTIFIER .)
    ,               reduce using rule 175 (identifier -> IDENTIFIER .)
    }               reduce using rule 175 (identifier -> IDENTIFIER .)
    )               reduce using rule 175 (identifier -> IDENTIFIER .)
    ]               reduce using rule 175 (identifier -> IDENTIFIER .)
    OF              reduce using rule 175 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 175 (identifier -> IDENTIFIER .)
    END             reduce using rule 175 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 175 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 175 (identifier -> IDENTIFIER .)
    DO              reduce using rule 175 (identifier -> IDENTIFIER .)


state 27

    (114) case_of -> CASE . expr OF case _24_repeat END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 58
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 28

    (105) if_expr -> IF . expr THEN _21_optional block_statement _22_optional END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 59
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 29

    (54) def_expr -> DEF . identifier ( _8_optional _9_repeat ) _10_optional do
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 60

state 30

    (185) literal -> STRING .
    INT_DIV         reduce using rule 185 (literal -> STRING .)
    NOT_MORE        reduce using rule 185 (literal -> STRING .)
    NOT_LESS        reduce using rule 185 (literal -> STRING .)
    >               reduce using rule 185 (literal -> STRING .)
    <               reduce using rule 185 (literal -> STRING .)
    *               reduce using rule 185 (literal -> STRING .)
    /               reduce using rule 185 (literal -> STRING .)
    -               reduce using rule 185 (literal -> STRING .)
    +               reduce using rule 185 (literal -> STRING .)
    CONCAT          reduce using rule 185 (literal -> STRING .)
    (               reduce using rule 185 (literal -> STRING .)
    NEWLINE         reduce using rule 185 (literal -> STRING .)
    $end            reduce using rule 185 (literal -> STRING .)
    ,               reduce using rule 185 (literal -> STRING .)
    }               reduce using rule 185 (literal -> STRING .)
    )               reduce using rule 185 (literal -> STRING .)
    ]               reduce using rule 185 (literal -> STRING .)
    OF              reduce using rule 185 (literal -> STRING .)
    THEN            reduce using rule 185 (literal -> STRING .)
    END             reduce using rule 185 (literal -> STRING .)
    ELIF            reduce using rule 185 (literal -> STRING .)
    ELSE            reduce using rule 185 (literal -> STRING .)


state 31

    (186) literal -> NUMBER .
    INT_DIV         reduce using rule 186 (literal -> NUMBER .)
    NOT_MORE        reduce using rule 186 (literal -> NUMBER .)
    NOT_LESS        reduce using rule 186 (literal -> NUMBER .)
    >               reduce using rule 186 (literal -> NUMBER .)
    <               reduce using rule 186 (literal -> NUMBER .)
    *               reduce using rule 186 (literal -> NUMBER .)
    /               reduce using rule 186 (literal -> NUMBER .)
    -               reduce using rule 186 (literal -> NUMBER .)
    +               reduce using rule 186 (literal -> NUMBER .)
    CONCAT          reduce using rule 186 (literal -> NUMBER .)
    (               reduce using rule 186 (literal -> NUMBER .)
    NEWLINE         reduce using rule 186 (literal -> NUMBER .)
    $end            reduce using rule 186 (literal -> NUMBER .)
    ,               reduce using rule 186 (literal -> NUMBER .)
    }               reduce using rule 186 (literal -> NUMBER .)
    )               reduce using rule 186 (literal -> NUMBER .)
    ]               reduce using rule 186 (literal -> NUMBER .)
    OF              reduce using rule 186 (literal -> NUMBER .)
    THEN            reduce using rule 186 (literal -> NUMBER .)
    END             reduce using rule 186 (literal -> NUMBER .)
    ELIF            reduce using rule 186 (literal -> NUMBER .)
    ELSE            reduce using rule 186 (literal -> NUMBER .)


state 32

    (36) do -> DO . _3_optional _4_optional _5_repeat END
    (37) _3_optional -> . : type
    (38) _3_optional -> .
    :               shift and go to state 62
    (               reduce using rule 38 (_3_optional -> .)
    -               reduce using rule 38 (_3_optional -> .)
    {               reduce using rule 38 (_3_optional -> .)
    [               reduce using rule 38 (_3_optional -> .)
    TYPE_IDENTIFIER reduce using rule 38 (_3_optional -> .)
    IDENTIFIER      reduce using rule 38 (_3_optional -> .)
    CASE            reduce using rule 38 (_3_optional -> .)
    IF              reduce using rule 38 (_3_optional -> .)
    DEF             reduce using rule 38 (_3_optional -> .)
    STRING          reduce using rule 38 (_3_optional -> .)
    NUMBER          reduce using rule 38 (_3_optional -> .)
    DO              reduce using rule 38 (_3_optional -> .)
    NEWLINE         reduce using rule 38 (_3_optional -> .)
    END             reduce using rule 38 (_3_optional -> .)

    _3_optional                    shift and go to state 61

state 33

    (1) program -> _1_optional _2_repeat .
    $end            reduce using rule 1 (program -> _1_optional _2_repeat .)


state 34

    (4) _2_repeat -> _2_items .
    (6) _2_items -> _2_items . _2_item
    (8) _2_item -> . NEWLINE stmt
    $end            reduce using rule 4 (_2_repeat -> _2_items .)
    NEWLINE         shift and go to state 36

    _2_item                        shift and go to state 63

state 35

    (7) _2_items -> _2_item .
    NEWLINE         reduce using rule 7 (_2_items -> _2_item .)
    $end            reduce using rule 7 (_2_items -> _2_item .)


state 36

    (8) _2_item -> NEWLINE . stmt
    (9) stmt -> . enum
    (10) stmt -> . struct
    (11) stmt -> . expr
    (85) enum -> . ENUM type_identifier _16_optional { _17_repeat }
    (72) struct -> . STRUCT type_identifier _13_optional { _15_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    stmt                           shift and go to state 64
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    type_identifier                shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 37

    (26) binary_expr -> expr INT_DIV . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 65
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 38

    (27) binary_expr -> expr NOT_MORE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 66
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 39

    (28) binary_expr -> expr NOT_LESS . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 67
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 40

    (29) binary_expr -> expr > . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 68
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 41

    (30) binary_expr -> expr < . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 69
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 42

    (31) binary_expr -> expr * . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 70
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 43

    (32) binary_expr -> expr / . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 71
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 44

    (33) binary_expr -> expr - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 72
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 45

    (34) binary_expr -> expr + . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 73
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 46

    (35) binary_expr -> expr CONCAT . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 74
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 47

    (167) call -> expr ( . _35_optional _36_repeat )
    (168) _35_optional -> . expr
    (169) _35_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    ,               reduce using rule 169 (_35_optional -> .)
    )               reduce using rule 169 (_35_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 75
    _35_optional                   shift and go to state 76
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 48

    (85) enum -> ENUM type_identifier . _16_optional { _17_repeat }
    (86) _16_optional -> . < fields_unnamed >
    (87) _16_optional -> .
    <               shift and go to state 78
    {               reduce using rule 87 (_16_optional -> .)

    _16_optional                   shift and go to state 77

state 49

    (159) tuple -> { _33_optional . _34_repeat }
    (162) _34_repeat -> . _34_items
    (163) _34_repeat -> .
    (164) _34_items -> . _34_items _34_item
    (165) _34_items -> . _34_item
    (166) _34_item -> . , expr
    }               reduce using rule 163 (_34_repeat -> .)
    ,               shift and go to state 82

    _34_repeat                     shift and go to state 79
    _34_items                      shift and go to state 80
    _34_item                       shift and go to state 81

state 50

    (160) _33_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    ,               reduce using rule 160 (_33_optional -> expr .)
    }               reduce using rule 160 (_33_optional -> expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 51

    (72) struct -> STRUCT type_identifier . _13_optional { _15_repeat }
    (73) _13_optional -> . < identifier _14_repeat >
    (79) _13_optional -> .
    <               shift and go to state 84
    {               reduce using rule 79 (_13_optional -> .)

    _13_optional                   shift and go to state 83

state 52

    (12) expr -> ( expr . )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    )               shift and go to state 85
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 53

    (13) expr -> - expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    INT_DIV         reduce using rule 13 (expr -> - expr .)
    NOT_MORE        reduce using rule 13 (expr -> - expr .)
    NOT_LESS        reduce using rule 13 (expr -> - expr .)
    >               reduce using rule 13 (expr -> - expr .)
    <               reduce using rule 13 (expr -> - expr .)
    *               reduce using rule 13 (expr -> - expr .)
    /               reduce using rule 13 (expr -> - expr .)
    -               reduce using rule 13 (expr -> - expr .)
    +               reduce using rule 13 (expr -> - expr .)
    CONCAT          reduce using rule 13 (expr -> - expr .)
    (               reduce using rule 13 (expr -> - expr .)
    NEWLINE         reduce using rule 13 (expr -> - expr .)
    $end            reduce using rule 13 (expr -> - expr .)
    ,               reduce using rule 13 (expr -> - expr .)
    }               reduce using rule 13 (expr -> - expr .)
    )               reduce using rule 13 (expr -> - expr .)
    ]               reduce using rule 13 (expr -> - expr .)
    OF              reduce using rule 13 (expr -> - expr .)
    THEN            reduce using rule 13 (expr -> - expr .)
    END             reduce using rule 13 (expr -> - expr .)
    ELIF            reduce using rule 13 (expr -> - expr .)
    ELSE            reduce using rule 13 (expr -> - expr .)


state 54

    (176) variable_declaration -> identifier : . type_identifier < type _37_repeat NOT_LESS expr
    (183) _38_optional -> : . type
    (150) type_identifier -> . TYPE_IDENTIFIER
    (64) type -> . type_identifier _11_optional
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 86
    type                           shift and go to state 87

state 55

    (182) variable_declaration -> identifier _38_optional . = expr
    =               shift and go to state 88


state 56

    (151) array -> [ _31_optional . _32_repeat ]
    (154) _32_repeat -> . _32_items
    (155) _32_repeat -> .
    (156) _32_items -> . _32_items _32_item
    (157) _32_items -> . _32_item
    (158) _32_item -> . , expr
    ]               reduce using rule 155 (_32_repeat -> .)
    ,               shift and go to state 92

    _32_repeat                     shift and go to state 89
    _32_items                      shift and go to state 90
    _32_item                       shift and go to state 91

state 57

    (152) _31_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    ,               reduce using rule 152 (_31_optional -> expr .)
    ]               reduce using rule 152 (_31_optional -> expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 58

    (114) case_of -> CASE expr . OF case _24_repeat END
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    OF              shift and go to state 93
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 59

    (105) if_expr -> IF expr . THEN _21_optional block_statement _22_optional END
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    THEN            shift and go to state 94
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 60

    (54) def_expr -> DEF identifier . ( _8_optional _9_repeat ) _10_optional do
    (               shift and go to state 95


state 61

    (36) do -> DO _3_optional . _4_optional _5_repeat END
    (39) _4_optional -> . expr
    (40) _4_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    NEWLINE         reduce using rule 40 (_4_optional -> .)
    END             reduce using rule 40 (_4_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    _4_optional                    shift and go to state 96
    expr                           shift and go to state 97
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 62

    (37) _3_optional -> : . type
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 98
    type_identifier                shift and go to state 99

state 63

    (6) _2_items -> _2_items _2_item .
    NEWLINE         reduce using rule 6 (_2_items -> _2_items _2_item .)
    $end            reduce using rule 6 (_2_items -> _2_items _2_item .)


state 64

    (8) _2_item -> NEWLINE stmt .
    NEWLINE         reduce using rule 8 (_2_item -> NEWLINE stmt .)
    $end            reduce using rule 8 (_2_item -> NEWLINE stmt .)


state 65

    (26) binary_expr -> expr INT_DIV expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    INT_DIV         reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    NOT_MORE        reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    NOT_LESS        reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    NEWLINE         reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    }               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    (               shift and go to state 47


state 66

    (27) binary_expr -> expr NOT_MORE expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NOT_MORE        reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    NOT_LESS        reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    >               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    <               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    NEWLINE         reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    $end            reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    ,               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    }               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    )               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    ]               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    OF              reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    THEN            reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    END             reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    INT_DIV         shift and go to state 37
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 67

    (28) binary_expr -> expr NOT_LESS expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NOT_MORE        reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    NOT_LESS        reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    >               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    <               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    NEWLINE         reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    $end            reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    ,               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    }               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    )               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    ]               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    OF              reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    THEN            reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    END             reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    INT_DIV         shift and go to state 37
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 68

    (29) binary_expr -> expr > expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NOT_MORE        reduce using rule 29 (binary_expr -> expr > expr .)
    NOT_LESS        reduce using rule 29 (binary_expr -> expr > expr .)
    >               reduce using rule 29 (binary_expr -> expr > expr .)
    <               reduce using rule 29 (binary_expr -> expr > expr .)
    NEWLINE         reduce using rule 29 (binary_expr -> expr > expr .)
    $end            reduce using rule 29 (binary_expr -> expr > expr .)
    ,               reduce using rule 29 (binary_expr -> expr > expr .)
    }               reduce using rule 29 (binary_expr -> expr > expr .)
    )               reduce using rule 29 (binary_expr -> expr > expr .)
    ]               reduce using rule 29 (binary_expr -> expr > expr .)
    OF              reduce using rule 29 (binary_expr -> expr > expr .)
    THEN            reduce using rule 29 (binary_expr -> expr > expr .)
    END             reduce using rule 29 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr > expr .)
    INT_DIV         shift and go to state 37
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 69

    (30) binary_expr -> expr < expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NOT_MORE        reduce using rule 30 (binary_expr -> expr < expr .)
    NOT_LESS        reduce using rule 30 (binary_expr -> expr < expr .)
    >               reduce using rule 30 (binary_expr -> expr < expr .)
    <               reduce using rule 30 (binary_expr -> expr < expr .)
    NEWLINE         reduce using rule 30 (binary_expr -> expr < expr .)
    $end            reduce using rule 30 (binary_expr -> expr < expr .)
    ,               reduce using rule 30 (binary_expr -> expr < expr .)
    }               reduce using rule 30 (binary_expr -> expr < expr .)
    )               reduce using rule 30 (binary_expr -> expr < expr .)
    ]               reduce using rule 30 (binary_expr -> expr < expr .)
    OF              reduce using rule 30 (binary_expr -> expr < expr .)
    THEN            reduce using rule 30 (binary_expr -> expr < expr .)
    END             reduce using rule 30 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr < expr .)
    INT_DIV         shift and go to state 37
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 70

    (31) binary_expr -> expr * expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    INT_DIV         reduce using rule 31 (binary_expr -> expr * expr .)
    NOT_MORE        reduce using rule 31 (binary_expr -> expr * expr .)
    NOT_LESS        reduce using rule 31 (binary_expr -> expr * expr .)
    >               reduce using rule 31 (binary_expr -> expr * expr .)
    <               reduce using rule 31 (binary_expr -> expr * expr .)
    *               reduce using rule 31 (binary_expr -> expr * expr .)
    /               reduce using rule 31 (binary_expr -> expr * expr .)
    -               reduce using rule 31 (binary_expr -> expr * expr .)
    +               reduce using rule 31 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 31 (binary_expr -> expr * expr .)
    NEWLINE         reduce using rule 31 (binary_expr -> expr * expr .)
    $end            reduce using rule 31 (binary_expr -> expr * expr .)
    ,               reduce using rule 31 (binary_expr -> expr * expr .)
    }               reduce using rule 31 (binary_expr -> expr * expr .)
    )               reduce using rule 31 (binary_expr -> expr * expr .)
    ]               reduce using rule 31 (binary_expr -> expr * expr .)
    OF              reduce using rule 31 (binary_expr -> expr * expr .)
    THEN            reduce using rule 31 (binary_expr -> expr * expr .)
    END             reduce using rule 31 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr * expr .)
    (               shift and go to state 47


state 71

    (32) binary_expr -> expr / expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    INT_DIV         reduce using rule 32 (binary_expr -> expr / expr .)
    NOT_MORE        reduce using rule 32 (binary_expr -> expr / expr .)
    NOT_LESS        reduce using rule 32 (binary_expr -> expr / expr .)
    >               reduce using rule 32 (binary_expr -> expr / expr .)
    <               reduce using rule 32 (binary_expr -> expr / expr .)
    *               reduce using rule 32 (binary_expr -> expr / expr .)
    /               reduce using rule 32 (binary_expr -> expr / expr .)
    -               reduce using rule 32 (binary_expr -> expr / expr .)
    +               reduce using rule 32 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 32 (binary_expr -> expr / expr .)
    NEWLINE         reduce using rule 32 (binary_expr -> expr / expr .)
    $end            reduce using rule 32 (binary_expr -> expr / expr .)
    ,               reduce using rule 32 (binary_expr -> expr / expr .)
    }               reduce using rule 32 (binary_expr -> expr / expr .)
    )               reduce using rule 32 (binary_expr -> expr / expr .)
    ]               reduce using rule 32 (binary_expr -> expr / expr .)
    OF              reduce using rule 32 (binary_expr -> expr / expr .)
    THEN            reduce using rule 32 (binary_expr -> expr / expr .)
    END             reduce using rule 32 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr / expr .)
    (               shift and go to state 47


state 72

    (33) binary_expr -> expr - expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NOT_MORE        reduce using rule 33 (binary_expr -> expr - expr .)
    NOT_LESS        reduce using rule 33 (binary_expr -> expr - expr .)
    >               reduce using rule 33 (binary_expr -> expr - expr .)
    <               reduce using rule 33 (binary_expr -> expr - expr .)
    -               reduce using rule 33 (binary_expr -> expr - expr .)
    +               reduce using rule 33 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 33 (binary_expr -> expr - expr .)
    NEWLINE         reduce using rule 33 (binary_expr -> expr - expr .)
    $end            reduce using rule 33 (binary_expr -> expr - expr .)
    ,               reduce using rule 33 (binary_expr -> expr - expr .)
    }               reduce using rule 33 (binary_expr -> expr - expr .)
    )               reduce using rule 33 (binary_expr -> expr - expr .)
    ]               reduce using rule 33 (binary_expr -> expr - expr .)
    OF              reduce using rule 33 (binary_expr -> expr - expr .)
    THEN            reduce using rule 33 (binary_expr -> expr - expr .)
    END             reduce using rule 33 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr - expr .)
    INT_DIV         shift and go to state 37
    *               shift and go to state 42
    /               shift and go to state 43
    (               shift and go to state 47


state 73

    (34) binary_expr -> expr + expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NOT_MORE        reduce using rule 34 (binary_expr -> expr + expr .)
    NOT_LESS        reduce using rule 34 (binary_expr -> expr + expr .)
    >               reduce using rule 34 (binary_expr -> expr + expr .)
    <               reduce using rule 34 (binary_expr -> expr + expr .)
    -               reduce using rule 34 (binary_expr -> expr + expr .)
    +               reduce using rule 34 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr + expr .)
    NEWLINE         reduce using rule 34 (binary_expr -> expr + expr .)
    $end            reduce using rule 34 (binary_expr -> expr + expr .)
    ,               reduce using rule 34 (binary_expr -> expr + expr .)
    }               reduce using rule 34 (binary_expr -> expr + expr .)
    )               reduce using rule 34 (binary_expr -> expr + expr .)
    ]               reduce using rule 34 (binary_expr -> expr + expr .)
    OF              reduce using rule 34 (binary_expr -> expr + expr .)
    THEN            reduce using rule 34 (binary_expr -> expr + expr .)
    END             reduce using rule 34 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr + expr .)
    INT_DIV         shift and go to state 37
    *               shift and go to state 42
    /               shift and go to state 43
    (               shift and go to state 47


state 74

    (35) binary_expr -> expr CONCAT expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NOT_MORE        reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    NOT_LESS        reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    NEWLINE         reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    }               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    INT_DIV         shift and go to state 37
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    (               shift and go to state 47


state 75

    (168) _35_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    ,               reduce using rule 168 (_35_optional -> expr .)
    )               reduce using rule 168 (_35_optional -> expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 76

    (167) call -> expr ( _35_optional . _36_repeat )
    (170) _36_repeat -> . _36_items
    (171) _36_repeat -> .
    (172) _36_items -> . _36_items _36_item
    (173) _36_items -> . _36_item
    (174) _36_item -> . , expr
    )               reduce using rule 171 (_36_repeat -> .)
    ,               shift and go to state 103

    _36_repeat                     shift and go to state 100
    _36_items                      shift and go to state 101
    _36_item                       shift and go to state 102

state 77

    (85) enum -> ENUM type_identifier _16_optional . { _17_repeat }
    {               shift and go to state 104


state 78

    (86) _16_optional -> < . fields_unnamed >
    (96) fields_unnamed -> . identifier _19_repeat
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    fields_unnamed                 shift and go to state 105
    identifier                     shift and go to state 106

state 79

    (159) tuple -> { _33_optional _34_repeat . }
    }               shift and go to state 107


state 80

    (162) _34_repeat -> _34_items .
    (164) _34_items -> _34_items . _34_item
    (166) _34_item -> . , expr
    }               reduce using rule 162 (_34_repeat -> _34_items .)
    ,               shift and go to state 82

    _34_item                       shift and go to state 108

state 81

    (165) _34_items -> _34_item .
    ,               reduce using rule 165 (_34_items -> _34_item .)
    }               reduce using rule 165 (_34_items -> _34_item .)


state 82

    (166) _34_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 109
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 83

    (72) struct -> STRUCT type_identifier _13_optional . { _15_repeat }
    {               shift and go to state 110


state 84

    (73) _13_optional -> < . identifier _14_repeat >
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 111

state 85

    (12) expr -> ( expr ) .
    INT_DIV         reduce using rule 12 (expr -> ( expr ) .)
    NOT_MORE        reduce using rule 12 (expr -> ( expr ) .)
    NOT_LESS        reduce using rule 12 (expr -> ( expr ) .)
    >               reduce using rule 12 (expr -> ( expr ) .)
    <               reduce using rule 12 (expr -> ( expr ) .)
    *               reduce using rule 12 (expr -> ( expr ) .)
    /               reduce using rule 12 (expr -> ( expr ) .)
    -               reduce using rule 12 (expr -> ( expr ) .)
    +               reduce using rule 12 (expr -> ( expr ) .)
    CONCAT          reduce using rule 12 (expr -> ( expr ) .)
    (               reduce using rule 12 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 12 (expr -> ( expr ) .)
    $end            reduce using rule 12 (expr -> ( expr ) .)
    ,               reduce using rule 12 (expr -> ( expr ) .)
    }               reduce using rule 12 (expr -> ( expr ) .)
    )               reduce using rule 12 (expr -> ( expr ) .)
    ]               reduce using rule 12 (expr -> ( expr ) .)
    OF              reduce using rule 12 (expr -> ( expr ) .)
    THEN            reduce using rule 12 (expr -> ( expr ) .)
    END             reduce using rule 12 (expr -> ( expr ) .)
    ELIF            reduce using rule 12 (expr -> ( expr ) .)
    ELSE            reduce using rule 12 (expr -> ( expr ) .)


state 86

    (176) variable_declaration -> identifier : type_identifier . < type _37_repeat NOT_LESS expr
    (64) type -> type_identifier . _11_optional
    (65) _11_optional -> . < type _12_repeat >
    (71) _11_optional -> .
    <               shift and go to state 112
    =               reduce using rule 71 (_11_optional -> .)

    _11_optional                   shift and go to state 113

state 87

    (183) _38_optional -> : type .
    =               reduce using rule 183 (_38_optional -> : type .)


state 88

    (182) variable_declaration -> identifier _38_optional = . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    identifier                     shift and go to state 16
    expr                           shift and go to state 114
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 89

    (151) array -> [ _31_optional _32_repeat . ]
    ]               shift and go to state 115


state 90

    (154) _32_repeat -> _32_items .
    (156) _32_items -> _32_items . _32_item
    (158) _32_item -> . , expr
    ]               reduce using rule 154 (_32_repeat -> _32_items .)
    ,               shift and go to state 92

    _32_item                       shift and go to state 116

state 91

    (157) _32_items -> _32_item .
    ,               reduce using rule 157 (_32_items -> _32_item .)
    ]               reduce using rule 157 (_32_items -> _32_item .)


state 92

    (158) _32_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 117
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 93

    (114) case_of -> CASE expr OF . case _24_repeat END
    (120) case -> . pattern do
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    case                           shift and go to state 118
    pattern                        shift and go to state 119
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    type_identifier                shift and go to state 126
    identifier                     shift and go to state 127

state 94

    (105) if_expr -> IF expr THEN . _21_optional block_statement _22_optional END
    (106) _21_optional -> . : type
    (107) _21_optional -> .
    :               shift and go to state 129
    (               reduce using rule 107 (_21_optional -> .)
    -               reduce using rule 107 (_21_optional -> .)
    {               reduce using rule 107 (_21_optional -> .)
    [               reduce using rule 107 (_21_optional -> .)
    TYPE_IDENTIFIER reduce using rule 107 (_21_optional -> .)
    IDENTIFIER      reduce using rule 107 (_21_optional -> .)
    CASE            reduce using rule 107 (_21_optional -> .)
    IF              reduce using rule 107 (_21_optional -> .)
    DEF             reduce using rule 107 (_21_optional -> .)
    STRING          reduce using rule 107 (_21_optional -> .)
    NUMBER          reduce using rule 107 (_21_optional -> .)
    DO              reduce using rule 107 (_21_optional -> .)
    ELIF            reduce using rule 107 (_21_optional -> .)
    ELSE            reduce using rule 107 (_21_optional -> .)
    END             reduce using rule 107 (_21_optional -> .)
    NEWLINE         reduce using rule 107 (_21_optional -> .)

    _21_optional                   shift and go to state 128

state 95

    (54) def_expr -> DEF identifier ( . _8_optional _9_repeat ) _10_optional do
    (55) _8_optional -> . param
    (56) _8_optional -> .
    (102) param -> . identifier _20_optional
    (175) identifier -> . IDENTIFIER
    ,               reduce using rule 56 (_8_optional -> .)
    )               reduce using rule 56 (_8_optional -> .)
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 130
    _8_optional                    shift and go to state 131
    param                          shift and go to state 132

state 96

    (36) do -> DO _3_optional _4_optional . _5_repeat END
    (41) _5_repeat -> . _5_items
    (42) _5_repeat -> .
    (43) _5_items -> . _5_items _5_item
    (44) _5_items -> . _5_item
    (45) _5_item -> . NEWLINE expr
    END             reduce using rule 42 (_5_repeat -> .)
    NEWLINE         shift and go to state 136

    _5_repeat                      shift and go to state 133
    _5_items                       shift and go to state 134
    _5_item                        shift and go to state 135

state 97

    (39) _4_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NEWLINE         reduce using rule 39 (_4_optional -> expr .)
    END             reduce using rule 39 (_4_optional -> expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 98

    (37) _3_optional -> : type .
    (               reduce using rule 37 (_3_optional -> : type .)
    -               reduce using rule 37 (_3_optional -> : type .)
    {               reduce using rule 37 (_3_optional -> : type .)
    [               reduce using rule 37 (_3_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 37 (_3_optional -> : type .)
    IDENTIFIER      reduce using rule 37 (_3_optional -> : type .)
    CASE            reduce using rule 37 (_3_optional -> : type .)
    IF              reduce using rule 37 (_3_optional -> : type .)
    DEF             reduce using rule 37 (_3_optional -> : type .)
    STRING          reduce using rule 37 (_3_optional -> : type .)
    NUMBER          reduce using rule 37 (_3_optional -> : type .)
    DO              reduce using rule 37 (_3_optional -> : type .)
    NEWLINE         reduce using rule 37 (_3_optional -> : type .)
    END             reduce using rule 37 (_3_optional -> : type .)


state 99

    (64) type -> type_identifier . _11_optional
    (65) _11_optional -> . < type _12_repeat >
    (71) _11_optional -> .
    <               shift and go to state 137
    (               reduce using rule 71 (_11_optional -> .)
    -               reduce using rule 71 (_11_optional -> .)
    {               reduce using rule 71 (_11_optional -> .)
    [               reduce using rule 71 (_11_optional -> .)
    TYPE_IDENTIFIER reduce using rule 71 (_11_optional -> .)
    IDENTIFIER      reduce using rule 71 (_11_optional -> .)
    CASE            reduce using rule 71 (_11_optional -> .)
    IF              reduce using rule 71 (_11_optional -> .)
    DEF             reduce using rule 71 (_11_optional -> .)
    STRING          reduce using rule 71 (_11_optional -> .)
    NUMBER          reduce using rule 71 (_11_optional -> .)
    DO              reduce using rule 71 (_11_optional -> .)
    NEWLINE         reduce using rule 71 (_11_optional -> .)
    END             reduce using rule 71 (_11_optional -> .)
    ,               reduce using rule 71 (_11_optional -> .)
    NOT_LESS        reduce using rule 71 (_11_optional -> .)
    >               reduce using rule 71 (_11_optional -> .)
    ELIF            reduce using rule 71 (_11_optional -> .)
    ELSE            reduce using rule 71 (_11_optional -> .)
    )               reduce using rule 71 (_11_optional -> .)
    }               reduce using rule 71 (_11_optional -> .)

    _11_optional                   shift and go to state 113

state 100

    (167) call -> expr ( _35_optional _36_repeat . )
    )               shift and go to state 138


state 101

    (170) _36_repeat -> _36_items .
    (172) _36_items -> _36_items . _36_item
    (174) _36_item -> . , expr
    )               reduce using rule 170 (_36_repeat -> _36_items .)
    ,               shift and go to state 103

    _36_item                       shift and go to state 139

state 102

    (173) _36_items -> _36_item .
    ,               reduce using rule 173 (_36_items -> _36_item .)
    )               reduce using rule 173 (_36_items -> _36_item .)


state 103

    (174) _36_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 140
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 104

    (85) enum -> ENUM type_identifier _16_optional { . _17_repeat }
    (88) _17_repeat -> . _17_items
    (89) _17_repeat -> .
    (90) _17_items -> . _17_items _17_item
    (91) _17_items -> . _17_item
    (92) _17_item -> . variant
    (93) variant -> . type_identifier _18_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 89 (_17_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 141
    _17_repeat                     shift and go to state 142
    _17_items                      shift and go to state 143
    _17_item                       shift and go to state 144
    variant                        shift and go to state 145

state 105

    (86) _16_optional -> < fields_unnamed . >
    >               shift and go to state 146


state 106

    (96) fields_unnamed -> identifier . _19_repeat
    (97) _19_repeat -> . _19_items
    (98) _19_repeat -> .
    (99) _19_items -> . _19_items _19_item
    (100) _19_items -> . _19_item
    (101) _19_item -> . , identifier
    >               reduce using rule 98 (_19_repeat -> .)
    )               reduce using rule 98 (_19_repeat -> .)
    ,               shift and go to state 150

    _19_repeat                     shift and go to state 147
    _19_items                      shift and go to state 148
    _19_item                       shift and go to state 149

state 107

    (159) tuple -> { _33_optional _34_repeat } .
    INT_DIV         reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    NOT_MORE        reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    NOT_LESS        reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    >               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    <               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    *               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    /               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    -               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    +               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    CONCAT          reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    (               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    NEWLINE         reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    $end            reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    ,               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    }               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    )               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    ]               reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    OF              reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    THEN            reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    END             reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    ELIF            reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)
    ELSE            reduce using rule 159 (tuple -> { _33_optional _34_repeat } .)


state 108

    (164) _34_items -> _34_items _34_item .
    ,               reduce using rule 164 (_34_items -> _34_items _34_item .)
    }               reduce using rule 164 (_34_items -> _34_items _34_item .)


state 109

    (166) _34_item -> , expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    ,               reduce using rule 166 (_34_item -> , expr .)
    }               reduce using rule 166 (_34_item -> , expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 110

    (72) struct -> STRUCT type_identifier _13_optional { . _15_repeat }
    (80) _15_repeat -> . _15_items
    (81) _15_repeat -> .
    (82) _15_items -> . _15_items _15_item
    (83) _15_items -> . _15_item
    (84) _15_item -> . identifier : type
    (175) identifier -> . IDENTIFIER
    }               reduce using rule 81 (_15_repeat -> .)
    IDENTIFIER      shift and go to state 26

    _15_repeat                     shift and go to state 151
    _15_items                      shift and go to state 152
    _15_item                       shift and go to state 153
    identifier                     shift and go to state 154

state 111

    (73) _13_optional -> < identifier . _14_repeat >
    (74) _14_repeat -> . _14_items
    (75) _14_repeat -> .
    (76) _14_items -> . _14_items _14_item
    (77) _14_items -> . _14_item
    (78) _14_item -> . , identifier
    >               reduce using rule 75 (_14_repeat -> .)
    ,               shift and go to state 158

    _14_repeat                     shift and go to state 155
    _14_items                      shift and go to state 156
    _14_item                       shift and go to state 157

state 112

    (176) variable_declaration -> identifier : type_identifier < . type _37_repeat NOT_LESS expr
    (65) _11_optional -> < . type _12_repeat >
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 99
    type                           shift and go to state 159

state 113

    (64) type -> type_identifier _11_optional .
    =               reduce using rule 64 (type -> type_identifier _11_optional .)
    (               reduce using rule 64 (type -> type_identifier _11_optional .)
    -               reduce using rule 64 (type -> type_identifier _11_optional .)
    {               reduce using rule 64 (type -> type_identifier _11_optional .)
    [               reduce using rule 64 (type -> type_identifier _11_optional .)
    TYPE_IDENTIFIER reduce using rule 64 (type -> type_identifier _11_optional .)
    IDENTIFIER      reduce using rule 64 (type -> type_identifier _11_optional .)
    CASE            reduce using rule 64 (type -> type_identifier _11_optional .)
    IF              reduce using rule 64 (type -> type_identifier _11_optional .)
    DEF             reduce using rule 64 (type -> type_identifier _11_optional .)
    STRING          reduce using rule 64 (type -> type_identifier _11_optional .)
    NUMBER          reduce using rule 64 (type -> type_identifier _11_optional .)
    DO              reduce using rule 64 (type -> type_identifier _11_optional .)
    NEWLINE         reduce using rule 64 (type -> type_identifier _11_optional .)
    END             reduce using rule 64 (type -> type_identifier _11_optional .)
    ,               reduce using rule 64 (type -> type_identifier _11_optional .)
    NOT_LESS        reduce using rule 64 (type -> type_identifier _11_optional .)
    >               reduce using rule 64 (type -> type_identifier _11_optional .)
    ELIF            reduce using rule 64 (type -> type_identifier _11_optional .)
    ELSE            reduce using rule 64 (type -> type_identifier _11_optional .)
    )               reduce using rule 64 (type -> type_identifier _11_optional .)
    }               reduce using rule 64 (type -> type_identifier _11_optional .)


state 114

    (182) variable_declaration -> identifier _38_optional = expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NEWLINE         reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    $end            reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    ,               reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    }               reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    )               reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    ]               reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    OF              reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    THEN            reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    END             reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    ELIF            reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    ELSE            reduce using rule 182 (variable_declaration -> identifier _38_optional = expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 115

    (151) array -> [ _31_optional _32_repeat ] .
    INT_DIV         reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    NOT_MORE        reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    NOT_LESS        reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    >               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    <               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    *               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    /               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    -               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    +               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    CONCAT          reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    (               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    NEWLINE         reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    $end            reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    ,               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    }               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    )               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    ]               reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    OF              reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    THEN            reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    END             reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    ELIF            reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)
    ELSE            reduce using rule 151 (array -> [ _31_optional _32_repeat ] .)


state 116

    (156) _32_items -> _32_items _32_item .
    ,               reduce using rule 156 (_32_items -> _32_items _32_item .)
    ]               reduce using rule 156 (_32_items -> _32_items _32_item .)


state 117

    (158) _32_item -> , expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    ,               reduce using rule 158 (_32_item -> , expr .)
    ]               reduce using rule 158 (_32_item -> , expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 118

    (114) case_of -> CASE expr OF case . _24_repeat END
    (115) _24_repeat -> . _24_items
    (116) _24_repeat -> .
    (117) _24_items -> . _24_items _24_item
    (118) _24_items -> . _24_item
    (119) _24_item -> . case
    (120) case -> . pattern do
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    END             reduce using rule 116 (_24_repeat -> .)
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    case                           shift and go to state 160
    _24_repeat                     shift and go to state 161
    _24_items                      shift and go to state 162
    _24_item                       shift and go to state 163
    pattern                        shift and go to state 119
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    type_identifier                shift and go to state 126
    identifier                     shift and go to state 127

state 119

    (120) case -> pattern . do
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    DO              shift and go to state 32

    do                             shift and go to state 164

state 120

    (121) pattern -> array_pattern .
    DO              reduce using rule 121 (pattern -> array_pattern .)
    ,               reduce using rule 121 (pattern -> array_pattern .)
    ]               reduce using rule 121 (pattern -> array_pattern .)
    }               reduce using rule 121 (pattern -> array_pattern .)
    )               reduce using rule 121 (pattern -> array_pattern .)


state 121

    (122) pattern -> tuple_pattern .
    DO              reduce using rule 122 (pattern -> tuple_pattern .)
    ,               reduce using rule 122 (pattern -> tuple_pattern .)
    ]               reduce using rule 122 (pattern -> tuple_pattern .)
    }               reduce using rule 122 (pattern -> tuple_pattern .)
    )               reduce using rule 122 (pattern -> tuple_pattern .)


state 122

    (123) pattern -> enum_pattern .
    DO              reduce using rule 123 (pattern -> enum_pattern .)
    ,               reduce using rule 123 (pattern -> enum_pattern .)
    ]               reduce using rule 123 (pattern -> enum_pattern .)
    }               reduce using rule 123 (pattern -> enum_pattern .)
    )               reduce using rule 123 (pattern -> enum_pattern .)


state 123

    (124) pattern -> param_pattern .
    DO              reduce using rule 124 (pattern -> param_pattern .)
    ,               reduce using rule 124 (pattern -> param_pattern .)
    ]               reduce using rule 124 (pattern -> param_pattern .)
    }               reduce using rule 124 (pattern -> param_pattern .)
    )               reduce using rule 124 (pattern -> param_pattern .)


state 124

    (126) array_pattern -> [ . _25_optional _26_repeat ]
    (127) _25_optional -> . pattern
    (128) _25_optional -> .
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    ,               reduce using rule 128 (_25_optional -> .)
    ]               reduce using rule 128 (_25_optional -> .)
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    _25_optional                   shift and go to state 165
    pattern                        shift and go to state 166
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    type_identifier                shift and go to state 126
    identifier                     shift and go to state 127

state 125

    (134) tuple_pattern -> { . _27_optional _28_repeat }
    (135) _27_optional -> . pattern
    (136) _27_optional -> .
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    ,               reduce using rule 136 (_27_optional -> .)
    }               reduce using rule 136 (_27_optional -> .)
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    _27_optional                   shift and go to state 167
    pattern                        shift and go to state 168
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    type_identifier                shift and go to state 126
    identifier                     shift and go to state 127

state 126

    (142) enum_pattern -> type_identifier . ( _29_optional _30_repeat )
    (               shift and go to state 169


state 127

    (125) param_pattern -> identifier .
    DO              reduce using rule 125 (param_pattern -> identifier .)
    ,               reduce using rule 125 (param_pattern -> identifier .)
    ]               reduce using rule 125 (param_pattern -> identifier .)
    }               reduce using rule 125 (param_pattern -> identifier .)
    )               reduce using rule 125 (param_pattern -> identifier .)


state 128

    (105) if_expr -> IF expr THEN _21_optional . block_statement _22_optional END
    (46) block_statement -> . _6_optional _7_repeat
    (47) _6_optional -> . expr
    (48) _6_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    NEWLINE         reduce using rule 48 (_6_optional -> .)
    ELIF            reduce using rule 48 (_6_optional -> .)
    ELSE            reduce using rule 48 (_6_optional -> .)
    END             reduce using rule 48 (_6_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 170
    block_statement                shift and go to state 171
    _6_optional                    shift and go to state 172
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 129

    (106) _21_optional -> : . type
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 173
    type_identifier                shift and go to state 99

state 130

    (102) param -> identifier . _20_optional
    (103) _20_optional -> . : type
    (104) _20_optional -> .
    :               shift and go to state 175
    ,               reduce using rule 104 (_20_optional -> .)
    )               reduce using rule 104 (_20_optional -> .)

    _20_optional                   shift and go to state 174

state 131

    (54) def_expr -> DEF identifier ( _8_optional . _9_repeat ) _10_optional do
    (57) _9_repeat -> . _9_items
    (58) _9_repeat -> .
    (59) _9_items -> . _9_items _9_item
    (60) _9_items -> . _9_item
    (61) _9_item -> . , param
    )               reduce using rule 58 (_9_repeat -> .)
    ,               shift and go to state 179

    _9_repeat                      shift and go to state 176
    _9_items                       shift and go to state 177
    _9_item                        shift and go to state 178

state 132

    (55) _8_optional -> param .
    ,               reduce using rule 55 (_8_optional -> param .)
    )               reduce using rule 55 (_8_optional -> param .)


state 133

    (36) do -> DO _3_optional _4_optional _5_repeat . END
    END             shift and go to state 180


state 134

    (41) _5_repeat -> _5_items .
    (43) _5_items -> _5_items . _5_item
    (45) _5_item -> . NEWLINE expr
    END             reduce using rule 41 (_5_repeat -> _5_items .)
    NEWLINE         shift and go to state 136

    _5_item                        shift and go to state 181

state 135

    (44) _5_items -> _5_item .
    NEWLINE         reduce using rule 44 (_5_items -> _5_item .)
    END             reduce using rule 44 (_5_items -> _5_item .)


state 136

    (45) _5_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 182
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 137

    (65) _11_optional -> < . type _12_repeat >
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 183
    type_identifier                shift and go to state 99

state 138

    (167) call -> expr ( _35_optional _36_repeat ) .
    INT_DIV         reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    NOT_MORE        reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    NOT_LESS        reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    >               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    <               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    *               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    /               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    -               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    +               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    CONCAT          reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    (               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    NEWLINE         reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    $end            reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    ,               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    }               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    )               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    ]               reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    OF              reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    THEN            reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    END             reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    ELIF            reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)
    ELSE            reduce using rule 167 (call -> expr ( _35_optional _36_repeat ) .)


state 139

    (172) _36_items -> _36_items _36_item .
    ,               reduce using rule 172 (_36_items -> _36_items _36_item .)
    )               reduce using rule 172 (_36_items -> _36_items _36_item .)


state 140

    (174) _36_item -> , expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    ,               reduce using rule 174 (_36_item -> , expr .)
    )               reduce using rule 174 (_36_item -> , expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 141

    (93) variant -> type_identifier . _18_optional
    (94) _18_optional -> . ( fields_unnamed )
    (95) _18_optional -> .
    (               shift and go to state 185
    TYPE_IDENTIFIER reduce using rule 95 (_18_optional -> .)
    }               reduce using rule 95 (_18_optional -> .)

    _18_optional                   shift and go to state 184

state 142

    (85) enum -> ENUM type_identifier _16_optional { _17_repeat . }
    }               shift and go to state 186


state 143

    (88) _17_repeat -> _17_items .
    (90) _17_items -> _17_items . _17_item
    (92) _17_item -> . variant
    (93) variant -> . type_identifier _18_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 88 (_17_repeat -> _17_items .)
    TYPE_IDENTIFIER shift and go to state 25

    _17_item                       shift and go to state 187
    variant                        shift and go to state 145
    type_identifier                shift and go to state 141

state 144

    (91) _17_items -> _17_item .
    TYPE_IDENTIFIER reduce using rule 91 (_17_items -> _17_item .)
    }               reduce using rule 91 (_17_items -> _17_item .)


state 145

    (92) _17_item -> variant .
    TYPE_IDENTIFIER reduce using rule 92 (_17_item -> variant .)
    }               reduce using rule 92 (_17_item -> variant .)


state 146

    (86) _16_optional -> < fields_unnamed > .
    {               reduce using rule 86 (_16_optional -> < fields_unnamed > .)


state 147

    (96) fields_unnamed -> identifier _19_repeat .
    >               reduce using rule 96 (fields_unnamed -> identifier _19_repeat .)
    )               reduce using rule 96 (fields_unnamed -> identifier _19_repeat .)


state 148

    (97) _19_repeat -> _19_items .
    (99) _19_items -> _19_items . _19_item
    (101) _19_item -> . , identifier
    >               reduce using rule 97 (_19_repeat -> _19_items .)
    )               reduce using rule 97 (_19_repeat -> _19_items .)
    ,               shift and go to state 150

    _19_item                       shift and go to state 188

state 149

    (100) _19_items -> _19_item .
    ,               reduce using rule 100 (_19_items -> _19_item .)
    >               reduce using rule 100 (_19_items -> _19_item .)
    )               reduce using rule 100 (_19_items -> _19_item .)


state 150

    (101) _19_item -> , . identifier
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 189

state 151

    (72) struct -> STRUCT type_identifier _13_optional { _15_repeat . }
    }               shift and go to state 190


state 152

    (80) _15_repeat -> _15_items .
    (82) _15_items -> _15_items . _15_item
    (84) _15_item -> . identifier : type
    (175) identifier -> . IDENTIFIER
    }               reduce using rule 80 (_15_repeat -> _15_items .)
    IDENTIFIER      shift and go to state 26

    _15_item                       shift and go to state 191
    identifier                     shift and go to state 154

state 153

    (83) _15_items -> _15_item .
    IDENTIFIER      reduce using rule 83 (_15_items -> _15_item .)
    }               reduce using rule 83 (_15_items -> _15_item .)


state 154

    (84) _15_item -> identifier . : type
    :               shift and go to state 192


state 155

    (73) _13_optional -> < identifier _14_repeat . >
    >               shift and go to state 193


state 156

    (74) _14_repeat -> _14_items .
    (76) _14_items -> _14_items . _14_item
    (78) _14_item -> . , identifier
    >               reduce using rule 74 (_14_repeat -> _14_items .)
    ,               shift and go to state 158

    _14_item                       shift and go to state 194

state 157

    (77) _14_items -> _14_item .
    ,               reduce using rule 77 (_14_items -> _14_item .)
    >               reduce using rule 77 (_14_items -> _14_item .)


state 158

    (78) _14_item -> , . identifier
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 195

state 159

    (176) variable_declaration -> identifier : type_identifier < type . _37_repeat NOT_LESS expr
    (65) _11_optional -> < type . _12_repeat >
    (177) _37_repeat -> . _37_items
    (178) _37_repeat -> .
    (66) _12_repeat -> . _12_items
    (67) _12_repeat -> .
    (179) _37_items -> . _37_items _37_item
    (180) _37_items -> . _37_item
    (68) _12_items -> . _12_items _12_item
    (69) _12_items -> . _12_item
    (181) _37_item -> . , type
    (70) _12_item -> . , type
    NOT_LESS        reduce using rule 178 (_37_repeat -> .)
    >               reduce using rule 67 (_12_repeat -> .)
    ,               shift and go to state 202

    _37_repeat                     shift and go to state 196
    _12_repeat                     shift and go to state 197
    _37_items                      shift and go to state 198
    _12_items                      shift and go to state 199
    _37_item                       shift and go to state 200
    _12_item                       shift and go to state 201

state 160

    (119) _24_item -> case .
    [               reduce using rule 119 (_24_item -> case .)
    {               reduce using rule 119 (_24_item -> case .)
    TYPE_IDENTIFIER reduce using rule 119 (_24_item -> case .)
    IDENTIFIER      reduce using rule 119 (_24_item -> case .)
    END             reduce using rule 119 (_24_item -> case .)


state 161

    (114) case_of -> CASE expr OF case _24_repeat . END
    END             shift and go to state 203


state 162

    (115) _24_repeat -> _24_items .
    (117) _24_items -> _24_items . _24_item
    (119) _24_item -> . case
    (120) case -> . pattern do
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    END             reduce using rule 115 (_24_repeat -> _24_items .)
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    _24_item                       shift and go to state 204
    case                           shift and go to state 160
    pattern                        shift and go to state 119
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    type_identifier                shift and go to state 126
    identifier                     shift and go to state 127

state 163

    (118) _24_items -> _24_item .
    [               reduce using rule 118 (_24_items -> _24_item .)
    {               reduce using rule 118 (_24_items -> _24_item .)
    TYPE_IDENTIFIER reduce using rule 118 (_24_items -> _24_item .)
    IDENTIFIER      reduce using rule 118 (_24_items -> _24_item .)
    END             reduce using rule 118 (_24_items -> _24_item .)


state 164

    (120) case -> pattern do .
    [               reduce using rule 120 (case -> pattern do .)
    {               reduce using rule 120 (case -> pattern do .)
    TYPE_IDENTIFIER reduce using rule 120 (case -> pattern do .)
    IDENTIFIER      reduce using rule 120 (case -> pattern do .)
    END             reduce using rule 120 (case -> pattern do .)


state 165

    (126) array_pattern -> [ _25_optional . _26_repeat ]
    (129) _26_repeat -> . _26_items
    (130) _26_repeat -> .
    (131) _26_items -> . _26_items _26_item
    (132) _26_items -> . _26_item
    (133) _26_item -> . , pattern
    ]               reduce using rule 130 (_26_repeat -> .)
    ,               shift and go to state 208

    _26_repeat                     shift and go to state 205
    _26_items                      shift and go to state 206
    _26_item                       shift and go to state 207

state 166

    (127) _25_optional -> pattern .
    ,               reduce using rule 127 (_25_optional -> pattern .)
    ]               reduce using rule 127 (_25_optional -> pattern .)


state 167

    (134) tuple_pattern -> { _27_optional . _28_repeat }
    (137) _28_repeat -> . _28_items
    (138) _28_repeat -> .
    (139) _28_items -> . _28_items _28_item
    (140) _28_items -> . _28_item
    (141) _28_item -> . , pattern
    }               reduce using rule 138 (_28_repeat -> .)
    ,               shift and go to state 212

    _28_repeat                     shift and go to state 209
    _28_items                      shift and go to state 210
    _28_item                       shift and go to state 211

state 168

    (135) _27_optional -> pattern .
    ,               reduce using rule 135 (_27_optional -> pattern .)
    }               reduce using rule 135 (_27_optional -> pattern .)


state 169

    (142) enum_pattern -> type_identifier ( . _29_optional _30_repeat )
    (143) _29_optional -> . pattern
    (144) _29_optional -> .
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    ,               reduce using rule 144 (_29_optional -> .)
    )               reduce using rule 144 (_29_optional -> .)
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    type_identifier                shift and go to state 126
    _29_optional                   shift and go to state 213
    pattern                        shift and go to state 214
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    identifier                     shift and go to state 127

state 170

    (47) _6_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NEWLINE         reduce using rule 47 (_6_optional -> expr .)
    ELIF            reduce using rule 47 (_6_optional -> expr .)
    ELSE            reduce using rule 47 (_6_optional -> expr .)
    END             reduce using rule 47 (_6_optional -> expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 171

    (105) if_expr -> IF expr THEN _21_optional block_statement . _22_optional END
    (108) _22_optional -> . or_else
    (109) _22_optional -> .
    (110) or_else -> . ELIF expr THEN block_statement _23_optional
    (113) or_else -> . ELSE block_statement
    END             reduce using rule 109 (_22_optional -> .)
    ELIF            shift and go to state 217
    ELSE            shift and go to state 218

    _22_optional                   shift and go to state 215
    or_else                        shift and go to state 216

state 172

    (46) block_statement -> _6_optional . _7_repeat
    (49) _7_repeat -> . _7_items
    (50) _7_repeat -> .
    (51) _7_items -> . _7_items _7_item
    (52) _7_items -> . _7_item
    (53) _7_item -> . NEWLINE expr
    ELIF            reduce using rule 50 (_7_repeat -> .)
    ELSE            reduce using rule 50 (_7_repeat -> .)
    END             reduce using rule 50 (_7_repeat -> .)
    NEWLINE         shift and go to state 222

    _7_repeat                      shift and go to state 219
    _7_items                       shift and go to state 220
    _7_item                        shift and go to state 221

state 173

    (106) _21_optional -> : type .
    (               reduce using rule 106 (_21_optional -> : type .)
    -               reduce using rule 106 (_21_optional -> : type .)
    {               reduce using rule 106 (_21_optional -> : type .)
    [               reduce using rule 106 (_21_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 106 (_21_optional -> : type .)
    IDENTIFIER      reduce using rule 106 (_21_optional -> : type .)
    CASE            reduce using rule 106 (_21_optional -> : type .)
    IF              reduce using rule 106 (_21_optional -> : type .)
    DEF             reduce using rule 106 (_21_optional -> : type .)
    STRING          reduce using rule 106 (_21_optional -> : type .)
    NUMBER          reduce using rule 106 (_21_optional -> : type .)
    DO              reduce using rule 106 (_21_optional -> : type .)
    ELIF            reduce using rule 106 (_21_optional -> : type .)
    ELSE            reduce using rule 106 (_21_optional -> : type .)
    END             reduce using rule 106 (_21_optional -> : type .)
    NEWLINE         reduce using rule 106 (_21_optional -> : type .)


state 174

    (102) param -> identifier _20_optional .
    ,               reduce using rule 102 (param -> identifier _20_optional .)
    )               reduce using rule 102 (param -> identifier _20_optional .)


state 175

    (103) _20_optional -> : . type
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 223
    type_identifier                shift and go to state 99

state 176

    (54) def_expr -> DEF identifier ( _8_optional _9_repeat . ) _10_optional do
    )               shift and go to state 224


state 177

    (57) _9_repeat -> _9_items .
    (59) _9_items -> _9_items . _9_item
    (61) _9_item -> . , param
    )               reduce using rule 57 (_9_repeat -> _9_items .)
    ,               shift and go to state 179

    _9_item                        shift and go to state 225

state 178

    (60) _9_items -> _9_item .
    ,               reduce using rule 60 (_9_items -> _9_item .)
    )               reduce using rule 60 (_9_items -> _9_item .)


state 179

    (61) _9_item -> , . param
    (102) param -> . identifier _20_optional
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    param                          shift and go to state 226
    identifier                     shift and go to state 130

state 180

    (36) do -> DO _3_optional _4_optional _5_repeat END .
    INT_DIV         reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    NOT_MORE        reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    NOT_LESS        reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    >               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    <               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    *               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    /               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    -               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    +               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    CONCAT          reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    (               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    NEWLINE         reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    $end            reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    ,               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    }               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    )               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    ]               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    OF              reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    THEN            reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    END             reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    ELIF            reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    ELSE            reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    [               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    {               reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    TYPE_IDENTIFIER reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)
    IDENTIFIER      reduce using rule 36 (do -> DO _3_optional _4_optional _5_repeat END .)


state 181

    (43) _5_items -> _5_items _5_item .
    NEWLINE         reduce using rule 43 (_5_items -> _5_items _5_item .)
    END             reduce using rule 43 (_5_items -> _5_items _5_item .)


state 182

    (45) _5_item -> NEWLINE expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NEWLINE         reduce using rule 45 (_5_item -> NEWLINE expr .)
    END             reduce using rule 45 (_5_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 183

    (65) _11_optional -> < type . _12_repeat >
    (66) _12_repeat -> . _12_items
    (67) _12_repeat -> .
    (68) _12_items -> . _12_items _12_item
    (69) _12_items -> . _12_item
    (70) _12_item -> . , type
    >               reduce using rule 67 (_12_repeat -> .)
    ,               shift and go to state 227

    _12_repeat                     shift and go to state 197
    _12_items                      shift and go to state 199
    _12_item                       shift and go to state 201

state 184

    (93) variant -> type_identifier _18_optional .
    TYPE_IDENTIFIER reduce using rule 93 (variant -> type_identifier _18_optional .)
    }               reduce using rule 93 (variant -> type_identifier _18_optional .)


state 185

    (94) _18_optional -> ( . fields_unnamed )
    (96) fields_unnamed -> . identifier _19_repeat
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    fields_unnamed                 shift and go to state 228
    identifier                     shift and go to state 106

state 186

    (85) enum -> ENUM type_identifier _16_optional { _17_repeat } .
    NEWLINE         reduce using rule 85 (enum -> ENUM type_identifier _16_optional { _17_repeat } .)
    $end            reduce using rule 85 (enum -> ENUM type_identifier _16_optional { _17_repeat } .)


state 187

    (90) _17_items -> _17_items _17_item .
    TYPE_IDENTIFIER reduce using rule 90 (_17_items -> _17_items _17_item .)
    }               reduce using rule 90 (_17_items -> _17_items _17_item .)


state 188

    (99) _19_items -> _19_items _19_item .
    ,               reduce using rule 99 (_19_items -> _19_items _19_item .)
    >               reduce using rule 99 (_19_items -> _19_items _19_item .)
    )               reduce using rule 99 (_19_items -> _19_items _19_item .)


state 189

    (101) _19_item -> , identifier .
    ,               reduce using rule 101 (_19_item -> , identifier .)
    >               reduce using rule 101 (_19_item -> , identifier .)
    )               reduce using rule 101 (_19_item -> , identifier .)


state 190

    (72) struct -> STRUCT type_identifier _13_optional { _15_repeat } .
    NEWLINE         reduce using rule 72 (struct -> STRUCT type_identifier _13_optional { _15_repeat } .)
    $end            reduce using rule 72 (struct -> STRUCT type_identifier _13_optional { _15_repeat } .)


state 191

    (82) _15_items -> _15_items _15_item .
    IDENTIFIER      reduce using rule 82 (_15_items -> _15_items _15_item .)
    }               reduce using rule 82 (_15_items -> _15_items _15_item .)


state 192

    (84) _15_item -> identifier : . type
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 229
    type_identifier                shift and go to state 99

state 193

    (73) _13_optional -> < identifier _14_repeat > .
    {               reduce using rule 73 (_13_optional -> < identifier _14_repeat > .)


state 194

    (76) _14_items -> _14_items _14_item .
    ,               reduce using rule 76 (_14_items -> _14_items _14_item .)
    >               reduce using rule 76 (_14_items -> _14_items _14_item .)


state 195

    (78) _14_item -> , identifier .
    ,               reduce using rule 78 (_14_item -> , identifier .)
    >               reduce using rule 78 (_14_item -> , identifier .)


state 196

    (176) variable_declaration -> identifier : type_identifier < type _37_repeat . NOT_LESS expr
    NOT_LESS        shift and go to state 230


state 197

    (65) _11_optional -> < type _12_repeat . >
    >               shift and go to state 231


state 198

    (177) _37_repeat -> _37_items .
    (179) _37_items -> _37_items . _37_item
    (181) _37_item -> . , type
    NOT_LESS        reduce using rule 177 (_37_repeat -> _37_items .)
    ,               shift and go to state 233

    _37_item                       shift and go to state 232

state 199

    (66) _12_repeat -> _12_items .
    (68) _12_items -> _12_items . _12_item
    (70) _12_item -> . , type
    >               reduce using rule 66 (_12_repeat -> _12_items .)
    ,               shift and go to state 227

    _12_item                       shift and go to state 234

state 200

    (180) _37_items -> _37_item .
    ,               reduce using rule 180 (_37_items -> _37_item .)
    NOT_LESS        reduce using rule 180 (_37_items -> _37_item .)


state 201

    (69) _12_items -> _12_item .
    ,               reduce using rule 69 (_12_items -> _12_item .)
    >               reduce using rule 69 (_12_items -> _12_item .)


state 202

    (181) _37_item -> , . type
    (70) _12_item -> , . type
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 235
    type_identifier                shift and go to state 99

state 203

    (114) case_of -> CASE expr OF case _24_repeat END .
    INT_DIV         reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    NOT_MORE        reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    NOT_LESS        reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    >               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    <               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    *               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    /               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    -               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    +               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    CONCAT          reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    (               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    NEWLINE         reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    $end            reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    ,               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    }               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    )               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    ]               reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    OF              reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    THEN            reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    END             reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    ELIF            reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)
    ELSE            reduce using rule 114 (case_of -> CASE expr OF case _24_repeat END .)


state 204

    (117) _24_items -> _24_items _24_item .
    [               reduce using rule 117 (_24_items -> _24_items _24_item .)
    {               reduce using rule 117 (_24_items -> _24_items _24_item .)
    TYPE_IDENTIFIER reduce using rule 117 (_24_items -> _24_items _24_item .)
    IDENTIFIER      reduce using rule 117 (_24_items -> _24_items _24_item .)
    END             reduce using rule 117 (_24_items -> _24_items _24_item .)


state 205

    (126) array_pattern -> [ _25_optional _26_repeat . ]
    ]               shift and go to state 236


state 206

    (129) _26_repeat -> _26_items .
    (131) _26_items -> _26_items . _26_item
    (133) _26_item -> . , pattern
    ]               reduce using rule 129 (_26_repeat -> _26_items .)
    ,               shift and go to state 208

    _26_item                       shift and go to state 237

state 207

    (132) _26_items -> _26_item .
    ,               reduce using rule 132 (_26_items -> _26_item .)
    ]               reduce using rule 132 (_26_items -> _26_item .)


state 208

    (133) _26_item -> , . pattern
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    pattern                        shift and go to state 238
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    type_identifier                shift and go to state 126
    identifier                     shift and go to state 127

state 209

    (134) tuple_pattern -> { _27_optional _28_repeat . }
    }               shift and go to state 239


state 210

    (137) _28_repeat -> _28_items .
    (139) _28_items -> _28_items . _28_item
    (141) _28_item -> . , pattern
    }               reduce using rule 137 (_28_repeat -> _28_items .)
    ,               shift and go to state 212

    _28_item                       shift and go to state 240

state 211

    (140) _28_items -> _28_item .
    ,               reduce using rule 140 (_28_items -> _28_item .)
    }               reduce using rule 140 (_28_items -> _28_item .)


state 212

    (141) _28_item -> , . pattern
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    pattern                        shift and go to state 241
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    type_identifier                shift and go to state 126
    identifier                     shift and go to state 127

state 213

    (142) enum_pattern -> type_identifier ( _29_optional . _30_repeat )
    (145) _30_repeat -> . _30_items
    (146) _30_repeat -> .
    (147) _30_items -> . _30_items _30_item
    (148) _30_items -> . _30_item
    (149) _30_item -> . , pattern
    )               reduce using rule 146 (_30_repeat -> .)
    ,               shift and go to state 245

    _30_repeat                     shift and go to state 242
    _30_items                      shift and go to state 243
    _30_item                       shift and go to state 244

state 214

    (143) _29_optional -> pattern .
    ,               reduce using rule 143 (_29_optional -> pattern .)
    )               reduce using rule 143 (_29_optional -> pattern .)


state 215

    (105) if_expr -> IF expr THEN _21_optional block_statement _22_optional . END
    END             shift and go to state 246


state 216

    (108) _22_optional -> or_else .
    END             reduce using rule 108 (_22_optional -> or_else .)


state 217

    (110) or_else -> ELIF . expr THEN block_statement _23_optional
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 247
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 218

    (113) or_else -> ELSE . block_statement
    (46) block_statement -> . _6_optional _7_repeat
    (47) _6_optional -> . expr
    (48) _6_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    NEWLINE         reduce using rule 48 (_6_optional -> .)
    END             reduce using rule 48 (_6_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    block_statement                shift and go to state 248
    _6_optional                    shift and go to state 172
    expr                           shift and go to state 170
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 219

    (46) block_statement -> _6_optional _7_repeat .
    ELIF            reduce using rule 46 (block_statement -> _6_optional _7_repeat .)
    ELSE            reduce using rule 46 (block_statement -> _6_optional _7_repeat .)
    END             reduce using rule 46 (block_statement -> _6_optional _7_repeat .)


state 220

    (49) _7_repeat -> _7_items .
    (51) _7_items -> _7_items . _7_item
    (53) _7_item -> . NEWLINE expr
    ELIF            reduce using rule 49 (_7_repeat -> _7_items .)
    ELSE            reduce using rule 49 (_7_repeat -> _7_items .)
    END             reduce using rule 49 (_7_repeat -> _7_items .)
    NEWLINE         shift and go to state 222

    _7_item                        shift and go to state 249

state 221

    (52) _7_items -> _7_item .
    NEWLINE         reduce using rule 52 (_7_items -> _7_item .)
    ELIF            reduce using rule 52 (_7_items -> _7_item .)
    ELSE            reduce using rule 52 (_7_items -> _7_item .)
    END             reduce using rule 52 (_7_items -> _7_item .)


state 222

    (53) _7_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 250
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 223

    (103) _20_optional -> : type .
    ,               reduce using rule 103 (_20_optional -> : type .)
    )               reduce using rule 103 (_20_optional -> : type .)


state 224

    (54) def_expr -> DEF identifier ( _8_optional _9_repeat ) . _10_optional do
    (62) _10_optional -> . : type
    (63) _10_optional -> .
    :               shift and go to state 252
    DO              reduce using rule 63 (_10_optional -> .)

    _10_optional                   shift and go to state 251

state 225

    (59) _9_items -> _9_items _9_item .
    ,               reduce using rule 59 (_9_items -> _9_items _9_item .)
    )               reduce using rule 59 (_9_items -> _9_items _9_item .)


state 226

    (61) _9_item -> , param .
    ,               reduce using rule 61 (_9_item -> , param .)
    )               reduce using rule 61 (_9_item -> , param .)


state 227

    (70) _12_item -> , . type
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 253
    type_identifier                shift and go to state 99

state 228

    (94) _18_optional -> ( fields_unnamed . )
    )               shift and go to state 254


state 229

    (84) _15_item -> identifier : type .
    IDENTIFIER      reduce using rule 84 (_15_item -> identifier : type .)
    }               reduce using rule 84 (_15_item -> identifier : type .)


state 230

    (176) variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    identifier                     shift and go to state 16
    type_identifier                shift and go to state 8
    expr                           shift and go to state 255
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 231

    (65) _11_optional -> < type _12_repeat > .
    =               reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    (               reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    -               reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    {               reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    [               reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    TYPE_IDENTIFIER reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    IDENTIFIER      reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    CASE            reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    IF              reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    DEF             reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    STRING          reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    NUMBER          reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    DO              reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    NEWLINE         reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    END             reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    ,               reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    NOT_LESS        reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    >               reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    ELIF            reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    ELSE            reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    )               reduce using rule 65 (_11_optional -> < type _12_repeat > .)
    }               reduce using rule 65 (_11_optional -> < type _12_repeat > .)


state 232

    (179) _37_items -> _37_items _37_item .
    ,               reduce using rule 179 (_37_items -> _37_items _37_item .)
    NOT_LESS        reduce using rule 179 (_37_items -> _37_items _37_item .)


state 233

    (181) _37_item -> , . type
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 256
    type_identifier                shift and go to state 99

state 234

    (68) _12_items -> _12_items _12_item .
    ,               reduce using rule 68 (_12_items -> _12_items _12_item .)
    >               reduce using rule 68 (_12_items -> _12_items _12_item .)


state 235

    (181) _37_item -> , type .
    (70) _12_item -> , type .
  ! reduce/reduce conflict for , resolved using rule 181 (_37_item -> , type .)
    ,               reduce using rule 181 (_37_item -> , type .)
    NOT_LESS        reduce using rule 181 (_37_item -> , type .)
    >               reduce using rule 70 (_12_item -> , type .)


state 236

    (126) array_pattern -> [ _25_optional _26_repeat ] .
    DO              reduce using rule 126 (array_pattern -> [ _25_optional _26_repeat ] .)
    ,               reduce using rule 126 (array_pattern -> [ _25_optional _26_repeat ] .)
    ]               reduce using rule 126 (array_pattern -> [ _25_optional _26_repeat ] .)
    }               reduce using rule 126 (array_pattern -> [ _25_optional _26_repeat ] .)
    )               reduce using rule 126 (array_pattern -> [ _25_optional _26_repeat ] .)


state 237

    (131) _26_items -> _26_items _26_item .
    ,               reduce using rule 131 (_26_items -> _26_items _26_item .)
    ]               reduce using rule 131 (_26_items -> _26_items _26_item .)


state 238

    (133) _26_item -> , pattern .
    ,               reduce using rule 133 (_26_item -> , pattern .)
    ]               reduce using rule 133 (_26_item -> , pattern .)


state 239

    (134) tuple_pattern -> { _27_optional _28_repeat } .
    DO              reduce using rule 134 (tuple_pattern -> { _27_optional _28_repeat } .)
    ,               reduce using rule 134 (tuple_pattern -> { _27_optional _28_repeat } .)
    ]               reduce using rule 134 (tuple_pattern -> { _27_optional _28_repeat } .)
    }               reduce using rule 134 (tuple_pattern -> { _27_optional _28_repeat } .)
    )               reduce using rule 134 (tuple_pattern -> { _27_optional _28_repeat } .)


state 240

    (139) _28_items -> _28_items _28_item .
    ,               reduce using rule 139 (_28_items -> _28_items _28_item .)
    }               reduce using rule 139 (_28_items -> _28_items _28_item .)


state 241

    (141) _28_item -> , pattern .
    ,               reduce using rule 141 (_28_item -> , pattern .)
    }               reduce using rule 141 (_28_item -> , pattern .)


state 242

    (142) enum_pattern -> type_identifier ( _29_optional _30_repeat . )
    )               shift and go to state 257


state 243

    (145) _30_repeat -> _30_items .
    (147) _30_items -> _30_items . _30_item
    (149) _30_item -> . , pattern
    )               reduce using rule 145 (_30_repeat -> _30_items .)
    ,               shift and go to state 245

    _30_item                       shift and go to state 258

state 244

    (148) _30_items -> _30_item .
    ,               reduce using rule 148 (_30_items -> _30_item .)
    )               reduce using rule 148 (_30_items -> _30_item .)


state 245

    (149) _30_item -> , . pattern
    (121) pattern -> . array_pattern
    (122) pattern -> . tuple_pattern
    (123) pattern -> . enum_pattern
    (124) pattern -> . param_pattern
    (126) array_pattern -> . [ _25_optional _26_repeat ]
    (134) tuple_pattern -> . { _27_optional _28_repeat }
    (142) enum_pattern -> . type_identifier ( _29_optional _30_repeat )
    (125) param_pattern -> . identifier
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    [               shift and go to state 124
    {               shift and go to state 125
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    pattern                        shift and go to state 259
    array_pattern                  shift and go to state 120
    tuple_pattern                  shift and go to state 121
    enum_pattern                   shift and go to state 122
    param_pattern                  shift and go to state 123
    type_identifier                shift and go to state 126
    identifier                     shift and go to state 127

state 246

    (105) if_expr -> IF expr THEN _21_optional block_statement _22_optional END .
    INT_DIV         reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    NOT_MORE        reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    NOT_LESS        reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    >               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    <               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    *               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    /               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    -               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    +               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    CONCAT          reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    (               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    NEWLINE         reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    $end            reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    ,               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    }               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    )               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    ]               reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    OF              reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    THEN            reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    END             reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    ELIF            reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)
    ELSE            reduce using rule 105 (if_expr -> IF expr THEN _21_optional block_statement _22_optional END .)


state 247

    (110) or_else -> ELIF expr . THEN block_statement _23_optional
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    THEN            shift and go to state 260
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 248

    (113) or_else -> ELSE block_statement .
    END             reduce using rule 113 (or_else -> ELSE block_statement .)


state 249

    (51) _7_items -> _7_items _7_item .
    NEWLINE         reduce using rule 51 (_7_items -> _7_items _7_item .)
    ELIF            reduce using rule 51 (_7_items -> _7_items _7_item .)
    ELSE            reduce using rule 51 (_7_items -> _7_items _7_item .)
    END             reduce using rule 51 (_7_items -> _7_items _7_item .)


state 250

    (53) _7_item -> NEWLINE expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NEWLINE         reduce using rule 53 (_7_item -> NEWLINE expr .)
    ELIF            reduce using rule 53 (_7_item -> NEWLINE expr .)
    ELSE            reduce using rule 53 (_7_item -> NEWLINE expr .)
    END             reduce using rule 53 (_7_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NOT_LESS        shift and go to state 39
    >               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 251

    (54) def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional . do
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    DO              shift and go to state 32

    do                             shift and go to state 261

state 252

    (62) _10_optional -> : . type
    (64) type -> . type_identifier _11_optional
    (150) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 262
    type_identifier                shift and go to state 99

state 253

    (70) _12_item -> , type .
    ,               reduce using rule 70 (_12_item -> , type .)
    >               reduce using rule 70 (_12_item -> , type .)


state 254

    (94) _18_optional -> ( fields_unnamed ) .
    TYPE_IDENTIFIER reduce using rule 94 (_18_optional -> ( fields_unnamed ) .)
    }               reduce using rule 94 (_18_optional -> ( fields_unnamed ) .)


state 255

    (176) variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    (167) call -> expr . ( _35_optional _36_repeat )
    NOT_MORE        reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    NOT_LESS        reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    >               reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    <               reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    NEWLINE         reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    $end            reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    ,               reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    }               reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    )               reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    ]               reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    OF              reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    THEN            reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    END             reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    ELIF            reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    ELSE            reduce using rule 176 (variable_declaration -> identifier : type_identifier < type _37_repeat NOT_LESS expr .)
    INT_DIV         shift and go to state 37
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46
    (               shift and go to state 47


state 256

    (181) _37_item -> , type .
    ,               reduce using rule 181 (_37_item -> , type .)
    NOT_LESS        reduce using rule 181 (_37_item -> , type .)


state 257

    (142) enum_pattern -> type_identifier ( _29_optional _30_repeat ) .
    DO              reduce using rule 142 (enum_pattern -> type_identifier ( _29_optional _30_repeat ) .)
    ,               reduce using rule 142 (enum_pattern -> type_identifier ( _29_optional _30_repeat ) .)
    ]               reduce using rule 142 (enum_pattern -> type_identifier ( _29_optional _30_repeat ) .)
    }               reduce using rule 142 (enum_pattern -> type_identifier ( _29_optional _30_repeat ) .)
    )               reduce using rule 142 (enum_pattern -> type_identifier ( _29_optional _30_repeat ) .)


state 258

    (147) _30_items -> _30_items _30_item .
    ,               reduce using rule 147 (_30_items -> _30_items _30_item .)
    )               reduce using rule 147 (_30_items -> _30_items _30_item .)


state 259

    (149) _30_item -> , pattern .
    ,               reduce using rule 149 (_30_item -> , pattern .)
    )               reduce using rule 149 (_30_item -> , pattern .)


state 260

    (110) or_else -> ELIF expr THEN . block_statement _23_optional
    (46) block_statement -> . _6_optional _7_repeat
    (47) _6_optional -> . expr
    (48) _6_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (159) tuple -> . { _33_optional _34_repeat }
    (151) array -> . [ _31_optional _32_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (150) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    (176) variable_declaration -> . identifier : type_identifier < type _37_repeat NOT_LESS expr
    (182) variable_declaration -> . identifier _38_optional = expr
    (114) case_of -> . CASE expr OF case _24_repeat END
    (167) call -> . expr ( _35_optional _36_repeat )
    (105) if_expr -> . IF expr THEN _21_optional block_statement _22_optional END
    (54) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (185) literal -> . STRING
    (186) literal -> . NUMBER
    (36) do -> . DO _3_optional _4_optional _5_repeat END
    NEWLINE         reduce using rule 48 (_6_optional -> .)
    ELIF            reduce using rule 48 (_6_optional -> .)
    ELSE            reduce using rule 48 (_6_optional -> .)
    END             reduce using rule 48 (_6_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32

    expr                           shift and go to state 170
    block_statement                shift and go to state 263
    _6_optional                    shift and go to state 172
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 261

    (54) def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .
    INT_DIV         reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    NOT_MORE        reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    NOT_LESS        reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    >               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    <               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    *               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    /               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    -               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    +               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    CONCAT          reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    (               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    NEWLINE         reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    $end            reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    ,               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    }               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    )               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    ]               reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    OF              reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    THEN            reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    END             reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    ELIF            reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    ELSE            reduce using rule 54 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)


state 262

    (62) _10_optional -> : type .
    DO              reduce using rule 62 (_10_optional -> : type .)


state 263

    (110) or_else -> ELIF expr THEN block_statement . _23_optional
    (111) _23_optional -> . or_else
    (112) _23_optional -> .
    (110) or_else -> . ELIF expr THEN block_statement _23_optional
    (113) or_else -> . ELSE block_statement
    END             reduce using rule 112 (_23_optional -> .)
    ELIF            shift and go to state 217
    ELSE            shift and go to state 218

    _23_optional                   shift and go to state 264
    or_else                        shift and go to state 265

state 264

    (110) or_else -> ELIF expr THEN block_statement _23_optional .
    END             reduce using rule 110 (or_else -> ELIF expr THEN block_statement _23_optional .)


state 265

    (111) _23_optional -> or_else .
    END             reduce using rule 111 (_23_optional -> or_else .)


Conflicts:

reduce/reduce conflict in state 235 resolved using rule _37_item -> , type
rejected rule (_12_item -> , type) in state 235