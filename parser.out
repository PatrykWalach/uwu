Grammar:

Rule 0     S' -> program
Rule 1     program -> expressions
Rule 2     expressions -> _1_repeat
Rule 3     _1_repeat -> _1_items
Rule 4     _1_repeat -> <empty>
Rule 5     _1_items -> _1_items _1_item
Rule 6     _1_items -> _1_item
Rule 7     _1_item -> expr
Rule 8     expr -> enum
Rule 9     expr -> struct
Rule 10    expr -> ( expr )
Rule 11    expr -> - expr  [precedence=right, level=4]
Rule 12    expr -> tuple
Rule 13    expr -> array
Rule 14    expr -> binary_expr
Rule 15    expr -> variable_declaration
Rule 16    expr -> case_of
Rule 17    expr -> call
Rule 18    expr -> _if
Rule 19    expr -> _def
Rule 20    expr -> literal
Rule 21    expr -> identifier
Rule 22    expr -> do
Rule 23    binary_expr -> expr INT_DIV expr  [precedence=left, level=3]
Rule 24    binary_expr -> expr * expr  [precedence=left, level=3]
Rule 25    binary_expr -> expr / expr  [precedence=left, level=3]
Rule 26    binary_expr -> expr - expr  [precedence=left, level=2]
Rule 27    binary_expr -> expr + expr  [precedence=left, level=2]
Rule 28    binary_expr -> expr CONCAT expr  [precedence=left, level=1]
Rule 29    do -> DO _2_optional expressions END
Rule 30    _2_optional -> type
Rule 31    _2_optional -> <empty>
Rule 32    _def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do
Rule 33    _3_optional -> param
Rule 34    _3_optional -> <empty>
Rule 35    _4_repeat -> _4_items
Rule 36    _4_repeat -> <empty>
Rule 37    _4_items -> _4_items _4_item
Rule 38    _4_items -> _4_item
Rule 39    _4_item -> , param
Rule 40    _5_optional -> type
Rule 41    _5_optional -> <empty>
Rule 42    type -> : type_identifier _6_optional
Rule 43    _6_optional -> < identifier _7_repeat >
Rule 44    _7_repeat -> _7_items
Rule 45    _7_repeat -> <empty>
Rule 46    _7_items -> _7_items _7_item
Rule 47    _7_items -> _7_item
Rule 48    _7_item -> , identifier
Rule 49    _6_optional -> <empty>
Rule 50    struct -> STRUCT type_identifier _8_optional { _10_repeat }
Rule 51    _8_optional -> < identifier _9_repeat >
Rule 52    _9_repeat -> _9_items
Rule 53    _9_repeat -> <empty>
Rule 54    _9_items -> _9_items _9_item
Rule 55    _9_items -> _9_item
Rule 56    _9_item -> , identifier
Rule 57    _8_optional -> <empty>
Rule 58    _10_repeat -> _10_items
Rule 59    _10_repeat -> <empty>
Rule 60    _10_items -> _10_items _10_item
Rule 61    _10_items -> _10_item
Rule 62    _10_item -> identifier type
Rule 63    enum -> ENUM type_identifier _11_optional { _13_repeat }
Rule 64    _11_optional -> < identifier _12_repeat >
Rule 65    _12_repeat -> _12_items
Rule 66    _12_repeat -> <empty>
Rule 67    _12_items -> _12_items _12_item
Rule 68    _12_items -> _12_item
Rule 69    _12_item -> , identifier
Rule 70    _11_optional -> <empty>
Rule 71    _13_repeat -> _13_items
Rule 72    _13_repeat -> <empty>
Rule 73    _13_items -> _13_items _13_item
Rule 74    _13_items -> _13_item
Rule 75    _13_item -> enum_key
Rule 76    enum_key -> identifier _14_optional
Rule 77    _14_optional -> ( identifier _15_repeat )
Rule 78    _15_repeat -> _15_items
Rule 79    _15_repeat -> <empty>
Rule 80    _15_items -> _15_items _15_item
Rule 81    _15_items -> _15_item
Rule 82    _15_item -> , identifier
Rule 83    _14_optional -> <empty>
Rule 84    param -> identifier _16_optional
Rule 85    _16_optional -> type
Rule 86    _16_optional -> <empty>
Rule 87    _if -> IF expr DO expressions _17_repeat _18_optional END
Rule 88    _17_repeat -> _17_items
Rule 89    _17_repeat -> <empty>
Rule 90    _17_items -> _17_items _17_item
Rule 91    _17_items -> _17_item
Rule 92    _17_item -> _elif
Rule 93    _18_optional -> ELSE expressions
Rule 94    _18_optional -> <empty>
Rule 95    _elif -> ELIF expr DO expressions
Rule 96    case_of -> CASE expr OF case _19_repeat END
Rule 97    _19_repeat -> _19_items
Rule 98    _19_repeat -> <empty>
Rule 99    _19_items -> _19_items _19_item
Rule 100   _19_items -> _19_item
Rule 101   _19_item -> case
Rule 102   case -> pattern _20_repeat do
Rule 103   _20_repeat -> _20_items
Rule 104   _20_repeat -> <empty>
Rule 105   _20_items -> _20_items _20_item
Rule 106   _20_items -> _20_item
Rule 107   _20_item -> , pattern
Rule 108   pattern -> array_pattern
Rule 109   pattern -> tuple_pattern
Rule 110   pattern -> enum_pattern
Rule 111   array_pattern -> [ _21_repeat _22_optional ]
Rule 112   _21_repeat -> _21_items
Rule 113   _21_repeat -> <empty>
Rule 114   _21_items -> _21_items _21_item
Rule 115   _21_items -> _21_item
Rule 116   _21_item -> pattern ,
Rule 117   _22_optional -> SPREAD identifier _23_repeat
Rule 118   _23_repeat -> _23_items
Rule 119   _23_repeat -> <empty>
Rule 120   _23_items -> _23_items _23_item
Rule 121   _23_items -> _23_item
Rule 122   _23_item -> , pattern
Rule 123   _22_optional -> <empty>
Rule 124   enum_pattern -> type_identifier _24_optional
Rule 125   _24_optional -> ( pattern _25_repeat )
Rule 126   _25_repeat -> _25_items
Rule 127   _25_repeat -> <empty>
Rule 128   _25_items -> _25_items _25_item
Rule 129   _25_items -> _25_item
Rule 130   _25_item -> , pattern
Rule 131   _24_optional -> <empty>
Rule 132   tuple_pattern -> { _26_repeat _27_optional }
Rule 133   _26_repeat -> _26_items
Rule 134   _26_repeat -> <empty>
Rule 135   _26_items -> _26_items _26_item
Rule 136   _26_items -> _26_item
Rule 137   _26_item -> pattern ,
Rule 138   _27_optional -> SPREAD identifier _28_repeat
Rule 139   _28_repeat -> _28_items
Rule 140   _28_repeat -> <empty>
Rule 141   _28_items -> _28_items _28_item
Rule 142   _28_items -> _28_item
Rule 143   _28_item -> , pattern
Rule 144   _27_optional -> <empty>
Rule 145   array -> [ _29_optional _30_repeat ]
Rule 146   _29_optional -> expr
Rule 147   _29_optional -> <empty>
Rule 148   _30_repeat -> _30_items
Rule 149   _30_repeat -> <empty>
Rule 150   _30_items -> _30_items _30_item
Rule 151   _30_items -> _30_item
Rule 152   _30_item -> , expr
Rule 153   tuple -> { _31_optional _32_repeat }
Rule 154   _31_optional -> expr
Rule 155   _31_optional -> <empty>
Rule 156   _32_repeat -> _32_items
Rule 157   _32_repeat -> <empty>
Rule 158   _32_items -> _32_items _32_item
Rule 159   _32_items -> _32_item
Rule 160   _32_item -> , expr
Rule 161   call -> callee ( _33_optional _34_repeat )
Rule 162   _33_optional -> expr
Rule 163   _33_optional -> <empty>
Rule 164   _34_repeat -> _34_items
Rule 165   _34_repeat -> <empty>
Rule 166   _34_items -> _34_items _34_item
Rule 167   _34_items -> _34_item
Rule 168   _34_item -> , expr
Rule 169   callee -> identifier
Rule 170   identifier -> IDENTIFIER
Rule 171   type_identifier -> TYPE_IDENTIFIER
Rule 172   variable_declaration -> identifier _35_optional = expr
Rule 173   _35_optional -> type
Rule 174   _35_optional -> <empty>
Rule 175   literal -> NUMBER
Rule 176   literal -> STRING

Terminals, with rules where they appear:

(                    : 10 32 77 125 161
)                    : 10 32 77 125 161
*                    : 24
+                    : 27
,                    : 39 48 56 69 82 107 116 122 130 137 143 152 160 168
-                    : 11 26
/                    : 25
:                    : 42
<                    : 43 51 64
=                    : 172
>                    : 43 51 64
CASE                 : 96
CONCAT               : 28
DEF                  : 32
DO                   : 29 87 95
ELIF                 : 95
ELSE                 : 93
END                  : 29 87 96
ENUM                 : 63
IDENTIFIER           : 170
IF                   : 87
INT_DIV              : 23
NUMBER               : 175
OF                   : 96
SPREAD               : 117 138
STRING               : 176
STRUCT               : 50
TYPE_IDENTIFIER      : 171
[                    : 111 145
]                    : 111 145
error                : 
{                    : 50 63 132 153
}                    : 50 63 132 153

Nonterminals, with rules where they appear:

_10_item             : 60 61
_10_items            : 58 60
_10_repeat           : 50
_11_optional         : 63
_12_item             : 67 68
_12_items            : 65 67
_12_repeat           : 64
_13_item             : 73 74
_13_items            : 71 73
_13_repeat           : 63
_14_optional         : 76
_15_item             : 80 81
_15_items            : 78 80
_15_repeat           : 77
_16_optional         : 84
_17_item             : 90 91
_17_items            : 88 90
_17_repeat           : 87
_18_optional         : 87
_19_item             : 99 100
_19_items            : 97 99
_19_repeat           : 96
_1_item              : 5 6
_1_items             : 3 5
_1_repeat            : 2
_20_item             : 105 106
_20_items            : 103 105
_20_repeat           : 102
_21_item             : 114 115
_21_items            : 112 114
_21_repeat           : 111
_22_optional         : 111
_23_item             : 120 121
_23_items            : 118 120
_23_repeat           : 117
_24_optional         : 124
_25_item             : 128 129
_25_items            : 126 128
_25_repeat           : 125
_26_item             : 135 136
_26_items            : 133 135
_26_repeat           : 132
_27_optional         : 132
_28_item             : 141 142
_28_items            : 139 141
_28_repeat           : 138
_29_optional         : 145
_2_optional          : 29
_30_item             : 150 151
_30_items            : 148 150
_30_repeat           : 145
_31_optional         : 153
_32_item             : 158 159
_32_items            : 156 158
_32_repeat           : 153
_33_optional         : 161
_34_item             : 166 167
_34_items            : 164 166
_34_repeat           : 161
_35_optional         : 172
_3_optional          : 32
_4_item              : 37 38
_4_items             : 35 37
_4_repeat            : 32
_5_optional          : 32
_6_optional          : 42
_7_item              : 46 47
_7_items             : 44 46
_7_repeat            : 43
_8_optional          : 50
_9_item              : 54 55
_9_items             : 52 54
_9_repeat            : 51
_def                 : 19
_elif                : 92
_if                  : 18
array                : 13
array_pattern        : 108
binary_expr          : 14
call                 : 17
callee               : 161
case                 : 96 101
case_of              : 16
do                   : 22 32 102
enum                 : 8
enum_key             : 75
enum_pattern         : 110
expr                 : 7 10 11 23 23 24 24 25 25 26 26 27 27 28 28 87 95 96 146 152 154 160 162 168 172
expressions          : 1 29 87 93 95
identifier           : 21 32 43 48 51 56 62 64 69 76 77 82 84 117 138 169 172
literal              : 20
param                : 33 39
pattern              : 102 107 116 122 125 130 137 143
program              : 0
struct               : 9
tuple                : 12
tuple_pattern        : 109
type                 : 30 40 62 85 173
type_identifier      : 42 50 63 124
variable_declaration : 15


state 0

    (0) S' -> . program
    (1) program -> . expressions
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    $end            reduce using rule 4 (_1_repeat -> .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    program                        shift and go to state 1
    expressions                    shift and go to state 2
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    expr                           shift and go to state 6
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 1

    (0) S' -> program .


state 2

    (1) program -> expressions .
    $end            reduce using rule 1 (program -> expressions .)


state 3

    (2) expressions -> _1_repeat .
    $end            reduce using rule 2 (expressions -> _1_repeat .)
    END             reduce using rule 2 (expressions -> _1_repeat .)
    ELIF            reduce using rule 2 (expressions -> _1_repeat .)
    ELSE            reduce using rule 2 (expressions -> _1_repeat .)


state 4

    (3) _1_repeat -> _1_items .
    (5) _1_items -> _1_items . _1_item
    (7) _1_item -> . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    $end            reduce using rule 3 (_1_repeat -> _1_items .)
    END             reduce using rule 3 (_1_repeat -> _1_items .)
    ELIF            reduce using rule 3 (_1_repeat -> _1_items .)
    ELSE            reduce using rule 3 (_1_repeat -> _1_items .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _1_item                        shift and go to state 34
    expr                           shift and go to state 6
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 5

    (6) _1_items -> _1_item .
    (               reduce using rule 6 (_1_items -> _1_item .)
    -               reduce using rule 6 (_1_items -> _1_item .)
    ENUM            reduce using rule 6 (_1_items -> _1_item .)
    STRUCT          reduce using rule 6 (_1_items -> _1_item .)
    {               reduce using rule 6 (_1_items -> _1_item .)
    [               reduce using rule 6 (_1_items -> _1_item .)
    CASE            reduce using rule 6 (_1_items -> _1_item .)
    IF              reduce using rule 6 (_1_items -> _1_item .)
    DEF             reduce using rule 6 (_1_items -> _1_item .)
    NUMBER          reduce using rule 6 (_1_items -> _1_item .)
    STRING          reduce using rule 6 (_1_items -> _1_item .)
    IDENTIFIER      reduce using rule 6 (_1_items -> _1_item .)
    DO              reduce using rule 6 (_1_items -> _1_item .)
    $end            reduce using rule 6 (_1_items -> _1_item .)
    END             reduce using rule 6 (_1_items -> _1_item .)
    ELIF            reduce using rule 6 (_1_items -> _1_item .)
    ELSE            reduce using rule 6 (_1_items -> _1_item .)


state 6

    (7) _1_item -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for - resolved as shift
    (               reduce using rule 7 (_1_item -> expr .)
    ENUM            reduce using rule 7 (_1_item -> expr .)
    STRUCT          reduce using rule 7 (_1_item -> expr .)
    {               reduce using rule 7 (_1_item -> expr .)
    [               reduce using rule 7 (_1_item -> expr .)
    CASE            reduce using rule 7 (_1_item -> expr .)
    IF              reduce using rule 7 (_1_item -> expr .)
    DEF             reduce using rule 7 (_1_item -> expr .)
    NUMBER          reduce using rule 7 (_1_item -> expr .)
    STRING          reduce using rule 7 (_1_item -> expr .)
    IDENTIFIER      reduce using rule 7 (_1_item -> expr .)
    DO              reduce using rule 7 (_1_item -> expr .)
    $end            reduce using rule 7 (_1_item -> expr .)
    END             reduce using rule 7 (_1_item -> expr .)
    ELIF            reduce using rule 7 (_1_item -> expr .)
    ELSE            reduce using rule 7 (_1_item -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 7

    (8) expr -> enum .
    INT_DIV         reduce using rule 8 (expr -> enum .)
    *               reduce using rule 8 (expr -> enum .)
    /               reduce using rule 8 (expr -> enum .)
    -               reduce using rule 8 (expr -> enum .)
    +               reduce using rule 8 (expr -> enum .)
    CONCAT          reduce using rule 8 (expr -> enum .)
    (               reduce using rule 8 (expr -> enum .)
    ENUM            reduce using rule 8 (expr -> enum .)
    STRUCT          reduce using rule 8 (expr -> enum .)
    {               reduce using rule 8 (expr -> enum .)
    [               reduce using rule 8 (expr -> enum .)
    CASE            reduce using rule 8 (expr -> enum .)
    IF              reduce using rule 8 (expr -> enum .)
    DEF             reduce using rule 8 (expr -> enum .)
    NUMBER          reduce using rule 8 (expr -> enum .)
    STRING          reduce using rule 8 (expr -> enum .)
    IDENTIFIER      reduce using rule 8 (expr -> enum .)
    DO              reduce using rule 8 (expr -> enum .)
    $end            reduce using rule 8 (expr -> enum .)
    END             reduce using rule 8 (expr -> enum .)
    ELIF            reduce using rule 8 (expr -> enum .)
    ELSE            reduce using rule 8 (expr -> enum .)
    )               reduce using rule 8 (expr -> enum .)
    ,               reduce using rule 8 (expr -> enum .)
    }               reduce using rule 8 (expr -> enum .)
    ]               reduce using rule 8 (expr -> enum .)
    OF              reduce using rule 8 (expr -> enum .)


state 8

    (9) expr -> struct .
    INT_DIV         reduce using rule 9 (expr -> struct .)
    *               reduce using rule 9 (expr -> struct .)
    /               reduce using rule 9 (expr -> struct .)
    -               reduce using rule 9 (expr -> struct .)
    +               reduce using rule 9 (expr -> struct .)
    CONCAT          reduce using rule 9 (expr -> struct .)
    (               reduce using rule 9 (expr -> struct .)
    ENUM            reduce using rule 9 (expr -> struct .)
    STRUCT          reduce using rule 9 (expr -> struct .)
    {               reduce using rule 9 (expr -> struct .)
    [               reduce using rule 9 (expr -> struct .)
    CASE            reduce using rule 9 (expr -> struct .)
    IF              reduce using rule 9 (expr -> struct .)
    DEF             reduce using rule 9 (expr -> struct .)
    NUMBER          reduce using rule 9 (expr -> struct .)
    STRING          reduce using rule 9 (expr -> struct .)
    IDENTIFIER      reduce using rule 9 (expr -> struct .)
    DO              reduce using rule 9 (expr -> struct .)
    $end            reduce using rule 9 (expr -> struct .)
    END             reduce using rule 9 (expr -> struct .)
    ELIF            reduce using rule 9 (expr -> struct .)
    ELSE            reduce using rule 9 (expr -> struct .)
    )               reduce using rule 9 (expr -> struct .)
    ,               reduce using rule 9 (expr -> struct .)
    }               reduce using rule 9 (expr -> struct .)
    ]               reduce using rule 9 (expr -> struct .)
    OF              reduce using rule 9 (expr -> struct .)


state 9

    (10) expr -> ( . expr )
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 41
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 10

    (11) expr -> - . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 42
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 11

    (12) expr -> tuple .
    INT_DIV         reduce using rule 12 (expr -> tuple .)
    *               reduce using rule 12 (expr -> tuple .)
    /               reduce using rule 12 (expr -> tuple .)
    -               reduce using rule 12 (expr -> tuple .)
    +               reduce using rule 12 (expr -> tuple .)
    CONCAT          reduce using rule 12 (expr -> tuple .)
    (               reduce using rule 12 (expr -> tuple .)
    ENUM            reduce using rule 12 (expr -> tuple .)
    STRUCT          reduce using rule 12 (expr -> tuple .)
    {               reduce using rule 12 (expr -> tuple .)
    [               reduce using rule 12 (expr -> tuple .)
    CASE            reduce using rule 12 (expr -> tuple .)
    IF              reduce using rule 12 (expr -> tuple .)
    DEF             reduce using rule 12 (expr -> tuple .)
    NUMBER          reduce using rule 12 (expr -> tuple .)
    STRING          reduce using rule 12 (expr -> tuple .)
    IDENTIFIER      reduce using rule 12 (expr -> tuple .)
    DO              reduce using rule 12 (expr -> tuple .)
    $end            reduce using rule 12 (expr -> tuple .)
    END             reduce using rule 12 (expr -> tuple .)
    ELIF            reduce using rule 12 (expr -> tuple .)
    ELSE            reduce using rule 12 (expr -> tuple .)
    )               reduce using rule 12 (expr -> tuple .)
    ,               reduce using rule 12 (expr -> tuple .)
    }               reduce using rule 12 (expr -> tuple .)
    ]               reduce using rule 12 (expr -> tuple .)
    OF              reduce using rule 12 (expr -> tuple .)


state 12

    (13) expr -> array .
    INT_DIV         reduce using rule 13 (expr -> array .)
    *               reduce using rule 13 (expr -> array .)
    /               reduce using rule 13 (expr -> array .)
    -               reduce using rule 13 (expr -> array .)
    +               reduce using rule 13 (expr -> array .)
    CONCAT          reduce using rule 13 (expr -> array .)
    (               reduce using rule 13 (expr -> array .)
    ENUM            reduce using rule 13 (expr -> array .)
    STRUCT          reduce using rule 13 (expr -> array .)
    {               reduce using rule 13 (expr -> array .)
    [               reduce using rule 13 (expr -> array .)
    CASE            reduce using rule 13 (expr -> array .)
    IF              reduce using rule 13 (expr -> array .)
    DEF             reduce using rule 13 (expr -> array .)
    NUMBER          reduce using rule 13 (expr -> array .)
    STRING          reduce using rule 13 (expr -> array .)
    IDENTIFIER      reduce using rule 13 (expr -> array .)
    DO              reduce using rule 13 (expr -> array .)
    $end            reduce using rule 13 (expr -> array .)
    END             reduce using rule 13 (expr -> array .)
    ELIF            reduce using rule 13 (expr -> array .)
    ELSE            reduce using rule 13 (expr -> array .)
    )               reduce using rule 13 (expr -> array .)
    ,               reduce using rule 13 (expr -> array .)
    }               reduce using rule 13 (expr -> array .)
    ]               reduce using rule 13 (expr -> array .)
    OF              reduce using rule 13 (expr -> array .)


state 13

    (14) expr -> binary_expr .
    INT_DIV         reduce using rule 14 (expr -> binary_expr .)
    *               reduce using rule 14 (expr -> binary_expr .)
    /               reduce using rule 14 (expr -> binary_expr .)
    -               reduce using rule 14 (expr -> binary_expr .)
    +               reduce using rule 14 (expr -> binary_expr .)
    CONCAT          reduce using rule 14 (expr -> binary_expr .)
    (               reduce using rule 14 (expr -> binary_expr .)
    ENUM            reduce using rule 14 (expr -> binary_expr .)
    STRUCT          reduce using rule 14 (expr -> binary_expr .)
    {               reduce using rule 14 (expr -> binary_expr .)
    [               reduce using rule 14 (expr -> binary_expr .)
    CASE            reduce using rule 14 (expr -> binary_expr .)
    IF              reduce using rule 14 (expr -> binary_expr .)
    DEF             reduce using rule 14 (expr -> binary_expr .)
    NUMBER          reduce using rule 14 (expr -> binary_expr .)
    STRING          reduce using rule 14 (expr -> binary_expr .)
    IDENTIFIER      reduce using rule 14 (expr -> binary_expr .)
    DO              reduce using rule 14 (expr -> binary_expr .)
    $end            reduce using rule 14 (expr -> binary_expr .)
    END             reduce using rule 14 (expr -> binary_expr .)
    ELIF            reduce using rule 14 (expr -> binary_expr .)
    ELSE            reduce using rule 14 (expr -> binary_expr .)
    )               reduce using rule 14 (expr -> binary_expr .)
    ,               reduce using rule 14 (expr -> binary_expr .)
    }               reduce using rule 14 (expr -> binary_expr .)
    ]               reduce using rule 14 (expr -> binary_expr .)
    OF              reduce using rule 14 (expr -> binary_expr .)


state 14

    (15) expr -> variable_declaration .
    INT_DIV         reduce using rule 15 (expr -> variable_declaration .)
    *               reduce using rule 15 (expr -> variable_declaration .)
    /               reduce using rule 15 (expr -> variable_declaration .)
    -               reduce using rule 15 (expr -> variable_declaration .)
    +               reduce using rule 15 (expr -> variable_declaration .)
    CONCAT          reduce using rule 15 (expr -> variable_declaration .)
    (               reduce using rule 15 (expr -> variable_declaration .)
    ENUM            reduce using rule 15 (expr -> variable_declaration .)
    STRUCT          reduce using rule 15 (expr -> variable_declaration .)
    {               reduce using rule 15 (expr -> variable_declaration .)
    [               reduce using rule 15 (expr -> variable_declaration .)
    CASE            reduce using rule 15 (expr -> variable_declaration .)
    IF              reduce using rule 15 (expr -> variable_declaration .)
    DEF             reduce using rule 15 (expr -> variable_declaration .)
    NUMBER          reduce using rule 15 (expr -> variable_declaration .)
    STRING          reduce using rule 15 (expr -> variable_declaration .)
    IDENTIFIER      reduce using rule 15 (expr -> variable_declaration .)
    DO              reduce using rule 15 (expr -> variable_declaration .)
    $end            reduce using rule 15 (expr -> variable_declaration .)
    END             reduce using rule 15 (expr -> variable_declaration .)
    ELIF            reduce using rule 15 (expr -> variable_declaration .)
    ELSE            reduce using rule 15 (expr -> variable_declaration .)
    )               reduce using rule 15 (expr -> variable_declaration .)
    ,               reduce using rule 15 (expr -> variable_declaration .)
    }               reduce using rule 15 (expr -> variable_declaration .)
    ]               reduce using rule 15 (expr -> variable_declaration .)
    OF              reduce using rule 15 (expr -> variable_declaration .)


state 15

    (16) expr -> case_of .
    INT_DIV         reduce using rule 16 (expr -> case_of .)
    *               reduce using rule 16 (expr -> case_of .)
    /               reduce using rule 16 (expr -> case_of .)
    -               reduce using rule 16 (expr -> case_of .)
    +               reduce using rule 16 (expr -> case_of .)
    CONCAT          reduce using rule 16 (expr -> case_of .)
    (               reduce using rule 16 (expr -> case_of .)
    ENUM            reduce using rule 16 (expr -> case_of .)
    STRUCT          reduce using rule 16 (expr -> case_of .)
    {               reduce using rule 16 (expr -> case_of .)
    [               reduce using rule 16 (expr -> case_of .)
    CASE            reduce using rule 16 (expr -> case_of .)
    IF              reduce using rule 16 (expr -> case_of .)
    DEF             reduce using rule 16 (expr -> case_of .)
    NUMBER          reduce using rule 16 (expr -> case_of .)
    STRING          reduce using rule 16 (expr -> case_of .)
    IDENTIFIER      reduce using rule 16 (expr -> case_of .)
    DO              reduce using rule 16 (expr -> case_of .)
    $end            reduce using rule 16 (expr -> case_of .)
    END             reduce using rule 16 (expr -> case_of .)
    ELIF            reduce using rule 16 (expr -> case_of .)
    ELSE            reduce using rule 16 (expr -> case_of .)
    )               reduce using rule 16 (expr -> case_of .)
    ,               reduce using rule 16 (expr -> case_of .)
    }               reduce using rule 16 (expr -> case_of .)
    ]               reduce using rule 16 (expr -> case_of .)
    OF              reduce using rule 16 (expr -> case_of .)


state 16

    (17) expr -> call .
    INT_DIV         reduce using rule 17 (expr -> call .)
    *               reduce using rule 17 (expr -> call .)
    /               reduce using rule 17 (expr -> call .)
    -               reduce using rule 17 (expr -> call .)
    +               reduce using rule 17 (expr -> call .)
    CONCAT          reduce using rule 17 (expr -> call .)
    (               reduce using rule 17 (expr -> call .)
    ENUM            reduce using rule 17 (expr -> call .)
    STRUCT          reduce using rule 17 (expr -> call .)
    {               reduce using rule 17 (expr -> call .)
    [               reduce using rule 17 (expr -> call .)
    CASE            reduce using rule 17 (expr -> call .)
    IF              reduce using rule 17 (expr -> call .)
    DEF             reduce using rule 17 (expr -> call .)
    NUMBER          reduce using rule 17 (expr -> call .)
    STRING          reduce using rule 17 (expr -> call .)
    IDENTIFIER      reduce using rule 17 (expr -> call .)
    DO              reduce using rule 17 (expr -> call .)
    $end            reduce using rule 17 (expr -> call .)
    END             reduce using rule 17 (expr -> call .)
    ELIF            reduce using rule 17 (expr -> call .)
    ELSE            reduce using rule 17 (expr -> call .)
    )               reduce using rule 17 (expr -> call .)
    ,               reduce using rule 17 (expr -> call .)
    }               reduce using rule 17 (expr -> call .)
    ]               reduce using rule 17 (expr -> call .)
    OF              reduce using rule 17 (expr -> call .)


state 17

    (18) expr -> _if .
    INT_DIV         reduce using rule 18 (expr -> _if .)
    *               reduce using rule 18 (expr -> _if .)
    /               reduce using rule 18 (expr -> _if .)
    -               reduce using rule 18 (expr -> _if .)
    +               reduce using rule 18 (expr -> _if .)
    CONCAT          reduce using rule 18 (expr -> _if .)
    (               reduce using rule 18 (expr -> _if .)
    ENUM            reduce using rule 18 (expr -> _if .)
    STRUCT          reduce using rule 18 (expr -> _if .)
    {               reduce using rule 18 (expr -> _if .)
    [               reduce using rule 18 (expr -> _if .)
    CASE            reduce using rule 18 (expr -> _if .)
    IF              reduce using rule 18 (expr -> _if .)
    DEF             reduce using rule 18 (expr -> _if .)
    NUMBER          reduce using rule 18 (expr -> _if .)
    STRING          reduce using rule 18 (expr -> _if .)
    IDENTIFIER      reduce using rule 18 (expr -> _if .)
    DO              reduce using rule 18 (expr -> _if .)
    $end            reduce using rule 18 (expr -> _if .)
    END             reduce using rule 18 (expr -> _if .)
    ELIF            reduce using rule 18 (expr -> _if .)
    ELSE            reduce using rule 18 (expr -> _if .)
    )               reduce using rule 18 (expr -> _if .)
    ,               reduce using rule 18 (expr -> _if .)
    }               reduce using rule 18 (expr -> _if .)
    ]               reduce using rule 18 (expr -> _if .)
    OF              reduce using rule 18 (expr -> _if .)


state 18

    (19) expr -> _def .
    INT_DIV         reduce using rule 19 (expr -> _def .)
    *               reduce using rule 19 (expr -> _def .)
    /               reduce using rule 19 (expr -> _def .)
    -               reduce using rule 19 (expr -> _def .)
    +               reduce using rule 19 (expr -> _def .)
    CONCAT          reduce using rule 19 (expr -> _def .)
    (               reduce using rule 19 (expr -> _def .)
    ENUM            reduce using rule 19 (expr -> _def .)
    STRUCT          reduce using rule 19 (expr -> _def .)
    {               reduce using rule 19 (expr -> _def .)
    [               reduce using rule 19 (expr -> _def .)
    CASE            reduce using rule 19 (expr -> _def .)
    IF              reduce using rule 19 (expr -> _def .)
    DEF             reduce using rule 19 (expr -> _def .)
    NUMBER          reduce using rule 19 (expr -> _def .)
    STRING          reduce using rule 19 (expr -> _def .)
    IDENTIFIER      reduce using rule 19 (expr -> _def .)
    DO              reduce using rule 19 (expr -> _def .)
    $end            reduce using rule 19 (expr -> _def .)
    END             reduce using rule 19 (expr -> _def .)
    ELIF            reduce using rule 19 (expr -> _def .)
    ELSE            reduce using rule 19 (expr -> _def .)
    )               reduce using rule 19 (expr -> _def .)
    ,               reduce using rule 19 (expr -> _def .)
    }               reduce using rule 19 (expr -> _def .)
    ]               reduce using rule 19 (expr -> _def .)
    OF              reduce using rule 19 (expr -> _def .)


state 19

    (20) expr -> literal .
    INT_DIV         reduce using rule 20 (expr -> literal .)
    *               reduce using rule 20 (expr -> literal .)
    /               reduce using rule 20 (expr -> literal .)
    -               reduce using rule 20 (expr -> literal .)
    +               reduce using rule 20 (expr -> literal .)
    CONCAT          reduce using rule 20 (expr -> literal .)
    (               reduce using rule 20 (expr -> literal .)
    ENUM            reduce using rule 20 (expr -> literal .)
    STRUCT          reduce using rule 20 (expr -> literal .)
    {               reduce using rule 20 (expr -> literal .)
    [               reduce using rule 20 (expr -> literal .)
    CASE            reduce using rule 20 (expr -> literal .)
    IF              reduce using rule 20 (expr -> literal .)
    DEF             reduce using rule 20 (expr -> literal .)
    NUMBER          reduce using rule 20 (expr -> literal .)
    STRING          reduce using rule 20 (expr -> literal .)
    IDENTIFIER      reduce using rule 20 (expr -> literal .)
    DO              reduce using rule 20 (expr -> literal .)
    $end            reduce using rule 20 (expr -> literal .)
    END             reduce using rule 20 (expr -> literal .)
    ELIF            reduce using rule 20 (expr -> literal .)
    ELSE            reduce using rule 20 (expr -> literal .)
    )               reduce using rule 20 (expr -> literal .)
    ,               reduce using rule 20 (expr -> literal .)
    }               reduce using rule 20 (expr -> literal .)
    ]               reduce using rule 20 (expr -> literal .)
    OF              reduce using rule 20 (expr -> literal .)


state 20

    (21) expr -> identifier .
    (172) variable_declaration -> identifier . _35_optional = expr
    (169) callee -> identifier .
    (173) _35_optional -> . type
    (174) _35_optional -> .
    (42) type -> . : type_identifier _6_optional
  ! reduce/reduce conflict for ( resolved using rule 21 (expr -> identifier .)
    INT_DIV         reduce using rule 21 (expr -> identifier .)
    *               reduce using rule 21 (expr -> identifier .)
    /               reduce using rule 21 (expr -> identifier .)
    -               reduce using rule 21 (expr -> identifier .)
    +               reduce using rule 21 (expr -> identifier .)
    CONCAT          reduce using rule 21 (expr -> identifier .)
    (               reduce using rule 21 (expr -> identifier .)
    ENUM            reduce using rule 21 (expr -> identifier .)
    STRUCT          reduce using rule 21 (expr -> identifier .)
    {               reduce using rule 21 (expr -> identifier .)
    [               reduce using rule 21 (expr -> identifier .)
    CASE            reduce using rule 21 (expr -> identifier .)
    IF              reduce using rule 21 (expr -> identifier .)
    DEF             reduce using rule 21 (expr -> identifier .)
    NUMBER          reduce using rule 21 (expr -> identifier .)
    STRING          reduce using rule 21 (expr -> identifier .)
    IDENTIFIER      reduce using rule 21 (expr -> identifier .)
    DO              reduce using rule 21 (expr -> identifier .)
    $end            reduce using rule 21 (expr -> identifier .)
    END             reduce using rule 21 (expr -> identifier .)
    ELIF            reduce using rule 21 (expr -> identifier .)
    ELSE            reduce using rule 21 (expr -> identifier .)
    )               reduce using rule 21 (expr -> identifier .)
    ,               reduce using rule 21 (expr -> identifier .)
    }               reduce using rule 21 (expr -> identifier .)
    ]               reduce using rule 21 (expr -> identifier .)
    OF              reduce using rule 21 (expr -> identifier .)
    =               reduce using rule 174 (_35_optional -> .)
    :               shift and go to state 45

    _35_optional                   shift and go to state 43
    type                           shift and go to state 44

state 21

    (22) expr -> do .
    INT_DIV         reduce using rule 22 (expr -> do .)
    *               reduce using rule 22 (expr -> do .)
    /               reduce using rule 22 (expr -> do .)
    -               reduce using rule 22 (expr -> do .)
    +               reduce using rule 22 (expr -> do .)
    CONCAT          reduce using rule 22 (expr -> do .)
    (               reduce using rule 22 (expr -> do .)
    ENUM            reduce using rule 22 (expr -> do .)
    STRUCT          reduce using rule 22 (expr -> do .)
    {               reduce using rule 22 (expr -> do .)
    [               reduce using rule 22 (expr -> do .)
    CASE            reduce using rule 22 (expr -> do .)
    IF              reduce using rule 22 (expr -> do .)
    DEF             reduce using rule 22 (expr -> do .)
    NUMBER          reduce using rule 22 (expr -> do .)
    STRING          reduce using rule 22 (expr -> do .)
    IDENTIFIER      reduce using rule 22 (expr -> do .)
    DO              reduce using rule 22 (expr -> do .)
    $end            reduce using rule 22 (expr -> do .)
    END             reduce using rule 22 (expr -> do .)
    ELIF            reduce using rule 22 (expr -> do .)
    ELSE            reduce using rule 22 (expr -> do .)
    )               reduce using rule 22 (expr -> do .)
    ,               reduce using rule 22 (expr -> do .)
    }               reduce using rule 22 (expr -> do .)
    ]               reduce using rule 22 (expr -> do .)
    OF              reduce using rule 22 (expr -> do .)


state 22

    (63) enum -> ENUM . type_identifier _11_optional { _13_repeat }
    (171) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 47

    type_identifier                shift and go to state 46

state 23

    (153) tuple -> { . _31_optional _32_repeat }
    (154) _31_optional -> . expr
    (155) _31_optional -> .
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    ,               reduce using rule 155 (_31_optional -> .)
    }               reduce using rule 155 (_31_optional -> .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _31_optional                   shift and go to state 48
    expr                           shift and go to state 49
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 24

    (50) struct -> STRUCT . type_identifier _8_optional { _10_repeat }
    (171) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 47

    type_identifier                shift and go to state 50

state 25

    (145) array -> [ . _29_optional _30_repeat ]
    (146) _29_optional -> . expr
    (147) _29_optional -> .
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    ,               reduce using rule 147 (_29_optional -> .)
    ]               reduce using rule 147 (_29_optional -> .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _29_optional                   shift and go to state 51
    expr                           shift and go to state 52
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 26

    (96) case_of -> CASE . expr OF case _19_repeat END
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 53
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 27

    (161) call -> callee . ( _33_optional _34_repeat )
    (               shift and go to state 54


state 28

    (87) _if -> IF . expr DO expressions _17_repeat _18_optional END
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 55
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 29

    (29) do -> DO . _2_optional expressions END
    (30) _2_optional -> . type
    (31) _2_optional -> .
    (42) type -> . : type_identifier _6_optional
    (               reduce using rule 31 (_2_optional -> .)
    -               reduce using rule 31 (_2_optional -> .)
    ENUM            reduce using rule 31 (_2_optional -> .)
    STRUCT          reduce using rule 31 (_2_optional -> .)
    {               reduce using rule 31 (_2_optional -> .)
    [               reduce using rule 31 (_2_optional -> .)
    CASE            reduce using rule 31 (_2_optional -> .)
    IF              reduce using rule 31 (_2_optional -> .)
    DEF             reduce using rule 31 (_2_optional -> .)
    NUMBER          reduce using rule 31 (_2_optional -> .)
    STRING          reduce using rule 31 (_2_optional -> .)
    IDENTIFIER      reduce using rule 31 (_2_optional -> .)
    DO              reduce using rule 31 (_2_optional -> .)
    END             reduce using rule 31 (_2_optional -> .)
    :               shift and go to state 45

    _2_optional                    shift and go to state 56
    type                           shift and go to state 57

state 30

    (32) _def -> DEF . identifier ( _3_optional _4_repeat ) _5_optional do
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 58

state 31

    (175) literal -> NUMBER .
    INT_DIV         reduce using rule 175 (literal -> NUMBER .)
    *               reduce using rule 175 (literal -> NUMBER .)
    /               reduce using rule 175 (literal -> NUMBER .)
    -               reduce using rule 175 (literal -> NUMBER .)
    +               reduce using rule 175 (literal -> NUMBER .)
    CONCAT          reduce using rule 175 (literal -> NUMBER .)
    (               reduce using rule 175 (literal -> NUMBER .)
    ENUM            reduce using rule 175 (literal -> NUMBER .)
    STRUCT          reduce using rule 175 (literal -> NUMBER .)
    {               reduce using rule 175 (literal -> NUMBER .)
    [               reduce using rule 175 (literal -> NUMBER .)
    CASE            reduce using rule 175 (literal -> NUMBER .)
    IF              reduce using rule 175 (literal -> NUMBER .)
    DEF             reduce using rule 175 (literal -> NUMBER .)
    NUMBER          reduce using rule 175 (literal -> NUMBER .)
    STRING          reduce using rule 175 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 175 (literal -> NUMBER .)
    DO              reduce using rule 175 (literal -> NUMBER .)
    $end            reduce using rule 175 (literal -> NUMBER .)
    END             reduce using rule 175 (literal -> NUMBER .)
    ELIF            reduce using rule 175 (literal -> NUMBER .)
    ELSE            reduce using rule 175 (literal -> NUMBER .)
    )               reduce using rule 175 (literal -> NUMBER .)
    ,               reduce using rule 175 (literal -> NUMBER .)
    }               reduce using rule 175 (literal -> NUMBER .)
    ]               reduce using rule 175 (literal -> NUMBER .)
    OF              reduce using rule 175 (literal -> NUMBER .)


state 32

    (176) literal -> STRING .
    INT_DIV         reduce using rule 176 (literal -> STRING .)
    *               reduce using rule 176 (literal -> STRING .)
    /               reduce using rule 176 (literal -> STRING .)
    -               reduce using rule 176 (literal -> STRING .)
    +               reduce using rule 176 (literal -> STRING .)
    CONCAT          reduce using rule 176 (literal -> STRING .)
    (               reduce using rule 176 (literal -> STRING .)
    ENUM            reduce using rule 176 (literal -> STRING .)
    STRUCT          reduce using rule 176 (literal -> STRING .)
    {               reduce using rule 176 (literal -> STRING .)
    [               reduce using rule 176 (literal -> STRING .)
    CASE            reduce using rule 176 (literal -> STRING .)
    IF              reduce using rule 176 (literal -> STRING .)
    DEF             reduce using rule 176 (literal -> STRING .)
    NUMBER          reduce using rule 176 (literal -> STRING .)
    STRING          reduce using rule 176 (literal -> STRING .)
    IDENTIFIER      reduce using rule 176 (literal -> STRING .)
    DO              reduce using rule 176 (literal -> STRING .)
    $end            reduce using rule 176 (literal -> STRING .)
    END             reduce using rule 176 (literal -> STRING .)
    ELIF            reduce using rule 176 (literal -> STRING .)
    ELSE            reduce using rule 176 (literal -> STRING .)
    )               reduce using rule 176 (literal -> STRING .)
    ,               reduce using rule 176 (literal -> STRING .)
    }               reduce using rule 176 (literal -> STRING .)
    ]               reduce using rule 176 (literal -> STRING .)
    OF              reduce using rule 176 (literal -> STRING .)


state 33

    (170) identifier -> IDENTIFIER .
    :               reduce using rule 170 (identifier -> IDENTIFIER .)
    =               reduce using rule 170 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 170 (identifier -> IDENTIFIER .)
    *               reduce using rule 170 (identifier -> IDENTIFIER .)
    /               reduce using rule 170 (identifier -> IDENTIFIER .)
    -               reduce using rule 170 (identifier -> IDENTIFIER .)
    +               reduce using rule 170 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 170 (identifier -> IDENTIFIER .)
    (               reduce using rule 170 (identifier -> IDENTIFIER .)
    ENUM            reduce using rule 170 (identifier -> IDENTIFIER .)
    STRUCT          reduce using rule 170 (identifier -> IDENTIFIER .)
    {               reduce using rule 170 (identifier -> IDENTIFIER .)
    [               reduce using rule 170 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 170 (identifier -> IDENTIFIER .)
    IF              reduce using rule 170 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 170 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 170 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 170 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 170 (identifier -> IDENTIFIER .)
    DO              reduce using rule 170 (identifier -> IDENTIFIER .)
    $end            reduce using rule 170 (identifier -> IDENTIFIER .)
    END             reduce using rule 170 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 170 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 170 (identifier -> IDENTIFIER .)
    )               reduce using rule 170 (identifier -> IDENTIFIER .)
    ,               reduce using rule 170 (identifier -> IDENTIFIER .)
    }               reduce using rule 170 (identifier -> IDENTIFIER .)
    ]               reduce using rule 170 (identifier -> IDENTIFIER .)
    OF              reduce using rule 170 (identifier -> IDENTIFIER .)
    >               reduce using rule 170 (identifier -> IDENTIFIER .)


state 34

    (5) _1_items -> _1_items _1_item .
    (               reduce using rule 5 (_1_items -> _1_items _1_item .)
    -               reduce using rule 5 (_1_items -> _1_items _1_item .)
    ENUM            reduce using rule 5 (_1_items -> _1_items _1_item .)
    STRUCT          reduce using rule 5 (_1_items -> _1_items _1_item .)
    {               reduce using rule 5 (_1_items -> _1_items _1_item .)
    [               reduce using rule 5 (_1_items -> _1_items _1_item .)
    CASE            reduce using rule 5 (_1_items -> _1_items _1_item .)
    IF              reduce using rule 5 (_1_items -> _1_items _1_item .)
    DEF             reduce using rule 5 (_1_items -> _1_items _1_item .)
    NUMBER          reduce using rule 5 (_1_items -> _1_items _1_item .)
    STRING          reduce using rule 5 (_1_items -> _1_items _1_item .)
    IDENTIFIER      reduce using rule 5 (_1_items -> _1_items _1_item .)
    DO              reduce using rule 5 (_1_items -> _1_items _1_item .)
    $end            reduce using rule 5 (_1_items -> _1_items _1_item .)
    END             reduce using rule 5 (_1_items -> _1_items _1_item .)
    ELIF            reduce using rule 5 (_1_items -> _1_items _1_item .)
    ELSE            reduce using rule 5 (_1_items -> _1_items _1_item .)


state 35

    (23) binary_expr -> expr INT_DIV . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 59
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 36

    (24) binary_expr -> expr * . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 60
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 37

    (25) binary_expr -> expr / . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 61
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 38

    (26) binary_expr -> expr - . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 62
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 39

    (27) binary_expr -> expr + . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 63
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 40

    (28) binary_expr -> expr CONCAT . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 64
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 41

    (10) expr -> ( expr . )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    )               shift and go to state 65
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 42

    (11) expr -> - expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 11 (expr -> - expr .)
    *               reduce using rule 11 (expr -> - expr .)
    /               reduce using rule 11 (expr -> - expr .)
    -               reduce using rule 11 (expr -> - expr .)
    +               reduce using rule 11 (expr -> - expr .)
    CONCAT          reduce using rule 11 (expr -> - expr .)
    (               reduce using rule 11 (expr -> - expr .)
    ENUM            reduce using rule 11 (expr -> - expr .)
    STRUCT          reduce using rule 11 (expr -> - expr .)
    {               reduce using rule 11 (expr -> - expr .)
    [               reduce using rule 11 (expr -> - expr .)
    CASE            reduce using rule 11 (expr -> - expr .)
    IF              reduce using rule 11 (expr -> - expr .)
    DEF             reduce using rule 11 (expr -> - expr .)
    NUMBER          reduce using rule 11 (expr -> - expr .)
    STRING          reduce using rule 11 (expr -> - expr .)
    IDENTIFIER      reduce using rule 11 (expr -> - expr .)
    DO              reduce using rule 11 (expr -> - expr .)
    $end            reduce using rule 11 (expr -> - expr .)
    END             reduce using rule 11 (expr -> - expr .)
    ELIF            reduce using rule 11 (expr -> - expr .)
    ELSE            reduce using rule 11 (expr -> - expr .)
    )               reduce using rule 11 (expr -> - expr .)
    ,               reduce using rule 11 (expr -> - expr .)
    }               reduce using rule 11 (expr -> - expr .)
    ]               reduce using rule 11 (expr -> - expr .)
    OF              reduce using rule 11 (expr -> - expr .)


state 43

    (172) variable_declaration -> identifier _35_optional . = expr
    =               shift and go to state 66


state 44

    (173) _35_optional -> type .
    =               reduce using rule 173 (_35_optional -> type .)


state 45

    (42) type -> : . type_identifier _6_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 47

    type_identifier                shift and go to state 67

state 46

    (63) enum -> ENUM type_identifier . _11_optional { _13_repeat }
    (64) _11_optional -> . < identifier _12_repeat >
    (70) _11_optional -> .
    <               shift and go to state 69
    {               reduce using rule 70 (_11_optional -> .)

    _11_optional                   shift and go to state 68

state 47

    (171) type_identifier -> TYPE_IDENTIFIER .
    <               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    (               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    STRUCT          reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)
    ]               reduce using rule 171 (type_identifier -> TYPE_IDENTIFIER .)


state 48

    (153) tuple -> { _31_optional . _32_repeat }
    (156) _32_repeat -> . _32_items
    (157) _32_repeat -> .
    (158) _32_items -> . _32_items _32_item
    (159) _32_items -> . _32_item
    (160) _32_item -> . , expr
    }               reduce using rule 157 (_32_repeat -> .)
    ,               shift and go to state 73

    _32_repeat                     shift and go to state 70
    _32_items                      shift and go to state 71
    _32_item                       shift and go to state 72

state 49

    (154) _31_optional -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 154 (_31_optional -> expr .)
    }               reduce using rule 154 (_31_optional -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 50

    (50) struct -> STRUCT type_identifier . _8_optional { _10_repeat }
    (51) _8_optional -> . < identifier _9_repeat >
    (57) _8_optional -> .
    <               shift and go to state 75
    {               reduce using rule 57 (_8_optional -> .)

    _8_optional                    shift and go to state 74

state 51

    (145) array -> [ _29_optional . _30_repeat ]
    (148) _30_repeat -> . _30_items
    (149) _30_repeat -> .
    (150) _30_items -> . _30_items _30_item
    (151) _30_items -> . _30_item
    (152) _30_item -> . , expr
    ]               reduce using rule 149 (_30_repeat -> .)
    ,               shift and go to state 79

    _30_repeat                     shift and go to state 76
    _30_items                      shift and go to state 77
    _30_item                       shift and go to state 78

state 52

    (146) _29_optional -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 146 (_29_optional -> expr .)
    ]               reduce using rule 146 (_29_optional -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 53

    (96) case_of -> CASE expr . OF case _19_repeat END
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 80
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 54

    (161) call -> callee ( . _33_optional _34_repeat )
    (162) _33_optional -> . expr
    (163) _33_optional -> .
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    ,               reduce using rule 163 (_33_optional -> .)
    )               reduce using rule 163 (_33_optional -> .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    callee                         shift and go to state 27
    _33_optional                   shift and go to state 81
    expr                           shift and go to state 82
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21

state 55

    (87) _if -> IF expr . DO expressions _17_repeat _18_optional END
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    DO              shift and go to state 83
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 56

    (29) do -> DO _2_optional . expressions END
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    END             reduce using rule 4 (_1_repeat -> .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expressions                    shift and go to state 84
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    expr                           shift and go to state 6
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 57

    (30) _2_optional -> type .
    (               reduce using rule 30 (_2_optional -> type .)
    -               reduce using rule 30 (_2_optional -> type .)
    ENUM            reduce using rule 30 (_2_optional -> type .)
    STRUCT          reduce using rule 30 (_2_optional -> type .)
    {               reduce using rule 30 (_2_optional -> type .)
    [               reduce using rule 30 (_2_optional -> type .)
    CASE            reduce using rule 30 (_2_optional -> type .)
    IF              reduce using rule 30 (_2_optional -> type .)
    DEF             reduce using rule 30 (_2_optional -> type .)
    NUMBER          reduce using rule 30 (_2_optional -> type .)
    STRING          reduce using rule 30 (_2_optional -> type .)
    IDENTIFIER      reduce using rule 30 (_2_optional -> type .)
    DO              reduce using rule 30 (_2_optional -> type .)
    END             reduce using rule 30 (_2_optional -> type .)


state 58

    (32) _def -> DEF identifier . ( _3_optional _4_repeat ) _5_optional do
    (               shift and go to state 85


state 59

    (23) binary_expr -> expr INT_DIV expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    (               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ENUM            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    STRUCT          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    {               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    [               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    CASE            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    IF              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    DEF             reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    NUMBER          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    STRING          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    IDENTIFIER      reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    DO              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    }               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)


state 60

    (24) binary_expr -> expr * expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 24 (binary_expr -> expr * expr .)
    *               reduce using rule 24 (binary_expr -> expr * expr .)
    /               reduce using rule 24 (binary_expr -> expr * expr .)
    -               reduce using rule 24 (binary_expr -> expr * expr .)
    +               reduce using rule 24 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 24 (binary_expr -> expr * expr .)
    (               reduce using rule 24 (binary_expr -> expr * expr .)
    ENUM            reduce using rule 24 (binary_expr -> expr * expr .)
    STRUCT          reduce using rule 24 (binary_expr -> expr * expr .)
    {               reduce using rule 24 (binary_expr -> expr * expr .)
    [               reduce using rule 24 (binary_expr -> expr * expr .)
    CASE            reduce using rule 24 (binary_expr -> expr * expr .)
    IF              reduce using rule 24 (binary_expr -> expr * expr .)
    DEF             reduce using rule 24 (binary_expr -> expr * expr .)
    NUMBER          reduce using rule 24 (binary_expr -> expr * expr .)
    STRING          reduce using rule 24 (binary_expr -> expr * expr .)
    IDENTIFIER      reduce using rule 24 (binary_expr -> expr * expr .)
    DO              reduce using rule 24 (binary_expr -> expr * expr .)
    $end            reduce using rule 24 (binary_expr -> expr * expr .)
    END             reduce using rule 24 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 24 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 24 (binary_expr -> expr * expr .)
    )               reduce using rule 24 (binary_expr -> expr * expr .)
    ,               reduce using rule 24 (binary_expr -> expr * expr .)
    }               reduce using rule 24 (binary_expr -> expr * expr .)
    ]               reduce using rule 24 (binary_expr -> expr * expr .)
    OF              reduce using rule 24 (binary_expr -> expr * expr .)


state 61

    (25) binary_expr -> expr / expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 25 (binary_expr -> expr / expr .)
    *               reduce using rule 25 (binary_expr -> expr / expr .)
    /               reduce using rule 25 (binary_expr -> expr / expr .)
    -               reduce using rule 25 (binary_expr -> expr / expr .)
    +               reduce using rule 25 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 25 (binary_expr -> expr / expr .)
    (               reduce using rule 25 (binary_expr -> expr / expr .)
    ENUM            reduce using rule 25 (binary_expr -> expr / expr .)
    STRUCT          reduce using rule 25 (binary_expr -> expr / expr .)
    {               reduce using rule 25 (binary_expr -> expr / expr .)
    [               reduce using rule 25 (binary_expr -> expr / expr .)
    CASE            reduce using rule 25 (binary_expr -> expr / expr .)
    IF              reduce using rule 25 (binary_expr -> expr / expr .)
    DEF             reduce using rule 25 (binary_expr -> expr / expr .)
    NUMBER          reduce using rule 25 (binary_expr -> expr / expr .)
    STRING          reduce using rule 25 (binary_expr -> expr / expr .)
    IDENTIFIER      reduce using rule 25 (binary_expr -> expr / expr .)
    DO              reduce using rule 25 (binary_expr -> expr / expr .)
    $end            reduce using rule 25 (binary_expr -> expr / expr .)
    END             reduce using rule 25 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 25 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 25 (binary_expr -> expr / expr .)
    )               reduce using rule 25 (binary_expr -> expr / expr .)
    ,               reduce using rule 25 (binary_expr -> expr / expr .)
    }               reduce using rule 25 (binary_expr -> expr / expr .)
    ]               reduce using rule 25 (binary_expr -> expr / expr .)
    OF              reduce using rule 25 (binary_expr -> expr / expr .)


state 62

    (26) binary_expr -> expr - expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    -               reduce using rule 26 (binary_expr -> expr - expr .)
    +               reduce using rule 26 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr - expr .)
    (               reduce using rule 26 (binary_expr -> expr - expr .)
    ENUM            reduce using rule 26 (binary_expr -> expr - expr .)
    STRUCT          reduce using rule 26 (binary_expr -> expr - expr .)
    {               reduce using rule 26 (binary_expr -> expr - expr .)
    [               reduce using rule 26 (binary_expr -> expr - expr .)
    CASE            reduce using rule 26 (binary_expr -> expr - expr .)
    IF              reduce using rule 26 (binary_expr -> expr - expr .)
    DEF             reduce using rule 26 (binary_expr -> expr - expr .)
    NUMBER          reduce using rule 26 (binary_expr -> expr - expr .)
    STRING          reduce using rule 26 (binary_expr -> expr - expr .)
    IDENTIFIER      reduce using rule 26 (binary_expr -> expr - expr .)
    DO              reduce using rule 26 (binary_expr -> expr - expr .)
    $end            reduce using rule 26 (binary_expr -> expr - expr .)
    END             reduce using rule 26 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr - expr .)
    )               reduce using rule 26 (binary_expr -> expr - expr .)
    ,               reduce using rule 26 (binary_expr -> expr - expr .)
    }               reduce using rule 26 (binary_expr -> expr - expr .)
    ]               reduce using rule 26 (binary_expr -> expr - expr .)
    OF              reduce using rule 26 (binary_expr -> expr - expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37


state 63

    (27) binary_expr -> expr + expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    -               reduce using rule 27 (binary_expr -> expr + expr .)
    +               reduce using rule 27 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 27 (binary_expr -> expr + expr .)
    (               reduce using rule 27 (binary_expr -> expr + expr .)
    ENUM            reduce using rule 27 (binary_expr -> expr + expr .)
    STRUCT          reduce using rule 27 (binary_expr -> expr + expr .)
    {               reduce using rule 27 (binary_expr -> expr + expr .)
    [               reduce using rule 27 (binary_expr -> expr + expr .)
    CASE            reduce using rule 27 (binary_expr -> expr + expr .)
    IF              reduce using rule 27 (binary_expr -> expr + expr .)
    DEF             reduce using rule 27 (binary_expr -> expr + expr .)
    NUMBER          reduce using rule 27 (binary_expr -> expr + expr .)
    STRING          reduce using rule 27 (binary_expr -> expr + expr .)
    IDENTIFIER      reduce using rule 27 (binary_expr -> expr + expr .)
    DO              reduce using rule 27 (binary_expr -> expr + expr .)
    $end            reduce using rule 27 (binary_expr -> expr + expr .)
    END             reduce using rule 27 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr + expr .)
    )               reduce using rule 27 (binary_expr -> expr + expr .)
    ,               reduce using rule 27 (binary_expr -> expr + expr .)
    }               reduce using rule 27 (binary_expr -> expr + expr .)
    ]               reduce using rule 27 (binary_expr -> expr + expr .)
    OF              reduce using rule 27 (binary_expr -> expr + expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37


state 64

    (28) binary_expr -> expr CONCAT expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    CONCAT          reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    (               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ENUM            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    STRUCT          reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    {               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    [               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    CASE            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    IF              reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    DEF             reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    NUMBER          reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    STRING          reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    IDENTIFIER      reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    DO              reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    }               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39


state 65

    (10) expr -> ( expr ) .
    INT_DIV         reduce using rule 10 (expr -> ( expr ) .)
    *               reduce using rule 10 (expr -> ( expr ) .)
    /               reduce using rule 10 (expr -> ( expr ) .)
    -               reduce using rule 10 (expr -> ( expr ) .)
    +               reduce using rule 10 (expr -> ( expr ) .)
    CONCAT          reduce using rule 10 (expr -> ( expr ) .)
    (               reduce using rule 10 (expr -> ( expr ) .)
    ENUM            reduce using rule 10 (expr -> ( expr ) .)
    STRUCT          reduce using rule 10 (expr -> ( expr ) .)
    {               reduce using rule 10 (expr -> ( expr ) .)
    [               reduce using rule 10 (expr -> ( expr ) .)
    CASE            reduce using rule 10 (expr -> ( expr ) .)
    IF              reduce using rule 10 (expr -> ( expr ) .)
    DEF             reduce using rule 10 (expr -> ( expr ) .)
    NUMBER          reduce using rule 10 (expr -> ( expr ) .)
    STRING          reduce using rule 10 (expr -> ( expr ) .)
    IDENTIFIER      reduce using rule 10 (expr -> ( expr ) .)
    DO              reduce using rule 10 (expr -> ( expr ) .)
    $end            reduce using rule 10 (expr -> ( expr ) .)
    END             reduce using rule 10 (expr -> ( expr ) .)
    ELIF            reduce using rule 10 (expr -> ( expr ) .)
    ELSE            reduce using rule 10 (expr -> ( expr ) .)
    )               reduce using rule 10 (expr -> ( expr ) .)
    ,               reduce using rule 10 (expr -> ( expr ) .)
    }               reduce using rule 10 (expr -> ( expr ) .)
    ]               reduce using rule 10 (expr -> ( expr ) .)
    OF              reduce using rule 10 (expr -> ( expr ) .)


state 66

    (172) variable_declaration -> identifier _35_optional = . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    identifier                     shift and go to state 20
    expr                           shift and go to state 86
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 67

    (42) type -> : type_identifier . _6_optional
    (43) _6_optional -> . < identifier _7_repeat >
    (49) _6_optional -> .
    <               shift and go to state 88
    =               reduce using rule 49 (_6_optional -> .)
    (               reduce using rule 49 (_6_optional -> .)
    -               reduce using rule 49 (_6_optional -> .)
    ENUM            reduce using rule 49 (_6_optional -> .)
    STRUCT          reduce using rule 49 (_6_optional -> .)
    {               reduce using rule 49 (_6_optional -> .)
    [               reduce using rule 49 (_6_optional -> .)
    CASE            reduce using rule 49 (_6_optional -> .)
    IF              reduce using rule 49 (_6_optional -> .)
    DEF             reduce using rule 49 (_6_optional -> .)
    NUMBER          reduce using rule 49 (_6_optional -> .)
    STRING          reduce using rule 49 (_6_optional -> .)
    IDENTIFIER      reduce using rule 49 (_6_optional -> .)
    DO              reduce using rule 49 (_6_optional -> .)
    END             reduce using rule 49 (_6_optional -> .)
    ,               reduce using rule 49 (_6_optional -> .)
    )               reduce using rule 49 (_6_optional -> .)
    }               reduce using rule 49 (_6_optional -> .)

    _6_optional                    shift and go to state 87

state 68

    (63) enum -> ENUM type_identifier _11_optional . { _13_repeat }
    {               shift and go to state 89


state 69

    (64) _11_optional -> < . identifier _12_repeat >
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 90

state 70

    (153) tuple -> { _31_optional _32_repeat . }
    }               shift and go to state 91


state 71

    (156) _32_repeat -> _32_items .
    (158) _32_items -> _32_items . _32_item
    (160) _32_item -> . , expr
    }               reduce using rule 156 (_32_repeat -> _32_items .)
    ,               shift and go to state 73

    _32_item                       shift and go to state 92

state 72

    (159) _32_items -> _32_item .
    ,               reduce using rule 159 (_32_items -> _32_item .)
    }               reduce using rule 159 (_32_items -> _32_item .)


state 73

    (160) _32_item -> , . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 93
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 74

    (50) struct -> STRUCT type_identifier _8_optional . { _10_repeat }
    {               shift and go to state 94


state 75

    (51) _8_optional -> < . identifier _9_repeat >
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 95

state 76

    (145) array -> [ _29_optional _30_repeat . ]
    ]               shift and go to state 96


state 77

    (148) _30_repeat -> _30_items .
    (150) _30_items -> _30_items . _30_item
    (152) _30_item -> . , expr
    ]               reduce using rule 148 (_30_repeat -> _30_items .)
    ,               shift and go to state 79

    _30_item                       shift and go to state 97

state 78

    (151) _30_items -> _30_item .
    ,               reduce using rule 151 (_30_items -> _30_item .)
    ]               reduce using rule 151 (_30_items -> _30_item .)


state 79

    (152) _30_item -> , . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 98
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 80

    (96) case_of -> CASE expr OF . case _19_repeat END
    (102) case -> . pattern _20_repeat do
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    case                           shift and go to state 99
    pattern                        shift and go to state 100
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 81

    (161) call -> callee ( _33_optional . _34_repeat )
    (164) _34_repeat -> . _34_items
    (165) _34_repeat -> .
    (166) _34_items -> . _34_items _34_item
    (167) _34_items -> . _34_item
    (168) _34_item -> . , expr
    )               reduce using rule 165 (_34_repeat -> .)
    ,               shift and go to state 110

    _34_repeat                     shift and go to state 107
    _34_items                      shift and go to state 108
    _34_item                       shift and go to state 109

state 82

    (162) _33_optional -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 162 (_33_optional -> expr .)
    )               reduce using rule 162 (_33_optional -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 83

    (87) _if -> IF expr DO . expressions _17_repeat _18_optional END
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    ELIF            reduce using rule 4 (_1_repeat -> .)
    ELSE            reduce using rule 4 (_1_repeat -> .)
    END             reduce using rule 4 (_1_repeat -> .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 6
    expressions                    shift and go to state 111
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 84

    (29) do -> DO _2_optional expressions . END
    END             shift and go to state 112


state 85

    (32) _def -> DEF identifier ( . _3_optional _4_repeat ) _5_optional do
    (33) _3_optional -> . param
    (34) _3_optional -> .
    (84) param -> . identifier _16_optional
    (170) identifier -> . IDENTIFIER
    ,               reduce using rule 34 (_3_optional -> .)
    )               reduce using rule 34 (_3_optional -> .)
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 113
    _3_optional                    shift and go to state 114
    param                          shift and go to state 115

state 86

    (172) variable_declaration -> identifier _35_optional = expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    (               reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    ENUM            reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    STRUCT          reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    {               reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    [               reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    CASE            reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    IF              reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    DEF             reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    NUMBER          reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    STRING          reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    IDENTIFIER      reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    DO              reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    $end            reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    END             reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    ELIF            reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    ELSE            reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    )               reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    ,               reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    }               reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    ]               reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    OF              reduce using rule 172 (variable_declaration -> identifier _35_optional = expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 87

    (42) type -> : type_identifier _6_optional .
    =               reduce using rule 42 (type -> : type_identifier _6_optional .)
    (               reduce using rule 42 (type -> : type_identifier _6_optional .)
    -               reduce using rule 42 (type -> : type_identifier _6_optional .)
    ENUM            reduce using rule 42 (type -> : type_identifier _6_optional .)
    STRUCT          reduce using rule 42 (type -> : type_identifier _6_optional .)
    {               reduce using rule 42 (type -> : type_identifier _6_optional .)
    [               reduce using rule 42 (type -> : type_identifier _6_optional .)
    CASE            reduce using rule 42 (type -> : type_identifier _6_optional .)
    IF              reduce using rule 42 (type -> : type_identifier _6_optional .)
    DEF             reduce using rule 42 (type -> : type_identifier _6_optional .)
    NUMBER          reduce using rule 42 (type -> : type_identifier _6_optional .)
    STRING          reduce using rule 42 (type -> : type_identifier _6_optional .)
    IDENTIFIER      reduce using rule 42 (type -> : type_identifier _6_optional .)
    DO              reduce using rule 42 (type -> : type_identifier _6_optional .)
    END             reduce using rule 42 (type -> : type_identifier _6_optional .)
    ,               reduce using rule 42 (type -> : type_identifier _6_optional .)
    )               reduce using rule 42 (type -> : type_identifier _6_optional .)
    }               reduce using rule 42 (type -> : type_identifier _6_optional .)


state 88

    (43) _6_optional -> < . identifier _7_repeat >
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 116

state 89

    (63) enum -> ENUM type_identifier _11_optional { . _13_repeat }
    (71) _13_repeat -> . _13_items
    (72) _13_repeat -> .
    (73) _13_items -> . _13_items _13_item
    (74) _13_items -> . _13_item
    (75) _13_item -> . enum_key
    (76) enum_key -> . identifier _14_optional
    (170) identifier -> . IDENTIFIER
    }               reduce using rule 72 (_13_repeat -> .)
    IDENTIFIER      shift and go to state 33

    _13_repeat                     shift and go to state 117
    _13_items                      shift and go to state 118
    _13_item                       shift and go to state 119
    enum_key                       shift and go to state 120
    identifier                     shift and go to state 121

state 90

    (64) _11_optional -> < identifier . _12_repeat >
    (65) _12_repeat -> . _12_items
    (66) _12_repeat -> .
    (67) _12_items -> . _12_items _12_item
    (68) _12_items -> . _12_item
    (69) _12_item -> . , identifier
    >               reduce using rule 66 (_12_repeat -> .)
    ,               shift and go to state 125

    _12_repeat                     shift and go to state 122
    _12_items                      shift and go to state 123
    _12_item                       shift and go to state 124

state 91

    (153) tuple -> { _31_optional _32_repeat } .
    INT_DIV         reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    *               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    /               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    -               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    +               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    CONCAT          reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    (               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    ENUM            reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    STRUCT          reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    {               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    [               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    CASE            reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    IF              reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    DEF             reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    NUMBER          reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    STRING          reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    IDENTIFIER      reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    DO              reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    $end            reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    END             reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    ELIF            reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    ELSE            reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    )               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    ,               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    }               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    ]               reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)
    OF              reduce using rule 153 (tuple -> { _31_optional _32_repeat } .)


state 92

    (158) _32_items -> _32_items _32_item .
    ,               reduce using rule 158 (_32_items -> _32_items _32_item .)
    }               reduce using rule 158 (_32_items -> _32_items _32_item .)


state 93

    (160) _32_item -> , expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 160 (_32_item -> , expr .)
    }               reduce using rule 160 (_32_item -> , expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 94

    (50) struct -> STRUCT type_identifier _8_optional { . _10_repeat }
    (58) _10_repeat -> . _10_items
    (59) _10_repeat -> .
    (60) _10_items -> . _10_items _10_item
    (61) _10_items -> . _10_item
    (62) _10_item -> . identifier type
    (170) identifier -> . IDENTIFIER
    }               reduce using rule 59 (_10_repeat -> .)
    IDENTIFIER      shift and go to state 33

    _10_repeat                     shift and go to state 126
    _10_items                      shift and go to state 127
    _10_item                       shift and go to state 128
    identifier                     shift and go to state 129

state 95

    (51) _8_optional -> < identifier . _9_repeat >
    (52) _9_repeat -> . _9_items
    (53) _9_repeat -> .
    (54) _9_items -> . _9_items _9_item
    (55) _9_items -> . _9_item
    (56) _9_item -> . , identifier
    >               reduce using rule 53 (_9_repeat -> .)
    ,               shift and go to state 133

    _9_repeat                      shift and go to state 130
    _9_items                       shift and go to state 131
    _9_item                        shift and go to state 132

state 96

    (145) array -> [ _29_optional _30_repeat ] .
    INT_DIV         reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    *               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    /               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    -               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    +               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    CONCAT          reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    (               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    ENUM            reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    STRUCT          reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    {               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    [               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    CASE            reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    IF              reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    DEF             reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    NUMBER          reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    STRING          reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    IDENTIFIER      reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    DO              reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    $end            reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    END             reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    ELIF            reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    ELSE            reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    )               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    ,               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    }               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    ]               reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)
    OF              reduce using rule 145 (array -> [ _29_optional _30_repeat ] .)


state 97

    (150) _30_items -> _30_items _30_item .
    ,               reduce using rule 150 (_30_items -> _30_items _30_item .)
    ]               reduce using rule 150 (_30_items -> _30_items _30_item .)


state 98

    (152) _30_item -> , expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 152 (_30_item -> , expr .)
    ]               reduce using rule 152 (_30_item -> , expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 99

    (96) case_of -> CASE expr OF case . _19_repeat END
    (97) _19_repeat -> . _19_items
    (98) _19_repeat -> .
    (99) _19_items -> . _19_items _19_item
    (100) _19_items -> . _19_item
    (101) _19_item -> . case
    (102) case -> . pattern _20_repeat do
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 98 (_19_repeat -> .)
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    case                           shift and go to state 134
    _19_repeat                     shift and go to state 135
    _19_items                      shift and go to state 136
    _19_item                       shift and go to state 137
    pattern                        shift and go to state 100
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 100

    (102) case -> pattern . _20_repeat do
    (103) _20_repeat -> . _20_items
    (104) _20_repeat -> .
    (105) _20_items -> . _20_items _20_item
    (106) _20_items -> . _20_item
    (107) _20_item -> . , pattern
    DO              reduce using rule 104 (_20_repeat -> .)
    ,               shift and go to state 141

    _20_repeat                     shift and go to state 138
    _20_items                      shift and go to state 139
    _20_item                       shift and go to state 140

state 101

    (108) pattern -> array_pattern .
    ,               reduce using rule 108 (pattern -> array_pattern .)
    DO              reduce using rule 108 (pattern -> array_pattern .)
    )               reduce using rule 108 (pattern -> array_pattern .)
    ]               reduce using rule 108 (pattern -> array_pattern .)
    }               reduce using rule 108 (pattern -> array_pattern .)


state 102

    (109) pattern -> tuple_pattern .
    ,               reduce using rule 109 (pattern -> tuple_pattern .)
    DO              reduce using rule 109 (pattern -> tuple_pattern .)
    )               reduce using rule 109 (pattern -> tuple_pattern .)
    ]               reduce using rule 109 (pattern -> tuple_pattern .)
    }               reduce using rule 109 (pattern -> tuple_pattern .)


state 103

    (110) pattern -> enum_pattern .
    ,               reduce using rule 110 (pattern -> enum_pattern .)
    DO              reduce using rule 110 (pattern -> enum_pattern .)
    )               reduce using rule 110 (pattern -> enum_pattern .)
    ]               reduce using rule 110 (pattern -> enum_pattern .)
    }               reduce using rule 110 (pattern -> enum_pattern .)


state 104

    (111) array_pattern -> [ . _21_repeat _22_optional ]
    (112) _21_repeat -> . _21_items
    (113) _21_repeat -> .
    (114) _21_items -> . _21_items _21_item
    (115) _21_items -> . _21_item
    (116) _21_item -> . pattern ,
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    SPREAD          reduce using rule 113 (_21_repeat -> .)
    ]               reduce using rule 113 (_21_repeat -> .)
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    _21_repeat                     shift and go to state 142
    _21_items                      shift and go to state 143
    _21_item                       shift and go to state 144
    pattern                        shift and go to state 145
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 105

    (132) tuple_pattern -> { . _26_repeat _27_optional }
    (133) _26_repeat -> . _26_items
    (134) _26_repeat -> .
    (135) _26_items -> . _26_items _26_item
    (136) _26_items -> . _26_item
    (137) _26_item -> . pattern ,
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    SPREAD          reduce using rule 134 (_26_repeat -> .)
    }               reduce using rule 134 (_26_repeat -> .)
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    _26_repeat                     shift and go to state 146
    _26_items                      shift and go to state 147
    _26_item                       shift and go to state 148
    pattern                        shift and go to state 149
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 106

    (124) enum_pattern -> type_identifier . _24_optional
    (125) _24_optional -> . ( pattern _25_repeat )
    (131) _24_optional -> .
    (               shift and go to state 151
    ,               reduce using rule 131 (_24_optional -> .)
    DO              reduce using rule 131 (_24_optional -> .)
    )               reduce using rule 131 (_24_optional -> .)
    ]               reduce using rule 131 (_24_optional -> .)
    }               reduce using rule 131 (_24_optional -> .)

    _24_optional                   shift and go to state 150

state 107

    (161) call -> callee ( _33_optional _34_repeat . )
    )               shift and go to state 152


state 108

    (164) _34_repeat -> _34_items .
    (166) _34_items -> _34_items . _34_item
    (168) _34_item -> . , expr
    )               reduce using rule 164 (_34_repeat -> _34_items .)
    ,               shift and go to state 110

    _34_item                       shift and go to state 153

state 109

    (167) _34_items -> _34_item .
    ,               reduce using rule 167 (_34_items -> _34_item .)
    )               reduce using rule 167 (_34_items -> _34_item .)


state 110

    (168) _34_item -> , . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 154
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 111

    (87) _if -> IF expr DO expressions . _17_repeat _18_optional END
    (88) _17_repeat -> . _17_items
    (89) _17_repeat -> .
    (90) _17_items -> . _17_items _17_item
    (91) _17_items -> . _17_item
    (92) _17_item -> . _elif
    (95) _elif -> . ELIF expr DO expressions
    ELSE            reduce using rule 89 (_17_repeat -> .)
    END             reduce using rule 89 (_17_repeat -> .)
    ELIF            shift and go to state 159

    _17_repeat                     shift and go to state 155
    _17_items                      shift and go to state 156
    _17_item                       shift and go to state 157
    _elif                          shift and go to state 158

state 112

    (29) do -> DO _2_optional expressions END .
    INT_DIV         reduce using rule 29 (do -> DO _2_optional expressions END .)
    *               reduce using rule 29 (do -> DO _2_optional expressions END .)
    /               reduce using rule 29 (do -> DO _2_optional expressions END .)
    -               reduce using rule 29 (do -> DO _2_optional expressions END .)
    +               reduce using rule 29 (do -> DO _2_optional expressions END .)
    CONCAT          reduce using rule 29 (do -> DO _2_optional expressions END .)
    (               reduce using rule 29 (do -> DO _2_optional expressions END .)
    ENUM            reduce using rule 29 (do -> DO _2_optional expressions END .)
    STRUCT          reduce using rule 29 (do -> DO _2_optional expressions END .)
    {               reduce using rule 29 (do -> DO _2_optional expressions END .)
    [               reduce using rule 29 (do -> DO _2_optional expressions END .)
    CASE            reduce using rule 29 (do -> DO _2_optional expressions END .)
    IF              reduce using rule 29 (do -> DO _2_optional expressions END .)
    DEF             reduce using rule 29 (do -> DO _2_optional expressions END .)
    NUMBER          reduce using rule 29 (do -> DO _2_optional expressions END .)
    STRING          reduce using rule 29 (do -> DO _2_optional expressions END .)
    IDENTIFIER      reduce using rule 29 (do -> DO _2_optional expressions END .)
    DO              reduce using rule 29 (do -> DO _2_optional expressions END .)
    $end            reduce using rule 29 (do -> DO _2_optional expressions END .)
    END             reduce using rule 29 (do -> DO _2_optional expressions END .)
    ELIF            reduce using rule 29 (do -> DO _2_optional expressions END .)
    ELSE            reduce using rule 29 (do -> DO _2_optional expressions END .)
    )               reduce using rule 29 (do -> DO _2_optional expressions END .)
    ,               reduce using rule 29 (do -> DO _2_optional expressions END .)
    }               reduce using rule 29 (do -> DO _2_optional expressions END .)
    ]               reduce using rule 29 (do -> DO _2_optional expressions END .)
    OF              reduce using rule 29 (do -> DO _2_optional expressions END .)
    TYPE_IDENTIFIER reduce using rule 29 (do -> DO _2_optional expressions END .)


state 113

    (84) param -> identifier . _16_optional
    (85) _16_optional -> . type
    (86) _16_optional -> .
    (42) type -> . : type_identifier _6_optional
    ,               reduce using rule 86 (_16_optional -> .)
    )               reduce using rule 86 (_16_optional -> .)
    :               shift and go to state 45

    _16_optional                   shift and go to state 160
    type                           shift and go to state 161

state 114

    (32) _def -> DEF identifier ( _3_optional . _4_repeat ) _5_optional do
    (35) _4_repeat -> . _4_items
    (36) _4_repeat -> .
    (37) _4_items -> . _4_items _4_item
    (38) _4_items -> . _4_item
    (39) _4_item -> . , param
    )               reduce using rule 36 (_4_repeat -> .)
    ,               shift and go to state 165

    _4_repeat                      shift and go to state 162
    _4_items                       shift and go to state 163
    _4_item                        shift and go to state 164

state 115

    (33) _3_optional -> param .
    ,               reduce using rule 33 (_3_optional -> param .)
    )               reduce using rule 33 (_3_optional -> param .)


state 116

    (43) _6_optional -> < identifier . _7_repeat >
    (44) _7_repeat -> . _7_items
    (45) _7_repeat -> .
    (46) _7_items -> . _7_items _7_item
    (47) _7_items -> . _7_item
    (48) _7_item -> . , identifier
    >               reduce using rule 45 (_7_repeat -> .)
    ,               shift and go to state 169

    _7_repeat                      shift and go to state 166
    _7_items                       shift and go to state 167
    _7_item                        shift and go to state 168

state 117

    (63) enum -> ENUM type_identifier _11_optional { _13_repeat . }
    }               shift and go to state 170


state 118

    (71) _13_repeat -> _13_items .
    (73) _13_items -> _13_items . _13_item
    (75) _13_item -> . enum_key
    (76) enum_key -> . identifier _14_optional
    (170) identifier -> . IDENTIFIER
    }               reduce using rule 71 (_13_repeat -> _13_items .)
    IDENTIFIER      shift and go to state 33

    _13_item                       shift and go to state 171
    enum_key                       shift and go to state 120
    identifier                     shift and go to state 121

state 119

    (74) _13_items -> _13_item .
    IDENTIFIER      reduce using rule 74 (_13_items -> _13_item .)
    }               reduce using rule 74 (_13_items -> _13_item .)


state 120

    (75) _13_item -> enum_key .
    IDENTIFIER      reduce using rule 75 (_13_item -> enum_key .)
    }               reduce using rule 75 (_13_item -> enum_key .)


state 121

    (76) enum_key -> identifier . _14_optional
    (77) _14_optional -> . ( identifier _15_repeat )
    (83) _14_optional -> .
    (               shift and go to state 173
    IDENTIFIER      reduce using rule 83 (_14_optional -> .)
    }               reduce using rule 83 (_14_optional -> .)

    _14_optional                   shift and go to state 172

state 122

    (64) _11_optional -> < identifier _12_repeat . >
    >               shift and go to state 174


state 123

    (65) _12_repeat -> _12_items .
    (67) _12_items -> _12_items . _12_item
    (69) _12_item -> . , identifier
    >               reduce using rule 65 (_12_repeat -> _12_items .)
    ,               shift and go to state 125

    _12_item                       shift and go to state 175

state 124

    (68) _12_items -> _12_item .
    ,               reduce using rule 68 (_12_items -> _12_item .)
    >               reduce using rule 68 (_12_items -> _12_item .)


state 125

    (69) _12_item -> , . identifier
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 176

state 126

    (50) struct -> STRUCT type_identifier _8_optional { _10_repeat . }
    }               shift and go to state 177


state 127

    (58) _10_repeat -> _10_items .
    (60) _10_items -> _10_items . _10_item
    (62) _10_item -> . identifier type
    (170) identifier -> . IDENTIFIER
    }               reduce using rule 58 (_10_repeat -> _10_items .)
    IDENTIFIER      shift and go to state 33

    _10_item                       shift and go to state 178
    identifier                     shift and go to state 129

state 128

    (61) _10_items -> _10_item .
    IDENTIFIER      reduce using rule 61 (_10_items -> _10_item .)
    }               reduce using rule 61 (_10_items -> _10_item .)


state 129

    (62) _10_item -> identifier . type
    (42) type -> . : type_identifier _6_optional
    :               shift and go to state 45

    type                           shift and go to state 179

state 130

    (51) _8_optional -> < identifier _9_repeat . >
    >               shift and go to state 180


state 131

    (52) _9_repeat -> _9_items .
    (54) _9_items -> _9_items . _9_item
    (56) _9_item -> . , identifier
    >               reduce using rule 52 (_9_repeat -> _9_items .)
    ,               shift and go to state 133

    _9_item                        shift and go to state 181

state 132

    (55) _9_items -> _9_item .
    ,               reduce using rule 55 (_9_items -> _9_item .)
    >               reduce using rule 55 (_9_items -> _9_item .)


state 133

    (56) _9_item -> , . identifier
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 182

state 134

    (101) _19_item -> case .
    [               reduce using rule 101 (_19_item -> case .)
    {               reduce using rule 101 (_19_item -> case .)
    TYPE_IDENTIFIER reduce using rule 101 (_19_item -> case .)
    END             reduce using rule 101 (_19_item -> case .)


state 135

    (96) case_of -> CASE expr OF case _19_repeat . END
    END             shift and go to state 183


state 136

    (97) _19_repeat -> _19_items .
    (99) _19_items -> _19_items . _19_item
    (101) _19_item -> . case
    (102) case -> . pattern _20_repeat do
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 97 (_19_repeat -> _19_items .)
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    _19_item                       shift and go to state 184
    case                           shift and go to state 134
    pattern                        shift and go to state 100
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 137

    (100) _19_items -> _19_item .
    [               reduce using rule 100 (_19_items -> _19_item .)
    {               reduce using rule 100 (_19_items -> _19_item .)
    TYPE_IDENTIFIER reduce using rule 100 (_19_items -> _19_item .)
    END             reduce using rule 100 (_19_items -> _19_item .)


state 138

    (102) case -> pattern _20_repeat . do
    (29) do -> . DO _2_optional expressions END
    DO              shift and go to state 29

    do                             shift and go to state 185

state 139

    (103) _20_repeat -> _20_items .
    (105) _20_items -> _20_items . _20_item
    (107) _20_item -> . , pattern
    DO              reduce using rule 103 (_20_repeat -> _20_items .)
    ,               shift and go to state 141

    _20_item                       shift and go to state 186

state 140

    (106) _20_items -> _20_item .
    ,               reduce using rule 106 (_20_items -> _20_item .)
    DO              reduce using rule 106 (_20_items -> _20_item .)


state 141

    (107) _20_item -> , . pattern
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    pattern                        shift and go to state 187
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 142

    (111) array_pattern -> [ _21_repeat . _22_optional ]
    (117) _22_optional -> . SPREAD identifier _23_repeat
    (123) _22_optional -> .
    SPREAD          shift and go to state 189
    ]               reduce using rule 123 (_22_optional -> .)

    _22_optional                   shift and go to state 188

state 143

    (112) _21_repeat -> _21_items .
    (114) _21_items -> _21_items . _21_item
    (116) _21_item -> . pattern ,
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    SPREAD          reduce using rule 112 (_21_repeat -> _21_items .)
    ]               reduce using rule 112 (_21_repeat -> _21_items .)
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    _21_item                       shift and go to state 190
    pattern                        shift and go to state 145
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 144

    (115) _21_items -> _21_item .
    [               reduce using rule 115 (_21_items -> _21_item .)
    {               reduce using rule 115 (_21_items -> _21_item .)
    TYPE_IDENTIFIER reduce using rule 115 (_21_items -> _21_item .)
    SPREAD          reduce using rule 115 (_21_items -> _21_item .)
    ]               reduce using rule 115 (_21_items -> _21_item .)


state 145

    (116) _21_item -> pattern . ,
    ,               shift and go to state 191


state 146

    (132) tuple_pattern -> { _26_repeat . _27_optional }
    (138) _27_optional -> . SPREAD identifier _28_repeat
    (144) _27_optional -> .
    SPREAD          shift and go to state 193
    }               reduce using rule 144 (_27_optional -> .)

    _27_optional                   shift and go to state 192

state 147

    (133) _26_repeat -> _26_items .
    (135) _26_items -> _26_items . _26_item
    (137) _26_item -> . pattern ,
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    SPREAD          reduce using rule 133 (_26_repeat -> _26_items .)
    }               reduce using rule 133 (_26_repeat -> _26_items .)
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    _26_item                       shift and go to state 194
    pattern                        shift and go to state 149
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 148

    (136) _26_items -> _26_item .
    [               reduce using rule 136 (_26_items -> _26_item .)
    {               reduce using rule 136 (_26_items -> _26_item .)
    TYPE_IDENTIFIER reduce using rule 136 (_26_items -> _26_item .)
    SPREAD          reduce using rule 136 (_26_items -> _26_item .)
    }               reduce using rule 136 (_26_items -> _26_item .)


state 149

    (137) _26_item -> pattern . ,
    ,               shift and go to state 195


state 150

    (124) enum_pattern -> type_identifier _24_optional .
    ,               reduce using rule 124 (enum_pattern -> type_identifier _24_optional .)
    DO              reduce using rule 124 (enum_pattern -> type_identifier _24_optional .)
    )               reduce using rule 124 (enum_pattern -> type_identifier _24_optional .)
    ]               reduce using rule 124 (enum_pattern -> type_identifier _24_optional .)
    }               reduce using rule 124 (enum_pattern -> type_identifier _24_optional .)


state 151

    (125) _24_optional -> ( . pattern _25_repeat )
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    pattern                        shift and go to state 196
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 152

    (161) call -> callee ( _33_optional _34_repeat ) .
    INT_DIV         reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    *               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    /               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    -               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    +               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    CONCAT          reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    (               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    ENUM            reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    STRUCT          reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    {               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    [               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    CASE            reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    IF              reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    DEF             reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    NUMBER          reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    STRING          reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    IDENTIFIER      reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    DO              reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    $end            reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    END             reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    ELIF            reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    ELSE            reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    )               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    ,               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    }               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    ]               reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)
    OF              reduce using rule 161 (call -> callee ( _33_optional _34_repeat ) .)


state 153

    (166) _34_items -> _34_items _34_item .
    ,               reduce using rule 166 (_34_items -> _34_items _34_item .)
    )               reduce using rule 166 (_34_items -> _34_items _34_item .)


state 154

    (168) _34_item -> , expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 168 (_34_item -> , expr .)
    )               reduce using rule 168 (_34_item -> , expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 155

    (87) _if -> IF expr DO expressions _17_repeat . _18_optional END
    (93) _18_optional -> . ELSE expressions
    (94) _18_optional -> .
    ELSE            shift and go to state 198
    END             reduce using rule 94 (_18_optional -> .)

    _18_optional                   shift and go to state 197

state 156

    (88) _17_repeat -> _17_items .
    (90) _17_items -> _17_items . _17_item
    (92) _17_item -> . _elif
    (95) _elif -> . ELIF expr DO expressions
    ELSE            reduce using rule 88 (_17_repeat -> _17_items .)
    END             reduce using rule 88 (_17_repeat -> _17_items .)
    ELIF            shift and go to state 159

    _17_item                       shift and go to state 199
    _elif                          shift and go to state 158

state 157

    (91) _17_items -> _17_item .
    ELIF            reduce using rule 91 (_17_items -> _17_item .)
    ELSE            reduce using rule 91 (_17_items -> _17_item .)
    END             reduce using rule 91 (_17_items -> _17_item .)


state 158

    (92) _17_item -> _elif .
    ELIF            reduce using rule 92 (_17_item -> _elif .)
    ELSE            reduce using rule 92 (_17_item -> _elif .)
    END             reduce using rule 92 (_17_item -> _elif .)


state 159

    (95) _elif -> ELIF . expr DO expressions
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 200
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 160

    (84) param -> identifier _16_optional .
    ,               reduce using rule 84 (param -> identifier _16_optional .)
    )               reduce using rule 84 (param -> identifier _16_optional .)


state 161

    (85) _16_optional -> type .
    ,               reduce using rule 85 (_16_optional -> type .)
    )               reduce using rule 85 (_16_optional -> type .)


state 162

    (32) _def -> DEF identifier ( _3_optional _4_repeat . ) _5_optional do
    )               shift and go to state 201


state 163

    (35) _4_repeat -> _4_items .
    (37) _4_items -> _4_items . _4_item
    (39) _4_item -> . , param
    )               reduce using rule 35 (_4_repeat -> _4_items .)
    ,               shift and go to state 165

    _4_item                        shift and go to state 202

state 164

    (38) _4_items -> _4_item .
    ,               reduce using rule 38 (_4_items -> _4_item .)
    )               reduce using rule 38 (_4_items -> _4_item .)


state 165

    (39) _4_item -> , . param
    (84) param -> . identifier _16_optional
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    param                          shift and go to state 203
    identifier                     shift and go to state 113

state 166

    (43) _6_optional -> < identifier _7_repeat . >
    >               shift and go to state 204


state 167

    (44) _7_repeat -> _7_items .
    (46) _7_items -> _7_items . _7_item
    (48) _7_item -> . , identifier
    >               reduce using rule 44 (_7_repeat -> _7_items .)
    ,               shift and go to state 169

    _7_item                        shift and go to state 205

state 168

    (47) _7_items -> _7_item .
    ,               reduce using rule 47 (_7_items -> _7_item .)
    >               reduce using rule 47 (_7_items -> _7_item .)


state 169

    (48) _7_item -> , . identifier
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 206

state 170

    (63) enum -> ENUM type_identifier _11_optional { _13_repeat } .
    INT_DIV         reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    *               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    /               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    -               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    +               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    CONCAT          reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    (               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    ENUM            reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    STRUCT          reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    {               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    [               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    CASE            reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    IF              reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    DEF             reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    NUMBER          reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    STRING          reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    IDENTIFIER      reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    DO              reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    $end            reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    END             reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    ELIF            reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    ELSE            reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    )               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    ,               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    }               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    ]               reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)
    OF              reduce using rule 63 (enum -> ENUM type_identifier _11_optional { _13_repeat } .)


state 171

    (73) _13_items -> _13_items _13_item .
    IDENTIFIER      reduce using rule 73 (_13_items -> _13_items _13_item .)
    }               reduce using rule 73 (_13_items -> _13_items _13_item .)


state 172

    (76) enum_key -> identifier _14_optional .
    IDENTIFIER      reduce using rule 76 (enum_key -> identifier _14_optional .)
    }               reduce using rule 76 (enum_key -> identifier _14_optional .)


state 173

    (77) _14_optional -> ( . identifier _15_repeat )
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 207

state 174

    (64) _11_optional -> < identifier _12_repeat > .
    {               reduce using rule 64 (_11_optional -> < identifier _12_repeat > .)


state 175

    (67) _12_items -> _12_items _12_item .
    ,               reduce using rule 67 (_12_items -> _12_items _12_item .)
    >               reduce using rule 67 (_12_items -> _12_items _12_item .)


state 176

    (69) _12_item -> , identifier .
    ,               reduce using rule 69 (_12_item -> , identifier .)
    >               reduce using rule 69 (_12_item -> , identifier .)


state 177

    (50) struct -> STRUCT type_identifier _8_optional { _10_repeat } .
    INT_DIV         reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    *               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    /               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    -               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    +               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    CONCAT          reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    (               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    ENUM            reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    STRUCT          reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    {               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    [               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    CASE            reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    IF              reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    DEF             reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    NUMBER          reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    STRING          reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    IDENTIFIER      reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    DO              reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    $end            reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    END             reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    ELIF            reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    ELSE            reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    )               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    ,               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    }               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    ]               reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)
    OF              reduce using rule 50 (struct -> STRUCT type_identifier _8_optional { _10_repeat } .)


state 178

    (60) _10_items -> _10_items _10_item .
    IDENTIFIER      reduce using rule 60 (_10_items -> _10_items _10_item .)
    }               reduce using rule 60 (_10_items -> _10_items _10_item .)


state 179

    (62) _10_item -> identifier type .
    IDENTIFIER      reduce using rule 62 (_10_item -> identifier type .)
    }               reduce using rule 62 (_10_item -> identifier type .)


state 180

    (51) _8_optional -> < identifier _9_repeat > .
    {               reduce using rule 51 (_8_optional -> < identifier _9_repeat > .)


state 181

    (54) _9_items -> _9_items _9_item .
    ,               reduce using rule 54 (_9_items -> _9_items _9_item .)
    >               reduce using rule 54 (_9_items -> _9_items _9_item .)


state 182

    (56) _9_item -> , identifier .
    ,               reduce using rule 56 (_9_item -> , identifier .)
    >               reduce using rule 56 (_9_item -> , identifier .)


state 183

    (96) case_of -> CASE expr OF case _19_repeat END .
    INT_DIV         reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    *               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    /               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    -               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    +               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    CONCAT          reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    (               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    ENUM            reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    STRUCT          reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    {               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    [               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    CASE            reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    IF              reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    DEF             reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    NUMBER          reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    STRING          reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    IDENTIFIER      reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    DO              reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    $end            reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    END             reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    ELIF            reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    ELSE            reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    )               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    ,               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    }               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    ]               reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)
    OF              reduce using rule 96 (case_of -> CASE expr OF case _19_repeat END .)


state 184

    (99) _19_items -> _19_items _19_item .
    [               reduce using rule 99 (_19_items -> _19_items _19_item .)
    {               reduce using rule 99 (_19_items -> _19_items _19_item .)
    TYPE_IDENTIFIER reduce using rule 99 (_19_items -> _19_items _19_item .)
    END             reduce using rule 99 (_19_items -> _19_items _19_item .)


state 185

    (102) case -> pattern _20_repeat do .
    [               reduce using rule 102 (case -> pattern _20_repeat do .)
    {               reduce using rule 102 (case -> pattern _20_repeat do .)
    TYPE_IDENTIFIER reduce using rule 102 (case -> pattern _20_repeat do .)
    END             reduce using rule 102 (case -> pattern _20_repeat do .)


state 186

    (105) _20_items -> _20_items _20_item .
    ,               reduce using rule 105 (_20_items -> _20_items _20_item .)
    DO              reduce using rule 105 (_20_items -> _20_items _20_item .)


state 187

    (107) _20_item -> , pattern .
    ,               reduce using rule 107 (_20_item -> , pattern .)
    DO              reduce using rule 107 (_20_item -> , pattern .)


state 188

    (111) array_pattern -> [ _21_repeat _22_optional . ]
    ]               shift and go to state 208


state 189

    (117) _22_optional -> SPREAD . identifier _23_repeat
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 209

state 190

    (114) _21_items -> _21_items _21_item .
    [               reduce using rule 114 (_21_items -> _21_items _21_item .)
    {               reduce using rule 114 (_21_items -> _21_items _21_item .)
    TYPE_IDENTIFIER reduce using rule 114 (_21_items -> _21_items _21_item .)
    SPREAD          reduce using rule 114 (_21_items -> _21_items _21_item .)
    ]               reduce using rule 114 (_21_items -> _21_items _21_item .)


state 191

    (116) _21_item -> pattern , .
    [               reduce using rule 116 (_21_item -> pattern , .)
    {               reduce using rule 116 (_21_item -> pattern , .)
    TYPE_IDENTIFIER reduce using rule 116 (_21_item -> pattern , .)
    SPREAD          reduce using rule 116 (_21_item -> pattern , .)
    ]               reduce using rule 116 (_21_item -> pattern , .)


state 192

    (132) tuple_pattern -> { _26_repeat _27_optional . }
    }               shift and go to state 210


state 193

    (138) _27_optional -> SPREAD . identifier _28_repeat
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 211

state 194

    (135) _26_items -> _26_items _26_item .
    [               reduce using rule 135 (_26_items -> _26_items _26_item .)
    {               reduce using rule 135 (_26_items -> _26_items _26_item .)
    TYPE_IDENTIFIER reduce using rule 135 (_26_items -> _26_items _26_item .)
    SPREAD          reduce using rule 135 (_26_items -> _26_items _26_item .)
    }               reduce using rule 135 (_26_items -> _26_items _26_item .)


state 195

    (137) _26_item -> pattern , .
    [               reduce using rule 137 (_26_item -> pattern , .)
    {               reduce using rule 137 (_26_item -> pattern , .)
    TYPE_IDENTIFIER reduce using rule 137 (_26_item -> pattern , .)
    SPREAD          reduce using rule 137 (_26_item -> pattern , .)
    }               reduce using rule 137 (_26_item -> pattern , .)


state 196

    (125) _24_optional -> ( pattern . _25_repeat )
    (126) _25_repeat -> . _25_items
    (127) _25_repeat -> .
    (128) _25_items -> . _25_items _25_item
    (129) _25_items -> . _25_item
    (130) _25_item -> . , pattern
    )               reduce using rule 127 (_25_repeat -> .)
    ,               shift and go to state 215

    _25_repeat                     shift and go to state 212
    _25_items                      shift and go to state 213
    _25_item                       shift and go to state 214

state 197

    (87) _if -> IF expr DO expressions _17_repeat _18_optional . END
    END             shift and go to state 216


state 198

    (93) _18_optional -> ELSE . expressions
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    END             reduce using rule 4 (_1_repeat -> .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expressions                    shift and go to state 217
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    expr                           shift and go to state 6
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 199

    (90) _17_items -> _17_items _17_item .
    ELIF            reduce using rule 90 (_17_items -> _17_items _17_item .)
    ELSE            reduce using rule 90 (_17_items -> _17_items _17_item .)
    END             reduce using rule 90 (_17_items -> _17_items _17_item .)


state 200

    (95) _elif -> ELIF expr . DO expressions
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    DO              shift and go to state 218
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 201

    (32) _def -> DEF identifier ( _3_optional _4_repeat ) . _5_optional do
    (40) _5_optional -> . type
    (41) _5_optional -> .
    (42) type -> . : type_identifier _6_optional
    DO              reduce using rule 41 (_5_optional -> .)
    :               shift and go to state 45

    _5_optional                    shift and go to state 219
    type                           shift and go to state 220

state 202

    (37) _4_items -> _4_items _4_item .
    ,               reduce using rule 37 (_4_items -> _4_items _4_item .)
    )               reduce using rule 37 (_4_items -> _4_items _4_item .)


state 203

    (39) _4_item -> , param .
    ,               reduce using rule 39 (_4_item -> , param .)
    )               reduce using rule 39 (_4_item -> , param .)


state 204

    (43) _6_optional -> < identifier _7_repeat > .
    =               reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    (               reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    -               reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    ENUM            reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    STRUCT          reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    {               reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    [               reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    CASE            reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    IF              reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    DEF             reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    NUMBER          reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    STRING          reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    IDENTIFIER      reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    DO              reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    END             reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    ,               reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    )               reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)
    }               reduce using rule 43 (_6_optional -> < identifier _7_repeat > .)


state 205

    (46) _7_items -> _7_items _7_item .
    ,               reduce using rule 46 (_7_items -> _7_items _7_item .)
    >               reduce using rule 46 (_7_items -> _7_items _7_item .)


state 206

    (48) _7_item -> , identifier .
    ,               reduce using rule 48 (_7_item -> , identifier .)
    >               reduce using rule 48 (_7_item -> , identifier .)


state 207

    (77) _14_optional -> ( identifier . _15_repeat )
    (78) _15_repeat -> . _15_items
    (79) _15_repeat -> .
    (80) _15_items -> . _15_items _15_item
    (81) _15_items -> . _15_item
    (82) _15_item -> . , identifier
    )               reduce using rule 79 (_15_repeat -> .)
    ,               shift and go to state 224

    _15_repeat                     shift and go to state 221
    _15_items                      shift and go to state 222
    _15_item                       shift and go to state 223

state 208

    (111) array_pattern -> [ _21_repeat _22_optional ] .
    ,               reduce using rule 111 (array_pattern -> [ _21_repeat _22_optional ] .)
    DO              reduce using rule 111 (array_pattern -> [ _21_repeat _22_optional ] .)
    )               reduce using rule 111 (array_pattern -> [ _21_repeat _22_optional ] .)
    ]               reduce using rule 111 (array_pattern -> [ _21_repeat _22_optional ] .)
    }               reduce using rule 111 (array_pattern -> [ _21_repeat _22_optional ] .)


state 209

    (117) _22_optional -> SPREAD identifier . _23_repeat
    (118) _23_repeat -> . _23_items
    (119) _23_repeat -> .
    (120) _23_items -> . _23_items _23_item
    (121) _23_items -> . _23_item
    (122) _23_item -> . , pattern
    ]               reduce using rule 119 (_23_repeat -> .)
    ,               shift and go to state 228

    _23_repeat                     shift and go to state 225
    _23_items                      shift and go to state 226
    _23_item                       shift and go to state 227

state 210

    (132) tuple_pattern -> { _26_repeat _27_optional } .
    ,               reduce using rule 132 (tuple_pattern -> { _26_repeat _27_optional } .)
    DO              reduce using rule 132 (tuple_pattern -> { _26_repeat _27_optional } .)
    )               reduce using rule 132 (tuple_pattern -> { _26_repeat _27_optional } .)
    ]               reduce using rule 132 (tuple_pattern -> { _26_repeat _27_optional } .)
    }               reduce using rule 132 (tuple_pattern -> { _26_repeat _27_optional } .)


state 211

    (138) _27_optional -> SPREAD identifier . _28_repeat
    (139) _28_repeat -> . _28_items
    (140) _28_repeat -> .
    (141) _28_items -> . _28_items _28_item
    (142) _28_items -> . _28_item
    (143) _28_item -> . , pattern
    }               reduce using rule 140 (_28_repeat -> .)
    ,               shift and go to state 232

    _28_repeat                     shift and go to state 229
    _28_items                      shift and go to state 230
    _28_item                       shift and go to state 231

state 212

    (125) _24_optional -> ( pattern _25_repeat . )
    )               shift and go to state 233


state 213

    (126) _25_repeat -> _25_items .
    (128) _25_items -> _25_items . _25_item
    (130) _25_item -> . , pattern
    )               reduce using rule 126 (_25_repeat -> _25_items .)
    ,               shift and go to state 215

    _25_item                       shift and go to state 234

state 214

    (129) _25_items -> _25_item .
    ,               reduce using rule 129 (_25_items -> _25_item .)
    )               reduce using rule 129 (_25_items -> _25_item .)


state 215

    (130) _25_item -> , . pattern
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    pattern                        shift and go to state 235
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 216

    (87) _if -> IF expr DO expressions _17_repeat _18_optional END .
    INT_DIV         reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    *               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    /               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    -               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    +               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    CONCAT          reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    (               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    ENUM            reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    STRUCT          reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    {               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    [               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    CASE            reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    IF              reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    DEF             reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    NUMBER          reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    STRING          reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    IDENTIFIER      reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    DO              reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    $end            reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    END             reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    ELIF            reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    ELSE            reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    )               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    ,               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    }               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    ]               reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)
    OF              reduce using rule 87 (_if -> IF expr DO expressions _17_repeat _18_optional END .)


state 217

    (93) _18_optional -> ELSE expressions .
    END             reduce using rule 93 (_18_optional -> ELSE expressions .)


state 218

    (95) _elif -> ELIF expr DO . expressions
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . enum
    (9) expr -> . struct
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (63) enum -> . ENUM type_identifier _11_optional { _13_repeat }
    (50) struct -> . STRUCT type_identifier _8_optional { _10_repeat }
    (153) tuple -> . { _31_optional _32_repeat }
    (145) array -> . [ _29_optional _30_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (172) variable_declaration -> . identifier _35_optional = expr
    (96) case_of -> . CASE expr OF case _19_repeat END
    (161) call -> . callee ( _33_optional _34_repeat )
    (87) _if -> . IF expr DO expressions _17_repeat _18_optional END
    (32) _def -> . DEF identifier ( _3_optional _4_repeat ) _5_optional do
    (175) literal -> . NUMBER
    (176) literal -> . STRING
    (170) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional expressions END
    (169) callee -> . identifier
    ELIF            reduce using rule 4 (_1_repeat -> .)
    ELSE            reduce using rule 4 (_1_repeat -> .)
    END             reduce using rule 4 (_1_repeat -> .)
    (               shift and go to state 9
    -               shift and go to state 10
    ENUM            shift and go to state 22
    STRUCT          shift and go to state 24
    {               shift and go to state 23
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 6
    expressions                    shift and go to state 236
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    enum                           shift and go to state 7
    struct                         shift and go to state 8
    tuple                          shift and go to state 11
    array                          shift and go to state 12
    binary_expr                    shift and go to state 13
    variable_declaration           shift and go to state 14
    case_of                        shift and go to state 15
    call                           shift and go to state 16
    _if                            shift and go to state 17
    _def                           shift and go to state 18
    literal                        shift and go to state 19
    identifier                     shift and go to state 20
    do                             shift and go to state 21
    callee                         shift and go to state 27

state 219

    (32) _def -> DEF identifier ( _3_optional _4_repeat ) _5_optional . do
    (29) do -> . DO _2_optional expressions END
    DO              shift and go to state 29

    do                             shift and go to state 237

state 220

    (40) _5_optional -> type .
    DO              reduce using rule 40 (_5_optional -> type .)


state 221

    (77) _14_optional -> ( identifier _15_repeat . )
    )               shift and go to state 238


state 222

    (78) _15_repeat -> _15_items .
    (80) _15_items -> _15_items . _15_item
    (82) _15_item -> . , identifier
    )               reduce using rule 78 (_15_repeat -> _15_items .)
    ,               shift and go to state 224

    _15_item                       shift and go to state 239

state 223

    (81) _15_items -> _15_item .
    ,               reduce using rule 81 (_15_items -> _15_item .)
    )               reduce using rule 81 (_15_items -> _15_item .)


state 224

    (82) _15_item -> , . identifier
    (170) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 240

state 225

    (117) _22_optional -> SPREAD identifier _23_repeat .
    ]               reduce using rule 117 (_22_optional -> SPREAD identifier _23_repeat .)


state 226

    (118) _23_repeat -> _23_items .
    (120) _23_items -> _23_items . _23_item
    (122) _23_item -> . , pattern
    ]               reduce using rule 118 (_23_repeat -> _23_items .)
    ,               shift and go to state 228

    _23_item                       shift and go to state 241

state 227

    (121) _23_items -> _23_item .
    ,               reduce using rule 121 (_23_items -> _23_item .)
    ]               reduce using rule 121 (_23_items -> _23_item .)


state 228

    (122) _23_item -> , . pattern
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    pattern                        shift and go to state 242
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 229

    (138) _27_optional -> SPREAD identifier _28_repeat .
    }               reduce using rule 138 (_27_optional -> SPREAD identifier _28_repeat .)


state 230

    (139) _28_repeat -> _28_items .
    (141) _28_items -> _28_items . _28_item
    (143) _28_item -> . , pattern
    }               reduce using rule 139 (_28_repeat -> _28_items .)
    ,               shift and go to state 232

    _28_item                       shift and go to state 243

state 231

    (142) _28_items -> _28_item .
    ,               reduce using rule 142 (_28_items -> _28_item .)
    }               reduce using rule 142 (_28_items -> _28_item .)


state 232

    (143) _28_item -> , . pattern
    (108) pattern -> . array_pattern
    (109) pattern -> . tuple_pattern
    (110) pattern -> . enum_pattern
    (111) array_pattern -> . [ _21_repeat _22_optional ]
    (132) tuple_pattern -> . { _26_repeat _27_optional }
    (124) enum_pattern -> . type_identifier _24_optional
    (171) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 104
    {               shift and go to state 105
    TYPE_IDENTIFIER shift and go to state 47

    pattern                        shift and go to state 244
    array_pattern                  shift and go to state 101
    tuple_pattern                  shift and go to state 102
    enum_pattern                   shift and go to state 103
    type_identifier                shift and go to state 106

state 233

    (125) _24_optional -> ( pattern _25_repeat ) .
    ,               reduce using rule 125 (_24_optional -> ( pattern _25_repeat ) .)
    DO              reduce using rule 125 (_24_optional -> ( pattern _25_repeat ) .)
    )               reduce using rule 125 (_24_optional -> ( pattern _25_repeat ) .)
    ]               reduce using rule 125 (_24_optional -> ( pattern _25_repeat ) .)
    }               reduce using rule 125 (_24_optional -> ( pattern _25_repeat ) .)


state 234

    (128) _25_items -> _25_items _25_item .
    ,               reduce using rule 128 (_25_items -> _25_items _25_item .)
    )               reduce using rule 128 (_25_items -> _25_items _25_item .)


state 235

    (130) _25_item -> , pattern .
    ,               reduce using rule 130 (_25_item -> , pattern .)
    )               reduce using rule 130 (_25_item -> , pattern .)


state 236

    (95) _elif -> ELIF expr DO expressions .
    ELIF            reduce using rule 95 (_elif -> ELIF expr DO expressions .)
    ELSE            reduce using rule 95 (_elif -> ELIF expr DO expressions .)
    END             reduce using rule 95 (_elif -> ELIF expr DO expressions .)


state 237

    (32) _def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .
    INT_DIV         reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    *               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    /               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    -               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    +               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    CONCAT          reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    (               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    ENUM            reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    STRUCT          reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    {               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    [               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    CASE            reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    IF              reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    DEF             reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    NUMBER          reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    STRING          reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    IDENTIFIER      reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    DO              reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    $end            reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    END             reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    ELIF            reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    ELSE            reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    )               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    ,               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    }               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    ]               reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)
    OF              reduce using rule 32 (_def -> DEF identifier ( _3_optional _4_repeat ) _5_optional do .)


state 238

    (77) _14_optional -> ( identifier _15_repeat ) .
    IDENTIFIER      reduce using rule 77 (_14_optional -> ( identifier _15_repeat ) .)
    }               reduce using rule 77 (_14_optional -> ( identifier _15_repeat ) .)


state 239

    (80) _15_items -> _15_items _15_item .
    ,               reduce using rule 80 (_15_items -> _15_items _15_item .)
    )               reduce using rule 80 (_15_items -> _15_items _15_item .)


state 240

    (82) _15_item -> , identifier .
    ,               reduce using rule 82 (_15_item -> , identifier .)
    )               reduce using rule 82 (_15_item -> , identifier .)


state 241

    (120) _23_items -> _23_items _23_item .
    ,               reduce using rule 120 (_23_items -> _23_items _23_item .)
    ]               reduce using rule 120 (_23_items -> _23_items _23_item .)


state 242

    (122) _23_item -> , pattern .
    ,               reduce using rule 122 (_23_item -> , pattern .)
    ]               reduce using rule 122 (_23_item -> , pattern .)


state 243

    (141) _28_items -> _28_items _28_item .
    ,               reduce using rule 141 (_28_items -> _28_items _28_item .)
    }               reduce using rule 141 (_28_items -> _28_items _28_item .)


state 244

    (143) _28_item -> , pattern .
    ,               reduce using rule 143 (_28_item -> , pattern .)
    }               reduce using rule 143 (_28_item -> , pattern .)


Conflicts:

shift/reduce conflict for - in state 6 resolved as shift
shift/reduce conflict for INT_DIV in state 86 resolved as shift
shift/reduce conflict for * in state 86 resolved as shift
shift/reduce conflict for / in state 86 resolved as shift
shift/reduce conflict for - in state 86 resolved as shift
shift/reduce conflict for + in state 86 resolved as shift
shift/reduce conflict for CONCAT in state 86 resolved as shift
reduce/reduce conflict in state 20 resolved using rule expr -> identifier
rejected rule (callee -> identifier) in state 20
Rule (callee -> identifier) is never reduced