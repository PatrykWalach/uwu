Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_optional _2_optional
Rule 2     _1_optional -> NEWLINE
Rule 3     _1_optional -> <empty>
Rule 4     _2_optional -> do_exprs
Rule 5     _2_optional -> <empty>
Rule 6     do_exprs -> expr _3_optional
Rule 7     _3_optional -> NEWLINE
Rule 8     _3_optional -> <empty>
Rule 9     do_exprs -> expr NEWLINE do_exprs
Rule 10    expr -> - expr  [precedence=right, level=6]
Rule 11    expr -> ( expr )  [precedence=left, level=7]
Rule 12    expr -> array
Rule 13    expr -> variant_call
Rule 14    expr -> identifier
Rule 15    expr -> variable_declaration
Rule 16    expr -> call
Rule 17    expr -> case_of
Rule 18    expr -> binary_expr
Rule 19    expr -> if_expr
Rule 20    expr -> def_expr
Rule 21    expr -> literal
Rule 22    expr -> do
Rule 23    expr -> external
Rule 24    expr -> enum
Rule 25    external -> EXTERNAL
Rule 26    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 27    binary_expr -> expr EQUAL expr  [precedence=left, level=2]
Rule 28    binary_expr -> expr NOT_EQUAL expr  [precedence=left, level=2]
Rule 29    binary_expr -> expr | expr  [precedence=left, level=4]
Rule 30    binary_expr -> expr > expr  [precedence=left, level=3]
Rule 31    binary_expr -> expr % expr  [precedence=left, level=5]
Rule 32    binary_expr -> expr < expr  [precedence=left, level=3]
Rule 33    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 34    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 35    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 36    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 37    binary_expr -> expr CONCAT expr  [precedence=left, level=4]
Rule 38    do -> DO _4_optional block_statement END
Rule 39    _4_optional -> : type
Rule 40    _4_optional -> <empty>
Rule 41    block_statement -> _5_optional _6_optional
Rule 42    _5_optional -> NEWLINE
Rule 43    _5_optional -> <empty>
Rule 44    _6_optional -> do_exprs
Rule 45    _6_optional -> <empty>
Rule 46    def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do  [precedence=left, level=7]
Rule 47    _7_optional -> NEWLINE
Rule 48    _7_optional -> <empty>
Rule 49    _8_optional -> params
Rule 50    _8_optional -> <empty>
Rule 51    _9_optional -> : type
Rule 52    _9_optional -> <empty>
Rule 53    def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do  [precedence=left, level=7]
Rule 54    _10_repeat -> _10_items
Rule 55    _10_repeat -> <empty>
Rule 56    _10_items -> _10_items _10_item
Rule 57    _10_items -> _10_item
Rule 58    _10_item -> , type_identifier
Rule 59    _11_optional -> NEWLINE
Rule 60    _11_optional -> <empty>
Rule 61    _12_optional -> params
Rule 62    _12_optional -> <empty>
Rule 63    _13_optional -> : type
Rule 64    _13_optional -> <empty>
Rule 65    params -> param _14_optional
Rule 66    _14_optional -> NEWLINE
Rule 67    _14_optional -> <empty>
Rule 68    params -> params , _15_optional param _16_optional
Rule 69    _15_optional -> NEWLINE
Rule 70    _15_optional -> <empty>
Rule 71    _16_optional -> NEWLINE
Rule 72    _16_optional -> <empty>
Rule 73    type -> type_identifier < type _17_repeat >  [precedence=left, level=3]
Rule 74    _17_repeat -> _17_items
Rule 75    _17_repeat -> <empty>
Rule 76    _17_items -> _17_items _17_item
Rule 77    _17_items -> _17_item
Rule 78    _17_item -> , type
Rule 79    type -> type_identifier
Rule 80    enum -> ENUM type_identifier { _18_optional _19_optional }
Rule 81    _18_optional -> NEWLINE
Rule 82    _18_optional -> <empty>
Rule 83    _19_optional -> variants
Rule 84    _19_optional -> <empty>
Rule 85    enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
Rule 86    _20_repeat -> _20_items
Rule 87    _20_repeat -> <empty>
Rule 88    _20_items -> _20_items _20_item
Rule 89    _20_items -> _20_item
Rule 90    _20_item -> , type_identifier
Rule 91    _21_optional -> NEWLINE
Rule 92    _21_optional -> <empty>
Rule 93    _22_optional -> variants
Rule 94    _22_optional -> <empty>
Rule 95    variants -> variant _23_optional
Rule 96    _23_optional -> NEWLINE
Rule 97    _23_optional -> <empty>
Rule 98    variants -> variants variant _24_optional
Rule 99    _24_optional -> NEWLINE
Rule 100   _24_optional -> <empty>
Rule 101   variant -> type_identifier
Rule 102   variant -> type_identifier ( type _25_repeat )  [precedence=left, level=7]
Rule 103   _25_repeat -> _25_items
Rule 104   _25_repeat -> <empty>
Rule 105   _25_items -> _25_items _25_item
Rule 106   _25_items -> _25_item
Rule 107   _25_item -> , type
Rule 108   param -> identifier _26_optional
Rule 109   _26_optional -> : type
Rule 110   _26_optional -> <empty>
Rule 111   if_expr -> IF expr THEN _27_optional block_statement _28_optional END
Rule 112   _27_optional -> : type
Rule 113   _27_optional -> <empty>
Rule 114   _28_optional -> or_else
Rule 115   _28_optional -> <empty>
Rule 116   or_else -> ELIF expr THEN block_statement _29_optional
Rule 117   _29_optional -> or_else
Rule 118   _29_optional -> <empty>
Rule 119   or_else -> ELSE block_statement
Rule 120   case_of -> CASE expr OF _30_optional _31_optional END
Rule 121   _30_optional -> NEWLINE
Rule 122   _30_optional -> <empty>
Rule 123   _31_optional -> cases
Rule 124   _31_optional -> <empty>
Rule 125   cases -> pattern do _32_optional
Rule 126   _32_optional -> NEWLINE
Rule 127   _32_optional -> <empty>
Rule 128   cases -> cases pattern do _33_optional
Rule 129   _33_optional -> NEWLINE
Rule 130   _33_optional -> <empty>
Rule 131   pattern -> match_variant
Rule 132   pattern -> match_as
Rule 133   match_as -> identifier
Rule 134   match_variant -> type_identifier
Rule 135   match_variant -> type_identifier ( _34_optional _35_optional )  [precedence=left, level=7]
Rule 136   _34_optional -> NEWLINE
Rule 137   _34_optional -> <empty>
Rule 138   _35_optional -> patterns
Rule 139   _35_optional -> <empty>
Rule 140   patterns -> pattern _36_optional
Rule 141   _36_optional -> NEWLINE
Rule 142   _36_optional -> <empty>
Rule 143   patterns -> patterns , _37_optional pattern _38_optional
Rule 144   _37_optional -> NEWLINE
Rule 145   _37_optional -> <empty>
Rule 146   _38_optional -> NEWLINE
Rule 147   _38_optional -> <empty>
Rule 148   array -> [ _39_optional _40_optional ]
Rule 149   _39_optional -> NEWLINE
Rule 150   _39_optional -> <empty>
Rule 151   _40_optional -> exprs
Rule 152   _40_optional -> <empty>
Rule 153   call -> expr ( _41_optional _42_optional )  [precedence=left, level=7]
Rule 154   _41_optional -> NEWLINE
Rule 155   _41_optional -> <empty>
Rule 156   _42_optional -> exprs
Rule 157   _42_optional -> <empty>
Rule 158   variant_call -> type_identifier ( _43_optional _44_optional )  [precedence=left, level=7]
Rule 159   _43_optional -> NEWLINE
Rule 160   _43_optional -> <empty>
Rule 161   _44_optional -> exprs
Rule 162   _44_optional -> <empty>
Rule 163   exprs -> expr _45_optional
Rule 164   _45_optional -> NEWLINE
Rule 165   _45_optional -> <empty>
Rule 166   exprs -> exprs , _46_optional expr _47_optional
Rule 167   _46_optional -> NEWLINE
Rule 168   _46_optional -> <empty>
Rule 169   _47_optional -> NEWLINE
Rule 170   _47_optional -> <empty>
Rule 171   identifier -> IDENTIFIER
Rule 172   type_identifier -> TYPE_IDENTIFIER
Rule 173   variable_declaration -> identifier _48_optional = expr  [precedence=left, level=1]
Rule 174   _48_optional -> : type
Rule 175   _48_optional -> <empty>
Rule 176   literal -> STRING
Rule 177   literal -> NUMBER

Terminals, with rules where they appear:

%                    : 31
(                    : 11 46 53 102 135 153 158
)                    : 11 46 53 102 135 153 158
*                    : 33
+                    : 36
,                    : 58 68 78 90 107 143 166
-                    : 10 35
/                    : 34
:                    : 39 51 63 109 112 174
<                    : 32 53 73 85
=                    : 173
>                    : 30 53 73 85
CASE                 : 120
CONCAT               : 37
DEF                  : 46 53
DO                   : 38
ELIF                 : 116
ELSE                 : 119
END                  : 38 111 120
ENUM                 : 80 85
EQUAL                : 27
EXTERNAL             : 25
IDENTIFIER           : 171
IF                   : 111
INT_DIV              : 26
NEWLINE              : 2 7 9 42 47 59 66 69 71 81 91 96 99 121 126 129 136 141 144 146 149 154 159 164 167 169
NOT_EQUAL            : 28
NUMBER               : 177
OF                   : 120
STRING               : 176
THEN                 : 111 116
TYPE_IDENTIFIER      : 172
[                    : 148
]                    : 148
error                : 
{                    : 80 85
|                    : 29
}                    : 80 85

Nonterminals, with rules where they appear:

_10_item             : 56 57
_10_items            : 54 56
_10_repeat           : 53
_11_optional         : 53
_12_optional         : 53
_13_optional         : 53
_14_optional         : 65
_15_optional         : 68
_16_optional         : 68
_17_item             : 76 77
_17_items            : 74 76
_17_repeat           : 73
_18_optional         : 80
_19_optional         : 80
_1_optional          : 1
_20_item             : 88 89
_20_items            : 86 88
_20_repeat           : 85
_21_optional         : 85
_22_optional         : 85
_23_optional         : 95
_24_optional         : 98
_25_item             : 105 106
_25_items            : 103 105
_25_repeat           : 102
_26_optional         : 108
_27_optional         : 111
_28_optional         : 111
_29_optional         : 116
_2_optional          : 1
_30_optional         : 120
_31_optional         : 120
_32_optional         : 125
_33_optional         : 128
_34_optional         : 135
_35_optional         : 135
_36_optional         : 140
_37_optional         : 143
_38_optional         : 143
_39_optional         : 148
_3_optional          : 6
_40_optional         : 148
_41_optional         : 153
_42_optional         : 153
_43_optional         : 158
_44_optional         : 158
_45_optional         : 163
_46_optional         : 166
_47_optional         : 166
_48_optional         : 173
_4_optional          : 38
_5_optional          : 41
_6_optional          : 41
_7_optional          : 46
_8_optional          : 46
_9_optional          : 46
array                : 12
binary_expr          : 18
block_statement      : 38 111 116 119
call                 : 16
case_of              : 17
cases                : 123 128
def_expr             : 20
do                   : 22 46 53 125 128
do_exprs             : 4 9 44
enum                 : 24
expr                 : 6 9 10 11 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 111 116 120 153 163 166 173
exprs                : 151 156 161 166
external             : 23
identifier           : 14 46 53 108 133 173
if_expr              : 19
literal              : 21
match_as             : 132
match_variant        : 131
or_else              : 114 117
param                : 65 68
params               : 49 61 68
pattern              : 125 128 140 143
patterns             : 138 143
program              : 0
type                 : 39 51 63 73 78 102 107 109 112 174
type_identifier      : 53 58 73 79 80 85 85 90 101 102 134 135 158
variable_declaration : 15
variant              : 95 98
variant_call         : 13
variants             : 83 93 98


state 0

    (0) S' -> . program
    (1) program -> . _1_optional _2_optional
    (2) _1_optional -> . NEWLINE
    (3) _1_optional -> .
    NEWLINE         shift and go to state 3
    -               reduce using rule 3 (_1_optional -> .)
    (               reduce using rule 3 (_1_optional -> .)
    [               reduce using rule 3 (_1_optional -> .)
    IDENTIFIER      reduce using rule 3 (_1_optional -> .)
    CASE            reduce using rule 3 (_1_optional -> .)
    IF              reduce using rule 3 (_1_optional -> .)
    DEF             reduce using rule 3 (_1_optional -> .)
    STRING          reduce using rule 3 (_1_optional -> .)
    NUMBER          reduce using rule 3 (_1_optional -> .)
    DO              reduce using rule 3 (_1_optional -> .)
    EXTERNAL        reduce using rule 3 (_1_optional -> .)
    ENUM            reduce using rule 3 (_1_optional -> .)
    TYPE_IDENTIFIER reduce using rule 3 (_1_optional -> .)
    $end            reduce using rule 3 (_1_optional -> .)

    program                        shift and go to state 1
    _1_optional                    shift and go to state 2

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_optional . _2_optional
    (4) _2_optional -> . do_exprs
    (5) _2_optional -> .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 5 (_2_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _2_optional                    shift and go to state 4
    do_exprs                       shift and go to state 5
    expr                           shift and go to state 6
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 3

    (2) _1_optional -> NEWLINE .
    -               reduce using rule 2 (_1_optional -> NEWLINE .)
    (               reduce using rule 2 (_1_optional -> NEWLINE .)
    [               reduce using rule 2 (_1_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 2 (_1_optional -> NEWLINE .)
    CASE            reduce using rule 2 (_1_optional -> NEWLINE .)
    IF              reduce using rule 2 (_1_optional -> NEWLINE .)
    DEF             reduce using rule 2 (_1_optional -> NEWLINE .)
    STRING          reduce using rule 2 (_1_optional -> NEWLINE .)
    NUMBER          reduce using rule 2 (_1_optional -> NEWLINE .)
    DO              reduce using rule 2 (_1_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 2 (_1_optional -> NEWLINE .)
    ENUM            reduce using rule 2 (_1_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 2 (_1_optional -> NEWLINE .)
    $end            reduce using rule 2 (_1_optional -> NEWLINE .)


state 4

    (1) program -> _1_optional _2_optional .
    $end            reduce using rule 1 (program -> _1_optional _2_optional .)


state 5

    (4) _2_optional -> do_exprs .
    $end            reduce using rule 4 (_2_optional -> do_exprs .)


state 6

    (6) do_exprs -> expr . _3_optional
    (9) do_exprs -> expr . NEWLINE do_exprs
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    (7) _3_optional -> . NEWLINE
    (8) _3_optional -> .
    NEWLINE         shift and go to state 35
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48
    $end            reduce using rule 8 (_3_optional -> .)
    END             reduce using rule 8 (_3_optional -> .)
    ELIF            reduce using rule 8 (_3_optional -> .)
    ELSE            reduce using rule 8 (_3_optional -> .)

    _3_optional                    shift and go to state 34

state 7

    (10) expr -> - . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 49
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 8

    (11) expr -> ( . expr )
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 50
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 9

    (12) expr -> array .
    NEWLINE         reduce using rule 12 (expr -> array .)
    (               reduce using rule 12 (expr -> array .)
    INT_DIV         reduce using rule 12 (expr -> array .)
    EQUAL           reduce using rule 12 (expr -> array .)
    NOT_EQUAL       reduce using rule 12 (expr -> array .)
    |               reduce using rule 12 (expr -> array .)
    >               reduce using rule 12 (expr -> array .)
    %               reduce using rule 12 (expr -> array .)
    <               reduce using rule 12 (expr -> array .)
    *               reduce using rule 12 (expr -> array .)
    /               reduce using rule 12 (expr -> array .)
    -               reduce using rule 12 (expr -> array .)
    +               reduce using rule 12 (expr -> array .)
    CONCAT          reduce using rule 12 (expr -> array .)
    $end            reduce using rule 12 (expr -> array .)
    )               reduce using rule 12 (expr -> array .)
    OF              reduce using rule 12 (expr -> array .)
    THEN            reduce using rule 12 (expr -> array .)
    END             reduce using rule 12 (expr -> array .)
    ELIF            reduce using rule 12 (expr -> array .)
    ELSE            reduce using rule 12 (expr -> array .)
    ,               reduce using rule 12 (expr -> array .)
    ]               reduce using rule 12 (expr -> array .)


state 10

    (13) expr -> variant_call .
    NEWLINE         reduce using rule 13 (expr -> variant_call .)
    (               reduce using rule 13 (expr -> variant_call .)
    INT_DIV         reduce using rule 13 (expr -> variant_call .)
    EQUAL           reduce using rule 13 (expr -> variant_call .)
    NOT_EQUAL       reduce using rule 13 (expr -> variant_call .)
    |               reduce using rule 13 (expr -> variant_call .)
    >               reduce using rule 13 (expr -> variant_call .)
    %               reduce using rule 13 (expr -> variant_call .)
    <               reduce using rule 13 (expr -> variant_call .)
    *               reduce using rule 13 (expr -> variant_call .)
    /               reduce using rule 13 (expr -> variant_call .)
    -               reduce using rule 13 (expr -> variant_call .)
    +               reduce using rule 13 (expr -> variant_call .)
    CONCAT          reduce using rule 13 (expr -> variant_call .)
    $end            reduce using rule 13 (expr -> variant_call .)
    )               reduce using rule 13 (expr -> variant_call .)
    OF              reduce using rule 13 (expr -> variant_call .)
    THEN            reduce using rule 13 (expr -> variant_call .)
    END             reduce using rule 13 (expr -> variant_call .)
    ELIF            reduce using rule 13 (expr -> variant_call .)
    ELSE            reduce using rule 13 (expr -> variant_call .)
    ,               reduce using rule 13 (expr -> variant_call .)
    ]               reduce using rule 13 (expr -> variant_call .)


state 11

    (14) expr -> identifier .
    (173) variable_declaration -> identifier . _48_optional = expr
    (174) _48_optional -> . : type
    (175) _48_optional -> .
    NEWLINE         reduce using rule 14 (expr -> identifier .)
    (               reduce using rule 14 (expr -> identifier .)
    INT_DIV         reduce using rule 14 (expr -> identifier .)
    EQUAL           reduce using rule 14 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 14 (expr -> identifier .)
    |               reduce using rule 14 (expr -> identifier .)
    >               reduce using rule 14 (expr -> identifier .)
    %               reduce using rule 14 (expr -> identifier .)
    <               reduce using rule 14 (expr -> identifier .)
    *               reduce using rule 14 (expr -> identifier .)
    /               reduce using rule 14 (expr -> identifier .)
    -               reduce using rule 14 (expr -> identifier .)
    +               reduce using rule 14 (expr -> identifier .)
    CONCAT          reduce using rule 14 (expr -> identifier .)
    $end            reduce using rule 14 (expr -> identifier .)
    )               reduce using rule 14 (expr -> identifier .)
    OF              reduce using rule 14 (expr -> identifier .)
    THEN            reduce using rule 14 (expr -> identifier .)
    END             reduce using rule 14 (expr -> identifier .)
    ELIF            reduce using rule 14 (expr -> identifier .)
    ELSE            reduce using rule 14 (expr -> identifier .)
    ,               reduce using rule 14 (expr -> identifier .)
    ]               reduce using rule 14 (expr -> identifier .)
    :               shift and go to state 52
    =               reduce using rule 175 (_48_optional -> .)

    _48_optional                   shift and go to state 51

state 12

    (15) expr -> variable_declaration .
    NEWLINE         reduce using rule 15 (expr -> variable_declaration .)
    (               reduce using rule 15 (expr -> variable_declaration .)
    INT_DIV         reduce using rule 15 (expr -> variable_declaration .)
    EQUAL           reduce using rule 15 (expr -> variable_declaration .)
    NOT_EQUAL       reduce using rule 15 (expr -> variable_declaration .)
    |               reduce using rule 15 (expr -> variable_declaration .)
    >               reduce using rule 15 (expr -> variable_declaration .)
    %               reduce using rule 15 (expr -> variable_declaration .)
    <               reduce using rule 15 (expr -> variable_declaration .)
    *               reduce using rule 15 (expr -> variable_declaration .)
    /               reduce using rule 15 (expr -> variable_declaration .)
    -               reduce using rule 15 (expr -> variable_declaration .)
    +               reduce using rule 15 (expr -> variable_declaration .)
    CONCAT          reduce using rule 15 (expr -> variable_declaration .)
    $end            reduce using rule 15 (expr -> variable_declaration .)
    )               reduce using rule 15 (expr -> variable_declaration .)
    OF              reduce using rule 15 (expr -> variable_declaration .)
    THEN            reduce using rule 15 (expr -> variable_declaration .)
    END             reduce using rule 15 (expr -> variable_declaration .)
    ELIF            reduce using rule 15 (expr -> variable_declaration .)
    ELSE            reduce using rule 15 (expr -> variable_declaration .)
    ,               reduce using rule 15 (expr -> variable_declaration .)
    ]               reduce using rule 15 (expr -> variable_declaration .)


state 13

    (16) expr -> call .
    NEWLINE         reduce using rule 16 (expr -> call .)
    (               reduce using rule 16 (expr -> call .)
    INT_DIV         reduce using rule 16 (expr -> call .)
    EQUAL           reduce using rule 16 (expr -> call .)
    NOT_EQUAL       reduce using rule 16 (expr -> call .)
    |               reduce using rule 16 (expr -> call .)
    >               reduce using rule 16 (expr -> call .)
    %               reduce using rule 16 (expr -> call .)
    <               reduce using rule 16 (expr -> call .)
    *               reduce using rule 16 (expr -> call .)
    /               reduce using rule 16 (expr -> call .)
    -               reduce using rule 16 (expr -> call .)
    +               reduce using rule 16 (expr -> call .)
    CONCAT          reduce using rule 16 (expr -> call .)
    $end            reduce using rule 16 (expr -> call .)
    )               reduce using rule 16 (expr -> call .)
    OF              reduce using rule 16 (expr -> call .)
    THEN            reduce using rule 16 (expr -> call .)
    END             reduce using rule 16 (expr -> call .)
    ELIF            reduce using rule 16 (expr -> call .)
    ELSE            reduce using rule 16 (expr -> call .)
    ,               reduce using rule 16 (expr -> call .)
    ]               reduce using rule 16 (expr -> call .)


state 14

    (17) expr -> case_of .
    NEWLINE         reduce using rule 17 (expr -> case_of .)
    (               reduce using rule 17 (expr -> case_of .)
    INT_DIV         reduce using rule 17 (expr -> case_of .)
    EQUAL           reduce using rule 17 (expr -> case_of .)
    NOT_EQUAL       reduce using rule 17 (expr -> case_of .)
    |               reduce using rule 17 (expr -> case_of .)
    >               reduce using rule 17 (expr -> case_of .)
    %               reduce using rule 17 (expr -> case_of .)
    <               reduce using rule 17 (expr -> case_of .)
    *               reduce using rule 17 (expr -> case_of .)
    /               reduce using rule 17 (expr -> case_of .)
    -               reduce using rule 17 (expr -> case_of .)
    +               reduce using rule 17 (expr -> case_of .)
    CONCAT          reduce using rule 17 (expr -> case_of .)
    $end            reduce using rule 17 (expr -> case_of .)
    )               reduce using rule 17 (expr -> case_of .)
    OF              reduce using rule 17 (expr -> case_of .)
    THEN            reduce using rule 17 (expr -> case_of .)
    END             reduce using rule 17 (expr -> case_of .)
    ELIF            reduce using rule 17 (expr -> case_of .)
    ELSE            reduce using rule 17 (expr -> case_of .)
    ,               reduce using rule 17 (expr -> case_of .)
    ]               reduce using rule 17 (expr -> case_of .)


state 15

    (18) expr -> binary_expr .
    NEWLINE         reduce using rule 18 (expr -> binary_expr .)
    (               reduce using rule 18 (expr -> binary_expr .)
    INT_DIV         reduce using rule 18 (expr -> binary_expr .)
    EQUAL           reduce using rule 18 (expr -> binary_expr .)
    NOT_EQUAL       reduce using rule 18 (expr -> binary_expr .)
    |               reduce using rule 18 (expr -> binary_expr .)
    >               reduce using rule 18 (expr -> binary_expr .)
    %               reduce using rule 18 (expr -> binary_expr .)
    <               reduce using rule 18 (expr -> binary_expr .)
    *               reduce using rule 18 (expr -> binary_expr .)
    /               reduce using rule 18 (expr -> binary_expr .)
    -               reduce using rule 18 (expr -> binary_expr .)
    +               reduce using rule 18 (expr -> binary_expr .)
    CONCAT          reduce using rule 18 (expr -> binary_expr .)
    $end            reduce using rule 18 (expr -> binary_expr .)
    )               reduce using rule 18 (expr -> binary_expr .)
    OF              reduce using rule 18 (expr -> binary_expr .)
    THEN            reduce using rule 18 (expr -> binary_expr .)
    END             reduce using rule 18 (expr -> binary_expr .)
    ELIF            reduce using rule 18 (expr -> binary_expr .)
    ELSE            reduce using rule 18 (expr -> binary_expr .)
    ,               reduce using rule 18 (expr -> binary_expr .)
    ]               reduce using rule 18 (expr -> binary_expr .)


state 16

    (19) expr -> if_expr .
    NEWLINE         reduce using rule 19 (expr -> if_expr .)
    (               reduce using rule 19 (expr -> if_expr .)
    INT_DIV         reduce using rule 19 (expr -> if_expr .)
    EQUAL           reduce using rule 19 (expr -> if_expr .)
    NOT_EQUAL       reduce using rule 19 (expr -> if_expr .)
    |               reduce using rule 19 (expr -> if_expr .)
    >               reduce using rule 19 (expr -> if_expr .)
    %               reduce using rule 19 (expr -> if_expr .)
    <               reduce using rule 19 (expr -> if_expr .)
    *               reduce using rule 19 (expr -> if_expr .)
    /               reduce using rule 19 (expr -> if_expr .)
    -               reduce using rule 19 (expr -> if_expr .)
    +               reduce using rule 19 (expr -> if_expr .)
    CONCAT          reduce using rule 19 (expr -> if_expr .)
    $end            reduce using rule 19 (expr -> if_expr .)
    )               reduce using rule 19 (expr -> if_expr .)
    OF              reduce using rule 19 (expr -> if_expr .)
    THEN            reduce using rule 19 (expr -> if_expr .)
    END             reduce using rule 19 (expr -> if_expr .)
    ELIF            reduce using rule 19 (expr -> if_expr .)
    ELSE            reduce using rule 19 (expr -> if_expr .)
    ,               reduce using rule 19 (expr -> if_expr .)
    ]               reduce using rule 19 (expr -> if_expr .)


state 17

    (20) expr -> def_expr .
    NEWLINE         reduce using rule 20 (expr -> def_expr .)
    (               reduce using rule 20 (expr -> def_expr .)
    INT_DIV         reduce using rule 20 (expr -> def_expr .)
    EQUAL           reduce using rule 20 (expr -> def_expr .)
    NOT_EQUAL       reduce using rule 20 (expr -> def_expr .)
    |               reduce using rule 20 (expr -> def_expr .)
    >               reduce using rule 20 (expr -> def_expr .)
    %               reduce using rule 20 (expr -> def_expr .)
    <               reduce using rule 20 (expr -> def_expr .)
    *               reduce using rule 20 (expr -> def_expr .)
    /               reduce using rule 20 (expr -> def_expr .)
    -               reduce using rule 20 (expr -> def_expr .)
    +               reduce using rule 20 (expr -> def_expr .)
    CONCAT          reduce using rule 20 (expr -> def_expr .)
    $end            reduce using rule 20 (expr -> def_expr .)
    )               reduce using rule 20 (expr -> def_expr .)
    OF              reduce using rule 20 (expr -> def_expr .)
    THEN            reduce using rule 20 (expr -> def_expr .)
    END             reduce using rule 20 (expr -> def_expr .)
    ELIF            reduce using rule 20 (expr -> def_expr .)
    ELSE            reduce using rule 20 (expr -> def_expr .)
    ,               reduce using rule 20 (expr -> def_expr .)
    ]               reduce using rule 20 (expr -> def_expr .)


state 18

    (21) expr -> literal .
    NEWLINE         reduce using rule 21 (expr -> literal .)
    (               reduce using rule 21 (expr -> literal .)
    INT_DIV         reduce using rule 21 (expr -> literal .)
    EQUAL           reduce using rule 21 (expr -> literal .)
    NOT_EQUAL       reduce using rule 21 (expr -> literal .)
    |               reduce using rule 21 (expr -> literal .)
    >               reduce using rule 21 (expr -> literal .)
    %               reduce using rule 21 (expr -> literal .)
    <               reduce using rule 21 (expr -> literal .)
    *               reduce using rule 21 (expr -> literal .)
    /               reduce using rule 21 (expr -> literal .)
    -               reduce using rule 21 (expr -> literal .)
    +               reduce using rule 21 (expr -> literal .)
    CONCAT          reduce using rule 21 (expr -> literal .)
    $end            reduce using rule 21 (expr -> literal .)
    )               reduce using rule 21 (expr -> literal .)
    OF              reduce using rule 21 (expr -> literal .)
    THEN            reduce using rule 21 (expr -> literal .)
    END             reduce using rule 21 (expr -> literal .)
    ELIF            reduce using rule 21 (expr -> literal .)
    ELSE            reduce using rule 21 (expr -> literal .)
    ,               reduce using rule 21 (expr -> literal .)
    ]               reduce using rule 21 (expr -> literal .)


state 19

    (22) expr -> do .
    NEWLINE         reduce using rule 22 (expr -> do .)
    (               reduce using rule 22 (expr -> do .)
    INT_DIV         reduce using rule 22 (expr -> do .)
    EQUAL           reduce using rule 22 (expr -> do .)
    NOT_EQUAL       reduce using rule 22 (expr -> do .)
    |               reduce using rule 22 (expr -> do .)
    >               reduce using rule 22 (expr -> do .)
    %               reduce using rule 22 (expr -> do .)
    <               reduce using rule 22 (expr -> do .)
    *               reduce using rule 22 (expr -> do .)
    /               reduce using rule 22 (expr -> do .)
    -               reduce using rule 22 (expr -> do .)
    +               reduce using rule 22 (expr -> do .)
    CONCAT          reduce using rule 22 (expr -> do .)
    $end            reduce using rule 22 (expr -> do .)
    )               reduce using rule 22 (expr -> do .)
    OF              reduce using rule 22 (expr -> do .)
    THEN            reduce using rule 22 (expr -> do .)
    END             reduce using rule 22 (expr -> do .)
    ELIF            reduce using rule 22 (expr -> do .)
    ELSE            reduce using rule 22 (expr -> do .)
    ,               reduce using rule 22 (expr -> do .)
    ]               reduce using rule 22 (expr -> do .)


state 20

    (23) expr -> external .
    NEWLINE         reduce using rule 23 (expr -> external .)
    (               reduce using rule 23 (expr -> external .)
    INT_DIV         reduce using rule 23 (expr -> external .)
    EQUAL           reduce using rule 23 (expr -> external .)
    NOT_EQUAL       reduce using rule 23 (expr -> external .)
    |               reduce using rule 23 (expr -> external .)
    >               reduce using rule 23 (expr -> external .)
    %               reduce using rule 23 (expr -> external .)
    <               reduce using rule 23 (expr -> external .)
    *               reduce using rule 23 (expr -> external .)
    /               reduce using rule 23 (expr -> external .)
    -               reduce using rule 23 (expr -> external .)
    +               reduce using rule 23 (expr -> external .)
    CONCAT          reduce using rule 23 (expr -> external .)
    $end            reduce using rule 23 (expr -> external .)
    )               reduce using rule 23 (expr -> external .)
    OF              reduce using rule 23 (expr -> external .)
    THEN            reduce using rule 23 (expr -> external .)
    END             reduce using rule 23 (expr -> external .)
    ELIF            reduce using rule 23 (expr -> external .)
    ELSE            reduce using rule 23 (expr -> external .)
    ,               reduce using rule 23 (expr -> external .)
    ]               reduce using rule 23 (expr -> external .)


state 21

    (24) expr -> enum .
    NEWLINE         reduce using rule 24 (expr -> enum .)
    (               reduce using rule 24 (expr -> enum .)
    INT_DIV         reduce using rule 24 (expr -> enum .)
    EQUAL           reduce using rule 24 (expr -> enum .)
    NOT_EQUAL       reduce using rule 24 (expr -> enum .)
    |               reduce using rule 24 (expr -> enum .)
    >               reduce using rule 24 (expr -> enum .)
    %               reduce using rule 24 (expr -> enum .)
    <               reduce using rule 24 (expr -> enum .)
    *               reduce using rule 24 (expr -> enum .)
    /               reduce using rule 24 (expr -> enum .)
    -               reduce using rule 24 (expr -> enum .)
    +               reduce using rule 24 (expr -> enum .)
    CONCAT          reduce using rule 24 (expr -> enum .)
    $end            reduce using rule 24 (expr -> enum .)
    )               reduce using rule 24 (expr -> enum .)
    OF              reduce using rule 24 (expr -> enum .)
    THEN            reduce using rule 24 (expr -> enum .)
    END             reduce using rule 24 (expr -> enum .)
    ELIF            reduce using rule 24 (expr -> enum .)
    ELSE            reduce using rule 24 (expr -> enum .)
    ,               reduce using rule 24 (expr -> enum .)
    ]               reduce using rule 24 (expr -> enum .)


state 22

    (148) array -> [ . _39_optional _40_optional ]
    (149) _39_optional -> . NEWLINE
    (150) _39_optional -> .
    NEWLINE         shift and go to state 54
    -               reduce using rule 150 (_39_optional -> .)
    (               reduce using rule 150 (_39_optional -> .)
    [               reduce using rule 150 (_39_optional -> .)
    IDENTIFIER      reduce using rule 150 (_39_optional -> .)
    CASE            reduce using rule 150 (_39_optional -> .)
    IF              reduce using rule 150 (_39_optional -> .)
    DEF             reduce using rule 150 (_39_optional -> .)
    STRING          reduce using rule 150 (_39_optional -> .)
    NUMBER          reduce using rule 150 (_39_optional -> .)
    DO              reduce using rule 150 (_39_optional -> .)
    EXTERNAL        reduce using rule 150 (_39_optional -> .)
    ENUM            reduce using rule 150 (_39_optional -> .)
    TYPE_IDENTIFIER reduce using rule 150 (_39_optional -> .)
    ]               reduce using rule 150 (_39_optional -> .)

    _39_optional                   shift and go to state 53

state 23

    (158) variant_call -> type_identifier . ( _43_optional _44_optional )
    (               shift and go to state 55


state 24

    (171) identifier -> IDENTIFIER .
    :               reduce using rule 171 (identifier -> IDENTIFIER .)
    =               reduce using rule 171 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 171 (identifier -> IDENTIFIER .)
    (               reduce using rule 171 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 171 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 171 (identifier -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 171 (identifier -> IDENTIFIER .)
    |               reduce using rule 171 (identifier -> IDENTIFIER .)
    >               reduce using rule 171 (identifier -> IDENTIFIER .)
    %               reduce using rule 171 (identifier -> IDENTIFIER .)
    <               reduce using rule 171 (identifier -> IDENTIFIER .)
    *               reduce using rule 171 (identifier -> IDENTIFIER .)
    /               reduce using rule 171 (identifier -> IDENTIFIER .)
    -               reduce using rule 171 (identifier -> IDENTIFIER .)
    +               reduce using rule 171 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 171 (identifier -> IDENTIFIER .)
    $end            reduce using rule 171 (identifier -> IDENTIFIER .)
    )               reduce using rule 171 (identifier -> IDENTIFIER .)
    OF              reduce using rule 171 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 171 (identifier -> IDENTIFIER .)
    END             reduce using rule 171 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 171 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 171 (identifier -> IDENTIFIER .)
    ,               reduce using rule 171 (identifier -> IDENTIFIER .)
    ]               reduce using rule 171 (identifier -> IDENTIFIER .)
    DO              reduce using rule 171 (identifier -> IDENTIFIER .)


state 25

    (120) case_of -> CASE . expr OF _30_optional _31_optional END
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 56
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 26

    (111) if_expr -> IF . expr THEN _27_optional block_statement _28_optional END
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 57
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 27

    (46) def_expr -> DEF . identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> DEF . identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (171) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 58

state 28

    (176) literal -> STRING .
    NEWLINE         reduce using rule 176 (literal -> STRING .)
    (               reduce using rule 176 (literal -> STRING .)
    INT_DIV         reduce using rule 176 (literal -> STRING .)
    EQUAL           reduce using rule 176 (literal -> STRING .)
    NOT_EQUAL       reduce using rule 176 (literal -> STRING .)
    |               reduce using rule 176 (literal -> STRING .)
    >               reduce using rule 176 (literal -> STRING .)
    %               reduce using rule 176 (literal -> STRING .)
    <               reduce using rule 176 (literal -> STRING .)
    *               reduce using rule 176 (literal -> STRING .)
    /               reduce using rule 176 (literal -> STRING .)
    -               reduce using rule 176 (literal -> STRING .)
    +               reduce using rule 176 (literal -> STRING .)
    CONCAT          reduce using rule 176 (literal -> STRING .)
    $end            reduce using rule 176 (literal -> STRING .)
    )               reduce using rule 176 (literal -> STRING .)
    OF              reduce using rule 176 (literal -> STRING .)
    THEN            reduce using rule 176 (literal -> STRING .)
    END             reduce using rule 176 (literal -> STRING .)
    ELIF            reduce using rule 176 (literal -> STRING .)
    ELSE            reduce using rule 176 (literal -> STRING .)
    ,               reduce using rule 176 (literal -> STRING .)
    ]               reduce using rule 176 (literal -> STRING .)


state 29

    (177) literal -> NUMBER .
    NEWLINE         reduce using rule 177 (literal -> NUMBER .)
    (               reduce using rule 177 (literal -> NUMBER .)
    INT_DIV         reduce using rule 177 (literal -> NUMBER .)
    EQUAL           reduce using rule 177 (literal -> NUMBER .)
    NOT_EQUAL       reduce using rule 177 (literal -> NUMBER .)
    |               reduce using rule 177 (literal -> NUMBER .)
    >               reduce using rule 177 (literal -> NUMBER .)
    %               reduce using rule 177 (literal -> NUMBER .)
    <               reduce using rule 177 (literal -> NUMBER .)
    *               reduce using rule 177 (literal -> NUMBER .)
    /               reduce using rule 177 (literal -> NUMBER .)
    -               reduce using rule 177 (literal -> NUMBER .)
    +               reduce using rule 177 (literal -> NUMBER .)
    CONCAT          reduce using rule 177 (literal -> NUMBER .)
    $end            reduce using rule 177 (literal -> NUMBER .)
    )               reduce using rule 177 (literal -> NUMBER .)
    OF              reduce using rule 177 (literal -> NUMBER .)
    THEN            reduce using rule 177 (literal -> NUMBER .)
    END             reduce using rule 177 (literal -> NUMBER .)
    ELIF            reduce using rule 177 (literal -> NUMBER .)
    ELSE            reduce using rule 177 (literal -> NUMBER .)
    ,               reduce using rule 177 (literal -> NUMBER .)
    ]               reduce using rule 177 (literal -> NUMBER .)


state 30

    (38) do -> DO . _4_optional block_statement END
    (39) _4_optional -> . : type
    (40) _4_optional -> .
    :               shift and go to state 60
    NEWLINE         reduce using rule 40 (_4_optional -> .)
    END             reduce using rule 40 (_4_optional -> .)
    -               reduce using rule 40 (_4_optional -> .)
    (               reduce using rule 40 (_4_optional -> .)
    [               reduce using rule 40 (_4_optional -> .)
    IDENTIFIER      reduce using rule 40 (_4_optional -> .)
    CASE            reduce using rule 40 (_4_optional -> .)
    IF              reduce using rule 40 (_4_optional -> .)
    DEF             reduce using rule 40 (_4_optional -> .)
    STRING          reduce using rule 40 (_4_optional -> .)
    NUMBER          reduce using rule 40 (_4_optional -> .)
    DO              reduce using rule 40 (_4_optional -> .)
    EXTERNAL        reduce using rule 40 (_4_optional -> .)
    ENUM            reduce using rule 40 (_4_optional -> .)
    TYPE_IDENTIFIER reduce using rule 40 (_4_optional -> .)

    _4_optional                    shift and go to state 59

state 31

    (25) external -> EXTERNAL .
    NEWLINE         reduce using rule 25 (external -> EXTERNAL .)
    (               reduce using rule 25 (external -> EXTERNAL .)
    INT_DIV         reduce using rule 25 (external -> EXTERNAL .)
    EQUAL           reduce using rule 25 (external -> EXTERNAL .)
    NOT_EQUAL       reduce using rule 25 (external -> EXTERNAL .)
    |               reduce using rule 25 (external -> EXTERNAL .)
    >               reduce using rule 25 (external -> EXTERNAL .)
    %               reduce using rule 25 (external -> EXTERNAL .)
    <               reduce using rule 25 (external -> EXTERNAL .)
    *               reduce using rule 25 (external -> EXTERNAL .)
    /               reduce using rule 25 (external -> EXTERNAL .)
    -               reduce using rule 25 (external -> EXTERNAL .)
    +               reduce using rule 25 (external -> EXTERNAL .)
    CONCAT          reduce using rule 25 (external -> EXTERNAL .)
    $end            reduce using rule 25 (external -> EXTERNAL .)
    )               reduce using rule 25 (external -> EXTERNAL .)
    OF              reduce using rule 25 (external -> EXTERNAL .)
    THEN            reduce using rule 25 (external -> EXTERNAL .)
    END             reduce using rule 25 (external -> EXTERNAL .)
    ELIF            reduce using rule 25 (external -> EXTERNAL .)
    ELSE            reduce using rule 25 (external -> EXTERNAL .)
    ,               reduce using rule 25 (external -> EXTERNAL .)
    ]               reduce using rule 25 (external -> EXTERNAL .)


state 32

    (80) enum -> ENUM . type_identifier { _18_optional _19_optional }
    (85) enum -> ENUM . type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 61

state 33

    (172) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 172 (type_identifier -> TYPE_IDENTIFIER .)


state 34

    (6) do_exprs -> expr _3_optional .
    $end            reduce using rule 6 (do_exprs -> expr _3_optional .)
    END             reduce using rule 6 (do_exprs -> expr _3_optional .)
    ELIF            reduce using rule 6 (do_exprs -> expr _3_optional .)
    ELSE            reduce using rule 6 (do_exprs -> expr _3_optional .)


state 35

    (9) do_exprs -> expr NEWLINE . do_exprs
    (7) _3_optional -> NEWLINE .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 7 (_3_optional -> NEWLINE .)
    END             reduce using rule 7 (_3_optional -> NEWLINE .)
    ELIF            reduce using rule 7 (_3_optional -> NEWLINE .)
    ELSE            reduce using rule 7 (_3_optional -> NEWLINE .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 6
    do_exprs                       shift and go to state 62
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 36

    (153) call -> expr ( . _41_optional _42_optional )
    (154) _41_optional -> . NEWLINE
    (155) _41_optional -> .
    NEWLINE         shift and go to state 64
    -               reduce using rule 155 (_41_optional -> .)
    (               reduce using rule 155 (_41_optional -> .)
    [               reduce using rule 155 (_41_optional -> .)
    IDENTIFIER      reduce using rule 155 (_41_optional -> .)
    CASE            reduce using rule 155 (_41_optional -> .)
    IF              reduce using rule 155 (_41_optional -> .)
    DEF             reduce using rule 155 (_41_optional -> .)
    STRING          reduce using rule 155 (_41_optional -> .)
    NUMBER          reduce using rule 155 (_41_optional -> .)
    DO              reduce using rule 155 (_41_optional -> .)
    EXTERNAL        reduce using rule 155 (_41_optional -> .)
    ENUM            reduce using rule 155 (_41_optional -> .)
    TYPE_IDENTIFIER reduce using rule 155 (_41_optional -> .)
    )               reduce using rule 155 (_41_optional -> .)

    _41_optional                   shift and go to state 63

state 37

    (26) binary_expr -> expr INT_DIV . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 65
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 38

    (27) binary_expr -> expr EQUAL . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 66
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 39

    (28) binary_expr -> expr NOT_EQUAL . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 67
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 40

    (29) binary_expr -> expr | . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 68
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 41

    (30) binary_expr -> expr > . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 69
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 42

    (31) binary_expr -> expr % . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 70
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 43

    (32) binary_expr -> expr < . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 71
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 44

    (33) binary_expr -> expr * . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 72
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 45

    (34) binary_expr -> expr / . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 73
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 46

    (35) binary_expr -> expr - . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 74
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 47

    (36) binary_expr -> expr + . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 75
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 48

    (37) binary_expr -> expr CONCAT . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 76
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 49

    (10) expr -> - expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 10 (expr -> - expr .)
    INT_DIV         reduce using rule 10 (expr -> - expr .)
    EQUAL           reduce using rule 10 (expr -> - expr .)
    NOT_EQUAL       reduce using rule 10 (expr -> - expr .)
    |               reduce using rule 10 (expr -> - expr .)
    >               reduce using rule 10 (expr -> - expr .)
    %               reduce using rule 10 (expr -> - expr .)
    <               reduce using rule 10 (expr -> - expr .)
    *               reduce using rule 10 (expr -> - expr .)
    /               reduce using rule 10 (expr -> - expr .)
    -               reduce using rule 10 (expr -> - expr .)
    +               reduce using rule 10 (expr -> - expr .)
    CONCAT          reduce using rule 10 (expr -> - expr .)
    $end            reduce using rule 10 (expr -> - expr .)
    )               reduce using rule 10 (expr -> - expr .)
    OF              reduce using rule 10 (expr -> - expr .)
    THEN            reduce using rule 10 (expr -> - expr .)
    END             reduce using rule 10 (expr -> - expr .)
    ELIF            reduce using rule 10 (expr -> - expr .)
    ELSE            reduce using rule 10 (expr -> - expr .)
    ,               reduce using rule 10 (expr -> - expr .)
    ]               reduce using rule 10 (expr -> - expr .)
    (               shift and go to state 36


state 50

    (11) expr -> ( expr . )
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    )               shift and go to state 77
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 51

    (173) variable_declaration -> identifier _48_optional . = expr
    =               shift and go to state 78


state 52

    (174) _48_optional -> : . type
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 79
    type_identifier                shift and go to state 80

state 53

    (148) array -> [ _39_optional . _40_optional ]
    (151) _40_optional -> . exprs
    (152) _40_optional -> .
    (163) exprs -> . expr _45_optional
    (166) exprs -> . exprs , _46_optional expr _47_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    ]               reduce using rule 152 (_40_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _40_optional                   shift and go to state 81
    exprs                          shift and go to state 82
    expr                           shift and go to state 83
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 54

    (149) _39_optional -> NEWLINE .
    -               reduce using rule 149 (_39_optional -> NEWLINE .)
    (               reduce using rule 149 (_39_optional -> NEWLINE .)
    [               reduce using rule 149 (_39_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 149 (_39_optional -> NEWLINE .)
    CASE            reduce using rule 149 (_39_optional -> NEWLINE .)
    IF              reduce using rule 149 (_39_optional -> NEWLINE .)
    DEF             reduce using rule 149 (_39_optional -> NEWLINE .)
    STRING          reduce using rule 149 (_39_optional -> NEWLINE .)
    NUMBER          reduce using rule 149 (_39_optional -> NEWLINE .)
    DO              reduce using rule 149 (_39_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 149 (_39_optional -> NEWLINE .)
    ENUM            reduce using rule 149 (_39_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 149 (_39_optional -> NEWLINE .)
    ]               reduce using rule 149 (_39_optional -> NEWLINE .)


state 55

    (158) variant_call -> type_identifier ( . _43_optional _44_optional )
    (159) _43_optional -> . NEWLINE
    (160) _43_optional -> .
    NEWLINE         shift and go to state 85
    -               reduce using rule 160 (_43_optional -> .)
    (               reduce using rule 160 (_43_optional -> .)
    [               reduce using rule 160 (_43_optional -> .)
    IDENTIFIER      reduce using rule 160 (_43_optional -> .)
    CASE            reduce using rule 160 (_43_optional -> .)
    IF              reduce using rule 160 (_43_optional -> .)
    DEF             reduce using rule 160 (_43_optional -> .)
    STRING          reduce using rule 160 (_43_optional -> .)
    NUMBER          reduce using rule 160 (_43_optional -> .)
    DO              reduce using rule 160 (_43_optional -> .)
    EXTERNAL        reduce using rule 160 (_43_optional -> .)
    ENUM            reduce using rule 160 (_43_optional -> .)
    TYPE_IDENTIFIER reduce using rule 160 (_43_optional -> .)
    )               reduce using rule 160 (_43_optional -> .)

    _43_optional                   shift and go to state 84

state 56

    (120) case_of -> CASE expr . OF _30_optional _31_optional END
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 86
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 57

    (111) if_expr -> IF expr . THEN _27_optional block_statement _28_optional END
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 87
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 58

    (46) def_expr -> DEF identifier . ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> DEF identifier . < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (               shift and go to state 88
    <               shift and go to state 89


state 59

    (38) do -> DO _4_optional . block_statement END
    (41) block_statement -> . _5_optional _6_optional
    (42) _5_optional -> . NEWLINE
    (43) _5_optional -> .
    NEWLINE         shift and go to state 92
    -               reduce using rule 43 (_5_optional -> .)
    (               reduce using rule 43 (_5_optional -> .)
    [               reduce using rule 43 (_5_optional -> .)
    IDENTIFIER      reduce using rule 43 (_5_optional -> .)
    CASE            reduce using rule 43 (_5_optional -> .)
    IF              reduce using rule 43 (_5_optional -> .)
    DEF             reduce using rule 43 (_5_optional -> .)
    STRING          reduce using rule 43 (_5_optional -> .)
    NUMBER          reduce using rule 43 (_5_optional -> .)
    DO              reduce using rule 43 (_5_optional -> .)
    EXTERNAL        reduce using rule 43 (_5_optional -> .)
    ENUM            reduce using rule 43 (_5_optional -> .)
    TYPE_IDENTIFIER reduce using rule 43 (_5_optional -> .)
    END             reduce using rule 43 (_5_optional -> .)

    block_statement                shift and go to state 90
    _5_optional                    shift and go to state 91

state 60

    (39) _4_optional -> : . type
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 93
    type_identifier                shift and go to state 80

state 61

    (80) enum -> ENUM type_identifier . { _18_optional _19_optional }
    (85) enum -> ENUM type_identifier . < type_identifier _20_repeat > { _21_optional _22_optional }
    {               shift and go to state 94
    <               shift and go to state 95


state 62

    (9) do_exprs -> expr NEWLINE do_exprs .
    $end            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    END             reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELIF            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELSE            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)


state 63

    (153) call -> expr ( _41_optional . _42_optional )
    (156) _42_optional -> . exprs
    (157) _42_optional -> .
    (163) exprs -> . expr _45_optional
    (166) exprs -> . exprs , _46_optional expr _47_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 157 (_42_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 83
    _42_optional                   shift and go to state 96
    exprs                          shift and go to state 97
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 64

    (154) _41_optional -> NEWLINE .
    -               reduce using rule 154 (_41_optional -> NEWLINE .)
    (               reduce using rule 154 (_41_optional -> NEWLINE .)
    [               reduce using rule 154 (_41_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 154 (_41_optional -> NEWLINE .)
    CASE            reduce using rule 154 (_41_optional -> NEWLINE .)
    IF              reduce using rule 154 (_41_optional -> NEWLINE .)
    DEF             reduce using rule 154 (_41_optional -> NEWLINE .)
    STRING          reduce using rule 154 (_41_optional -> NEWLINE .)
    NUMBER          reduce using rule 154 (_41_optional -> NEWLINE .)
    DO              reduce using rule 154 (_41_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 154 (_41_optional -> NEWLINE .)
    ENUM            reduce using rule 154 (_41_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 154 (_41_optional -> NEWLINE .)
    )               reduce using rule 154 (_41_optional -> NEWLINE .)


state 65

    (26) binary_expr -> expr INT_DIV expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    INT_DIV         reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    EQUAL           reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    NOT_EQUAL       reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    |               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    %               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    (               shift and go to state 36


state 66

    (27) binary_expr -> expr EQUAL expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    $end            reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    )               reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    OF              reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    THEN            reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    END             reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    ,               reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    ]               reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 67

    (28) binary_expr -> expr NOT_EQUAL expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    END             reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    ]               reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 68

    (29) binary_expr -> expr | expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 29 (binary_expr -> expr | expr .)
    EQUAL           reduce using rule 29 (binary_expr -> expr | expr .)
    NOT_EQUAL       reduce using rule 29 (binary_expr -> expr | expr .)
    |               reduce using rule 29 (binary_expr -> expr | expr .)
    >               reduce using rule 29 (binary_expr -> expr | expr .)
    <               reduce using rule 29 (binary_expr -> expr | expr .)
    -               reduce using rule 29 (binary_expr -> expr | expr .)
    +               reduce using rule 29 (binary_expr -> expr | expr .)
    CONCAT          reduce using rule 29 (binary_expr -> expr | expr .)
    $end            reduce using rule 29 (binary_expr -> expr | expr .)
    )               reduce using rule 29 (binary_expr -> expr | expr .)
    OF              reduce using rule 29 (binary_expr -> expr | expr .)
    THEN            reduce using rule 29 (binary_expr -> expr | expr .)
    END             reduce using rule 29 (binary_expr -> expr | expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr | expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr | expr .)
    ,               reduce using rule 29 (binary_expr -> expr | expr .)
    ]               reduce using rule 29 (binary_expr -> expr | expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45


state 69

    (30) binary_expr -> expr > expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 30 (binary_expr -> expr > expr .)
    EQUAL           reduce using rule 30 (binary_expr -> expr > expr .)
    NOT_EQUAL       reduce using rule 30 (binary_expr -> expr > expr .)
    >               reduce using rule 30 (binary_expr -> expr > expr .)
    <               reduce using rule 30 (binary_expr -> expr > expr .)
    $end            reduce using rule 30 (binary_expr -> expr > expr .)
    )               reduce using rule 30 (binary_expr -> expr > expr .)
    OF              reduce using rule 30 (binary_expr -> expr > expr .)
    THEN            reduce using rule 30 (binary_expr -> expr > expr .)
    END             reduce using rule 30 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr > expr .)
    ,               reduce using rule 30 (binary_expr -> expr > expr .)
    ]               reduce using rule 30 (binary_expr -> expr > expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    |               shift and go to state 40
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 70

    (31) binary_expr -> expr % expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 31 (binary_expr -> expr % expr .)
    INT_DIV         reduce using rule 31 (binary_expr -> expr % expr .)
    EQUAL           reduce using rule 31 (binary_expr -> expr % expr .)
    NOT_EQUAL       reduce using rule 31 (binary_expr -> expr % expr .)
    |               reduce using rule 31 (binary_expr -> expr % expr .)
    >               reduce using rule 31 (binary_expr -> expr % expr .)
    %               reduce using rule 31 (binary_expr -> expr % expr .)
    <               reduce using rule 31 (binary_expr -> expr % expr .)
    *               reduce using rule 31 (binary_expr -> expr % expr .)
    /               reduce using rule 31 (binary_expr -> expr % expr .)
    -               reduce using rule 31 (binary_expr -> expr % expr .)
    +               reduce using rule 31 (binary_expr -> expr % expr .)
    CONCAT          reduce using rule 31 (binary_expr -> expr % expr .)
    $end            reduce using rule 31 (binary_expr -> expr % expr .)
    )               reduce using rule 31 (binary_expr -> expr % expr .)
    OF              reduce using rule 31 (binary_expr -> expr % expr .)
    THEN            reduce using rule 31 (binary_expr -> expr % expr .)
    END             reduce using rule 31 (binary_expr -> expr % expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr % expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr % expr .)
    ,               reduce using rule 31 (binary_expr -> expr % expr .)
    ]               reduce using rule 31 (binary_expr -> expr % expr .)
    (               shift and go to state 36


state 71

    (32) binary_expr -> expr < expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 32 (binary_expr -> expr < expr .)
    EQUAL           reduce using rule 32 (binary_expr -> expr < expr .)
    NOT_EQUAL       reduce using rule 32 (binary_expr -> expr < expr .)
    >               reduce using rule 32 (binary_expr -> expr < expr .)
    <               reduce using rule 32 (binary_expr -> expr < expr .)
    $end            reduce using rule 32 (binary_expr -> expr < expr .)
    )               reduce using rule 32 (binary_expr -> expr < expr .)
    OF              reduce using rule 32 (binary_expr -> expr < expr .)
    THEN            reduce using rule 32 (binary_expr -> expr < expr .)
    END             reduce using rule 32 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr < expr .)
    ,               reduce using rule 32 (binary_expr -> expr < expr .)
    ]               reduce using rule 32 (binary_expr -> expr < expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    |               shift and go to state 40
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 72

    (33) binary_expr -> expr * expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 33 (binary_expr -> expr * expr .)
    INT_DIV         reduce using rule 33 (binary_expr -> expr * expr .)
    EQUAL           reduce using rule 33 (binary_expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 33 (binary_expr -> expr * expr .)
    |               reduce using rule 33 (binary_expr -> expr * expr .)
    >               reduce using rule 33 (binary_expr -> expr * expr .)
    %               reduce using rule 33 (binary_expr -> expr * expr .)
    <               reduce using rule 33 (binary_expr -> expr * expr .)
    *               reduce using rule 33 (binary_expr -> expr * expr .)
    /               reduce using rule 33 (binary_expr -> expr * expr .)
    -               reduce using rule 33 (binary_expr -> expr * expr .)
    +               reduce using rule 33 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 33 (binary_expr -> expr * expr .)
    $end            reduce using rule 33 (binary_expr -> expr * expr .)
    )               reduce using rule 33 (binary_expr -> expr * expr .)
    OF              reduce using rule 33 (binary_expr -> expr * expr .)
    THEN            reduce using rule 33 (binary_expr -> expr * expr .)
    END             reduce using rule 33 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr * expr .)
    ,               reduce using rule 33 (binary_expr -> expr * expr .)
    ]               reduce using rule 33 (binary_expr -> expr * expr .)
    (               shift and go to state 36


state 73

    (34) binary_expr -> expr / expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 34 (binary_expr -> expr / expr .)
    INT_DIV         reduce using rule 34 (binary_expr -> expr / expr .)
    EQUAL           reduce using rule 34 (binary_expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 34 (binary_expr -> expr / expr .)
    |               reduce using rule 34 (binary_expr -> expr / expr .)
    >               reduce using rule 34 (binary_expr -> expr / expr .)
    %               reduce using rule 34 (binary_expr -> expr / expr .)
    <               reduce using rule 34 (binary_expr -> expr / expr .)
    *               reduce using rule 34 (binary_expr -> expr / expr .)
    /               reduce using rule 34 (binary_expr -> expr / expr .)
    -               reduce using rule 34 (binary_expr -> expr / expr .)
    +               reduce using rule 34 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr / expr .)
    $end            reduce using rule 34 (binary_expr -> expr / expr .)
    )               reduce using rule 34 (binary_expr -> expr / expr .)
    OF              reduce using rule 34 (binary_expr -> expr / expr .)
    THEN            reduce using rule 34 (binary_expr -> expr / expr .)
    END             reduce using rule 34 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr / expr .)
    ,               reduce using rule 34 (binary_expr -> expr / expr .)
    ]               reduce using rule 34 (binary_expr -> expr / expr .)
    (               shift and go to state 36


state 74

    (35) binary_expr -> expr - expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 35 (binary_expr -> expr - expr .)
    EQUAL           reduce using rule 35 (binary_expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 35 (binary_expr -> expr - expr .)
    |               reduce using rule 35 (binary_expr -> expr - expr .)
    >               reduce using rule 35 (binary_expr -> expr - expr .)
    <               reduce using rule 35 (binary_expr -> expr - expr .)
    -               reduce using rule 35 (binary_expr -> expr - expr .)
    +               reduce using rule 35 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 35 (binary_expr -> expr - expr .)
    $end            reduce using rule 35 (binary_expr -> expr - expr .)
    )               reduce using rule 35 (binary_expr -> expr - expr .)
    OF              reduce using rule 35 (binary_expr -> expr - expr .)
    THEN            reduce using rule 35 (binary_expr -> expr - expr .)
    END             reduce using rule 35 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr - expr .)
    ,               reduce using rule 35 (binary_expr -> expr - expr .)
    ]               reduce using rule 35 (binary_expr -> expr - expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45


state 75

    (36) binary_expr -> expr + expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 36 (binary_expr -> expr + expr .)
    EQUAL           reduce using rule 36 (binary_expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 36 (binary_expr -> expr + expr .)
    |               reduce using rule 36 (binary_expr -> expr + expr .)
    >               reduce using rule 36 (binary_expr -> expr + expr .)
    <               reduce using rule 36 (binary_expr -> expr + expr .)
    -               reduce using rule 36 (binary_expr -> expr + expr .)
    +               reduce using rule 36 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 36 (binary_expr -> expr + expr .)
    $end            reduce using rule 36 (binary_expr -> expr + expr .)
    )               reduce using rule 36 (binary_expr -> expr + expr .)
    OF              reduce using rule 36 (binary_expr -> expr + expr .)
    THEN            reduce using rule 36 (binary_expr -> expr + expr .)
    END             reduce using rule 36 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 36 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 36 (binary_expr -> expr + expr .)
    ,               reduce using rule 36 (binary_expr -> expr + expr .)
    ]               reduce using rule 36 (binary_expr -> expr + expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45


state 76

    (37) binary_expr -> expr CONCAT expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    EQUAL           reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    NOT_EQUAL       reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    |               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    -               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    +               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45


state 77

    (11) expr -> ( expr ) .
    NEWLINE         reduce using rule 11 (expr -> ( expr ) .)
    (               reduce using rule 11 (expr -> ( expr ) .)
    INT_DIV         reduce using rule 11 (expr -> ( expr ) .)
    EQUAL           reduce using rule 11 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 11 (expr -> ( expr ) .)
    |               reduce using rule 11 (expr -> ( expr ) .)
    >               reduce using rule 11 (expr -> ( expr ) .)
    %               reduce using rule 11 (expr -> ( expr ) .)
    <               reduce using rule 11 (expr -> ( expr ) .)
    *               reduce using rule 11 (expr -> ( expr ) .)
    /               reduce using rule 11 (expr -> ( expr ) .)
    -               reduce using rule 11 (expr -> ( expr ) .)
    +               reduce using rule 11 (expr -> ( expr ) .)
    CONCAT          reduce using rule 11 (expr -> ( expr ) .)
    $end            reduce using rule 11 (expr -> ( expr ) .)
    )               reduce using rule 11 (expr -> ( expr ) .)
    OF              reduce using rule 11 (expr -> ( expr ) .)
    THEN            reduce using rule 11 (expr -> ( expr ) .)
    END             reduce using rule 11 (expr -> ( expr ) .)
    ELIF            reduce using rule 11 (expr -> ( expr ) .)
    ELSE            reduce using rule 11 (expr -> ( expr ) .)
    ,               reduce using rule 11 (expr -> ( expr ) .)
    ]               reduce using rule 11 (expr -> ( expr ) .)


state 78

    (173) variable_declaration -> identifier _48_optional = . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    identifier                     shift and go to state 11
    expr                           shift and go to state 98
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 79

    (174) _48_optional -> : type .
    =               reduce using rule 174 (_48_optional -> : type .)


state 80

    (73) type -> type_identifier . < type _17_repeat >
    (79) type -> type_identifier .
    <               shift and go to state 99
    =               reduce using rule 79 (type -> type_identifier .)
    NEWLINE         reduce using rule 79 (type -> type_identifier .)
    END             reduce using rule 79 (type -> type_identifier .)
    -               reduce using rule 79 (type -> type_identifier .)
    (               reduce using rule 79 (type -> type_identifier .)
    [               reduce using rule 79 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 79 (type -> type_identifier .)
    CASE            reduce using rule 79 (type -> type_identifier .)
    IF              reduce using rule 79 (type -> type_identifier .)
    DEF             reduce using rule 79 (type -> type_identifier .)
    STRING          reduce using rule 79 (type -> type_identifier .)
    NUMBER          reduce using rule 79 (type -> type_identifier .)
    DO              reduce using rule 79 (type -> type_identifier .)
    EXTERNAL        reduce using rule 79 (type -> type_identifier .)
    ENUM            reduce using rule 79 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 79 (type -> type_identifier .)
    ,               reduce using rule 79 (type -> type_identifier .)
    >               reduce using rule 79 (type -> type_identifier .)
    ELIF            reduce using rule 79 (type -> type_identifier .)
    ELSE            reduce using rule 79 (type -> type_identifier .)
    )               reduce using rule 79 (type -> type_identifier .)


state 81

    (148) array -> [ _39_optional _40_optional . ]
    ]               shift and go to state 100


state 82

    (151) _40_optional -> exprs .
    (166) exprs -> exprs . , _46_optional expr _47_optional
    ]               reduce using rule 151 (_40_optional -> exprs .)
    ,               shift and go to state 101


state 83

    (163) exprs -> expr . _45_optional
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    (164) _45_optional -> . NEWLINE
    (165) _45_optional -> .
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48
    NEWLINE         shift and go to state 103
    ,               reduce using rule 165 (_45_optional -> .)
    ]               reduce using rule 165 (_45_optional -> .)
    )               reduce using rule 165 (_45_optional -> .)

    _45_optional                   shift and go to state 102

state 84

    (158) variant_call -> type_identifier ( _43_optional . _44_optional )
    (161) _44_optional -> . exprs
    (162) _44_optional -> .
    (163) exprs -> . expr _45_optional
    (166) exprs -> . exprs , _46_optional expr _47_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 162 (_44_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 23
    _44_optional                   shift and go to state 104
    exprs                          shift and go to state 105
    expr                           shift and go to state 83
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21

state 85

    (159) _43_optional -> NEWLINE .
    -               reduce using rule 159 (_43_optional -> NEWLINE .)
    (               reduce using rule 159 (_43_optional -> NEWLINE .)
    [               reduce using rule 159 (_43_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 159 (_43_optional -> NEWLINE .)
    CASE            reduce using rule 159 (_43_optional -> NEWLINE .)
    IF              reduce using rule 159 (_43_optional -> NEWLINE .)
    DEF             reduce using rule 159 (_43_optional -> NEWLINE .)
    STRING          reduce using rule 159 (_43_optional -> NEWLINE .)
    NUMBER          reduce using rule 159 (_43_optional -> NEWLINE .)
    DO              reduce using rule 159 (_43_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 159 (_43_optional -> NEWLINE .)
    ENUM            reduce using rule 159 (_43_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 159 (_43_optional -> NEWLINE .)
    )               reduce using rule 159 (_43_optional -> NEWLINE .)


state 86

    (120) case_of -> CASE expr OF . _30_optional _31_optional END
    (121) _30_optional -> . NEWLINE
    (122) _30_optional -> .
    NEWLINE         shift and go to state 107
    TYPE_IDENTIFIER reduce using rule 122 (_30_optional -> .)
    IDENTIFIER      reduce using rule 122 (_30_optional -> .)
    END             reduce using rule 122 (_30_optional -> .)

    _30_optional                   shift and go to state 106

state 87

    (111) if_expr -> IF expr THEN . _27_optional block_statement _28_optional END
    (112) _27_optional -> . : type
    (113) _27_optional -> .
    :               shift and go to state 109
    NEWLINE         reduce using rule 113 (_27_optional -> .)
    ELIF            reduce using rule 113 (_27_optional -> .)
    ELSE            reduce using rule 113 (_27_optional -> .)
    END             reduce using rule 113 (_27_optional -> .)
    -               reduce using rule 113 (_27_optional -> .)
    (               reduce using rule 113 (_27_optional -> .)
    [               reduce using rule 113 (_27_optional -> .)
    IDENTIFIER      reduce using rule 113 (_27_optional -> .)
    CASE            reduce using rule 113 (_27_optional -> .)
    IF              reduce using rule 113 (_27_optional -> .)
    DEF             reduce using rule 113 (_27_optional -> .)
    STRING          reduce using rule 113 (_27_optional -> .)
    NUMBER          reduce using rule 113 (_27_optional -> .)
    DO              reduce using rule 113 (_27_optional -> .)
    EXTERNAL        reduce using rule 113 (_27_optional -> .)
    ENUM            reduce using rule 113 (_27_optional -> .)
    TYPE_IDENTIFIER reduce using rule 113 (_27_optional -> .)

    _27_optional                   shift and go to state 108

state 88

    (46) def_expr -> DEF identifier ( . _7_optional _8_optional ) _9_optional do
    (47) _7_optional -> . NEWLINE
    (48) _7_optional -> .
    NEWLINE         shift and go to state 111
    IDENTIFIER      reduce using rule 48 (_7_optional -> .)
    )               reduce using rule 48 (_7_optional -> .)

    _7_optional                    shift and go to state 110

state 89

    (53) def_expr -> DEF identifier < . type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 112

state 90

    (38) do -> DO _4_optional block_statement . END
    END             shift and go to state 113


state 91

    (41) block_statement -> _5_optional . _6_optional
    (44) _6_optional -> . do_exprs
    (45) _6_optional -> .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 45 (_6_optional -> .)
    ELIF            reduce using rule 45 (_6_optional -> .)
    ELSE            reduce using rule 45 (_6_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _6_optional                    shift and go to state 114
    do_exprs                       shift and go to state 115
    expr                           shift and go to state 6
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 92

    (42) _5_optional -> NEWLINE .
    -               reduce using rule 42 (_5_optional -> NEWLINE .)
    (               reduce using rule 42 (_5_optional -> NEWLINE .)
    [               reduce using rule 42 (_5_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 42 (_5_optional -> NEWLINE .)
    CASE            reduce using rule 42 (_5_optional -> NEWLINE .)
    IF              reduce using rule 42 (_5_optional -> NEWLINE .)
    DEF             reduce using rule 42 (_5_optional -> NEWLINE .)
    STRING          reduce using rule 42 (_5_optional -> NEWLINE .)
    NUMBER          reduce using rule 42 (_5_optional -> NEWLINE .)
    DO              reduce using rule 42 (_5_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 42 (_5_optional -> NEWLINE .)
    ENUM            reduce using rule 42 (_5_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 42 (_5_optional -> NEWLINE .)
    END             reduce using rule 42 (_5_optional -> NEWLINE .)
    ELIF            reduce using rule 42 (_5_optional -> NEWLINE .)
    ELSE            reduce using rule 42 (_5_optional -> NEWLINE .)


state 93

    (39) _4_optional -> : type .
    NEWLINE         reduce using rule 39 (_4_optional -> : type .)
    END             reduce using rule 39 (_4_optional -> : type .)
    -               reduce using rule 39 (_4_optional -> : type .)
    (               reduce using rule 39 (_4_optional -> : type .)
    [               reduce using rule 39 (_4_optional -> : type .)
    IDENTIFIER      reduce using rule 39 (_4_optional -> : type .)
    CASE            reduce using rule 39 (_4_optional -> : type .)
    IF              reduce using rule 39 (_4_optional -> : type .)
    DEF             reduce using rule 39 (_4_optional -> : type .)
    STRING          reduce using rule 39 (_4_optional -> : type .)
    NUMBER          reduce using rule 39 (_4_optional -> : type .)
    DO              reduce using rule 39 (_4_optional -> : type .)
    EXTERNAL        reduce using rule 39 (_4_optional -> : type .)
    ENUM            reduce using rule 39 (_4_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 39 (_4_optional -> : type .)


state 94

    (80) enum -> ENUM type_identifier { . _18_optional _19_optional }
    (81) _18_optional -> . NEWLINE
    (82) _18_optional -> .
    NEWLINE         shift and go to state 117
    TYPE_IDENTIFIER reduce using rule 82 (_18_optional -> .)
    }               reduce using rule 82 (_18_optional -> .)

    _18_optional                   shift and go to state 116

state 95

    (85) enum -> ENUM type_identifier < . type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 118

state 96

    (153) call -> expr ( _41_optional _42_optional . )
    )               shift and go to state 119


state 97

    (156) _42_optional -> exprs .
    (166) exprs -> exprs . , _46_optional expr _47_optional
    )               reduce using rule 156 (_42_optional -> exprs .)
    ,               shift and go to state 101


state 98

    (173) variable_declaration -> identifier _48_optional = expr .
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    $end            reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    )               reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    OF              reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    THEN            reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    END             reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    ELIF            reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    ELSE            reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    ,               reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    ]               reduce using rule 173 (variable_declaration -> identifier _48_optional = expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 99

    (73) type -> type_identifier < . type _17_repeat >
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 80
    type                           shift and go to state 120

state 100

    (148) array -> [ _39_optional _40_optional ] .
    NEWLINE         reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    (               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    INT_DIV         reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    EQUAL           reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    NOT_EQUAL       reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    |               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    >               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    %               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    <               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    *               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    /               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    -               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    +               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    CONCAT          reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    $end            reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    )               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    OF              reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    THEN            reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    END             reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    ELIF            reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    ELSE            reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    ,               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)
    ]               reduce using rule 148 (array -> [ _39_optional _40_optional ] .)


state 101

    (166) exprs -> exprs , . _46_optional expr _47_optional
    (167) _46_optional -> . NEWLINE
    (168) _46_optional -> .
    NEWLINE         shift and go to state 122
    -               reduce using rule 168 (_46_optional -> .)
    (               reduce using rule 168 (_46_optional -> .)
    [               reduce using rule 168 (_46_optional -> .)
    IDENTIFIER      reduce using rule 168 (_46_optional -> .)
    CASE            reduce using rule 168 (_46_optional -> .)
    IF              reduce using rule 168 (_46_optional -> .)
    DEF             reduce using rule 168 (_46_optional -> .)
    STRING          reduce using rule 168 (_46_optional -> .)
    NUMBER          reduce using rule 168 (_46_optional -> .)
    DO              reduce using rule 168 (_46_optional -> .)
    EXTERNAL        reduce using rule 168 (_46_optional -> .)
    ENUM            reduce using rule 168 (_46_optional -> .)
    TYPE_IDENTIFIER reduce using rule 168 (_46_optional -> .)

    _46_optional                   shift and go to state 121

state 102

    (163) exprs -> expr _45_optional .
    ,               reduce using rule 163 (exprs -> expr _45_optional .)
    ]               reduce using rule 163 (exprs -> expr _45_optional .)
    )               reduce using rule 163 (exprs -> expr _45_optional .)


state 103

    (164) _45_optional -> NEWLINE .
    ,               reduce using rule 164 (_45_optional -> NEWLINE .)
    ]               reduce using rule 164 (_45_optional -> NEWLINE .)
    )               reduce using rule 164 (_45_optional -> NEWLINE .)


state 104

    (158) variant_call -> type_identifier ( _43_optional _44_optional . )
    )               shift and go to state 123


state 105

    (161) _44_optional -> exprs .
    (166) exprs -> exprs . , _46_optional expr _47_optional
    )               reduce using rule 161 (_44_optional -> exprs .)
    ,               shift and go to state 101


state 106

    (120) case_of -> CASE expr OF _30_optional . _31_optional END
    (123) _31_optional -> . cases
    (124) _31_optional -> .
    (125) cases -> . pattern do _32_optional
    (128) cases -> . cases pattern do _33_optional
    (131) pattern -> . match_variant
    (132) pattern -> . match_as
    (134) match_variant -> . type_identifier
    (135) match_variant -> . type_identifier ( _34_optional _35_optional )
    (133) match_as -> . identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    (171) identifier -> . IDENTIFIER
    END             reduce using rule 124 (_31_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 24

    _31_optional                   shift and go to state 124
    cases                          shift and go to state 125
    pattern                        shift and go to state 126
    match_variant                  shift and go to state 127
    match_as                       shift and go to state 128
    type_identifier                shift and go to state 129
    identifier                     shift and go to state 130

state 107

    (121) _30_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 121 (_30_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 121 (_30_optional -> NEWLINE .)
    END             reduce using rule 121 (_30_optional -> NEWLINE .)


state 108

    (111) if_expr -> IF expr THEN _27_optional . block_statement _28_optional END
    (41) block_statement -> . _5_optional _6_optional
    (42) _5_optional -> . NEWLINE
    (43) _5_optional -> .
    NEWLINE         shift and go to state 92
    -               reduce using rule 43 (_5_optional -> .)
    (               reduce using rule 43 (_5_optional -> .)
    [               reduce using rule 43 (_5_optional -> .)
    IDENTIFIER      reduce using rule 43 (_5_optional -> .)
    CASE            reduce using rule 43 (_5_optional -> .)
    IF              reduce using rule 43 (_5_optional -> .)
    DEF             reduce using rule 43 (_5_optional -> .)
    STRING          reduce using rule 43 (_5_optional -> .)
    NUMBER          reduce using rule 43 (_5_optional -> .)
    DO              reduce using rule 43 (_5_optional -> .)
    EXTERNAL        reduce using rule 43 (_5_optional -> .)
    ENUM            reduce using rule 43 (_5_optional -> .)
    TYPE_IDENTIFIER reduce using rule 43 (_5_optional -> .)
    ELIF            reduce using rule 43 (_5_optional -> .)
    ELSE            reduce using rule 43 (_5_optional -> .)
    END             reduce using rule 43 (_5_optional -> .)

    block_statement                shift and go to state 131
    _5_optional                    shift and go to state 91

state 109

    (112) _27_optional -> : . type
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 132
    type_identifier                shift and go to state 80

state 110

    (46) def_expr -> DEF identifier ( _7_optional . _8_optional ) _9_optional do
    (49) _8_optional -> . params
    (50) _8_optional -> .
    (65) params -> . param _14_optional
    (68) params -> . params , _15_optional param _16_optional
    (108) param -> . identifier _26_optional
    (171) identifier -> . IDENTIFIER
    )               reduce using rule 50 (_8_optional -> .)
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 133
    _8_optional                    shift and go to state 134
    params                         shift and go to state 135
    param                          shift and go to state 136

state 111

    (47) _7_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 47 (_7_optional -> NEWLINE .)
    )               reduce using rule 47 (_7_optional -> NEWLINE .)


state 112

    (53) def_expr -> DEF identifier < type_identifier . _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (54) _10_repeat -> . _10_items
    (55) _10_repeat -> .
    (56) _10_items -> . _10_items _10_item
    (57) _10_items -> . _10_item
    (58) _10_item -> . , type_identifier
    >               reduce using rule 55 (_10_repeat -> .)
    ,               shift and go to state 140

    _10_repeat                     shift and go to state 137
    _10_items                      shift and go to state 138
    _10_item                       shift and go to state 139

state 113

    (38) do -> DO _4_optional block_statement END .
    NEWLINE         reduce using rule 38 (do -> DO _4_optional block_statement END .)
    (               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    INT_DIV         reduce using rule 38 (do -> DO _4_optional block_statement END .)
    EQUAL           reduce using rule 38 (do -> DO _4_optional block_statement END .)
    NOT_EQUAL       reduce using rule 38 (do -> DO _4_optional block_statement END .)
    |               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    >               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    %               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    <               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    *               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    /               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    -               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    +               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    CONCAT          reduce using rule 38 (do -> DO _4_optional block_statement END .)
    $end            reduce using rule 38 (do -> DO _4_optional block_statement END .)
    )               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    OF              reduce using rule 38 (do -> DO _4_optional block_statement END .)
    THEN            reduce using rule 38 (do -> DO _4_optional block_statement END .)
    END             reduce using rule 38 (do -> DO _4_optional block_statement END .)
    ELIF            reduce using rule 38 (do -> DO _4_optional block_statement END .)
    ELSE            reduce using rule 38 (do -> DO _4_optional block_statement END .)
    ,               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    ]               reduce using rule 38 (do -> DO _4_optional block_statement END .)
    TYPE_IDENTIFIER reduce using rule 38 (do -> DO _4_optional block_statement END .)
    IDENTIFIER      reduce using rule 38 (do -> DO _4_optional block_statement END .)


state 114

    (41) block_statement -> _5_optional _6_optional .
    END             reduce using rule 41 (block_statement -> _5_optional _6_optional .)
    ELIF            reduce using rule 41 (block_statement -> _5_optional _6_optional .)
    ELSE            reduce using rule 41 (block_statement -> _5_optional _6_optional .)


state 115

    (44) _6_optional -> do_exprs .
    END             reduce using rule 44 (_6_optional -> do_exprs .)
    ELIF            reduce using rule 44 (_6_optional -> do_exprs .)
    ELSE            reduce using rule 44 (_6_optional -> do_exprs .)


state 116

    (80) enum -> ENUM type_identifier { _18_optional . _19_optional }
    (83) _19_optional -> . variants
    (84) _19_optional -> .
    (95) variants -> . variant _23_optional
    (98) variants -> . variants variant _24_optional
    (101) variant -> . type_identifier
    (102) variant -> . type_identifier ( type _25_repeat )
    (172) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 84 (_19_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 141
    _19_optional                   shift and go to state 142
    variants                       shift and go to state 143
    variant                        shift and go to state 144

state 117

    (81) _18_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 81 (_18_optional -> NEWLINE .)
    }               reduce using rule 81 (_18_optional -> NEWLINE .)


state 118

    (85) enum -> ENUM type_identifier < type_identifier . _20_repeat > { _21_optional _22_optional }
    (86) _20_repeat -> . _20_items
    (87) _20_repeat -> .
    (88) _20_items -> . _20_items _20_item
    (89) _20_items -> . _20_item
    (90) _20_item -> . , type_identifier
    >               reduce using rule 87 (_20_repeat -> .)
    ,               shift and go to state 148

    _20_repeat                     shift and go to state 145
    _20_items                      shift and go to state 146
    _20_item                       shift and go to state 147

state 119

    (153) call -> expr ( _41_optional _42_optional ) .
    NEWLINE         reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    (               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    INT_DIV         reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    EQUAL           reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    NOT_EQUAL       reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    |               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    >               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    %               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    <               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    *               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    /               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    -               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    +               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    CONCAT          reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    $end            reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    )               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    OF              reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    THEN            reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    END             reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    ELIF            reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    ELSE            reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    ,               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)
    ]               reduce using rule 153 (call -> expr ( _41_optional _42_optional ) .)


state 120

    (73) type -> type_identifier < type . _17_repeat >
    (74) _17_repeat -> . _17_items
    (75) _17_repeat -> .
    (76) _17_items -> . _17_items _17_item
    (77) _17_items -> . _17_item
    (78) _17_item -> . , type
    >               reduce using rule 75 (_17_repeat -> .)
    ,               shift and go to state 152

    _17_repeat                     shift and go to state 149
    _17_items                      shift and go to state 150
    _17_item                       shift and go to state 151

state 121

    (166) exprs -> exprs , _46_optional . expr _47_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 153
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 122

    (167) _46_optional -> NEWLINE .
    -               reduce using rule 167 (_46_optional -> NEWLINE .)
    (               reduce using rule 167 (_46_optional -> NEWLINE .)
    [               reduce using rule 167 (_46_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 167 (_46_optional -> NEWLINE .)
    CASE            reduce using rule 167 (_46_optional -> NEWLINE .)
    IF              reduce using rule 167 (_46_optional -> NEWLINE .)
    DEF             reduce using rule 167 (_46_optional -> NEWLINE .)
    STRING          reduce using rule 167 (_46_optional -> NEWLINE .)
    NUMBER          reduce using rule 167 (_46_optional -> NEWLINE .)
    DO              reduce using rule 167 (_46_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 167 (_46_optional -> NEWLINE .)
    ENUM            reduce using rule 167 (_46_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 167 (_46_optional -> NEWLINE .)


state 123

    (158) variant_call -> type_identifier ( _43_optional _44_optional ) .
    NEWLINE         reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    (               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    INT_DIV         reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    EQUAL           reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    NOT_EQUAL       reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    |               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    >               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    %               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    <               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    *               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    /               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    -               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    +               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    CONCAT          reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    $end            reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    )               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    OF              reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    THEN            reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    END             reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    ELIF            reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    ELSE            reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    ,               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    ]               reduce using rule 158 (variant_call -> type_identifier ( _43_optional _44_optional ) .)


state 124

    (120) case_of -> CASE expr OF _30_optional _31_optional . END
    END             shift and go to state 154


state 125

    (123) _31_optional -> cases .
    (128) cases -> cases . pattern do _33_optional
    (131) pattern -> . match_variant
    (132) pattern -> . match_as
    (134) match_variant -> . type_identifier
    (135) match_variant -> . type_identifier ( _34_optional _35_optional )
    (133) match_as -> . identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    (171) identifier -> . IDENTIFIER
    END             reduce using rule 123 (_31_optional -> cases .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 24

    pattern                        shift and go to state 155
    match_variant                  shift and go to state 127
    match_as                       shift and go to state 128
    type_identifier                shift and go to state 129
    identifier                     shift and go to state 130

state 126

    (125) cases -> pattern . do _32_optional
    (38) do -> . DO _4_optional block_statement END
    DO              shift and go to state 30

    do                             shift and go to state 156

state 127

    (131) pattern -> match_variant .
    DO              reduce using rule 131 (pattern -> match_variant .)
    NEWLINE         reduce using rule 131 (pattern -> match_variant .)
    ,               reduce using rule 131 (pattern -> match_variant .)
    )               reduce using rule 131 (pattern -> match_variant .)


state 128

    (132) pattern -> match_as .
    DO              reduce using rule 132 (pattern -> match_as .)
    NEWLINE         reduce using rule 132 (pattern -> match_as .)
    ,               reduce using rule 132 (pattern -> match_as .)
    )               reduce using rule 132 (pattern -> match_as .)


state 129

    (134) match_variant -> type_identifier .
    (135) match_variant -> type_identifier . ( _34_optional _35_optional )
    DO              reduce using rule 134 (match_variant -> type_identifier .)
    NEWLINE         reduce using rule 134 (match_variant -> type_identifier .)
    ,               reduce using rule 134 (match_variant -> type_identifier .)
    )               reduce using rule 134 (match_variant -> type_identifier .)
    (               shift and go to state 157


state 130

    (133) match_as -> identifier .
    DO              reduce using rule 133 (match_as -> identifier .)
    NEWLINE         reduce using rule 133 (match_as -> identifier .)
    ,               reduce using rule 133 (match_as -> identifier .)
    )               reduce using rule 133 (match_as -> identifier .)


state 131

    (111) if_expr -> IF expr THEN _27_optional block_statement . _28_optional END
    (114) _28_optional -> . or_else
    (115) _28_optional -> .
    (116) or_else -> . ELIF expr THEN block_statement _29_optional
    (119) or_else -> . ELSE block_statement
    END             reduce using rule 115 (_28_optional -> .)
    ELIF            shift and go to state 160
    ELSE            shift and go to state 161

    _28_optional                   shift and go to state 158
    or_else                        shift and go to state 159

state 132

    (112) _27_optional -> : type .
    NEWLINE         reduce using rule 112 (_27_optional -> : type .)
    ELIF            reduce using rule 112 (_27_optional -> : type .)
    ELSE            reduce using rule 112 (_27_optional -> : type .)
    END             reduce using rule 112 (_27_optional -> : type .)
    -               reduce using rule 112 (_27_optional -> : type .)
    (               reduce using rule 112 (_27_optional -> : type .)
    [               reduce using rule 112 (_27_optional -> : type .)
    IDENTIFIER      reduce using rule 112 (_27_optional -> : type .)
    CASE            reduce using rule 112 (_27_optional -> : type .)
    IF              reduce using rule 112 (_27_optional -> : type .)
    DEF             reduce using rule 112 (_27_optional -> : type .)
    STRING          reduce using rule 112 (_27_optional -> : type .)
    NUMBER          reduce using rule 112 (_27_optional -> : type .)
    DO              reduce using rule 112 (_27_optional -> : type .)
    EXTERNAL        reduce using rule 112 (_27_optional -> : type .)
    ENUM            reduce using rule 112 (_27_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 112 (_27_optional -> : type .)


state 133

    (108) param -> identifier . _26_optional
    (109) _26_optional -> . : type
    (110) _26_optional -> .
    :               shift and go to state 163
    NEWLINE         reduce using rule 110 (_26_optional -> .)
    ,               reduce using rule 110 (_26_optional -> .)
    )               reduce using rule 110 (_26_optional -> .)

    _26_optional                   shift and go to state 162

state 134

    (46) def_expr -> DEF identifier ( _7_optional _8_optional . ) _9_optional do
    )               shift and go to state 164


state 135

    (49) _8_optional -> params .
    (68) params -> params . , _15_optional param _16_optional
    )               reduce using rule 49 (_8_optional -> params .)
    ,               shift and go to state 165


state 136

    (65) params -> param . _14_optional
    (66) _14_optional -> . NEWLINE
    (67) _14_optional -> .
    NEWLINE         shift and go to state 167
    ,               reduce using rule 67 (_14_optional -> .)
    )               reduce using rule 67 (_14_optional -> .)

    _14_optional                   shift and go to state 166

state 137

    (53) def_expr -> DEF identifier < type_identifier _10_repeat . > ( _11_optional _12_optional ) _13_optional do
    >               shift and go to state 168


state 138

    (54) _10_repeat -> _10_items .
    (56) _10_items -> _10_items . _10_item
    (58) _10_item -> . , type_identifier
    >               reduce using rule 54 (_10_repeat -> _10_items .)
    ,               shift and go to state 140

    _10_item                       shift and go to state 169

state 139

    (57) _10_items -> _10_item .
    ,               reduce using rule 57 (_10_items -> _10_item .)
    >               reduce using rule 57 (_10_items -> _10_item .)


state 140

    (58) _10_item -> , . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 170

state 141

    (101) variant -> type_identifier .
    (102) variant -> type_identifier . ( type _25_repeat )
    NEWLINE         reduce using rule 101 (variant -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 101 (variant -> type_identifier .)
    }               reduce using rule 101 (variant -> type_identifier .)
    (               shift and go to state 171


state 142

    (80) enum -> ENUM type_identifier { _18_optional _19_optional . }
    }               shift and go to state 172


state 143

    (83) _19_optional -> variants .
    (98) variants -> variants . variant _24_optional
    (101) variant -> . type_identifier
    (102) variant -> . type_identifier ( type _25_repeat )
    (172) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 83 (_19_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 33

    variant                        shift and go to state 173
    type_identifier                shift and go to state 141

state 144

    (95) variants -> variant . _23_optional
    (96) _23_optional -> . NEWLINE
    (97) _23_optional -> .
    NEWLINE         shift and go to state 175
    TYPE_IDENTIFIER reduce using rule 97 (_23_optional -> .)
    }               reduce using rule 97 (_23_optional -> .)

    _23_optional                   shift and go to state 174

state 145

    (85) enum -> ENUM type_identifier < type_identifier _20_repeat . > { _21_optional _22_optional }
    >               shift and go to state 176


state 146

    (86) _20_repeat -> _20_items .
    (88) _20_items -> _20_items . _20_item
    (90) _20_item -> . , type_identifier
    >               reduce using rule 86 (_20_repeat -> _20_items .)
    ,               shift and go to state 148

    _20_item                       shift and go to state 177

state 147

    (89) _20_items -> _20_item .
    ,               reduce using rule 89 (_20_items -> _20_item .)
    >               reduce using rule 89 (_20_items -> _20_item .)


state 148

    (90) _20_item -> , . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 178

state 149

    (73) type -> type_identifier < type _17_repeat . >
    >               shift and go to state 179


state 150

    (74) _17_repeat -> _17_items .
    (76) _17_items -> _17_items . _17_item
    (78) _17_item -> . , type
    >               reduce using rule 74 (_17_repeat -> _17_items .)
    ,               shift and go to state 152

    _17_item                       shift and go to state 180

state 151

    (77) _17_items -> _17_item .
    ,               reduce using rule 77 (_17_items -> _17_item .)
    >               reduce using rule 77 (_17_items -> _17_item .)


state 152

    (78) _17_item -> , . type
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 181
    type_identifier                shift and go to state 80

state 153

    (166) exprs -> exprs , _46_optional expr . _47_optional
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    (169) _47_optional -> . NEWLINE
    (170) _47_optional -> .
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48
    NEWLINE         shift and go to state 183
    ,               reduce using rule 170 (_47_optional -> .)
    ]               reduce using rule 170 (_47_optional -> .)
    )               reduce using rule 170 (_47_optional -> .)

    _47_optional                   shift and go to state 182

state 154

    (120) case_of -> CASE expr OF _30_optional _31_optional END .
    NEWLINE         reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    (               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    INT_DIV         reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    EQUAL           reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    NOT_EQUAL       reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    |               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    >               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    %               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    <               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    *               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    /               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    -               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    +               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    CONCAT          reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    $end            reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    )               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    OF              reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    THEN            reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    END             reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    ELIF            reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    ELSE            reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    ,               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)
    ]               reduce using rule 120 (case_of -> CASE expr OF _30_optional _31_optional END .)


state 155

    (128) cases -> cases pattern . do _33_optional
    (38) do -> . DO _4_optional block_statement END
    DO              shift and go to state 30

    do                             shift and go to state 184

state 156

    (125) cases -> pattern do . _32_optional
    (126) _32_optional -> . NEWLINE
    (127) _32_optional -> .
    NEWLINE         shift and go to state 186
    TYPE_IDENTIFIER reduce using rule 127 (_32_optional -> .)
    IDENTIFIER      reduce using rule 127 (_32_optional -> .)
    END             reduce using rule 127 (_32_optional -> .)

    _32_optional                   shift and go to state 185

state 157

    (135) match_variant -> type_identifier ( . _34_optional _35_optional )
    (136) _34_optional -> . NEWLINE
    (137) _34_optional -> .
    NEWLINE         shift and go to state 188
    TYPE_IDENTIFIER reduce using rule 137 (_34_optional -> .)
    IDENTIFIER      reduce using rule 137 (_34_optional -> .)
    )               reduce using rule 137 (_34_optional -> .)

    _34_optional                   shift and go to state 187

state 158

    (111) if_expr -> IF expr THEN _27_optional block_statement _28_optional . END
    END             shift and go to state 189


state 159

    (114) _28_optional -> or_else .
    END             reduce using rule 114 (_28_optional -> or_else .)


state 160

    (116) or_else -> ELIF . expr THEN block_statement _29_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . variable_declaration
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (148) array -> . [ _39_optional _40_optional ]
    (158) variant_call -> . type_identifier ( _43_optional _44_optional )
    (171) identifier -> . IDENTIFIER
    (173) variable_declaration -> . identifier _48_optional = expr
    (153) call -> . expr ( _41_optional _42_optional )
    (120) case_of -> . CASE expr OF _30_optional _31_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (111) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (46) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (53) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (38) do -> . DO _4_optional block_statement END
    (25) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (85) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (172) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 190
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    variable_declaration           shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 161

    (119) or_else -> ELSE . block_statement
    (41) block_statement -> . _5_optional _6_optional
    (42) _5_optional -> . NEWLINE
    (43) _5_optional -> .
    NEWLINE         shift and go to state 92
    -               reduce using rule 43 (_5_optional -> .)
    (               reduce using rule 43 (_5_optional -> .)
    [               reduce using rule 43 (_5_optional -> .)
    IDENTIFIER      reduce using rule 43 (_5_optional -> .)
    CASE            reduce using rule 43 (_5_optional -> .)
    IF              reduce using rule 43 (_5_optional -> .)
    DEF             reduce using rule 43 (_5_optional -> .)
    STRING          reduce using rule 43 (_5_optional -> .)
    NUMBER          reduce using rule 43 (_5_optional -> .)
    DO              reduce using rule 43 (_5_optional -> .)
    EXTERNAL        reduce using rule 43 (_5_optional -> .)
    ENUM            reduce using rule 43 (_5_optional -> .)
    TYPE_IDENTIFIER reduce using rule 43 (_5_optional -> .)
    END             reduce using rule 43 (_5_optional -> .)

    block_statement                shift and go to state 191
    _5_optional                    shift and go to state 91

state 162

    (108) param -> identifier _26_optional .
    NEWLINE         reduce using rule 108 (param -> identifier _26_optional .)
    ,               reduce using rule 108 (param -> identifier _26_optional .)
    )               reduce using rule 108 (param -> identifier _26_optional .)


state 163

    (109) _26_optional -> : . type
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 192
    type_identifier                shift and go to state 80

state 164

    (46) def_expr -> DEF identifier ( _7_optional _8_optional ) . _9_optional do
    (51) _9_optional -> . : type
    (52) _9_optional -> .
    :               shift and go to state 194
    DO              reduce using rule 52 (_9_optional -> .)

    _9_optional                    shift and go to state 193

state 165

    (68) params -> params , . _15_optional param _16_optional
    (69) _15_optional -> . NEWLINE
    (70) _15_optional -> .
    NEWLINE         shift and go to state 196
    IDENTIFIER      reduce using rule 70 (_15_optional -> .)

    _15_optional                   shift and go to state 195

state 166

    (65) params -> param _14_optional .
    ,               reduce using rule 65 (params -> param _14_optional .)
    )               reduce using rule 65 (params -> param _14_optional .)


state 167

    (66) _14_optional -> NEWLINE .
    ,               reduce using rule 66 (_14_optional -> NEWLINE .)
    )               reduce using rule 66 (_14_optional -> NEWLINE .)


state 168

    (53) def_expr -> DEF identifier < type_identifier _10_repeat > . ( _11_optional _12_optional ) _13_optional do
    (               shift and go to state 197


state 169

    (56) _10_items -> _10_items _10_item .
    ,               reduce using rule 56 (_10_items -> _10_items _10_item .)
    >               reduce using rule 56 (_10_items -> _10_items _10_item .)


state 170

    (58) _10_item -> , type_identifier .
    ,               reduce using rule 58 (_10_item -> , type_identifier .)
    >               reduce using rule 58 (_10_item -> , type_identifier .)


state 171

    (102) variant -> type_identifier ( . type _25_repeat )
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 80
    type                           shift and go to state 198

state 172

    (80) enum -> ENUM type_identifier { _18_optional _19_optional } .
    NEWLINE         reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    (               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    INT_DIV         reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    EQUAL           reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    NOT_EQUAL       reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    |               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    >               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    %               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    <               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    *               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    /               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    -               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    +               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    CONCAT          reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    $end            reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    )               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    OF              reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    THEN            reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    END             reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    ELIF            reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    ELSE            reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    ,               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    ]               reduce using rule 80 (enum -> ENUM type_identifier { _18_optional _19_optional } .)


state 173

    (98) variants -> variants variant . _24_optional
    (99) _24_optional -> . NEWLINE
    (100) _24_optional -> .
    NEWLINE         shift and go to state 200
    TYPE_IDENTIFIER reduce using rule 100 (_24_optional -> .)
    }               reduce using rule 100 (_24_optional -> .)

    _24_optional                   shift and go to state 199

state 174

    (95) variants -> variant _23_optional .
    TYPE_IDENTIFIER reduce using rule 95 (variants -> variant _23_optional .)
    }               reduce using rule 95 (variants -> variant _23_optional .)


state 175

    (96) _23_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 96 (_23_optional -> NEWLINE .)
    }               reduce using rule 96 (_23_optional -> NEWLINE .)


state 176

    (85) enum -> ENUM type_identifier < type_identifier _20_repeat > . { _21_optional _22_optional }
    {               shift and go to state 201


state 177

    (88) _20_items -> _20_items _20_item .
    ,               reduce using rule 88 (_20_items -> _20_items _20_item .)
    >               reduce using rule 88 (_20_items -> _20_items _20_item .)


state 178

    (90) _20_item -> , type_identifier .
    ,               reduce using rule 90 (_20_item -> , type_identifier .)
    >               reduce using rule 90 (_20_item -> , type_identifier .)


state 179

    (73) type -> type_identifier < type _17_repeat > .
    =               reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    NEWLINE         reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    END             reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    -               reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    (               reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    [               reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    IDENTIFIER      reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    CASE            reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    IF              reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    DEF             reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    STRING          reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    NUMBER          reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    DO              reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    EXTERNAL        reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    ENUM            reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    TYPE_IDENTIFIER reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    ,               reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    >               reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    ELIF            reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    ELSE            reduce using rule 73 (type -> type_identifier < type _17_repeat > .)
    )               reduce using rule 73 (type -> type_identifier < type _17_repeat > .)


state 180

    (76) _17_items -> _17_items _17_item .
    ,               reduce using rule 76 (_17_items -> _17_items _17_item .)
    >               reduce using rule 76 (_17_items -> _17_items _17_item .)


state 181

    (78) _17_item -> , type .
    ,               reduce using rule 78 (_17_item -> , type .)
    >               reduce using rule 78 (_17_item -> , type .)


state 182

    (166) exprs -> exprs , _46_optional expr _47_optional .
    ,               reduce using rule 166 (exprs -> exprs , _46_optional expr _47_optional .)
    ]               reduce using rule 166 (exprs -> exprs , _46_optional expr _47_optional .)
    )               reduce using rule 166 (exprs -> exprs , _46_optional expr _47_optional .)


state 183

    (169) _47_optional -> NEWLINE .
    ,               reduce using rule 169 (_47_optional -> NEWLINE .)
    ]               reduce using rule 169 (_47_optional -> NEWLINE .)
    )               reduce using rule 169 (_47_optional -> NEWLINE .)


state 184

    (128) cases -> cases pattern do . _33_optional
    (129) _33_optional -> . NEWLINE
    (130) _33_optional -> .
    NEWLINE         shift and go to state 203
    TYPE_IDENTIFIER reduce using rule 130 (_33_optional -> .)
    IDENTIFIER      reduce using rule 130 (_33_optional -> .)
    END             reduce using rule 130 (_33_optional -> .)

    _33_optional                   shift and go to state 202

state 185

    (125) cases -> pattern do _32_optional .
    TYPE_IDENTIFIER reduce using rule 125 (cases -> pattern do _32_optional .)
    IDENTIFIER      reduce using rule 125 (cases -> pattern do _32_optional .)
    END             reduce using rule 125 (cases -> pattern do _32_optional .)


state 186

    (126) _32_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 126 (_32_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 126 (_32_optional -> NEWLINE .)
    END             reduce using rule 126 (_32_optional -> NEWLINE .)


state 187

    (135) match_variant -> type_identifier ( _34_optional . _35_optional )
    (138) _35_optional -> . patterns
    (139) _35_optional -> .
    (140) patterns -> . pattern _36_optional
    (143) patterns -> . patterns , _37_optional pattern _38_optional
    (131) pattern -> . match_variant
    (132) pattern -> . match_as
    (134) match_variant -> . type_identifier
    (135) match_variant -> . type_identifier ( _34_optional _35_optional )
    (133) match_as -> . identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    (171) identifier -> . IDENTIFIER
    )               reduce using rule 139 (_35_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 24

    type_identifier                shift and go to state 129
    _35_optional                   shift and go to state 204
    patterns                       shift and go to state 205
    pattern                        shift and go to state 206
    match_variant                  shift and go to state 127
    match_as                       shift and go to state 128
    identifier                     shift and go to state 130

state 188

    (136) _34_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 136 (_34_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 136 (_34_optional -> NEWLINE .)
    )               reduce using rule 136 (_34_optional -> NEWLINE .)


state 189

    (111) if_expr -> IF expr THEN _27_optional block_statement _28_optional END .
    NEWLINE         reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    (               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    INT_DIV         reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    EQUAL           reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    NOT_EQUAL       reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    |               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    >               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    %               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    <               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    *               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    /               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    -               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    +               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    CONCAT          reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    $end            reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    )               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    OF              reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    THEN            reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    END             reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    ELIF            reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    ELSE            reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    ,               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    ]               reduce using rule 111 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)


state 190

    (116) or_else -> ELIF expr . THEN block_statement _29_optional
    (153) call -> expr . ( _41_optional _42_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 207
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 191

    (119) or_else -> ELSE block_statement .
    END             reduce using rule 119 (or_else -> ELSE block_statement .)


state 192

    (109) _26_optional -> : type .
    NEWLINE         reduce using rule 109 (_26_optional -> : type .)
    ,               reduce using rule 109 (_26_optional -> : type .)
    )               reduce using rule 109 (_26_optional -> : type .)


state 193

    (46) def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional . do
    (38) do -> . DO _4_optional block_statement END
    DO              shift and go to state 30

    do                             shift and go to state 208

state 194

    (51) _9_optional -> : . type
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 209
    type_identifier                shift and go to state 80

state 195

    (68) params -> params , _15_optional . param _16_optional
    (108) param -> . identifier _26_optional
    (171) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    param                          shift and go to state 210
    identifier                     shift and go to state 133

state 196

    (69) _15_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 69 (_15_optional -> NEWLINE .)


state 197

    (53) def_expr -> DEF identifier < type_identifier _10_repeat > ( . _11_optional _12_optional ) _13_optional do
    (59) _11_optional -> . NEWLINE
    (60) _11_optional -> .
    NEWLINE         shift and go to state 212
    IDENTIFIER      reduce using rule 60 (_11_optional -> .)
    )               reduce using rule 60 (_11_optional -> .)

    _11_optional                   shift and go to state 211

state 198

    (102) variant -> type_identifier ( type . _25_repeat )
    (103) _25_repeat -> . _25_items
    (104) _25_repeat -> .
    (105) _25_items -> . _25_items _25_item
    (106) _25_items -> . _25_item
    (107) _25_item -> . , type
    )               reduce using rule 104 (_25_repeat -> .)
    ,               shift and go to state 216

    _25_repeat                     shift and go to state 213
    _25_items                      shift and go to state 214
    _25_item                       shift and go to state 215

state 199

    (98) variants -> variants variant _24_optional .
    TYPE_IDENTIFIER reduce using rule 98 (variants -> variants variant _24_optional .)
    }               reduce using rule 98 (variants -> variants variant _24_optional .)


state 200

    (99) _24_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 99 (_24_optional -> NEWLINE .)
    }               reduce using rule 99 (_24_optional -> NEWLINE .)


state 201

    (85) enum -> ENUM type_identifier < type_identifier _20_repeat > { . _21_optional _22_optional }
    (91) _21_optional -> . NEWLINE
    (92) _21_optional -> .
    NEWLINE         shift and go to state 218
    TYPE_IDENTIFIER reduce using rule 92 (_21_optional -> .)
    }               reduce using rule 92 (_21_optional -> .)

    _21_optional                   shift and go to state 217

state 202

    (128) cases -> cases pattern do _33_optional .
    TYPE_IDENTIFIER reduce using rule 128 (cases -> cases pattern do _33_optional .)
    IDENTIFIER      reduce using rule 128 (cases -> cases pattern do _33_optional .)
    END             reduce using rule 128 (cases -> cases pattern do _33_optional .)


state 203

    (129) _33_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 129 (_33_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 129 (_33_optional -> NEWLINE .)
    END             reduce using rule 129 (_33_optional -> NEWLINE .)


state 204

    (135) match_variant -> type_identifier ( _34_optional _35_optional . )
    )               shift and go to state 219


state 205

    (138) _35_optional -> patterns .
    (143) patterns -> patterns . , _37_optional pattern _38_optional
    )               reduce using rule 138 (_35_optional -> patterns .)
    ,               shift and go to state 220


state 206

    (140) patterns -> pattern . _36_optional
    (141) _36_optional -> . NEWLINE
    (142) _36_optional -> .
    NEWLINE         shift and go to state 222
    ,               reduce using rule 142 (_36_optional -> .)
    )               reduce using rule 142 (_36_optional -> .)

    _36_optional                   shift and go to state 221

state 207

    (116) or_else -> ELIF expr THEN . block_statement _29_optional
    (41) block_statement -> . _5_optional _6_optional
    (42) _5_optional -> . NEWLINE
    (43) _5_optional -> .
    NEWLINE         shift and go to state 92
    -               reduce using rule 43 (_5_optional -> .)
    (               reduce using rule 43 (_5_optional -> .)
    [               reduce using rule 43 (_5_optional -> .)
    IDENTIFIER      reduce using rule 43 (_5_optional -> .)
    CASE            reduce using rule 43 (_5_optional -> .)
    IF              reduce using rule 43 (_5_optional -> .)
    DEF             reduce using rule 43 (_5_optional -> .)
    STRING          reduce using rule 43 (_5_optional -> .)
    NUMBER          reduce using rule 43 (_5_optional -> .)
    DO              reduce using rule 43 (_5_optional -> .)
    EXTERNAL        reduce using rule 43 (_5_optional -> .)
    ENUM            reduce using rule 43 (_5_optional -> .)
    TYPE_IDENTIFIER reduce using rule 43 (_5_optional -> .)
    ELIF            reduce using rule 43 (_5_optional -> .)
    ELSE            reduce using rule 43 (_5_optional -> .)
    END             reduce using rule 43 (_5_optional -> .)

    block_statement                shift and go to state 223
    _5_optional                    shift and go to state 91

state 208

    (46) def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .
    NEWLINE         reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    (               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    INT_DIV         reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    EQUAL           reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    NOT_EQUAL       reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    |               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    >               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    %               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    <               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    *               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    /               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    -               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    +               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    CONCAT          reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    $end            reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    )               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    OF              reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    THEN            reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    END             reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    ELIF            reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    ELSE            reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    ,               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    ]               reduce using rule 46 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)


state 209

    (51) _9_optional -> : type .
    DO              reduce using rule 51 (_9_optional -> : type .)


state 210

    (68) params -> params , _15_optional param . _16_optional
    (71) _16_optional -> . NEWLINE
    (72) _16_optional -> .
    NEWLINE         shift and go to state 225
    ,               reduce using rule 72 (_16_optional -> .)
    )               reduce using rule 72 (_16_optional -> .)

    _16_optional                   shift and go to state 224

state 211

    (53) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional . _12_optional ) _13_optional do
    (61) _12_optional -> . params
    (62) _12_optional -> .
    (65) params -> . param _14_optional
    (68) params -> . params , _15_optional param _16_optional
    (108) param -> . identifier _26_optional
    (171) identifier -> . IDENTIFIER
    )               reduce using rule 62 (_12_optional -> .)
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 133
    _12_optional                   shift and go to state 226
    params                         shift and go to state 227
    param                          shift and go to state 136

state 212

    (59) _11_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 59 (_11_optional -> NEWLINE .)
    )               reduce using rule 59 (_11_optional -> NEWLINE .)


state 213

    (102) variant -> type_identifier ( type _25_repeat . )
    )               shift and go to state 228


state 214

    (103) _25_repeat -> _25_items .
    (105) _25_items -> _25_items . _25_item
    (107) _25_item -> . , type
    )               reduce using rule 103 (_25_repeat -> _25_items .)
    ,               shift and go to state 216

    _25_item                       shift and go to state 229

state 215

    (106) _25_items -> _25_item .
    ,               reduce using rule 106 (_25_items -> _25_item .)
    )               reduce using rule 106 (_25_items -> _25_item .)


state 216

    (107) _25_item -> , . type
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 230
    type_identifier                shift and go to state 80

state 217

    (85) enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional . _22_optional }
    (93) _22_optional -> . variants
    (94) _22_optional -> .
    (95) variants -> . variant _23_optional
    (98) variants -> . variants variant _24_optional
    (101) variant -> . type_identifier
    (102) variant -> . type_identifier ( type _25_repeat )
    (172) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 94 (_22_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 141
    _22_optional                   shift and go to state 231
    variants                       shift and go to state 232
    variant                        shift and go to state 144

state 218

    (91) _21_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 91 (_21_optional -> NEWLINE .)
    }               reduce using rule 91 (_21_optional -> NEWLINE .)


state 219

    (135) match_variant -> type_identifier ( _34_optional _35_optional ) .
    DO              reduce using rule 135 (match_variant -> type_identifier ( _34_optional _35_optional ) .)
    NEWLINE         reduce using rule 135 (match_variant -> type_identifier ( _34_optional _35_optional ) .)
    ,               reduce using rule 135 (match_variant -> type_identifier ( _34_optional _35_optional ) .)
    )               reduce using rule 135 (match_variant -> type_identifier ( _34_optional _35_optional ) .)


state 220

    (143) patterns -> patterns , . _37_optional pattern _38_optional
    (144) _37_optional -> . NEWLINE
    (145) _37_optional -> .
    NEWLINE         shift and go to state 234
    TYPE_IDENTIFIER reduce using rule 145 (_37_optional -> .)
    IDENTIFIER      reduce using rule 145 (_37_optional -> .)

    _37_optional                   shift and go to state 233

state 221

    (140) patterns -> pattern _36_optional .
    ,               reduce using rule 140 (patterns -> pattern _36_optional .)
    )               reduce using rule 140 (patterns -> pattern _36_optional .)


state 222

    (141) _36_optional -> NEWLINE .
    ,               reduce using rule 141 (_36_optional -> NEWLINE .)
    )               reduce using rule 141 (_36_optional -> NEWLINE .)


state 223

    (116) or_else -> ELIF expr THEN block_statement . _29_optional
    (117) _29_optional -> . or_else
    (118) _29_optional -> .
    (116) or_else -> . ELIF expr THEN block_statement _29_optional
    (119) or_else -> . ELSE block_statement
    END             reduce using rule 118 (_29_optional -> .)
    ELIF            shift and go to state 160
    ELSE            shift and go to state 161

    _29_optional                   shift and go to state 235
    or_else                        shift and go to state 236

state 224

    (68) params -> params , _15_optional param _16_optional .
    ,               reduce using rule 68 (params -> params , _15_optional param _16_optional .)
    )               reduce using rule 68 (params -> params , _15_optional param _16_optional .)


state 225

    (71) _16_optional -> NEWLINE .
    ,               reduce using rule 71 (_16_optional -> NEWLINE .)
    )               reduce using rule 71 (_16_optional -> NEWLINE .)


state 226

    (53) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional . ) _13_optional do
    )               shift and go to state 237


state 227

    (61) _12_optional -> params .
    (68) params -> params . , _15_optional param _16_optional
    )               reduce using rule 61 (_12_optional -> params .)
    ,               shift and go to state 165


state 228

    (102) variant -> type_identifier ( type _25_repeat ) .
    NEWLINE         reduce using rule 102 (variant -> type_identifier ( type _25_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 102 (variant -> type_identifier ( type _25_repeat ) .)
    }               reduce using rule 102 (variant -> type_identifier ( type _25_repeat ) .)


state 229

    (105) _25_items -> _25_items _25_item .
    ,               reduce using rule 105 (_25_items -> _25_items _25_item .)
    )               reduce using rule 105 (_25_items -> _25_items _25_item .)


state 230

    (107) _25_item -> , type .
    ,               reduce using rule 107 (_25_item -> , type .)
    )               reduce using rule 107 (_25_item -> , type .)


state 231

    (85) enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional . }
    }               shift and go to state 238


state 232

    (93) _22_optional -> variants .
    (98) variants -> variants . variant _24_optional
    (101) variant -> . type_identifier
    (102) variant -> . type_identifier ( type _25_repeat )
    (172) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 93 (_22_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 33

    variant                        shift and go to state 173
    type_identifier                shift and go to state 141

state 233

    (143) patterns -> patterns , _37_optional . pattern _38_optional
    (131) pattern -> . match_variant
    (132) pattern -> . match_as
    (134) match_variant -> . type_identifier
    (135) match_variant -> . type_identifier ( _34_optional _35_optional )
    (133) match_as -> . identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    (171) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 24

    pattern                        shift and go to state 239
    match_variant                  shift and go to state 127
    match_as                       shift and go to state 128
    type_identifier                shift and go to state 129
    identifier                     shift and go to state 130

state 234

    (144) _37_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 144 (_37_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 144 (_37_optional -> NEWLINE .)


state 235

    (116) or_else -> ELIF expr THEN block_statement _29_optional .
    END             reduce using rule 116 (or_else -> ELIF expr THEN block_statement _29_optional .)


state 236

    (117) _29_optional -> or_else .
    END             reduce using rule 117 (_29_optional -> or_else .)


state 237

    (53) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) . _13_optional do
    (63) _13_optional -> . : type
    (64) _13_optional -> .
    :               shift and go to state 241
    DO              reduce using rule 64 (_13_optional -> .)

    _13_optional                   shift and go to state 240

state 238

    (85) enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .
    NEWLINE         reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    (               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    INT_DIV         reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    EQUAL           reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    NOT_EQUAL       reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    |               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    >               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    %               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    <               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    *               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    /               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    -               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    +               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    CONCAT          reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    $end            reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    )               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    OF              reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    THEN            reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    END             reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    ELIF            reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    ELSE            reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    ,               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    ]               reduce using rule 85 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)


state 239

    (143) patterns -> patterns , _37_optional pattern . _38_optional
    (146) _38_optional -> . NEWLINE
    (147) _38_optional -> .
    NEWLINE         shift and go to state 243
    ,               reduce using rule 147 (_38_optional -> .)
    )               reduce using rule 147 (_38_optional -> .)

    _38_optional                   shift and go to state 242

state 240

    (53) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional . do
    (38) do -> . DO _4_optional block_statement END
    DO              shift and go to state 30

    do                             shift and go to state 244

state 241

    (63) _13_optional -> : . type
    (73) type -> . type_identifier < type _17_repeat >
    (79) type -> . type_identifier
    (172) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 245
    type_identifier                shift and go to state 80

state 242

    (143) patterns -> patterns , _37_optional pattern _38_optional .
    ,               reduce using rule 143 (patterns -> patterns , _37_optional pattern _38_optional .)
    )               reduce using rule 143 (patterns -> patterns , _37_optional pattern _38_optional .)


state 243

    (146) _38_optional -> NEWLINE .
    ,               reduce using rule 146 (_38_optional -> NEWLINE .)
    )               reduce using rule 146 (_38_optional -> NEWLINE .)


state 244

    (53) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .
    NEWLINE         reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    (               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    INT_DIV         reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    EQUAL           reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    NOT_EQUAL       reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    |               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    >               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    %               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    <               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    *               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    /               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    -               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    +               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    CONCAT          reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    $end            reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    )               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    OF              reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    THEN            reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    END             reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    ELIF            reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    ELSE            reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    ,               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    ]               reduce using rule 53 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)


state 245

    (63) _13_optional -> : type .
    DO              reduce using rule 63 (_13_optional -> : type .)
