Grammar:

Rule 0     S' -> program
Rule 1     program -> expressions
Rule 2     expressions -> _1_repeat
Rule 3     _1_repeat -> _1_items
Rule 4     _1_repeat -> <empty>
Rule 5     _1_items -> _1_items _1_item
Rule 6     _1_items -> _1_item
Rule 7     _1_item -> expr
Rule 8     expr -> tuple
Rule 9     expr -> array
Rule 10    expr -> binary_expr
Rule 11    expr -> variable_declaration
Rule 12    expr -> case_of
Rule 13    expr -> call
Rule 14    expr -> _if
Rule 15    expr -> _def
Rule 16    expr -> literal
Rule 17    expr -> identifier
Rule 18    expr -> do
Rule 19    binary_expr -> ( binary_expr )
Rule 20    binary_expr -> expr INT_DIV expr
Rule 21    binary_expr -> expr / expr
Rule 22    binary_expr -> expr - expr
Rule 23    binary_expr -> expr + expr
Rule 24    binary_expr -> expr CONCAT expr
Rule 25    do -> _2_optional DO expressions END
Rule 26    _2_optional -> type
Rule 27    _2_optional -> <empty>
Rule 28    _def -> DEF IDENTIFIER ( params ) do
Rule 29    type -> % IDENTIFIER _3_optional
Rule 30    _3_optional -> < IDENTIFIER _4_repeat >
Rule 31    _4_repeat -> _4_items
Rule 32    _4_repeat -> <empty>
Rule 33    _4_items -> _4_items _4_item
Rule 34    _4_items -> _4_item
Rule 35    _4_item -> , IDENTIFIER
Rule 36    _3_optional -> <empty>
Rule 37    params -> _5_optional _6_repeat
Rule 38    _5_optional -> param
Rule 39    _5_optional -> <empty>
Rule 40    _6_repeat -> _6_items
Rule 41    _6_repeat -> <empty>
Rule 42    _6_items -> _6_items _6_item
Rule 43    _6_items -> _6_item
Rule 44    _6_item -> , param
Rule 45    param -> _7_optional identifier
Rule 46    _7_optional -> type
Rule 47    _7_optional -> <empty>
Rule 48    _if -> IF expr DO expressions _8_repeat _9_optional END
Rule 49    _8_repeat -> _8_items
Rule 50    _8_repeat -> <empty>
Rule 51    _8_items -> _8_items _8_item
Rule 52    _8_items -> _8_item
Rule 53    _8_item -> _elif
Rule 54    _9_optional -> ELSE expressions
Rule 55    _9_optional -> <empty>
Rule 56    _elif -> ELIF expr DO expressions
Rule 57    case_of -> CASE expr OF case _10_repeat END
Rule 58    _10_repeat -> _10_items
Rule 59    _10_repeat -> <empty>
Rule 60    _10_items -> _10_items _10_item
Rule 61    _10_items -> _10_item
Rule 62    _10_item -> case
Rule 63    case -> pattern _11_repeat do
Rule 64    _11_repeat -> _11_items
Rule 65    _11_repeat -> <empty>
Rule 66    _11_items -> _11_items _11_item
Rule 67    _11_items -> _11_item
Rule 68    _11_item -> , pattern
Rule 69    pattern -> array_pattern
Rule 70    pattern -> tuple_pattern
Rule 71    pattern -> identifier _12_optional
Rule 72    _12_optional -> ( pattern _13_repeat )
Rule 73    _13_repeat -> _13_items
Rule 74    _13_repeat -> <empty>
Rule 75    _13_items -> _13_items _13_item
Rule 76    _13_items -> _13_item
Rule 77    _13_item -> , pattern
Rule 78    _12_optional -> <empty>
Rule 79    array_pattern -> [ _14_repeat _15_optional ]
Rule 80    _14_repeat -> _14_items
Rule 81    _14_repeat -> <empty>
Rule 82    _14_items -> _14_items _14_item
Rule 83    _14_items -> _14_item
Rule 84    _14_item -> pattern ,
Rule 85    _15_optional -> SPREAD identifier _16_repeat
Rule 86    _16_repeat -> _16_items
Rule 87    _16_repeat -> <empty>
Rule 88    _16_items -> _16_items _16_item
Rule 89    _16_items -> _16_item
Rule 90    _16_item -> , pattern
Rule 91    _15_optional -> <empty>
Rule 92    tuple_pattern -> { _17_optional _18_repeat _19_optional }
Rule 93    _17_optional -> pattern
Rule 94    _17_optional -> <empty>
Rule 95    _18_repeat -> _18_items
Rule 96    _18_repeat -> <empty>
Rule 97    _18_items -> _18_items _18_item
Rule 98    _18_items -> _18_item
Rule 99    _18_item -> , pattern
Rule 100   _19_optional -> SPREAD identifier _20_repeat
Rule 101   _20_repeat -> _20_items
Rule 102   _20_repeat -> <empty>
Rule 103   _20_items -> _20_items _20_item
Rule 104   _20_items -> _20_item
Rule 105   _20_item -> , pattern
Rule 106   _19_optional -> <empty>
Rule 107   array -> [ _21_optional _22_repeat ]
Rule 108   _21_optional -> expr
Rule 109   _21_optional -> <empty>
Rule 110   _22_repeat -> _22_items
Rule 111   _22_repeat -> <empty>
Rule 112   _22_items -> _22_items _22_item
Rule 113   _22_items -> _22_item
Rule 114   _22_item -> , expr
Rule 115   tuple -> { _23_optional _24_repeat }
Rule 116   _23_optional -> expr
Rule 117   _23_optional -> <empty>
Rule 118   _24_repeat -> _24_items
Rule 119   _24_repeat -> <empty>
Rule 120   _24_items -> _24_items _24_item
Rule 121   _24_items -> _24_item
Rule 122   _24_item -> , expr
Rule 123   call -> callee ( _25_optional _26_repeat )
Rule 124   _25_optional -> expr
Rule 125   _25_optional -> <empty>
Rule 126   _26_repeat -> _26_items
Rule 127   _26_repeat -> <empty>
Rule 128   _26_items -> _26_items _26_item
Rule 129   _26_items -> _26_item
Rule 130   _26_item -> , expr
Rule 131   callee -> identifier
Rule 132   identifier -> IDENTIFIER
Rule 133   variable_declaration -> identifier = expr
Rule 134   literal -> NUMBER
Rule 135   literal -> STRING

Unused terminals:

    NEWLINE
    COMMENT

Terminals, with rules where they appear:

%                    : 29
(                    : 19 28 72 123
)                    : 19 28 72 123
+                    : 23
,                    : 35 44 68 77 84 90 99 105 114 122 130
-                    : 22
/                    : 21
<                    : 30
=                    : 133
>                    : 30
CASE                 : 57
COMMENT              : 
CONCAT               : 24
DEF                  : 28
DO                   : 25 48 56
ELIF                 : 56
ELSE                 : 54
END                  : 25 48 57
IDENTIFIER           : 28 29 30 35 132
IF                   : 48
INT_DIV              : 20
NEWLINE              : 
NUMBER               : 134
OF                   : 57
SPREAD               : 85 100
STRING               : 135
[                    : 79 107
]                    : 79 107
error                : 
{                    : 92 115
}                    : 92 115

Nonterminals, with rules where they appear:

_10_item             : 60 61
_10_items            : 58 60
_10_repeat           : 57
_11_item             : 66 67
_11_items            : 64 66
_11_repeat           : 63
_12_optional         : 71
_13_item             : 75 76
_13_items            : 73 75
_13_repeat           : 72
_14_item             : 82 83
_14_items            : 80 82
_14_repeat           : 79
_15_optional         : 79
_16_item             : 88 89
_16_items            : 86 88
_16_repeat           : 85
_17_optional         : 92
_18_item             : 97 98
_18_items            : 95 97
_18_repeat           : 92
_19_optional         : 92
_1_item              : 5 6
_1_items             : 3 5
_1_repeat            : 2
_20_item             : 103 104
_20_items            : 101 103
_20_repeat           : 100
_21_optional         : 107
_22_item             : 112 113
_22_items            : 110 112
_22_repeat           : 107
_23_optional         : 115
_24_item             : 120 121
_24_items            : 118 120
_24_repeat           : 115
_25_optional         : 123
_26_item             : 128 129
_26_items            : 126 128
_26_repeat           : 123
_2_optional          : 25
_3_optional          : 29
_4_item              : 33 34
_4_items             : 31 33
_4_repeat            : 30
_5_optional          : 37
_6_item              : 42 43
_6_items             : 40 42
_6_repeat            : 37
_7_optional          : 45
_8_item              : 51 52
_8_items             : 49 51
_8_repeat            : 48
_9_optional          : 48
_def                 : 15
_elif                : 53
_if                  : 14
array                : 9
array_pattern        : 69
binary_expr          : 10 19
call                 : 13
callee               : 123
case                 : 57 62
case_of              : 12
do                   : 18 28 63
expr                 : 7 20 20 21 21 22 22 23 23 24 24 48 56 57 108 114 116 122 124 130 133
expressions          : 1 25 48 54 56
identifier           : 17 45 71 85 100 131 133
literal              : 16
param                : 38 44
params               : 28
pattern              : 63 68 72 77 84 90 93 99 105
program              : 0
tuple                : 8
tuple_pattern        : 70
type                 : 26 46
variable_declaration : 11


state 0

    (0) S' -> . program
    (1) program -> . expressions
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    $end            reduce using rule 4 (_1_repeat -> .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    program                        shift and go to state 1
    expressions                    shift and go to state 2
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    expr                           shift and go to state 6
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 1

    (0) S' -> program .


state 2

    (1) program -> expressions .
    $end            reduce using rule 1 (program -> expressions .)


state 3

    (2) expressions -> _1_repeat .
    $end            reduce using rule 2 (expressions -> _1_repeat .)
    END             reduce using rule 2 (expressions -> _1_repeat .)
    ELIF            reduce using rule 2 (expressions -> _1_repeat .)
    ELSE            reduce using rule 2 (expressions -> _1_repeat .)


state 4

    (3) _1_repeat -> _1_items .
    (5) _1_items -> _1_items . _1_item
    (7) _1_item -> . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    $end            reduce using rule 3 (_1_repeat -> _1_items .)
    END             reduce using rule 3 (_1_repeat -> _1_items .)
    ELIF            reduce using rule 3 (_1_repeat -> _1_items .)
    ELSE            reduce using rule 3 (_1_repeat -> _1_items .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    _1_item                        shift and go to state 31
    expr                           shift and go to state 6
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 5

    (6) _1_items -> _1_item .
    {               reduce using rule 6 (_1_items -> _1_item .)
    [               reduce using rule 6 (_1_items -> _1_item .)
    (               reduce using rule 6 (_1_items -> _1_item .)
    CASE            reduce using rule 6 (_1_items -> _1_item .)
    IF              reduce using rule 6 (_1_items -> _1_item .)
    DEF             reduce using rule 6 (_1_items -> _1_item .)
    NUMBER          reduce using rule 6 (_1_items -> _1_item .)
    STRING          reduce using rule 6 (_1_items -> _1_item .)
    IDENTIFIER      reduce using rule 6 (_1_items -> _1_item .)
    %               reduce using rule 6 (_1_items -> _1_item .)
    DO              reduce using rule 6 (_1_items -> _1_item .)
    $end            reduce using rule 6 (_1_items -> _1_item .)
    END             reduce using rule 6 (_1_items -> _1_item .)
    ELIF            reduce using rule 6 (_1_items -> _1_item .)
    ELSE            reduce using rule 6 (_1_items -> _1_item .)


state 6

    (7) _1_item -> expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    {               reduce using rule 7 (_1_item -> expr .)
    [               reduce using rule 7 (_1_item -> expr .)
    (               reduce using rule 7 (_1_item -> expr .)
    CASE            reduce using rule 7 (_1_item -> expr .)
    IF              reduce using rule 7 (_1_item -> expr .)
    DEF             reduce using rule 7 (_1_item -> expr .)
    NUMBER          reduce using rule 7 (_1_item -> expr .)
    STRING          reduce using rule 7 (_1_item -> expr .)
    IDENTIFIER      reduce using rule 7 (_1_item -> expr .)
    %               reduce using rule 7 (_1_item -> expr .)
    DO              reduce using rule 7 (_1_item -> expr .)
    $end            reduce using rule 7 (_1_item -> expr .)
    END             reduce using rule 7 (_1_item -> expr .)
    ELIF            reduce using rule 7 (_1_item -> expr .)
    ELSE            reduce using rule 7 (_1_item -> expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 7

    (8) expr -> tuple .
    INT_DIV         reduce using rule 8 (expr -> tuple .)
    /               reduce using rule 8 (expr -> tuple .)
    -               reduce using rule 8 (expr -> tuple .)
    +               reduce using rule 8 (expr -> tuple .)
    CONCAT          reduce using rule 8 (expr -> tuple .)
    {               reduce using rule 8 (expr -> tuple .)
    [               reduce using rule 8 (expr -> tuple .)
    (               reduce using rule 8 (expr -> tuple .)
    CASE            reduce using rule 8 (expr -> tuple .)
    IF              reduce using rule 8 (expr -> tuple .)
    DEF             reduce using rule 8 (expr -> tuple .)
    NUMBER          reduce using rule 8 (expr -> tuple .)
    STRING          reduce using rule 8 (expr -> tuple .)
    IDENTIFIER      reduce using rule 8 (expr -> tuple .)
    %               reduce using rule 8 (expr -> tuple .)
    DO              reduce using rule 8 (expr -> tuple .)
    $end            reduce using rule 8 (expr -> tuple .)
    END             reduce using rule 8 (expr -> tuple .)
    ELIF            reduce using rule 8 (expr -> tuple .)
    ELSE            reduce using rule 8 (expr -> tuple .)
    ,               reduce using rule 8 (expr -> tuple .)
    }               reduce using rule 8 (expr -> tuple .)
    ]               reduce using rule 8 (expr -> tuple .)
    OF              reduce using rule 8 (expr -> tuple .)
    )               reduce using rule 8 (expr -> tuple .)


state 8

    (9) expr -> array .
    INT_DIV         reduce using rule 9 (expr -> array .)
    /               reduce using rule 9 (expr -> array .)
    -               reduce using rule 9 (expr -> array .)
    +               reduce using rule 9 (expr -> array .)
    CONCAT          reduce using rule 9 (expr -> array .)
    {               reduce using rule 9 (expr -> array .)
    [               reduce using rule 9 (expr -> array .)
    (               reduce using rule 9 (expr -> array .)
    CASE            reduce using rule 9 (expr -> array .)
    IF              reduce using rule 9 (expr -> array .)
    DEF             reduce using rule 9 (expr -> array .)
    NUMBER          reduce using rule 9 (expr -> array .)
    STRING          reduce using rule 9 (expr -> array .)
    IDENTIFIER      reduce using rule 9 (expr -> array .)
    %               reduce using rule 9 (expr -> array .)
    DO              reduce using rule 9 (expr -> array .)
    $end            reduce using rule 9 (expr -> array .)
    END             reduce using rule 9 (expr -> array .)
    ELIF            reduce using rule 9 (expr -> array .)
    ELSE            reduce using rule 9 (expr -> array .)
    ,               reduce using rule 9 (expr -> array .)
    }               reduce using rule 9 (expr -> array .)
    ]               reduce using rule 9 (expr -> array .)
    OF              reduce using rule 9 (expr -> array .)
    )               reduce using rule 9 (expr -> array .)


state 9

    (10) expr -> binary_expr .
    INT_DIV         reduce using rule 10 (expr -> binary_expr .)
    /               reduce using rule 10 (expr -> binary_expr .)
    -               reduce using rule 10 (expr -> binary_expr .)
    +               reduce using rule 10 (expr -> binary_expr .)
    CONCAT          reduce using rule 10 (expr -> binary_expr .)
    {               reduce using rule 10 (expr -> binary_expr .)
    [               reduce using rule 10 (expr -> binary_expr .)
    (               reduce using rule 10 (expr -> binary_expr .)
    CASE            reduce using rule 10 (expr -> binary_expr .)
    IF              reduce using rule 10 (expr -> binary_expr .)
    DEF             reduce using rule 10 (expr -> binary_expr .)
    NUMBER          reduce using rule 10 (expr -> binary_expr .)
    STRING          reduce using rule 10 (expr -> binary_expr .)
    IDENTIFIER      reduce using rule 10 (expr -> binary_expr .)
    %               reduce using rule 10 (expr -> binary_expr .)
    DO              reduce using rule 10 (expr -> binary_expr .)
    $end            reduce using rule 10 (expr -> binary_expr .)
    END             reduce using rule 10 (expr -> binary_expr .)
    ELIF            reduce using rule 10 (expr -> binary_expr .)
    ELSE            reduce using rule 10 (expr -> binary_expr .)
    ,               reduce using rule 10 (expr -> binary_expr .)
    }               reduce using rule 10 (expr -> binary_expr .)
    ]               reduce using rule 10 (expr -> binary_expr .)
    OF              reduce using rule 10 (expr -> binary_expr .)
    )               reduce using rule 10 (expr -> binary_expr .)


state 10

    (11) expr -> variable_declaration .
    INT_DIV         reduce using rule 11 (expr -> variable_declaration .)
    /               reduce using rule 11 (expr -> variable_declaration .)
    -               reduce using rule 11 (expr -> variable_declaration .)
    +               reduce using rule 11 (expr -> variable_declaration .)
    CONCAT          reduce using rule 11 (expr -> variable_declaration .)
    {               reduce using rule 11 (expr -> variable_declaration .)
    [               reduce using rule 11 (expr -> variable_declaration .)
    (               reduce using rule 11 (expr -> variable_declaration .)
    CASE            reduce using rule 11 (expr -> variable_declaration .)
    IF              reduce using rule 11 (expr -> variable_declaration .)
    DEF             reduce using rule 11 (expr -> variable_declaration .)
    NUMBER          reduce using rule 11 (expr -> variable_declaration .)
    STRING          reduce using rule 11 (expr -> variable_declaration .)
    IDENTIFIER      reduce using rule 11 (expr -> variable_declaration .)
    %               reduce using rule 11 (expr -> variable_declaration .)
    DO              reduce using rule 11 (expr -> variable_declaration .)
    $end            reduce using rule 11 (expr -> variable_declaration .)
    END             reduce using rule 11 (expr -> variable_declaration .)
    ELIF            reduce using rule 11 (expr -> variable_declaration .)
    ELSE            reduce using rule 11 (expr -> variable_declaration .)
    ,               reduce using rule 11 (expr -> variable_declaration .)
    }               reduce using rule 11 (expr -> variable_declaration .)
    ]               reduce using rule 11 (expr -> variable_declaration .)
    OF              reduce using rule 11 (expr -> variable_declaration .)
    )               reduce using rule 11 (expr -> variable_declaration .)


state 11

    (12) expr -> case_of .
    INT_DIV         reduce using rule 12 (expr -> case_of .)
    /               reduce using rule 12 (expr -> case_of .)
    -               reduce using rule 12 (expr -> case_of .)
    +               reduce using rule 12 (expr -> case_of .)
    CONCAT          reduce using rule 12 (expr -> case_of .)
    {               reduce using rule 12 (expr -> case_of .)
    [               reduce using rule 12 (expr -> case_of .)
    (               reduce using rule 12 (expr -> case_of .)
    CASE            reduce using rule 12 (expr -> case_of .)
    IF              reduce using rule 12 (expr -> case_of .)
    DEF             reduce using rule 12 (expr -> case_of .)
    NUMBER          reduce using rule 12 (expr -> case_of .)
    STRING          reduce using rule 12 (expr -> case_of .)
    IDENTIFIER      reduce using rule 12 (expr -> case_of .)
    %               reduce using rule 12 (expr -> case_of .)
    DO              reduce using rule 12 (expr -> case_of .)
    $end            reduce using rule 12 (expr -> case_of .)
    END             reduce using rule 12 (expr -> case_of .)
    ELIF            reduce using rule 12 (expr -> case_of .)
    ELSE            reduce using rule 12 (expr -> case_of .)
    ,               reduce using rule 12 (expr -> case_of .)
    }               reduce using rule 12 (expr -> case_of .)
    ]               reduce using rule 12 (expr -> case_of .)
    OF              reduce using rule 12 (expr -> case_of .)
    )               reduce using rule 12 (expr -> case_of .)


state 12

    (13) expr -> call .
    INT_DIV         reduce using rule 13 (expr -> call .)
    /               reduce using rule 13 (expr -> call .)
    -               reduce using rule 13 (expr -> call .)
    +               reduce using rule 13 (expr -> call .)
    CONCAT          reduce using rule 13 (expr -> call .)
    {               reduce using rule 13 (expr -> call .)
    [               reduce using rule 13 (expr -> call .)
    (               reduce using rule 13 (expr -> call .)
    CASE            reduce using rule 13 (expr -> call .)
    IF              reduce using rule 13 (expr -> call .)
    DEF             reduce using rule 13 (expr -> call .)
    NUMBER          reduce using rule 13 (expr -> call .)
    STRING          reduce using rule 13 (expr -> call .)
    IDENTIFIER      reduce using rule 13 (expr -> call .)
    %               reduce using rule 13 (expr -> call .)
    DO              reduce using rule 13 (expr -> call .)
    $end            reduce using rule 13 (expr -> call .)
    END             reduce using rule 13 (expr -> call .)
    ELIF            reduce using rule 13 (expr -> call .)
    ELSE            reduce using rule 13 (expr -> call .)
    ,               reduce using rule 13 (expr -> call .)
    }               reduce using rule 13 (expr -> call .)
    ]               reduce using rule 13 (expr -> call .)
    OF              reduce using rule 13 (expr -> call .)
    )               reduce using rule 13 (expr -> call .)


state 13

    (14) expr -> _if .
    INT_DIV         reduce using rule 14 (expr -> _if .)
    /               reduce using rule 14 (expr -> _if .)
    -               reduce using rule 14 (expr -> _if .)
    +               reduce using rule 14 (expr -> _if .)
    CONCAT          reduce using rule 14 (expr -> _if .)
    {               reduce using rule 14 (expr -> _if .)
    [               reduce using rule 14 (expr -> _if .)
    (               reduce using rule 14 (expr -> _if .)
    CASE            reduce using rule 14 (expr -> _if .)
    IF              reduce using rule 14 (expr -> _if .)
    DEF             reduce using rule 14 (expr -> _if .)
    NUMBER          reduce using rule 14 (expr -> _if .)
    STRING          reduce using rule 14 (expr -> _if .)
    IDENTIFIER      reduce using rule 14 (expr -> _if .)
    %               reduce using rule 14 (expr -> _if .)
    DO              reduce using rule 14 (expr -> _if .)
    $end            reduce using rule 14 (expr -> _if .)
    END             reduce using rule 14 (expr -> _if .)
    ELIF            reduce using rule 14 (expr -> _if .)
    ELSE            reduce using rule 14 (expr -> _if .)
    ,               reduce using rule 14 (expr -> _if .)
    }               reduce using rule 14 (expr -> _if .)
    ]               reduce using rule 14 (expr -> _if .)
    OF              reduce using rule 14 (expr -> _if .)
    )               reduce using rule 14 (expr -> _if .)


state 14

    (15) expr -> _def .
    INT_DIV         reduce using rule 15 (expr -> _def .)
    /               reduce using rule 15 (expr -> _def .)
    -               reduce using rule 15 (expr -> _def .)
    +               reduce using rule 15 (expr -> _def .)
    CONCAT          reduce using rule 15 (expr -> _def .)
    {               reduce using rule 15 (expr -> _def .)
    [               reduce using rule 15 (expr -> _def .)
    (               reduce using rule 15 (expr -> _def .)
    CASE            reduce using rule 15 (expr -> _def .)
    IF              reduce using rule 15 (expr -> _def .)
    DEF             reduce using rule 15 (expr -> _def .)
    NUMBER          reduce using rule 15 (expr -> _def .)
    STRING          reduce using rule 15 (expr -> _def .)
    IDENTIFIER      reduce using rule 15 (expr -> _def .)
    %               reduce using rule 15 (expr -> _def .)
    DO              reduce using rule 15 (expr -> _def .)
    $end            reduce using rule 15 (expr -> _def .)
    END             reduce using rule 15 (expr -> _def .)
    ELIF            reduce using rule 15 (expr -> _def .)
    ELSE            reduce using rule 15 (expr -> _def .)
    ,               reduce using rule 15 (expr -> _def .)
    }               reduce using rule 15 (expr -> _def .)
    ]               reduce using rule 15 (expr -> _def .)
    OF              reduce using rule 15 (expr -> _def .)
    )               reduce using rule 15 (expr -> _def .)


state 15

    (16) expr -> literal .
    INT_DIV         reduce using rule 16 (expr -> literal .)
    /               reduce using rule 16 (expr -> literal .)
    -               reduce using rule 16 (expr -> literal .)
    +               reduce using rule 16 (expr -> literal .)
    CONCAT          reduce using rule 16 (expr -> literal .)
    {               reduce using rule 16 (expr -> literal .)
    [               reduce using rule 16 (expr -> literal .)
    (               reduce using rule 16 (expr -> literal .)
    CASE            reduce using rule 16 (expr -> literal .)
    IF              reduce using rule 16 (expr -> literal .)
    DEF             reduce using rule 16 (expr -> literal .)
    NUMBER          reduce using rule 16 (expr -> literal .)
    STRING          reduce using rule 16 (expr -> literal .)
    IDENTIFIER      reduce using rule 16 (expr -> literal .)
    %               reduce using rule 16 (expr -> literal .)
    DO              reduce using rule 16 (expr -> literal .)
    $end            reduce using rule 16 (expr -> literal .)
    END             reduce using rule 16 (expr -> literal .)
    ELIF            reduce using rule 16 (expr -> literal .)
    ELSE            reduce using rule 16 (expr -> literal .)
    ,               reduce using rule 16 (expr -> literal .)
    }               reduce using rule 16 (expr -> literal .)
    ]               reduce using rule 16 (expr -> literal .)
    OF              reduce using rule 16 (expr -> literal .)
    )               reduce using rule 16 (expr -> literal .)


state 16

    (17) expr -> identifier .
    (133) variable_declaration -> identifier . = expr
    (131) callee -> identifier .
  ! reduce/reduce conflict for ( resolved using rule 17 (expr -> identifier .)
    INT_DIV         reduce using rule 17 (expr -> identifier .)
    /               reduce using rule 17 (expr -> identifier .)
    -               reduce using rule 17 (expr -> identifier .)
    +               reduce using rule 17 (expr -> identifier .)
    CONCAT          reduce using rule 17 (expr -> identifier .)
    {               reduce using rule 17 (expr -> identifier .)
    [               reduce using rule 17 (expr -> identifier .)
    (               reduce using rule 17 (expr -> identifier .)
    CASE            reduce using rule 17 (expr -> identifier .)
    IF              reduce using rule 17 (expr -> identifier .)
    DEF             reduce using rule 17 (expr -> identifier .)
    NUMBER          reduce using rule 17 (expr -> identifier .)
    STRING          reduce using rule 17 (expr -> identifier .)
    IDENTIFIER      reduce using rule 17 (expr -> identifier .)
    %               reduce using rule 17 (expr -> identifier .)
    DO              reduce using rule 17 (expr -> identifier .)
    $end            reduce using rule 17 (expr -> identifier .)
    END             reduce using rule 17 (expr -> identifier .)
    ELIF            reduce using rule 17 (expr -> identifier .)
    ELSE            reduce using rule 17 (expr -> identifier .)
    ,               reduce using rule 17 (expr -> identifier .)
    }               reduce using rule 17 (expr -> identifier .)
    ]               reduce using rule 17 (expr -> identifier .)
    OF              reduce using rule 17 (expr -> identifier .)
    )               reduce using rule 17 (expr -> identifier .)
    =               shift and go to state 37


state 17

    (18) expr -> do .
    INT_DIV         reduce using rule 18 (expr -> do .)
    /               reduce using rule 18 (expr -> do .)
    -               reduce using rule 18 (expr -> do .)
    +               reduce using rule 18 (expr -> do .)
    CONCAT          reduce using rule 18 (expr -> do .)
    {               reduce using rule 18 (expr -> do .)
    [               reduce using rule 18 (expr -> do .)
    (               reduce using rule 18 (expr -> do .)
    CASE            reduce using rule 18 (expr -> do .)
    IF              reduce using rule 18 (expr -> do .)
    DEF             reduce using rule 18 (expr -> do .)
    NUMBER          reduce using rule 18 (expr -> do .)
    STRING          reduce using rule 18 (expr -> do .)
    IDENTIFIER      reduce using rule 18 (expr -> do .)
    %               reduce using rule 18 (expr -> do .)
    DO              reduce using rule 18 (expr -> do .)
    $end            reduce using rule 18 (expr -> do .)
    END             reduce using rule 18 (expr -> do .)
    ELIF            reduce using rule 18 (expr -> do .)
    ELSE            reduce using rule 18 (expr -> do .)
    ,               reduce using rule 18 (expr -> do .)
    }               reduce using rule 18 (expr -> do .)
    ]               reduce using rule 18 (expr -> do .)
    OF              reduce using rule 18 (expr -> do .)
    )               reduce using rule 18 (expr -> do .)


state 18

    (115) tuple -> { . _23_optional _24_repeat }
    (116) _23_optional -> . expr
    (117) _23_optional -> .
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    ,               reduce using rule 117 (_23_optional -> .)
    }               reduce using rule 117 (_23_optional -> .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    _23_optional                   shift and go to state 38
    expr                           shift and go to state 39
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 19

    (107) array -> [ . _21_optional _22_repeat ]
    (108) _21_optional -> . expr
    (109) _21_optional -> .
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    ,               reduce using rule 109 (_21_optional -> .)
    ]               reduce using rule 109 (_21_optional -> .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    _21_optional                   shift and go to state 40
    expr                           shift and go to state 41
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 20

    (19) binary_expr -> ( . binary_expr )
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    (               shift and go to state 20
    {               shift and go to state 18
    [               shift and go to state 19
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    binary_expr                    shift and go to state 42
    expr                           shift and go to state 43
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 21

    (57) case_of -> CASE . expr OF case _10_repeat END
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 44
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 22

    (123) call -> callee . ( _25_optional _26_repeat )
    (               shift and go to state 45


state 23

    (48) _if -> IF . expr DO expressions _8_repeat _9_optional END
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 46
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 24

    (28) _def -> DEF . IDENTIFIER ( params ) do
    IDENTIFIER      shift and go to state 47


state 25

    (132) identifier -> IDENTIFIER .
    =               reduce using rule 132 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 132 (identifier -> IDENTIFIER .)
    /               reduce using rule 132 (identifier -> IDENTIFIER .)
    -               reduce using rule 132 (identifier -> IDENTIFIER .)
    +               reduce using rule 132 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 132 (identifier -> IDENTIFIER .)
    {               reduce using rule 132 (identifier -> IDENTIFIER .)
    [               reduce using rule 132 (identifier -> IDENTIFIER .)
    (               reduce using rule 132 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 132 (identifier -> IDENTIFIER .)
    IF              reduce using rule 132 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 132 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 132 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 132 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 132 (identifier -> IDENTIFIER .)
    %               reduce using rule 132 (identifier -> IDENTIFIER .)
    DO              reduce using rule 132 (identifier -> IDENTIFIER .)
    $end            reduce using rule 132 (identifier -> IDENTIFIER .)
    END             reduce using rule 132 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 132 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 132 (identifier -> IDENTIFIER .)
    ,               reduce using rule 132 (identifier -> IDENTIFIER .)
    }               reduce using rule 132 (identifier -> IDENTIFIER .)
    ]               reduce using rule 132 (identifier -> IDENTIFIER .)
    OF              reduce using rule 132 (identifier -> IDENTIFIER .)
    )               reduce using rule 132 (identifier -> IDENTIFIER .)
    SPREAD          reduce using rule 132 (identifier -> IDENTIFIER .)


state 26

    (134) literal -> NUMBER .
    INT_DIV         reduce using rule 134 (literal -> NUMBER .)
    /               reduce using rule 134 (literal -> NUMBER .)
    -               reduce using rule 134 (literal -> NUMBER .)
    +               reduce using rule 134 (literal -> NUMBER .)
    CONCAT          reduce using rule 134 (literal -> NUMBER .)
    {               reduce using rule 134 (literal -> NUMBER .)
    [               reduce using rule 134 (literal -> NUMBER .)
    (               reduce using rule 134 (literal -> NUMBER .)
    CASE            reduce using rule 134 (literal -> NUMBER .)
    IF              reduce using rule 134 (literal -> NUMBER .)
    DEF             reduce using rule 134 (literal -> NUMBER .)
    NUMBER          reduce using rule 134 (literal -> NUMBER .)
    STRING          reduce using rule 134 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 134 (literal -> NUMBER .)
    %               reduce using rule 134 (literal -> NUMBER .)
    DO              reduce using rule 134 (literal -> NUMBER .)
    $end            reduce using rule 134 (literal -> NUMBER .)
    END             reduce using rule 134 (literal -> NUMBER .)
    ELIF            reduce using rule 134 (literal -> NUMBER .)
    ELSE            reduce using rule 134 (literal -> NUMBER .)
    ,               reduce using rule 134 (literal -> NUMBER .)
    }               reduce using rule 134 (literal -> NUMBER .)
    ]               reduce using rule 134 (literal -> NUMBER .)
    OF              reduce using rule 134 (literal -> NUMBER .)
    )               reduce using rule 134 (literal -> NUMBER .)


state 27

    (135) literal -> STRING .
    INT_DIV         reduce using rule 135 (literal -> STRING .)
    /               reduce using rule 135 (literal -> STRING .)
    -               reduce using rule 135 (literal -> STRING .)
    +               reduce using rule 135 (literal -> STRING .)
    CONCAT          reduce using rule 135 (literal -> STRING .)
    {               reduce using rule 135 (literal -> STRING .)
    [               reduce using rule 135 (literal -> STRING .)
    (               reduce using rule 135 (literal -> STRING .)
    CASE            reduce using rule 135 (literal -> STRING .)
    IF              reduce using rule 135 (literal -> STRING .)
    DEF             reduce using rule 135 (literal -> STRING .)
    NUMBER          reduce using rule 135 (literal -> STRING .)
    STRING          reduce using rule 135 (literal -> STRING .)
    IDENTIFIER      reduce using rule 135 (literal -> STRING .)
    %               reduce using rule 135 (literal -> STRING .)
    DO              reduce using rule 135 (literal -> STRING .)
    $end            reduce using rule 135 (literal -> STRING .)
    END             reduce using rule 135 (literal -> STRING .)
    ELIF            reduce using rule 135 (literal -> STRING .)
    ELSE            reduce using rule 135 (literal -> STRING .)
    ,               reduce using rule 135 (literal -> STRING .)
    }               reduce using rule 135 (literal -> STRING .)
    ]               reduce using rule 135 (literal -> STRING .)
    OF              reduce using rule 135 (literal -> STRING .)
    )               reduce using rule 135 (literal -> STRING .)


state 28

    (25) do -> _2_optional . DO expressions END
    DO              shift and go to state 48


state 29

    (26) _2_optional -> type .
    DO              reduce using rule 26 (_2_optional -> type .)


state 30

    (29) type -> % . IDENTIFIER _3_optional
    IDENTIFIER      shift and go to state 49


state 31

    (5) _1_items -> _1_items _1_item .
    {               reduce using rule 5 (_1_items -> _1_items _1_item .)
    [               reduce using rule 5 (_1_items -> _1_items _1_item .)
    (               reduce using rule 5 (_1_items -> _1_items _1_item .)
    CASE            reduce using rule 5 (_1_items -> _1_items _1_item .)
    IF              reduce using rule 5 (_1_items -> _1_items _1_item .)
    DEF             reduce using rule 5 (_1_items -> _1_items _1_item .)
    NUMBER          reduce using rule 5 (_1_items -> _1_items _1_item .)
    STRING          reduce using rule 5 (_1_items -> _1_items _1_item .)
    IDENTIFIER      reduce using rule 5 (_1_items -> _1_items _1_item .)
    %               reduce using rule 5 (_1_items -> _1_items _1_item .)
    DO              reduce using rule 5 (_1_items -> _1_items _1_item .)
    $end            reduce using rule 5 (_1_items -> _1_items _1_item .)
    END             reduce using rule 5 (_1_items -> _1_items _1_item .)
    ELIF            reduce using rule 5 (_1_items -> _1_items _1_item .)
    ELSE            reduce using rule 5 (_1_items -> _1_items _1_item .)


state 32

    (20) binary_expr -> expr INT_DIV . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 50
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 33

    (21) binary_expr -> expr / . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 51
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 34

    (22) binary_expr -> expr - . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 52
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 35

    (23) binary_expr -> expr + . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 53
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 36

    (24) binary_expr -> expr CONCAT . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 54
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 37

    (133) variable_declaration -> identifier = . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    identifier                     shift and go to state 16
    expr                           shift and go to state 55
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 38

    (115) tuple -> { _23_optional . _24_repeat }
    (118) _24_repeat -> . _24_items
    (119) _24_repeat -> .
    (120) _24_items -> . _24_items _24_item
    (121) _24_items -> . _24_item
    (122) _24_item -> . , expr
    }               reduce using rule 119 (_24_repeat -> .)
    ,               shift and go to state 59

    _24_repeat                     shift and go to state 56
    _24_items                      shift and go to state 57
    _24_item                       shift and go to state 58

state 39

    (116) _23_optional -> expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 116 (_23_optional -> expr .)
    }               reduce using rule 116 (_23_optional -> expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 40

    (107) array -> [ _21_optional . _22_repeat ]
    (110) _22_repeat -> . _22_items
    (111) _22_repeat -> .
    (112) _22_items -> . _22_items _22_item
    (113) _22_items -> . _22_item
    (114) _22_item -> . , expr
    ]               reduce using rule 111 (_22_repeat -> .)
    ,               shift and go to state 63

    _22_repeat                     shift and go to state 60
    _22_items                      shift and go to state 61
    _22_item                       shift and go to state 62

state 41

    (108) _21_optional -> expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 108 (_21_optional -> expr .)
    ]               reduce using rule 108 (_21_optional -> expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 42

    (19) binary_expr -> ( binary_expr . )
    (10) expr -> binary_expr .
    )               shift and go to state 64
    INT_DIV         reduce using rule 10 (expr -> binary_expr .)
    /               reduce using rule 10 (expr -> binary_expr .)
    -               reduce using rule 10 (expr -> binary_expr .)
    +               reduce using rule 10 (expr -> binary_expr .)
    CONCAT          reduce using rule 10 (expr -> binary_expr .)


state 43

    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 44

    (57) case_of -> CASE expr . OF case _10_repeat END
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 65
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 45

    (123) call -> callee ( . _25_optional _26_repeat )
    (124) _25_optional -> . expr
    (125) _25_optional -> .
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    ,               reduce using rule 125 (_25_optional -> .)
    )               reduce using rule 125 (_25_optional -> .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    callee                         shift and go to state 22
    _25_optional                   shift and go to state 66
    expr                           shift and go to state 67
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 46

    (48) _if -> IF expr . DO expressions _8_repeat _9_optional END
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    DO              shift and go to state 68
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 47

    (28) _def -> DEF IDENTIFIER . ( params ) do
    (               shift and go to state 69


state 48

    (25) do -> _2_optional DO . expressions END
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    END             reduce using rule 4 (_1_repeat -> .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    _2_optional                    shift and go to state 28
    expressions                    shift and go to state 70
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    expr                           shift and go to state 6
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    type                           shift and go to state 29

state 49

    (29) type -> % IDENTIFIER . _3_optional
    (30) _3_optional -> . < IDENTIFIER _4_repeat >
    (36) _3_optional -> .
    <               shift and go to state 72
    DO              reduce using rule 36 (_3_optional -> .)
    IDENTIFIER      reduce using rule 36 (_3_optional -> .)

    _3_optional                    shift and go to state 71

state 50

    (20) binary_expr -> expr INT_DIV expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    {               reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    [               reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    (               reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    CASE            reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    IF              reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    DEF             reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    NUMBER          reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    STRING          reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    IDENTIFIER      reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    %               reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    DO              reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    }               reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 20 (binary_expr -> expr INT_DIV expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 51

    (21) binary_expr -> expr / expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    {               reduce using rule 21 (binary_expr -> expr / expr .)
    [               reduce using rule 21 (binary_expr -> expr / expr .)
    (               reduce using rule 21 (binary_expr -> expr / expr .)
    CASE            reduce using rule 21 (binary_expr -> expr / expr .)
    IF              reduce using rule 21 (binary_expr -> expr / expr .)
    DEF             reduce using rule 21 (binary_expr -> expr / expr .)
    NUMBER          reduce using rule 21 (binary_expr -> expr / expr .)
    STRING          reduce using rule 21 (binary_expr -> expr / expr .)
    IDENTIFIER      reduce using rule 21 (binary_expr -> expr / expr .)
    %               reduce using rule 21 (binary_expr -> expr / expr .)
    DO              reduce using rule 21 (binary_expr -> expr / expr .)
    $end            reduce using rule 21 (binary_expr -> expr / expr .)
    END             reduce using rule 21 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 21 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 21 (binary_expr -> expr / expr .)
    ,               reduce using rule 21 (binary_expr -> expr / expr .)
    }               reduce using rule 21 (binary_expr -> expr / expr .)
    ]               reduce using rule 21 (binary_expr -> expr / expr .)
    )               reduce using rule 21 (binary_expr -> expr / expr .)
    OF              reduce using rule 21 (binary_expr -> expr / expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 52

    (22) binary_expr -> expr - expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    {               reduce using rule 22 (binary_expr -> expr - expr .)
    [               reduce using rule 22 (binary_expr -> expr - expr .)
    (               reduce using rule 22 (binary_expr -> expr - expr .)
    CASE            reduce using rule 22 (binary_expr -> expr - expr .)
    IF              reduce using rule 22 (binary_expr -> expr - expr .)
    DEF             reduce using rule 22 (binary_expr -> expr - expr .)
    NUMBER          reduce using rule 22 (binary_expr -> expr - expr .)
    STRING          reduce using rule 22 (binary_expr -> expr - expr .)
    IDENTIFIER      reduce using rule 22 (binary_expr -> expr - expr .)
    %               reduce using rule 22 (binary_expr -> expr - expr .)
    DO              reduce using rule 22 (binary_expr -> expr - expr .)
    $end            reduce using rule 22 (binary_expr -> expr - expr .)
    END             reduce using rule 22 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 22 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 22 (binary_expr -> expr - expr .)
    ,               reduce using rule 22 (binary_expr -> expr - expr .)
    }               reduce using rule 22 (binary_expr -> expr - expr .)
    ]               reduce using rule 22 (binary_expr -> expr - expr .)
    )               reduce using rule 22 (binary_expr -> expr - expr .)
    OF              reduce using rule 22 (binary_expr -> expr - expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 53

    (23) binary_expr -> expr + expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    {               reduce using rule 23 (binary_expr -> expr + expr .)
    [               reduce using rule 23 (binary_expr -> expr + expr .)
    (               reduce using rule 23 (binary_expr -> expr + expr .)
    CASE            reduce using rule 23 (binary_expr -> expr + expr .)
    IF              reduce using rule 23 (binary_expr -> expr + expr .)
    DEF             reduce using rule 23 (binary_expr -> expr + expr .)
    NUMBER          reduce using rule 23 (binary_expr -> expr + expr .)
    STRING          reduce using rule 23 (binary_expr -> expr + expr .)
    IDENTIFIER      reduce using rule 23 (binary_expr -> expr + expr .)
    %               reduce using rule 23 (binary_expr -> expr + expr .)
    DO              reduce using rule 23 (binary_expr -> expr + expr .)
    $end            reduce using rule 23 (binary_expr -> expr + expr .)
    END             reduce using rule 23 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 23 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 23 (binary_expr -> expr + expr .)
    ,               reduce using rule 23 (binary_expr -> expr + expr .)
    }               reduce using rule 23 (binary_expr -> expr + expr .)
    ]               reduce using rule 23 (binary_expr -> expr + expr .)
    )               reduce using rule 23 (binary_expr -> expr + expr .)
    OF              reduce using rule 23 (binary_expr -> expr + expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 54

    (24) binary_expr -> expr CONCAT expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    {               reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    [               reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    (               reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    CASE            reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    IF              reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    DEF             reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    NUMBER          reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    STRING          reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    IDENTIFIER      reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    %               reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    DO              reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    }               reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 24 (binary_expr -> expr CONCAT expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 55

    (133) variable_declaration -> identifier = expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    {               reduce using rule 133 (variable_declaration -> identifier = expr .)
    [               reduce using rule 133 (variable_declaration -> identifier = expr .)
    (               reduce using rule 133 (variable_declaration -> identifier = expr .)
    CASE            reduce using rule 133 (variable_declaration -> identifier = expr .)
    IF              reduce using rule 133 (variable_declaration -> identifier = expr .)
    DEF             reduce using rule 133 (variable_declaration -> identifier = expr .)
    NUMBER          reduce using rule 133 (variable_declaration -> identifier = expr .)
    STRING          reduce using rule 133 (variable_declaration -> identifier = expr .)
    IDENTIFIER      reduce using rule 133 (variable_declaration -> identifier = expr .)
    %               reduce using rule 133 (variable_declaration -> identifier = expr .)
    DO              reduce using rule 133 (variable_declaration -> identifier = expr .)
    $end            reduce using rule 133 (variable_declaration -> identifier = expr .)
    END             reduce using rule 133 (variable_declaration -> identifier = expr .)
    ELIF            reduce using rule 133 (variable_declaration -> identifier = expr .)
    ELSE            reduce using rule 133 (variable_declaration -> identifier = expr .)
    ,               reduce using rule 133 (variable_declaration -> identifier = expr .)
    }               reduce using rule 133 (variable_declaration -> identifier = expr .)
    ]               reduce using rule 133 (variable_declaration -> identifier = expr .)
    OF              reduce using rule 133 (variable_declaration -> identifier = expr .)
    )               reduce using rule 133 (variable_declaration -> identifier = expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 56

    (115) tuple -> { _23_optional _24_repeat . }
    }               shift and go to state 73


state 57

    (118) _24_repeat -> _24_items .
    (120) _24_items -> _24_items . _24_item
    (122) _24_item -> . , expr
    }               reduce using rule 118 (_24_repeat -> _24_items .)
    ,               shift and go to state 59

    _24_item                       shift and go to state 74

state 58

    (121) _24_items -> _24_item .
    ,               reduce using rule 121 (_24_items -> _24_item .)
    }               reduce using rule 121 (_24_items -> _24_item .)


state 59

    (122) _24_item -> , . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 75
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 60

    (107) array -> [ _21_optional _22_repeat . ]
    ]               shift and go to state 76


state 61

    (110) _22_repeat -> _22_items .
    (112) _22_items -> _22_items . _22_item
    (114) _22_item -> . , expr
    ]               reduce using rule 110 (_22_repeat -> _22_items .)
    ,               shift and go to state 63

    _22_item                       shift and go to state 77

state 62

    (113) _22_items -> _22_item .
    ,               reduce using rule 113 (_22_items -> _22_item .)
    ]               reduce using rule 113 (_22_items -> _22_item .)


state 63

    (114) _22_item -> , . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 78
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 64

    (19) binary_expr -> ( binary_expr ) .
    INT_DIV         reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    /               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    -               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    +               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    CONCAT          reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    {               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    [               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    (               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    CASE            reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    IF              reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    DEF             reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    NUMBER          reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    STRING          reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    IDENTIFIER      reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    %               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    DO              reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    $end            reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    END             reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    ELIF            reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    ELSE            reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    ,               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    }               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    ]               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    )               reduce using rule 19 (binary_expr -> ( binary_expr ) .)
    OF              reduce using rule 19 (binary_expr -> ( binary_expr ) .)


state 65

    (57) case_of -> CASE expr OF . case _10_repeat END
    (63) case -> . pattern _11_repeat do
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    case                           shift and go to state 79
    pattern                        shift and go to state 80
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 66

    (123) call -> callee ( _25_optional . _26_repeat )
    (126) _26_repeat -> . _26_items
    (127) _26_repeat -> .
    (128) _26_items -> . _26_items _26_item
    (129) _26_items -> . _26_item
    (130) _26_item -> . , expr
    )               reduce using rule 127 (_26_repeat -> .)
    ,               shift and go to state 89

    _26_repeat                     shift and go to state 86
    _26_items                      shift and go to state 87
    _26_item                       shift and go to state 88

state 67

    (124) _25_optional -> expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 124 (_25_optional -> expr .)
    )               reduce using rule 124 (_25_optional -> expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 68

    (48) _if -> IF expr DO . expressions _8_repeat _9_optional END
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    ELIF            reduce using rule 4 (_1_repeat -> .)
    ELSE            reduce using rule 4 (_1_repeat -> .)
    END             reduce using rule 4 (_1_repeat -> .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 6
    expressions                    shift and go to state 90
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 69

    (28) _def -> DEF IDENTIFIER ( . params ) do
    (37) params -> . _5_optional _6_repeat
    (38) _5_optional -> . param
    (39) _5_optional -> .
    (45) param -> . _7_optional identifier
    (46) _7_optional -> . type
    (47) _7_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    ,               reduce using rule 39 (_5_optional -> .)
    )               reduce using rule 39 (_5_optional -> .)
    IDENTIFIER      reduce using rule 47 (_7_optional -> .)
    %               shift and go to state 30

    params                         shift and go to state 91
    _5_optional                    shift and go to state 92
    param                          shift and go to state 93
    _7_optional                    shift and go to state 94
    type                           shift and go to state 95

state 70

    (25) do -> _2_optional DO expressions . END
    END             shift and go to state 96


state 71

    (29) type -> % IDENTIFIER _3_optional .
    DO              reduce using rule 29 (type -> % IDENTIFIER _3_optional .)
    IDENTIFIER      reduce using rule 29 (type -> % IDENTIFIER _3_optional .)


state 72

    (30) _3_optional -> < . IDENTIFIER _4_repeat >
    IDENTIFIER      shift and go to state 97


state 73

    (115) tuple -> { _23_optional _24_repeat } .
    INT_DIV         reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    /               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    -               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    +               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    CONCAT          reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    {               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    [               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    (               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    CASE            reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    IF              reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    DEF             reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    NUMBER          reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    STRING          reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    IDENTIFIER      reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    %               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    DO              reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    $end            reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    END             reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    ELIF            reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    ELSE            reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    ,               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    }               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    ]               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    OF              reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)
    )               reduce using rule 115 (tuple -> { _23_optional _24_repeat } .)


state 74

    (120) _24_items -> _24_items _24_item .
    ,               reduce using rule 120 (_24_items -> _24_items _24_item .)
    }               reduce using rule 120 (_24_items -> _24_items _24_item .)


state 75

    (122) _24_item -> , expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 122 (_24_item -> , expr .)
    }               reduce using rule 122 (_24_item -> , expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 76

    (107) array -> [ _21_optional _22_repeat ] .
    INT_DIV         reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    /               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    -               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    +               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    CONCAT          reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    {               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    [               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    (               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    CASE            reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    IF              reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    DEF             reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    NUMBER          reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    STRING          reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    IDENTIFIER      reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    %               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    DO              reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    $end            reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    END             reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    ELIF            reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    ELSE            reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    ,               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    }               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    ]               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    OF              reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)
    )               reduce using rule 107 (array -> [ _21_optional _22_repeat ] .)


state 77

    (112) _22_items -> _22_items _22_item .
    ,               reduce using rule 112 (_22_items -> _22_items _22_item .)
    ]               reduce using rule 112 (_22_items -> _22_items _22_item .)


state 78

    (114) _22_item -> , expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 114 (_22_item -> , expr .)
    ]               reduce using rule 114 (_22_item -> , expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 79

    (57) case_of -> CASE expr OF case . _10_repeat END
    (58) _10_repeat -> . _10_items
    (59) _10_repeat -> .
    (60) _10_items -> . _10_items _10_item
    (61) _10_items -> . _10_item
    (62) _10_item -> . case
    (63) case -> . pattern _11_repeat do
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    END             reduce using rule 59 (_10_repeat -> .)
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    case                           shift and go to state 98
    _10_repeat                     shift and go to state 99
    _10_items                      shift and go to state 100
    _10_item                       shift and go to state 101
    pattern                        shift and go to state 80
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 80

    (63) case -> pattern . _11_repeat do
    (64) _11_repeat -> . _11_items
    (65) _11_repeat -> .
    (66) _11_items -> . _11_items _11_item
    (67) _11_items -> . _11_item
    (68) _11_item -> . , pattern
    %               reduce using rule 65 (_11_repeat -> .)
    DO              reduce using rule 65 (_11_repeat -> .)
    ,               shift and go to state 105

    _11_repeat                     shift and go to state 102
    _11_items                      shift and go to state 103
    _11_item                       shift and go to state 104

state 81

    (69) pattern -> array_pattern .
    ,               reduce using rule 69 (pattern -> array_pattern .)
    %               reduce using rule 69 (pattern -> array_pattern .)
    DO              reduce using rule 69 (pattern -> array_pattern .)
    SPREAD          reduce using rule 69 (pattern -> array_pattern .)
    }               reduce using rule 69 (pattern -> array_pattern .)
    )               reduce using rule 69 (pattern -> array_pattern .)
    ]               reduce using rule 69 (pattern -> array_pattern .)


state 82

    (70) pattern -> tuple_pattern .
    ,               reduce using rule 70 (pattern -> tuple_pattern .)
    %               reduce using rule 70 (pattern -> tuple_pattern .)
    DO              reduce using rule 70 (pattern -> tuple_pattern .)
    SPREAD          reduce using rule 70 (pattern -> tuple_pattern .)
    }               reduce using rule 70 (pattern -> tuple_pattern .)
    )               reduce using rule 70 (pattern -> tuple_pattern .)
    ]               reduce using rule 70 (pattern -> tuple_pattern .)


state 83

    (71) pattern -> identifier . _12_optional
    (72) _12_optional -> . ( pattern _13_repeat )
    (78) _12_optional -> .
    (               shift and go to state 107
    ,               reduce using rule 78 (_12_optional -> .)
    %               reduce using rule 78 (_12_optional -> .)
    DO              reduce using rule 78 (_12_optional -> .)
    SPREAD          reduce using rule 78 (_12_optional -> .)
    }               reduce using rule 78 (_12_optional -> .)
    )               reduce using rule 78 (_12_optional -> .)
    ]               reduce using rule 78 (_12_optional -> .)

    _12_optional                   shift and go to state 106

state 84

    (79) array_pattern -> [ . _14_repeat _15_optional ]
    (80) _14_repeat -> . _14_items
    (81) _14_repeat -> .
    (82) _14_items -> . _14_items _14_item
    (83) _14_items -> . _14_item
    (84) _14_item -> . pattern ,
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    SPREAD          reduce using rule 81 (_14_repeat -> .)
    ]               reduce using rule 81 (_14_repeat -> .)
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    _14_repeat                     shift and go to state 108
    _14_items                      shift and go to state 109
    _14_item                       shift and go to state 110
    pattern                        shift and go to state 111
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 85

    (92) tuple_pattern -> { . _17_optional _18_repeat _19_optional }
    (93) _17_optional -> . pattern
    (94) _17_optional -> .
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    ,               reduce using rule 94 (_17_optional -> .)
    SPREAD          reduce using rule 94 (_17_optional -> .)
    }               reduce using rule 94 (_17_optional -> .)
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    _17_optional                   shift and go to state 112
    pattern                        shift and go to state 113
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 86

    (123) call -> callee ( _25_optional _26_repeat . )
    )               shift and go to state 114


state 87

    (126) _26_repeat -> _26_items .
    (128) _26_items -> _26_items . _26_item
    (130) _26_item -> . , expr
    )               reduce using rule 126 (_26_repeat -> _26_items .)
    ,               shift and go to state 89

    _26_item                       shift and go to state 115

state 88

    (129) _26_items -> _26_item .
    ,               reduce using rule 129 (_26_items -> _26_item .)
    )               reduce using rule 129 (_26_items -> _26_item .)


state 89

    (130) _26_item -> , . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 116
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 90

    (48) _if -> IF expr DO expressions . _8_repeat _9_optional END
    (49) _8_repeat -> . _8_items
    (50) _8_repeat -> .
    (51) _8_items -> . _8_items _8_item
    (52) _8_items -> . _8_item
    (53) _8_item -> . _elif
    (56) _elif -> . ELIF expr DO expressions
    ELSE            reduce using rule 50 (_8_repeat -> .)
    END             reduce using rule 50 (_8_repeat -> .)
    ELIF            shift and go to state 121

    _8_repeat                      shift and go to state 117
    _8_items                       shift and go to state 118
    _8_item                        shift and go to state 119
    _elif                          shift and go to state 120

state 91

    (28) _def -> DEF IDENTIFIER ( params . ) do
    )               shift and go to state 122


state 92

    (37) params -> _5_optional . _6_repeat
    (40) _6_repeat -> . _6_items
    (41) _6_repeat -> .
    (42) _6_items -> . _6_items _6_item
    (43) _6_items -> . _6_item
    (44) _6_item -> . , param
    )               reduce using rule 41 (_6_repeat -> .)
    ,               shift and go to state 126

    _6_repeat                      shift and go to state 123
    _6_items                       shift and go to state 124
    _6_item                        shift and go to state 125

state 93

    (38) _5_optional -> param .
    ,               reduce using rule 38 (_5_optional -> param .)
    )               reduce using rule 38 (_5_optional -> param .)


state 94

    (45) param -> _7_optional . identifier
    (132) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 127

state 95

    (46) _7_optional -> type .
    IDENTIFIER      reduce using rule 46 (_7_optional -> type .)


state 96

    (25) do -> _2_optional DO expressions END .
    INT_DIV         reduce using rule 25 (do -> _2_optional DO expressions END .)
    /               reduce using rule 25 (do -> _2_optional DO expressions END .)
    -               reduce using rule 25 (do -> _2_optional DO expressions END .)
    +               reduce using rule 25 (do -> _2_optional DO expressions END .)
    CONCAT          reduce using rule 25 (do -> _2_optional DO expressions END .)
    {               reduce using rule 25 (do -> _2_optional DO expressions END .)
    [               reduce using rule 25 (do -> _2_optional DO expressions END .)
    (               reduce using rule 25 (do -> _2_optional DO expressions END .)
    CASE            reduce using rule 25 (do -> _2_optional DO expressions END .)
    IF              reduce using rule 25 (do -> _2_optional DO expressions END .)
    DEF             reduce using rule 25 (do -> _2_optional DO expressions END .)
    NUMBER          reduce using rule 25 (do -> _2_optional DO expressions END .)
    STRING          reduce using rule 25 (do -> _2_optional DO expressions END .)
    IDENTIFIER      reduce using rule 25 (do -> _2_optional DO expressions END .)
    %               reduce using rule 25 (do -> _2_optional DO expressions END .)
    DO              reduce using rule 25 (do -> _2_optional DO expressions END .)
    $end            reduce using rule 25 (do -> _2_optional DO expressions END .)
    END             reduce using rule 25 (do -> _2_optional DO expressions END .)
    ELIF            reduce using rule 25 (do -> _2_optional DO expressions END .)
    ELSE            reduce using rule 25 (do -> _2_optional DO expressions END .)
    ,               reduce using rule 25 (do -> _2_optional DO expressions END .)
    }               reduce using rule 25 (do -> _2_optional DO expressions END .)
    ]               reduce using rule 25 (do -> _2_optional DO expressions END .)
    OF              reduce using rule 25 (do -> _2_optional DO expressions END .)
    )               reduce using rule 25 (do -> _2_optional DO expressions END .)


state 97

    (30) _3_optional -> < IDENTIFIER . _4_repeat >
    (31) _4_repeat -> . _4_items
    (32) _4_repeat -> .
    (33) _4_items -> . _4_items _4_item
    (34) _4_items -> . _4_item
    (35) _4_item -> . , IDENTIFIER
    >               reduce using rule 32 (_4_repeat -> .)
    ,               shift and go to state 131

    _4_repeat                      shift and go to state 128
    _4_items                       shift and go to state 129
    _4_item                        shift and go to state 130

state 98

    (62) _10_item -> case .
    [               reduce using rule 62 (_10_item -> case .)
    {               reduce using rule 62 (_10_item -> case .)
    IDENTIFIER      reduce using rule 62 (_10_item -> case .)
    END             reduce using rule 62 (_10_item -> case .)


state 99

    (57) case_of -> CASE expr OF case _10_repeat . END
    END             shift and go to state 132


state 100

    (58) _10_repeat -> _10_items .
    (60) _10_items -> _10_items . _10_item
    (62) _10_item -> . case
    (63) case -> . pattern _11_repeat do
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    END             reduce using rule 58 (_10_repeat -> _10_items .)
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    _10_item                       shift and go to state 133
    case                           shift and go to state 98
    pattern                        shift and go to state 80
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 101

    (61) _10_items -> _10_item .
    [               reduce using rule 61 (_10_items -> _10_item .)
    {               reduce using rule 61 (_10_items -> _10_item .)
    IDENTIFIER      reduce using rule 61 (_10_items -> _10_item .)
    END             reduce using rule 61 (_10_items -> _10_item .)


state 102

    (63) case -> pattern _11_repeat . do
    (25) do -> . _2_optional DO expressions END
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    do                             shift and go to state 134
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 103

    (64) _11_repeat -> _11_items .
    (66) _11_items -> _11_items . _11_item
    (68) _11_item -> . , pattern
    %               reduce using rule 64 (_11_repeat -> _11_items .)
    DO              reduce using rule 64 (_11_repeat -> _11_items .)
    ,               shift and go to state 105

    _11_item                       shift and go to state 135

state 104

    (67) _11_items -> _11_item .
    ,               reduce using rule 67 (_11_items -> _11_item .)
    %               reduce using rule 67 (_11_items -> _11_item .)
    DO              reduce using rule 67 (_11_items -> _11_item .)


state 105

    (68) _11_item -> , . pattern
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    pattern                        shift and go to state 136
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 106

    (71) pattern -> identifier _12_optional .
    ,               reduce using rule 71 (pattern -> identifier _12_optional .)
    %               reduce using rule 71 (pattern -> identifier _12_optional .)
    DO              reduce using rule 71 (pattern -> identifier _12_optional .)
    SPREAD          reduce using rule 71 (pattern -> identifier _12_optional .)
    }               reduce using rule 71 (pattern -> identifier _12_optional .)
    )               reduce using rule 71 (pattern -> identifier _12_optional .)
    ]               reduce using rule 71 (pattern -> identifier _12_optional .)


state 107

    (72) _12_optional -> ( . pattern _13_repeat )
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    pattern                        shift and go to state 137
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 108

    (79) array_pattern -> [ _14_repeat . _15_optional ]
    (85) _15_optional -> . SPREAD identifier _16_repeat
    (91) _15_optional -> .
    SPREAD          shift and go to state 139
    ]               reduce using rule 91 (_15_optional -> .)

    _15_optional                   shift and go to state 138

state 109

    (80) _14_repeat -> _14_items .
    (82) _14_items -> _14_items . _14_item
    (84) _14_item -> . pattern ,
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    SPREAD          reduce using rule 80 (_14_repeat -> _14_items .)
    ]               reduce using rule 80 (_14_repeat -> _14_items .)
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    _14_item                       shift and go to state 140
    pattern                        shift and go to state 111
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 110

    (83) _14_items -> _14_item .
    [               reduce using rule 83 (_14_items -> _14_item .)
    {               reduce using rule 83 (_14_items -> _14_item .)
    IDENTIFIER      reduce using rule 83 (_14_items -> _14_item .)
    SPREAD          reduce using rule 83 (_14_items -> _14_item .)
    ]               reduce using rule 83 (_14_items -> _14_item .)


state 111

    (84) _14_item -> pattern . ,
    ,               shift and go to state 141


state 112

    (92) tuple_pattern -> { _17_optional . _18_repeat _19_optional }
    (95) _18_repeat -> . _18_items
    (96) _18_repeat -> .
    (97) _18_items -> . _18_items _18_item
    (98) _18_items -> . _18_item
    (99) _18_item -> . , pattern
    SPREAD          reduce using rule 96 (_18_repeat -> .)
    }               reduce using rule 96 (_18_repeat -> .)
    ,               shift and go to state 145

    _18_repeat                     shift and go to state 142
    _18_items                      shift and go to state 143
    _18_item                       shift and go to state 144

state 113

    (93) _17_optional -> pattern .
    ,               reduce using rule 93 (_17_optional -> pattern .)
    SPREAD          reduce using rule 93 (_17_optional -> pattern .)
    }               reduce using rule 93 (_17_optional -> pattern .)


state 114

    (123) call -> callee ( _25_optional _26_repeat ) .
    INT_DIV         reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    /               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    -               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    +               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    CONCAT          reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    {               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    [               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    (               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    CASE            reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    IF              reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    DEF             reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    NUMBER          reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    STRING          reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    IDENTIFIER      reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    %               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    DO              reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    $end            reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    END             reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    ELIF            reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    ELSE            reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    ,               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    }               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    ]               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    OF              reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)
    )               reduce using rule 123 (call -> callee ( _25_optional _26_repeat ) .)


state 115

    (128) _26_items -> _26_items _26_item .
    ,               reduce using rule 128 (_26_items -> _26_items _26_item .)
    )               reduce using rule 128 (_26_items -> _26_items _26_item .)


state 116

    (130) _26_item -> , expr .
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 130 (_26_item -> , expr .)
    )               reduce using rule 130 (_26_item -> , expr .)
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 117

    (48) _if -> IF expr DO expressions _8_repeat . _9_optional END
    (54) _9_optional -> . ELSE expressions
    (55) _9_optional -> .
    ELSE            shift and go to state 147
    END             reduce using rule 55 (_9_optional -> .)

    _9_optional                    shift and go to state 146

state 118

    (49) _8_repeat -> _8_items .
    (51) _8_items -> _8_items . _8_item
    (53) _8_item -> . _elif
    (56) _elif -> . ELIF expr DO expressions
    ELSE            reduce using rule 49 (_8_repeat -> _8_items .)
    END             reduce using rule 49 (_8_repeat -> _8_items .)
    ELIF            shift and go to state 121

    _8_item                        shift and go to state 148
    _elif                          shift and go to state 120

state 119

    (52) _8_items -> _8_item .
    ELIF            reduce using rule 52 (_8_items -> _8_item .)
    ELSE            reduce using rule 52 (_8_items -> _8_item .)
    END             reduce using rule 52 (_8_items -> _8_item .)


state 120

    (53) _8_item -> _elif .
    ELIF            reduce using rule 53 (_8_item -> _elif .)
    ELSE            reduce using rule 53 (_8_item -> _elif .)
    END             reduce using rule 53 (_8_item -> _elif .)


state 121

    (56) _elif -> ELIF . expr DO expressions
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 149
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 122

    (28) _def -> DEF IDENTIFIER ( params ) . do
    (25) do -> . _2_optional DO expressions END
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    do                             shift and go to state 150
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 123

    (37) params -> _5_optional _6_repeat .
    )               reduce using rule 37 (params -> _5_optional _6_repeat .)


state 124

    (40) _6_repeat -> _6_items .
    (42) _6_items -> _6_items . _6_item
    (44) _6_item -> . , param
    )               reduce using rule 40 (_6_repeat -> _6_items .)
    ,               shift and go to state 126

    _6_item                        shift and go to state 151

state 125

    (43) _6_items -> _6_item .
    ,               reduce using rule 43 (_6_items -> _6_item .)
    )               reduce using rule 43 (_6_items -> _6_item .)


state 126

    (44) _6_item -> , . param
    (45) param -> . _7_optional identifier
    (46) _7_optional -> . type
    (47) _7_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    IDENTIFIER      reduce using rule 47 (_7_optional -> .)
    %               shift and go to state 30

    param                          shift and go to state 152
    _7_optional                    shift and go to state 94
    type                           shift and go to state 95

state 127

    (45) param -> _7_optional identifier .
    ,               reduce using rule 45 (param -> _7_optional identifier .)
    )               reduce using rule 45 (param -> _7_optional identifier .)


state 128

    (30) _3_optional -> < IDENTIFIER _4_repeat . >
    >               shift and go to state 153


state 129

    (31) _4_repeat -> _4_items .
    (33) _4_items -> _4_items . _4_item
    (35) _4_item -> . , IDENTIFIER
    >               reduce using rule 31 (_4_repeat -> _4_items .)
    ,               shift and go to state 131

    _4_item                        shift and go to state 154

state 130

    (34) _4_items -> _4_item .
    ,               reduce using rule 34 (_4_items -> _4_item .)
    >               reduce using rule 34 (_4_items -> _4_item .)


state 131

    (35) _4_item -> , . IDENTIFIER
    IDENTIFIER      shift and go to state 155


state 132

    (57) case_of -> CASE expr OF case _10_repeat END .
    INT_DIV         reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    /               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    -               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    +               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    CONCAT          reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    {               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    [               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    (               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    CASE            reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    IF              reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    DEF             reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    NUMBER          reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    STRING          reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    IDENTIFIER      reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    %               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    DO              reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    $end            reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    END             reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    ELIF            reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    ELSE            reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    ,               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    }               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    ]               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    OF              reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)
    )               reduce using rule 57 (case_of -> CASE expr OF case _10_repeat END .)


state 133

    (60) _10_items -> _10_items _10_item .
    [               reduce using rule 60 (_10_items -> _10_items _10_item .)
    {               reduce using rule 60 (_10_items -> _10_items _10_item .)
    IDENTIFIER      reduce using rule 60 (_10_items -> _10_items _10_item .)
    END             reduce using rule 60 (_10_items -> _10_items _10_item .)


state 134

    (63) case -> pattern _11_repeat do .
    [               reduce using rule 63 (case -> pattern _11_repeat do .)
    {               reduce using rule 63 (case -> pattern _11_repeat do .)
    IDENTIFIER      reduce using rule 63 (case -> pattern _11_repeat do .)
    END             reduce using rule 63 (case -> pattern _11_repeat do .)


state 135

    (66) _11_items -> _11_items _11_item .
    ,               reduce using rule 66 (_11_items -> _11_items _11_item .)
    %               reduce using rule 66 (_11_items -> _11_items _11_item .)
    DO              reduce using rule 66 (_11_items -> _11_items _11_item .)


state 136

    (68) _11_item -> , pattern .
    ,               reduce using rule 68 (_11_item -> , pattern .)
    %               reduce using rule 68 (_11_item -> , pattern .)
    DO              reduce using rule 68 (_11_item -> , pattern .)


state 137

    (72) _12_optional -> ( pattern . _13_repeat )
    (73) _13_repeat -> . _13_items
    (74) _13_repeat -> .
    (75) _13_items -> . _13_items _13_item
    (76) _13_items -> . _13_item
    (77) _13_item -> . , pattern
    )               reduce using rule 74 (_13_repeat -> .)
    ,               shift and go to state 159

    _13_repeat                     shift and go to state 156
    _13_items                      shift and go to state 157
    _13_item                       shift and go to state 158

state 138

    (79) array_pattern -> [ _14_repeat _15_optional . ]
    ]               shift and go to state 160


state 139

    (85) _15_optional -> SPREAD . identifier _16_repeat
    (132) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 161

state 140

    (82) _14_items -> _14_items _14_item .
    [               reduce using rule 82 (_14_items -> _14_items _14_item .)
    {               reduce using rule 82 (_14_items -> _14_items _14_item .)
    IDENTIFIER      reduce using rule 82 (_14_items -> _14_items _14_item .)
    SPREAD          reduce using rule 82 (_14_items -> _14_items _14_item .)
    ]               reduce using rule 82 (_14_items -> _14_items _14_item .)


state 141

    (84) _14_item -> pattern , .
    [               reduce using rule 84 (_14_item -> pattern , .)
    {               reduce using rule 84 (_14_item -> pattern , .)
    IDENTIFIER      reduce using rule 84 (_14_item -> pattern , .)
    SPREAD          reduce using rule 84 (_14_item -> pattern , .)
    ]               reduce using rule 84 (_14_item -> pattern , .)


state 142

    (92) tuple_pattern -> { _17_optional _18_repeat . _19_optional }
    (100) _19_optional -> . SPREAD identifier _20_repeat
    (106) _19_optional -> .
    SPREAD          shift and go to state 163
    }               reduce using rule 106 (_19_optional -> .)

    _19_optional                   shift and go to state 162

state 143

    (95) _18_repeat -> _18_items .
    (97) _18_items -> _18_items . _18_item
    (99) _18_item -> . , pattern
    SPREAD          reduce using rule 95 (_18_repeat -> _18_items .)
    }               reduce using rule 95 (_18_repeat -> _18_items .)
    ,               shift and go to state 145

    _18_item                       shift and go to state 164

state 144

    (98) _18_items -> _18_item .
    ,               reduce using rule 98 (_18_items -> _18_item .)
    SPREAD          reduce using rule 98 (_18_items -> _18_item .)
    }               reduce using rule 98 (_18_items -> _18_item .)


state 145

    (99) _18_item -> , . pattern
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    pattern                        shift and go to state 165
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 146

    (48) _if -> IF expr DO expressions _8_repeat _9_optional . END
    END             shift and go to state 166


state 147

    (54) _9_optional -> ELSE . expressions
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    END             reduce using rule 4 (_1_repeat -> .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expressions                    shift and go to state 167
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    expr                           shift and go to state 6
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 148

    (51) _8_items -> _8_items _8_item .
    ELIF            reduce using rule 51 (_8_items -> _8_items _8_item .)
    ELSE            reduce using rule 51 (_8_items -> _8_items _8_item .)
    END             reduce using rule 51 (_8_items -> _8_items _8_item .)


state 149

    (56) _elif -> ELIF expr . DO expressions
    (20) binary_expr -> expr . INT_DIV expr
    (21) binary_expr -> expr . / expr
    (22) binary_expr -> expr . - expr
    (23) binary_expr -> expr . + expr
    (24) binary_expr -> expr . CONCAT expr
    DO              shift and go to state 168
    INT_DIV         shift and go to state 32
    /               shift and go to state 33
    -               shift and go to state 34
    +               shift and go to state 35
    CONCAT          shift and go to state 36


state 150

    (28) _def -> DEF IDENTIFIER ( params ) do .
    INT_DIV         reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    /               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    -               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    +               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    CONCAT          reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    {               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    [               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    (               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    CASE            reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    IF              reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    DEF             reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    NUMBER          reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    STRING          reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    IDENTIFIER      reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    %               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    DO              reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    $end            reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    END             reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    ELIF            reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    ELSE            reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    ,               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    }               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    ]               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    OF              reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)
    )               reduce using rule 28 (_def -> DEF IDENTIFIER ( params ) do .)


state 151

    (42) _6_items -> _6_items _6_item .
    ,               reduce using rule 42 (_6_items -> _6_items _6_item .)
    )               reduce using rule 42 (_6_items -> _6_items _6_item .)


state 152

    (44) _6_item -> , param .
    ,               reduce using rule 44 (_6_item -> , param .)
    )               reduce using rule 44 (_6_item -> , param .)


state 153

    (30) _3_optional -> < IDENTIFIER _4_repeat > .
    DO              reduce using rule 30 (_3_optional -> < IDENTIFIER _4_repeat > .)
    IDENTIFIER      reduce using rule 30 (_3_optional -> < IDENTIFIER _4_repeat > .)


state 154

    (33) _4_items -> _4_items _4_item .
    ,               reduce using rule 33 (_4_items -> _4_items _4_item .)
    >               reduce using rule 33 (_4_items -> _4_items _4_item .)


state 155

    (35) _4_item -> , IDENTIFIER .
    ,               reduce using rule 35 (_4_item -> , IDENTIFIER .)
    >               reduce using rule 35 (_4_item -> , IDENTIFIER .)


state 156

    (72) _12_optional -> ( pattern _13_repeat . )
    )               shift and go to state 169


state 157

    (73) _13_repeat -> _13_items .
    (75) _13_items -> _13_items . _13_item
    (77) _13_item -> . , pattern
    )               reduce using rule 73 (_13_repeat -> _13_items .)
    ,               shift and go to state 159

    _13_item                       shift and go to state 170

state 158

    (76) _13_items -> _13_item .
    ,               reduce using rule 76 (_13_items -> _13_item .)
    )               reduce using rule 76 (_13_items -> _13_item .)


state 159

    (77) _13_item -> , . pattern
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    pattern                        shift and go to state 171
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 160

    (79) array_pattern -> [ _14_repeat _15_optional ] .
    ,               reduce using rule 79 (array_pattern -> [ _14_repeat _15_optional ] .)
    %               reduce using rule 79 (array_pattern -> [ _14_repeat _15_optional ] .)
    DO              reduce using rule 79 (array_pattern -> [ _14_repeat _15_optional ] .)
    SPREAD          reduce using rule 79 (array_pattern -> [ _14_repeat _15_optional ] .)
    }               reduce using rule 79 (array_pattern -> [ _14_repeat _15_optional ] .)
    )               reduce using rule 79 (array_pattern -> [ _14_repeat _15_optional ] .)
    ]               reduce using rule 79 (array_pattern -> [ _14_repeat _15_optional ] .)


state 161

    (85) _15_optional -> SPREAD identifier . _16_repeat
    (86) _16_repeat -> . _16_items
    (87) _16_repeat -> .
    (88) _16_items -> . _16_items _16_item
    (89) _16_items -> . _16_item
    (90) _16_item -> . , pattern
    ]               reduce using rule 87 (_16_repeat -> .)
    ,               shift and go to state 175

    _16_repeat                     shift and go to state 172
    _16_items                      shift and go to state 173
    _16_item                       shift and go to state 174

state 162

    (92) tuple_pattern -> { _17_optional _18_repeat _19_optional . }
    }               shift and go to state 176


state 163

    (100) _19_optional -> SPREAD . identifier _20_repeat
    (132) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 177

state 164

    (97) _18_items -> _18_items _18_item .
    ,               reduce using rule 97 (_18_items -> _18_items _18_item .)
    SPREAD          reduce using rule 97 (_18_items -> _18_items _18_item .)
    }               reduce using rule 97 (_18_items -> _18_items _18_item .)


state 165

    (99) _18_item -> , pattern .
    ,               reduce using rule 99 (_18_item -> , pattern .)
    SPREAD          reduce using rule 99 (_18_item -> , pattern .)
    }               reduce using rule 99 (_18_item -> , pattern .)


state 166

    (48) _if -> IF expr DO expressions _8_repeat _9_optional END .
    INT_DIV         reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    /               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    -               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    +               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    CONCAT          reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    {               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    [               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    (               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    CASE            reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    IF              reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    DEF             reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    NUMBER          reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    STRING          reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    IDENTIFIER      reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    %               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    DO              reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    $end            reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    END             reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    ELIF            reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    ELSE            reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    ,               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    }               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    ]               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    OF              reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)
    )               reduce using rule 48 (_if -> IF expr DO expressions _8_repeat _9_optional END .)


state 167

    (54) _9_optional -> ELSE expressions .
    END             reduce using rule 54 (_9_optional -> ELSE expressions .)


state 168

    (56) _elif -> ELIF expr DO . expressions
    (2) expressions -> . _1_repeat
    (3) _1_repeat -> . _1_items
    (4) _1_repeat -> .
    (5) _1_items -> . _1_items _1_item
    (6) _1_items -> . _1_item
    (7) _1_item -> . expr
    (8) expr -> . tuple
    (9) expr -> . array
    (10) expr -> . binary_expr
    (11) expr -> . variable_declaration
    (12) expr -> . case_of
    (13) expr -> . call
    (14) expr -> . _if
    (15) expr -> . _def
    (16) expr -> . literal
    (17) expr -> . identifier
    (18) expr -> . do
    (115) tuple -> . { _23_optional _24_repeat }
    (107) array -> . [ _21_optional _22_repeat ]
    (19) binary_expr -> . ( binary_expr )
    (20) binary_expr -> . expr INT_DIV expr
    (21) binary_expr -> . expr / expr
    (22) binary_expr -> . expr - expr
    (23) binary_expr -> . expr + expr
    (24) binary_expr -> . expr CONCAT expr
    (133) variable_declaration -> . identifier = expr
    (57) case_of -> . CASE expr OF case _10_repeat END
    (123) call -> . callee ( _25_optional _26_repeat )
    (48) _if -> . IF expr DO expressions _8_repeat _9_optional END
    (28) _def -> . DEF IDENTIFIER ( params ) do
    (134) literal -> . NUMBER
    (135) literal -> . STRING
    (132) identifier -> . IDENTIFIER
    (25) do -> . _2_optional DO expressions END
    (131) callee -> . identifier
    (26) _2_optional -> . type
    (27) _2_optional -> .
    (29) type -> . % IDENTIFIER _3_optional
    ELIF            reduce using rule 4 (_1_repeat -> .)
    ELSE            reduce using rule 4 (_1_repeat -> .)
    END             reduce using rule 4 (_1_repeat -> .)
    {               shift and go to state 18
    [               shift and go to state 19
    (               shift and go to state 20
    CASE            shift and go to state 21
    IF              shift and go to state 23
    DEF             shift and go to state 24
    NUMBER          shift and go to state 26
    STRING          shift and go to state 27
    IDENTIFIER      shift and go to state 25
    DO              reduce using rule 27 (_2_optional -> .)
    %               shift and go to state 30

    expr                           shift and go to state 6
    expressions                    shift and go to state 178
    _1_repeat                      shift and go to state 3
    _1_items                       shift and go to state 4
    _1_item                        shift and go to state 5
    tuple                          shift and go to state 7
    array                          shift and go to state 8
    binary_expr                    shift and go to state 9
    variable_declaration           shift and go to state 10
    case_of                        shift and go to state 11
    call                           shift and go to state 12
    _if                            shift and go to state 13
    _def                           shift and go to state 14
    literal                        shift and go to state 15
    identifier                     shift and go to state 16
    do                             shift and go to state 17
    callee                         shift and go to state 22
    _2_optional                    shift and go to state 28
    type                           shift and go to state 29

state 169

    (72) _12_optional -> ( pattern _13_repeat ) .
    ,               reduce using rule 72 (_12_optional -> ( pattern _13_repeat ) .)
    %               reduce using rule 72 (_12_optional -> ( pattern _13_repeat ) .)
    DO              reduce using rule 72 (_12_optional -> ( pattern _13_repeat ) .)
    SPREAD          reduce using rule 72 (_12_optional -> ( pattern _13_repeat ) .)
    }               reduce using rule 72 (_12_optional -> ( pattern _13_repeat ) .)
    )               reduce using rule 72 (_12_optional -> ( pattern _13_repeat ) .)
    ]               reduce using rule 72 (_12_optional -> ( pattern _13_repeat ) .)


state 170

    (75) _13_items -> _13_items _13_item .
    ,               reduce using rule 75 (_13_items -> _13_items _13_item .)
    )               reduce using rule 75 (_13_items -> _13_items _13_item .)


state 171

    (77) _13_item -> , pattern .
    ,               reduce using rule 77 (_13_item -> , pattern .)
    )               reduce using rule 77 (_13_item -> , pattern .)


state 172

    (85) _15_optional -> SPREAD identifier _16_repeat .
    ]               reduce using rule 85 (_15_optional -> SPREAD identifier _16_repeat .)


state 173

    (86) _16_repeat -> _16_items .
    (88) _16_items -> _16_items . _16_item
    (90) _16_item -> . , pattern
    ]               reduce using rule 86 (_16_repeat -> _16_items .)
    ,               shift and go to state 175

    _16_item                       shift and go to state 179

state 174

    (89) _16_items -> _16_item .
    ,               reduce using rule 89 (_16_items -> _16_item .)
    ]               reduce using rule 89 (_16_items -> _16_item .)


state 175

    (90) _16_item -> , . pattern
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    pattern                        shift and go to state 180
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 176

    (92) tuple_pattern -> { _17_optional _18_repeat _19_optional } .
    ,               reduce using rule 92 (tuple_pattern -> { _17_optional _18_repeat _19_optional } .)
    %               reduce using rule 92 (tuple_pattern -> { _17_optional _18_repeat _19_optional } .)
    DO              reduce using rule 92 (tuple_pattern -> { _17_optional _18_repeat _19_optional } .)
    SPREAD          reduce using rule 92 (tuple_pattern -> { _17_optional _18_repeat _19_optional } .)
    }               reduce using rule 92 (tuple_pattern -> { _17_optional _18_repeat _19_optional } .)
    )               reduce using rule 92 (tuple_pattern -> { _17_optional _18_repeat _19_optional } .)
    ]               reduce using rule 92 (tuple_pattern -> { _17_optional _18_repeat _19_optional } .)


state 177

    (100) _19_optional -> SPREAD identifier . _20_repeat
    (101) _20_repeat -> . _20_items
    (102) _20_repeat -> .
    (103) _20_items -> . _20_items _20_item
    (104) _20_items -> . _20_item
    (105) _20_item -> . , pattern
    }               reduce using rule 102 (_20_repeat -> .)
    ,               shift and go to state 184

    _20_repeat                     shift and go to state 181
    _20_items                      shift and go to state 182
    _20_item                       shift and go to state 183

state 178

    (56) _elif -> ELIF expr DO expressions .
    ELIF            reduce using rule 56 (_elif -> ELIF expr DO expressions .)
    ELSE            reduce using rule 56 (_elif -> ELIF expr DO expressions .)
    END             reduce using rule 56 (_elif -> ELIF expr DO expressions .)


state 179

    (88) _16_items -> _16_items _16_item .
    ,               reduce using rule 88 (_16_items -> _16_items _16_item .)
    ]               reduce using rule 88 (_16_items -> _16_items _16_item .)


state 180

    (90) _16_item -> , pattern .
    ,               reduce using rule 90 (_16_item -> , pattern .)
    ]               reduce using rule 90 (_16_item -> , pattern .)


state 181

    (100) _19_optional -> SPREAD identifier _20_repeat .
    }               reduce using rule 100 (_19_optional -> SPREAD identifier _20_repeat .)


state 182

    (101) _20_repeat -> _20_items .
    (103) _20_items -> _20_items . _20_item
    (105) _20_item -> . , pattern
    }               reduce using rule 101 (_20_repeat -> _20_items .)
    ,               shift and go to state 184

    _20_item                       shift and go to state 185

state 183

    (104) _20_items -> _20_item .
    ,               reduce using rule 104 (_20_items -> _20_item .)
    }               reduce using rule 104 (_20_items -> _20_item .)


state 184

    (105) _20_item -> , . pattern
    (69) pattern -> . array_pattern
    (70) pattern -> . tuple_pattern
    (71) pattern -> . identifier _12_optional
    (79) array_pattern -> . [ _14_repeat _15_optional ]
    (92) tuple_pattern -> . { _17_optional _18_repeat _19_optional }
    (132) identifier -> . IDENTIFIER
    [               shift and go to state 84
    {               shift and go to state 85
    IDENTIFIER      shift and go to state 25

    pattern                        shift and go to state 186
    array_pattern                  shift and go to state 81
    tuple_pattern                  shift and go to state 82
    identifier                     shift and go to state 83

state 185

    (103) _20_items -> _20_items _20_item .
    ,               reduce using rule 103 (_20_items -> _20_items _20_item .)
    }               reduce using rule 103 (_20_items -> _20_items _20_item .)


state 186

    (105) _20_item -> , pattern .
    ,               reduce using rule 105 (_20_item -> , pattern .)
    }               reduce using rule 105 (_20_item -> , pattern .)


Conflicts:

shift/reduce conflict for INT_DIV in state 50 resolved as shift
shift/reduce conflict for / in state 50 resolved as shift
shift/reduce conflict for - in state 50 resolved as shift
shift/reduce conflict for + in state 50 resolved as shift
shift/reduce conflict for CONCAT in state 50 resolved as shift
shift/reduce conflict for INT_DIV in state 51 resolved as shift
shift/reduce conflict for / in state 51 resolved as shift
shift/reduce conflict for - in state 51 resolved as shift
shift/reduce conflict for + in state 51 resolved as shift
shift/reduce conflict for CONCAT in state 51 resolved as shift
shift/reduce conflict for INT_DIV in state 52 resolved as shift
shift/reduce conflict for / in state 52 resolved as shift
shift/reduce conflict for - in state 52 resolved as shift
shift/reduce conflict for + in state 52 resolved as shift
shift/reduce conflict for CONCAT in state 52 resolved as shift
shift/reduce conflict for INT_DIV in state 53 resolved as shift
shift/reduce conflict for / in state 53 resolved as shift
shift/reduce conflict for - in state 53 resolved as shift
shift/reduce conflict for + in state 53 resolved as shift
shift/reduce conflict for CONCAT in state 53 resolved as shift
shift/reduce conflict for INT_DIV in state 54 resolved as shift
shift/reduce conflict for / in state 54 resolved as shift
shift/reduce conflict for - in state 54 resolved as shift
shift/reduce conflict for + in state 54 resolved as shift
shift/reduce conflict for CONCAT in state 54 resolved as shift
shift/reduce conflict for INT_DIV in state 55 resolved as shift
shift/reduce conflict for / in state 55 resolved as shift
shift/reduce conflict for - in state 55 resolved as shift
shift/reduce conflict for + in state 55 resolved as shift
shift/reduce conflict for CONCAT in state 55 resolved as shift
reduce/reduce conflict in state 16 resolved using rule expr -> identifier
rejected rule (callee -> identifier) in state 16
Rule (callee -> identifier) is never reduced