Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_repeat
Rule 2     _1_repeat -> _1_items
Rule 3     _1_repeat -> <empty>
Rule 4     _1_items -> _1_items _1_item
Rule 5     _1_items -> _1_item
Rule 6     _1_item -> stmt
Rule 7     stmt -> enum
Rule 8     stmt -> expr
Rule 9     expr -> ( expr )  [precedence=left, level=6]
Rule 10    expr -> - expr  [precedence=right, level=7]
Rule 11    expr -> array
Rule 12    expr -> variant_call
Rule 13    expr -> identifier
Rule 14    expr -> variable_declaration
Rule 15    expr -> call
Rule 16    expr -> case_of
Rule 17    expr -> binary_expr
Rule 18    expr -> if_expr
Rule 19    expr -> def_expr
Rule 20    expr -> literal
Rule 21    expr -> do
Rule 22    expr -> external
Rule 23    external -> EXTERNAL
Rule 24    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 25    binary_expr -> expr NOT_MORE expr  [precedence=left, level=1]
Rule 26    binary_expr -> expr NUM_NOT_EQUAL expr  [precedence=left, level=1]
Rule 27    binary_expr -> expr > expr  [precedence=left, level=1]
Rule 28    binary_expr -> expr % expr  [precedence=left, level=3]
Rule 29    binary_expr -> expr < expr  [precedence=left, level=1]
Rule 30    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 31    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 32    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 33    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 34    binary_expr -> expr CONCAT expr  [precedence=left, level=2]
Rule 35    do -> DO _2_optional _3_repeat END
Rule 36    _2_optional -> : type
Rule 37    _2_optional -> <empty>
Rule 38    _3_repeat -> _3_items
Rule 39    _3_repeat -> <empty>
Rule 40    _3_items -> _3_items _3_item
Rule 41    _3_items -> _3_item
Rule 42    _3_item -> expr
Rule 43    block_statement -> _4_repeat
Rule 44    _4_repeat -> _4_items
Rule 45    _4_repeat -> <empty>
Rule 46    _4_items -> _4_items _4_item
Rule 47    _4_items -> _4_item
Rule 48    _4_item -> expr
Rule 49    def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do  [precedence=left, level=6]
Rule 50    _5_optional -> param
Rule 51    _5_optional -> <empty>
Rule 52    _6_repeat -> _6_items
Rule 53    _6_repeat -> <empty>
Rule 54    _6_items -> _6_items _6_item
Rule 55    _6_items -> _6_item
Rule 56    _6_item -> , param
Rule 57    _7_optional -> : type
Rule 58    _7_optional -> <empty>
Rule 59    type -> type_identifier < type _8_repeat >  [precedence=left, level=1]
Rule 60    _8_repeat -> _8_items
Rule 61    _8_repeat -> <empty>
Rule 62    _8_items -> _8_items _8_item
Rule 63    _8_items -> _8_item
Rule 64    _8_item -> , type
Rule 65    type -> type_identifier
Rule 66    enum -> ENUM type_identifier { _9_repeat }
Rule 67    _9_repeat -> _9_items
Rule 68    _9_repeat -> <empty>
Rule 69    _9_items -> _9_items _9_item
Rule 70    _9_items -> _9_item
Rule 71    _9_item -> variant
Rule 72    enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat }
Rule 73    _10_repeat -> _10_items
Rule 74    _10_repeat -> <empty>
Rule 75    _10_items -> _10_items _10_item
Rule 76    _10_items -> _10_item
Rule 77    _10_item -> , type_identifier
Rule 78    _11_repeat -> _11_items
Rule 79    _11_repeat -> <empty>
Rule 80    _11_items -> _11_items _11_item
Rule 81    _11_items -> _11_item
Rule 82    _11_item -> variant
Rule 83    variant -> type_identifier
Rule 84    variant -> type_identifier ( type _12_repeat )  [precedence=left, level=6]
Rule 85    _12_repeat -> _12_items
Rule 86    _12_repeat -> <empty>
Rule 87    _12_items -> _12_items _12_item
Rule 88    _12_items -> _12_item
Rule 89    _12_item -> , type
Rule 90    param -> identifier _13_optional
Rule 91    _13_optional -> : type
Rule 92    _13_optional -> <empty>
Rule 93    if_expr -> IF expr THEN _14_optional block_statement _15_optional END
Rule 94    _14_optional -> : type
Rule 95    _14_optional -> <empty>
Rule 96    _15_optional -> or_else
Rule 97    _15_optional -> <empty>
Rule 98    or_else -> ELIF expr THEN block_statement _16_optional
Rule 99    _16_optional -> or_else
Rule 100   _16_optional -> <empty>
Rule 101   or_else -> ELSE block_statement
Rule 102   case_of -> CASE expr OF _17_repeat END
Rule 103   _17_repeat -> _17_items
Rule 104   _17_repeat -> <empty>
Rule 105   _17_items -> _17_items _17_item
Rule 106   _17_items -> _17_item
Rule 107   _17_item -> pattern do
Rule 108   pattern -> match_variant
Rule 109   pattern -> match_as
Rule 110   match_as -> identifier
Rule 111   match_variant -> type_identifier
Rule 112   match_variant -> type_identifier ( _18_optional _19_repeat )  [precedence=left, level=6]
Rule 113   _18_optional -> pattern
Rule 114   _18_optional -> <empty>
Rule 115   _19_repeat -> _19_items
Rule 116   _19_repeat -> <empty>
Rule 117   _19_items -> _19_items _19_item
Rule 118   _19_items -> _19_item
Rule 119   _19_item -> , pattern
Rule 120   array -> [ _20_optional _21_repeat ]
Rule 121   _20_optional -> expr
Rule 122   _20_optional -> <empty>
Rule 123   _21_repeat -> _21_items
Rule 124   _21_repeat -> <empty>
Rule 125   _21_items -> _21_items _21_item
Rule 126   _21_items -> _21_item
Rule 127   _21_item -> , expr
Rule 128   call -> expr ( _22_optional _23_repeat )  [precedence=left, level=6]
Rule 129   _22_optional -> expr
Rule 130   _22_optional -> <empty>
Rule 131   _23_repeat -> _23_items
Rule 132   _23_repeat -> <empty>
Rule 133   _23_items -> _23_items _23_item
Rule 134   _23_items -> _23_item
Rule 135   _23_item -> , expr
Rule 136   variant_call -> type_identifier
Rule 137   variant_call -> type_identifier ( _24_optional _25_repeat )  [precedence=left, level=6]
Rule 138   _24_optional -> expr
Rule 139   _24_optional -> <empty>
Rule 140   _25_repeat -> _25_items
Rule 141   _25_repeat -> <empty>
Rule 142   _25_items -> _25_items _25_item
Rule 143   _25_items -> _25_item
Rule 144   _25_item -> , expr
Rule 145   identifier -> IDENTIFIER
Rule 146   type_identifier -> TYPE_IDENTIFIER
Rule 147   variable_declaration -> LET identifier _26_optional = expr  [precedence=left, level=1]
Rule 148   _26_optional -> : type
Rule 149   _26_optional -> <empty>
Rule 150   literal -> STRING
Rule 151   literal -> NUMBER

Terminals, with rules where they appear:

%                    : 28
(                    : 9 49 84 112 128 137
)                    : 9 49 84 112 128 137
*                    : 30
+                    : 33
,                    : 56 64 77 89 119 127 135 144
-                    : 10 32
/                    : 31
:                    : 36 57 91 94 148
<                    : 29 59 72
=                    : 147
>                    : 27 59 72
CASE                 : 102
CONCAT               : 34
DEF                  : 49
DO                   : 35
ELIF                 : 98
ELSE                 : 101
END                  : 35 93 102
ENUM                 : 66 72
EXTERNAL             : 23
IDENTIFIER           : 145
IF                   : 93
INT_DIV              : 24
LET                  : 147
NOT_MORE             : 25
NUMBER               : 151
NUM_NOT_EQUAL        : 26
OF                   : 102
STRING               : 150
THEN                 : 93 98
TYPE_IDENTIFIER      : 146
[                    : 120
]                    : 120
error                : 
{                    : 66 72
}                    : 66 72

Nonterminals, with rules where they appear:

_10_item             : 75 76
_10_items            : 73 75
_10_repeat           : 72
_11_item             : 80 81
_11_items            : 78 80
_11_repeat           : 72
_12_item             : 87 88
_12_items            : 85 87
_12_repeat           : 84
_13_optional         : 90
_14_optional         : 93
_15_optional         : 93
_16_optional         : 98
_17_item             : 105 106
_17_items            : 103 105
_17_repeat           : 102
_18_optional         : 112
_19_item             : 117 118
_19_items            : 115 117
_19_repeat           : 112
_1_item              : 4 5
_1_items             : 2 4
_1_repeat            : 1
_20_optional         : 120
_21_item             : 125 126
_21_items            : 123 125
_21_repeat           : 120
_22_optional         : 128
_23_item             : 133 134
_23_items            : 131 133
_23_repeat           : 128
_24_optional         : 137
_25_item             : 142 143
_25_items            : 140 142
_25_repeat           : 137
_26_optional         : 147
_2_optional          : 35
_3_item              : 40 41
_3_items             : 38 40
_3_repeat            : 35
_4_item              : 46 47
_4_items             : 44 46
_4_repeat            : 43
_5_optional          : 49
_6_item              : 54 55
_6_items             : 52 54
_6_repeat            : 49
_7_optional          : 49
_8_item              : 62 63
_8_items             : 60 62
_8_repeat            : 59
_9_item              : 69 70
_9_items             : 67 69
_9_repeat            : 66
array                : 11
binary_expr          : 17
block_statement      : 93 98 101
call                 : 15
case_of              : 16
def_expr             : 19
do                   : 21 49 107
enum                 : 7
expr                 : 8 9 10 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 42 48 93 98 102 121 127 128 129 135 138 144 147
external             : 22
identifier           : 13 49 90 110 147
if_expr              : 18
literal              : 20
match_as             : 109
match_variant        : 108
or_else              : 96 99
param                : 50 56
pattern              : 107 113 119
program              : 0
stmt                 : 6
type                 : 36 57 59 64 84 89 91 94 148
type_identifier      : 59 65 66 72 72 77 83 84 111 112 136 137
variable_declaration : 14
variant              : 71 82
variant_call         : 12


state 0

    (0) S' -> . program
    (1) program -> . _1_repeat
    (2) _1_repeat -> . _1_items
    (3) _1_repeat -> .
    (4) _1_items -> . _1_items _1_item
    (5) _1_items -> . _1_item
    (6) _1_item -> . stmt
    (7) stmt -> . enum
    (8) stmt -> . expr
    (66) enum -> . ENUM type_identifier { _9_repeat }
    (72) enum -> . ENUM type_identifier < type_identifier _10_repeat > { _11_repeat }
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 3 (_1_repeat -> .)
    ENUM            shift and go to state 8
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    program                        shift and go to state 1
    _1_repeat                      shift and go to state 2
    _1_items                       shift and go to state 3
    _1_item                        shift and go to state 4
    stmt                           shift and go to state 5
    enum                           shift and go to state 6
    expr                           shift and go to state 7
    type_identifier                shift and go to state 9
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_repeat .
    $end            reduce using rule 1 (program -> _1_repeat .)


state 3

    (2) _1_repeat -> _1_items .
    (4) _1_items -> _1_items . _1_item
    (6) _1_item -> . stmt
    (7) stmt -> . enum
    (8) stmt -> . expr
    (66) enum -> . ENUM type_identifier { _9_repeat }
    (72) enum -> . ENUM type_identifier < type_identifier _10_repeat > { _11_repeat }
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 2 (_1_repeat -> _1_items .)
    ENUM            shift and go to state 8
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _1_item                        shift and go to state 35
    stmt                           shift and go to state 5
    enum                           shift and go to state 6
    expr                           shift and go to state 7
    type_identifier                shift and go to state 9
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23

state 4

    (5) _1_items -> _1_item .
    ENUM            reduce using rule 5 (_1_items -> _1_item .)
    (               reduce using rule 5 (_1_items -> _1_item .)
    -               reduce using rule 5 (_1_items -> _1_item .)
    [               reduce using rule 5 (_1_items -> _1_item .)
    IDENTIFIER      reduce using rule 5 (_1_items -> _1_item .)
    LET             reduce using rule 5 (_1_items -> _1_item .)
    CASE            reduce using rule 5 (_1_items -> _1_item .)
    IF              reduce using rule 5 (_1_items -> _1_item .)
    DEF             reduce using rule 5 (_1_items -> _1_item .)
    STRING          reduce using rule 5 (_1_items -> _1_item .)
    NUMBER          reduce using rule 5 (_1_items -> _1_item .)
    DO              reduce using rule 5 (_1_items -> _1_item .)
    EXTERNAL        reduce using rule 5 (_1_items -> _1_item .)
    TYPE_IDENTIFIER reduce using rule 5 (_1_items -> _1_item .)
    $end            reduce using rule 5 (_1_items -> _1_item .)


state 5

    (6) _1_item -> stmt .
    ENUM            reduce using rule 6 (_1_item -> stmt .)
    (               reduce using rule 6 (_1_item -> stmt .)
    -               reduce using rule 6 (_1_item -> stmt .)
    [               reduce using rule 6 (_1_item -> stmt .)
    IDENTIFIER      reduce using rule 6 (_1_item -> stmt .)
    LET             reduce using rule 6 (_1_item -> stmt .)
    CASE            reduce using rule 6 (_1_item -> stmt .)
    IF              reduce using rule 6 (_1_item -> stmt .)
    DEF             reduce using rule 6 (_1_item -> stmt .)
    STRING          reduce using rule 6 (_1_item -> stmt .)
    NUMBER          reduce using rule 6 (_1_item -> stmt .)
    DO              reduce using rule 6 (_1_item -> stmt .)
    EXTERNAL        reduce using rule 6 (_1_item -> stmt .)
    TYPE_IDENTIFIER reduce using rule 6 (_1_item -> stmt .)
    $end            reduce using rule 6 (_1_item -> stmt .)


state 6

    (7) stmt -> enum .
    ENUM            reduce using rule 7 (stmt -> enum .)
    (               reduce using rule 7 (stmt -> enum .)
    -               reduce using rule 7 (stmt -> enum .)
    [               reduce using rule 7 (stmt -> enum .)
    IDENTIFIER      reduce using rule 7 (stmt -> enum .)
    LET             reduce using rule 7 (stmt -> enum .)
    CASE            reduce using rule 7 (stmt -> enum .)
    IF              reduce using rule 7 (stmt -> enum .)
    DEF             reduce using rule 7 (stmt -> enum .)
    STRING          reduce using rule 7 (stmt -> enum .)
    NUMBER          reduce using rule 7 (stmt -> enum .)
    DO              reduce using rule 7 (stmt -> enum .)
    EXTERNAL        reduce using rule 7 (stmt -> enum .)
    TYPE_IDENTIFIER reduce using rule 7 (stmt -> enum .)
    $end            reduce using rule 7 (stmt -> enum .)


state 7

    (8) stmt -> expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    ENUM            reduce using rule 8 (stmt -> expr .)
    [               reduce using rule 8 (stmt -> expr .)
    IDENTIFIER      reduce using rule 8 (stmt -> expr .)
    LET             reduce using rule 8 (stmt -> expr .)
    CASE            reduce using rule 8 (stmt -> expr .)
    IF              reduce using rule 8 (stmt -> expr .)
    DEF             reduce using rule 8 (stmt -> expr .)
    STRING          reduce using rule 8 (stmt -> expr .)
    NUMBER          reduce using rule 8 (stmt -> expr .)
    DO              reduce using rule 8 (stmt -> expr .)
    EXTERNAL        reduce using rule 8 (stmt -> expr .)
    TYPE_IDENTIFIER reduce using rule 8 (stmt -> expr .)
    $end            reduce using rule 8 (stmt -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 8

    (66) enum -> ENUM . type_identifier { _9_repeat }
    (72) enum -> ENUM . type_identifier < type_identifier _10_repeat > { _11_repeat }
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 48

state 9

    (136) variant_call -> type_identifier .
    (137) variant_call -> type_identifier . ( _24_optional _25_repeat )
  ! shift/reduce conflict for ( resolved as shift
    INT_DIV         reduce using rule 136 (variant_call -> type_identifier .)
    NOT_MORE        reduce using rule 136 (variant_call -> type_identifier .)
    NUM_NOT_EQUAL   reduce using rule 136 (variant_call -> type_identifier .)
    >               reduce using rule 136 (variant_call -> type_identifier .)
    %               reduce using rule 136 (variant_call -> type_identifier .)
    <               reduce using rule 136 (variant_call -> type_identifier .)
    *               reduce using rule 136 (variant_call -> type_identifier .)
    /               reduce using rule 136 (variant_call -> type_identifier .)
    -               reduce using rule 136 (variant_call -> type_identifier .)
    +               reduce using rule 136 (variant_call -> type_identifier .)
    CONCAT          reduce using rule 136 (variant_call -> type_identifier .)
    ENUM            reduce using rule 136 (variant_call -> type_identifier .)
    [               reduce using rule 136 (variant_call -> type_identifier .)
    IDENTIFIER      reduce using rule 136 (variant_call -> type_identifier .)
    LET             reduce using rule 136 (variant_call -> type_identifier .)
    CASE            reduce using rule 136 (variant_call -> type_identifier .)
    IF              reduce using rule 136 (variant_call -> type_identifier .)
    DEF             reduce using rule 136 (variant_call -> type_identifier .)
    STRING          reduce using rule 136 (variant_call -> type_identifier .)
    NUMBER          reduce using rule 136 (variant_call -> type_identifier .)
    DO              reduce using rule 136 (variant_call -> type_identifier .)
    EXTERNAL        reduce using rule 136 (variant_call -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 136 (variant_call -> type_identifier .)
    $end            reduce using rule 136 (variant_call -> type_identifier .)
    )               reduce using rule 136 (variant_call -> type_identifier .)
    ,               reduce using rule 136 (variant_call -> type_identifier .)
    ]               reduce using rule 136 (variant_call -> type_identifier .)
    OF              reduce using rule 136 (variant_call -> type_identifier .)
    THEN            reduce using rule 136 (variant_call -> type_identifier .)
    END             reduce using rule 136 (variant_call -> type_identifier .)
    ELIF            reduce using rule 136 (variant_call -> type_identifier .)
    ELSE            reduce using rule 136 (variant_call -> type_identifier .)
    (               shift and go to state 49


state 10

    (9) expr -> ( . expr )
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 50
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 11

    (10) expr -> - . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 51
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 12

    (11) expr -> array .
    (               reduce using rule 11 (expr -> array .)
    INT_DIV         reduce using rule 11 (expr -> array .)
    NOT_MORE        reduce using rule 11 (expr -> array .)
    NUM_NOT_EQUAL   reduce using rule 11 (expr -> array .)
    >               reduce using rule 11 (expr -> array .)
    %               reduce using rule 11 (expr -> array .)
    <               reduce using rule 11 (expr -> array .)
    *               reduce using rule 11 (expr -> array .)
    /               reduce using rule 11 (expr -> array .)
    -               reduce using rule 11 (expr -> array .)
    +               reduce using rule 11 (expr -> array .)
    CONCAT          reduce using rule 11 (expr -> array .)
    ENUM            reduce using rule 11 (expr -> array .)
    [               reduce using rule 11 (expr -> array .)
    IDENTIFIER      reduce using rule 11 (expr -> array .)
    LET             reduce using rule 11 (expr -> array .)
    CASE            reduce using rule 11 (expr -> array .)
    IF              reduce using rule 11 (expr -> array .)
    DEF             reduce using rule 11 (expr -> array .)
    STRING          reduce using rule 11 (expr -> array .)
    NUMBER          reduce using rule 11 (expr -> array .)
    DO              reduce using rule 11 (expr -> array .)
    EXTERNAL        reduce using rule 11 (expr -> array .)
    TYPE_IDENTIFIER reduce using rule 11 (expr -> array .)
    $end            reduce using rule 11 (expr -> array .)
    )               reduce using rule 11 (expr -> array .)
    ,               reduce using rule 11 (expr -> array .)
    ]               reduce using rule 11 (expr -> array .)
    OF              reduce using rule 11 (expr -> array .)
    THEN            reduce using rule 11 (expr -> array .)
    END             reduce using rule 11 (expr -> array .)
    ELIF            reduce using rule 11 (expr -> array .)
    ELSE            reduce using rule 11 (expr -> array .)


state 13

    (12) expr -> variant_call .
    (               reduce using rule 12 (expr -> variant_call .)
    INT_DIV         reduce using rule 12 (expr -> variant_call .)
    NOT_MORE        reduce using rule 12 (expr -> variant_call .)
    NUM_NOT_EQUAL   reduce using rule 12 (expr -> variant_call .)
    >               reduce using rule 12 (expr -> variant_call .)
    %               reduce using rule 12 (expr -> variant_call .)
    <               reduce using rule 12 (expr -> variant_call .)
    *               reduce using rule 12 (expr -> variant_call .)
    /               reduce using rule 12 (expr -> variant_call .)
    -               reduce using rule 12 (expr -> variant_call .)
    +               reduce using rule 12 (expr -> variant_call .)
    CONCAT          reduce using rule 12 (expr -> variant_call .)
    ENUM            reduce using rule 12 (expr -> variant_call .)
    [               reduce using rule 12 (expr -> variant_call .)
    IDENTIFIER      reduce using rule 12 (expr -> variant_call .)
    LET             reduce using rule 12 (expr -> variant_call .)
    CASE            reduce using rule 12 (expr -> variant_call .)
    IF              reduce using rule 12 (expr -> variant_call .)
    DEF             reduce using rule 12 (expr -> variant_call .)
    STRING          reduce using rule 12 (expr -> variant_call .)
    NUMBER          reduce using rule 12 (expr -> variant_call .)
    DO              reduce using rule 12 (expr -> variant_call .)
    EXTERNAL        reduce using rule 12 (expr -> variant_call .)
    TYPE_IDENTIFIER reduce using rule 12 (expr -> variant_call .)
    $end            reduce using rule 12 (expr -> variant_call .)
    )               reduce using rule 12 (expr -> variant_call .)
    ,               reduce using rule 12 (expr -> variant_call .)
    ]               reduce using rule 12 (expr -> variant_call .)
    OF              reduce using rule 12 (expr -> variant_call .)
    THEN            reduce using rule 12 (expr -> variant_call .)
    END             reduce using rule 12 (expr -> variant_call .)
    ELIF            reduce using rule 12 (expr -> variant_call .)
    ELSE            reduce using rule 12 (expr -> variant_call .)


state 14

    (13) expr -> identifier .
    (               reduce using rule 13 (expr -> identifier .)
    INT_DIV         reduce using rule 13 (expr -> identifier .)
    NOT_MORE        reduce using rule 13 (expr -> identifier .)
    NUM_NOT_EQUAL   reduce using rule 13 (expr -> identifier .)
    >               reduce using rule 13 (expr -> identifier .)
    %               reduce using rule 13 (expr -> identifier .)
    <               reduce using rule 13 (expr -> identifier .)
    *               reduce using rule 13 (expr -> identifier .)
    /               reduce using rule 13 (expr -> identifier .)
    -               reduce using rule 13 (expr -> identifier .)
    +               reduce using rule 13 (expr -> identifier .)
    CONCAT          reduce using rule 13 (expr -> identifier .)
    ENUM            reduce using rule 13 (expr -> identifier .)
    [               reduce using rule 13 (expr -> identifier .)
    IDENTIFIER      reduce using rule 13 (expr -> identifier .)
    LET             reduce using rule 13 (expr -> identifier .)
    CASE            reduce using rule 13 (expr -> identifier .)
    IF              reduce using rule 13 (expr -> identifier .)
    DEF             reduce using rule 13 (expr -> identifier .)
    STRING          reduce using rule 13 (expr -> identifier .)
    NUMBER          reduce using rule 13 (expr -> identifier .)
    DO              reduce using rule 13 (expr -> identifier .)
    EXTERNAL        reduce using rule 13 (expr -> identifier .)
    TYPE_IDENTIFIER reduce using rule 13 (expr -> identifier .)
    $end            reduce using rule 13 (expr -> identifier .)
    )               reduce using rule 13 (expr -> identifier .)
    ,               reduce using rule 13 (expr -> identifier .)
    ]               reduce using rule 13 (expr -> identifier .)
    OF              reduce using rule 13 (expr -> identifier .)
    THEN            reduce using rule 13 (expr -> identifier .)
    END             reduce using rule 13 (expr -> identifier .)
    ELIF            reduce using rule 13 (expr -> identifier .)
    ELSE            reduce using rule 13 (expr -> identifier .)


state 15

    (14) expr -> variable_declaration .
    (               reduce using rule 14 (expr -> variable_declaration .)
    INT_DIV         reduce using rule 14 (expr -> variable_declaration .)
    NOT_MORE        reduce using rule 14 (expr -> variable_declaration .)
    NUM_NOT_EQUAL   reduce using rule 14 (expr -> variable_declaration .)
    >               reduce using rule 14 (expr -> variable_declaration .)
    %               reduce using rule 14 (expr -> variable_declaration .)
    <               reduce using rule 14 (expr -> variable_declaration .)
    *               reduce using rule 14 (expr -> variable_declaration .)
    /               reduce using rule 14 (expr -> variable_declaration .)
    -               reduce using rule 14 (expr -> variable_declaration .)
    +               reduce using rule 14 (expr -> variable_declaration .)
    CONCAT          reduce using rule 14 (expr -> variable_declaration .)
    ENUM            reduce using rule 14 (expr -> variable_declaration .)
    [               reduce using rule 14 (expr -> variable_declaration .)
    IDENTIFIER      reduce using rule 14 (expr -> variable_declaration .)
    LET             reduce using rule 14 (expr -> variable_declaration .)
    CASE            reduce using rule 14 (expr -> variable_declaration .)
    IF              reduce using rule 14 (expr -> variable_declaration .)
    DEF             reduce using rule 14 (expr -> variable_declaration .)
    STRING          reduce using rule 14 (expr -> variable_declaration .)
    NUMBER          reduce using rule 14 (expr -> variable_declaration .)
    DO              reduce using rule 14 (expr -> variable_declaration .)
    EXTERNAL        reduce using rule 14 (expr -> variable_declaration .)
    TYPE_IDENTIFIER reduce using rule 14 (expr -> variable_declaration .)
    $end            reduce using rule 14 (expr -> variable_declaration .)
    )               reduce using rule 14 (expr -> variable_declaration .)
    ,               reduce using rule 14 (expr -> variable_declaration .)
    ]               reduce using rule 14 (expr -> variable_declaration .)
    OF              reduce using rule 14 (expr -> variable_declaration .)
    THEN            reduce using rule 14 (expr -> variable_declaration .)
    END             reduce using rule 14 (expr -> variable_declaration .)
    ELIF            reduce using rule 14 (expr -> variable_declaration .)
    ELSE            reduce using rule 14 (expr -> variable_declaration .)


state 16

    (15) expr -> call .
    (               reduce using rule 15 (expr -> call .)
    INT_DIV         reduce using rule 15 (expr -> call .)
    NOT_MORE        reduce using rule 15 (expr -> call .)
    NUM_NOT_EQUAL   reduce using rule 15 (expr -> call .)
    >               reduce using rule 15 (expr -> call .)
    %               reduce using rule 15 (expr -> call .)
    <               reduce using rule 15 (expr -> call .)
    *               reduce using rule 15 (expr -> call .)
    /               reduce using rule 15 (expr -> call .)
    -               reduce using rule 15 (expr -> call .)
    +               reduce using rule 15 (expr -> call .)
    CONCAT          reduce using rule 15 (expr -> call .)
    ENUM            reduce using rule 15 (expr -> call .)
    [               reduce using rule 15 (expr -> call .)
    IDENTIFIER      reduce using rule 15 (expr -> call .)
    LET             reduce using rule 15 (expr -> call .)
    CASE            reduce using rule 15 (expr -> call .)
    IF              reduce using rule 15 (expr -> call .)
    DEF             reduce using rule 15 (expr -> call .)
    STRING          reduce using rule 15 (expr -> call .)
    NUMBER          reduce using rule 15 (expr -> call .)
    DO              reduce using rule 15 (expr -> call .)
    EXTERNAL        reduce using rule 15 (expr -> call .)
    TYPE_IDENTIFIER reduce using rule 15 (expr -> call .)
    $end            reduce using rule 15 (expr -> call .)
    )               reduce using rule 15 (expr -> call .)
    ,               reduce using rule 15 (expr -> call .)
    ]               reduce using rule 15 (expr -> call .)
    OF              reduce using rule 15 (expr -> call .)
    THEN            reduce using rule 15 (expr -> call .)
    END             reduce using rule 15 (expr -> call .)
    ELIF            reduce using rule 15 (expr -> call .)
    ELSE            reduce using rule 15 (expr -> call .)


state 17

    (16) expr -> case_of .
    (               reduce using rule 16 (expr -> case_of .)
    INT_DIV         reduce using rule 16 (expr -> case_of .)
    NOT_MORE        reduce using rule 16 (expr -> case_of .)
    NUM_NOT_EQUAL   reduce using rule 16 (expr -> case_of .)
    >               reduce using rule 16 (expr -> case_of .)
    %               reduce using rule 16 (expr -> case_of .)
    <               reduce using rule 16 (expr -> case_of .)
    *               reduce using rule 16 (expr -> case_of .)
    /               reduce using rule 16 (expr -> case_of .)
    -               reduce using rule 16 (expr -> case_of .)
    +               reduce using rule 16 (expr -> case_of .)
    CONCAT          reduce using rule 16 (expr -> case_of .)
    ENUM            reduce using rule 16 (expr -> case_of .)
    [               reduce using rule 16 (expr -> case_of .)
    IDENTIFIER      reduce using rule 16 (expr -> case_of .)
    LET             reduce using rule 16 (expr -> case_of .)
    CASE            reduce using rule 16 (expr -> case_of .)
    IF              reduce using rule 16 (expr -> case_of .)
    DEF             reduce using rule 16 (expr -> case_of .)
    STRING          reduce using rule 16 (expr -> case_of .)
    NUMBER          reduce using rule 16 (expr -> case_of .)
    DO              reduce using rule 16 (expr -> case_of .)
    EXTERNAL        reduce using rule 16 (expr -> case_of .)
    TYPE_IDENTIFIER reduce using rule 16 (expr -> case_of .)
    $end            reduce using rule 16 (expr -> case_of .)
    )               reduce using rule 16 (expr -> case_of .)
    ,               reduce using rule 16 (expr -> case_of .)
    ]               reduce using rule 16 (expr -> case_of .)
    OF              reduce using rule 16 (expr -> case_of .)
    THEN            reduce using rule 16 (expr -> case_of .)
    END             reduce using rule 16 (expr -> case_of .)
    ELIF            reduce using rule 16 (expr -> case_of .)
    ELSE            reduce using rule 16 (expr -> case_of .)


state 18

    (17) expr -> binary_expr .
    (               reduce using rule 17 (expr -> binary_expr .)
    INT_DIV         reduce using rule 17 (expr -> binary_expr .)
    NOT_MORE        reduce using rule 17 (expr -> binary_expr .)
    NUM_NOT_EQUAL   reduce using rule 17 (expr -> binary_expr .)
    >               reduce using rule 17 (expr -> binary_expr .)
    %               reduce using rule 17 (expr -> binary_expr .)
    <               reduce using rule 17 (expr -> binary_expr .)
    *               reduce using rule 17 (expr -> binary_expr .)
    /               reduce using rule 17 (expr -> binary_expr .)
    -               reduce using rule 17 (expr -> binary_expr .)
    +               reduce using rule 17 (expr -> binary_expr .)
    CONCAT          reduce using rule 17 (expr -> binary_expr .)
    ENUM            reduce using rule 17 (expr -> binary_expr .)
    [               reduce using rule 17 (expr -> binary_expr .)
    IDENTIFIER      reduce using rule 17 (expr -> binary_expr .)
    LET             reduce using rule 17 (expr -> binary_expr .)
    CASE            reduce using rule 17 (expr -> binary_expr .)
    IF              reduce using rule 17 (expr -> binary_expr .)
    DEF             reduce using rule 17 (expr -> binary_expr .)
    STRING          reduce using rule 17 (expr -> binary_expr .)
    NUMBER          reduce using rule 17 (expr -> binary_expr .)
    DO              reduce using rule 17 (expr -> binary_expr .)
    EXTERNAL        reduce using rule 17 (expr -> binary_expr .)
    TYPE_IDENTIFIER reduce using rule 17 (expr -> binary_expr .)
    $end            reduce using rule 17 (expr -> binary_expr .)
    )               reduce using rule 17 (expr -> binary_expr .)
    ,               reduce using rule 17 (expr -> binary_expr .)
    ]               reduce using rule 17 (expr -> binary_expr .)
    OF              reduce using rule 17 (expr -> binary_expr .)
    THEN            reduce using rule 17 (expr -> binary_expr .)
    END             reduce using rule 17 (expr -> binary_expr .)
    ELIF            reduce using rule 17 (expr -> binary_expr .)
    ELSE            reduce using rule 17 (expr -> binary_expr .)


state 19

    (18) expr -> if_expr .
    (               reduce using rule 18 (expr -> if_expr .)
    INT_DIV         reduce using rule 18 (expr -> if_expr .)
    NOT_MORE        reduce using rule 18 (expr -> if_expr .)
    NUM_NOT_EQUAL   reduce using rule 18 (expr -> if_expr .)
    >               reduce using rule 18 (expr -> if_expr .)
    %               reduce using rule 18 (expr -> if_expr .)
    <               reduce using rule 18 (expr -> if_expr .)
    *               reduce using rule 18 (expr -> if_expr .)
    /               reduce using rule 18 (expr -> if_expr .)
    -               reduce using rule 18 (expr -> if_expr .)
    +               reduce using rule 18 (expr -> if_expr .)
    CONCAT          reduce using rule 18 (expr -> if_expr .)
    ENUM            reduce using rule 18 (expr -> if_expr .)
    [               reduce using rule 18 (expr -> if_expr .)
    IDENTIFIER      reduce using rule 18 (expr -> if_expr .)
    LET             reduce using rule 18 (expr -> if_expr .)
    CASE            reduce using rule 18 (expr -> if_expr .)
    IF              reduce using rule 18 (expr -> if_expr .)
    DEF             reduce using rule 18 (expr -> if_expr .)
    STRING          reduce using rule 18 (expr -> if_expr .)
    NUMBER          reduce using rule 18 (expr -> if_expr .)
    DO              reduce using rule 18 (expr -> if_expr .)
    EXTERNAL        reduce using rule 18 (expr -> if_expr .)
    TYPE_IDENTIFIER reduce using rule 18 (expr -> if_expr .)
    $end            reduce using rule 18 (expr -> if_expr .)
    )               reduce using rule 18 (expr -> if_expr .)
    ,               reduce using rule 18 (expr -> if_expr .)
    ]               reduce using rule 18 (expr -> if_expr .)
    OF              reduce using rule 18 (expr -> if_expr .)
    THEN            reduce using rule 18 (expr -> if_expr .)
    END             reduce using rule 18 (expr -> if_expr .)
    ELIF            reduce using rule 18 (expr -> if_expr .)
    ELSE            reduce using rule 18 (expr -> if_expr .)


state 20

    (19) expr -> def_expr .
    (               reduce using rule 19 (expr -> def_expr .)
    INT_DIV         reduce using rule 19 (expr -> def_expr .)
    NOT_MORE        reduce using rule 19 (expr -> def_expr .)
    NUM_NOT_EQUAL   reduce using rule 19 (expr -> def_expr .)
    >               reduce using rule 19 (expr -> def_expr .)
    %               reduce using rule 19 (expr -> def_expr .)
    <               reduce using rule 19 (expr -> def_expr .)
    *               reduce using rule 19 (expr -> def_expr .)
    /               reduce using rule 19 (expr -> def_expr .)
    -               reduce using rule 19 (expr -> def_expr .)
    +               reduce using rule 19 (expr -> def_expr .)
    CONCAT          reduce using rule 19 (expr -> def_expr .)
    ENUM            reduce using rule 19 (expr -> def_expr .)
    [               reduce using rule 19 (expr -> def_expr .)
    IDENTIFIER      reduce using rule 19 (expr -> def_expr .)
    LET             reduce using rule 19 (expr -> def_expr .)
    CASE            reduce using rule 19 (expr -> def_expr .)
    IF              reduce using rule 19 (expr -> def_expr .)
    DEF             reduce using rule 19 (expr -> def_expr .)
    STRING          reduce using rule 19 (expr -> def_expr .)
    NUMBER          reduce using rule 19 (expr -> def_expr .)
    DO              reduce using rule 19 (expr -> def_expr .)
    EXTERNAL        reduce using rule 19 (expr -> def_expr .)
    TYPE_IDENTIFIER reduce using rule 19 (expr -> def_expr .)
    $end            reduce using rule 19 (expr -> def_expr .)
    )               reduce using rule 19 (expr -> def_expr .)
    ,               reduce using rule 19 (expr -> def_expr .)
    ]               reduce using rule 19 (expr -> def_expr .)
    OF              reduce using rule 19 (expr -> def_expr .)
    THEN            reduce using rule 19 (expr -> def_expr .)
    END             reduce using rule 19 (expr -> def_expr .)
    ELIF            reduce using rule 19 (expr -> def_expr .)
    ELSE            reduce using rule 19 (expr -> def_expr .)


state 21

    (20) expr -> literal .
    (               reduce using rule 20 (expr -> literal .)
    INT_DIV         reduce using rule 20 (expr -> literal .)
    NOT_MORE        reduce using rule 20 (expr -> literal .)
    NUM_NOT_EQUAL   reduce using rule 20 (expr -> literal .)
    >               reduce using rule 20 (expr -> literal .)
    %               reduce using rule 20 (expr -> literal .)
    <               reduce using rule 20 (expr -> literal .)
    *               reduce using rule 20 (expr -> literal .)
    /               reduce using rule 20 (expr -> literal .)
    -               reduce using rule 20 (expr -> literal .)
    +               reduce using rule 20 (expr -> literal .)
    CONCAT          reduce using rule 20 (expr -> literal .)
    ENUM            reduce using rule 20 (expr -> literal .)
    [               reduce using rule 20 (expr -> literal .)
    IDENTIFIER      reduce using rule 20 (expr -> literal .)
    LET             reduce using rule 20 (expr -> literal .)
    CASE            reduce using rule 20 (expr -> literal .)
    IF              reduce using rule 20 (expr -> literal .)
    DEF             reduce using rule 20 (expr -> literal .)
    STRING          reduce using rule 20 (expr -> literal .)
    NUMBER          reduce using rule 20 (expr -> literal .)
    DO              reduce using rule 20 (expr -> literal .)
    EXTERNAL        reduce using rule 20 (expr -> literal .)
    TYPE_IDENTIFIER reduce using rule 20 (expr -> literal .)
    $end            reduce using rule 20 (expr -> literal .)
    )               reduce using rule 20 (expr -> literal .)
    ,               reduce using rule 20 (expr -> literal .)
    ]               reduce using rule 20 (expr -> literal .)
    OF              reduce using rule 20 (expr -> literal .)
    THEN            reduce using rule 20 (expr -> literal .)
    END             reduce using rule 20 (expr -> literal .)
    ELIF            reduce using rule 20 (expr -> literal .)
    ELSE            reduce using rule 20 (expr -> literal .)


state 22

    (21) expr -> do .
    (               reduce using rule 21 (expr -> do .)
    INT_DIV         reduce using rule 21 (expr -> do .)
    NOT_MORE        reduce using rule 21 (expr -> do .)
    NUM_NOT_EQUAL   reduce using rule 21 (expr -> do .)
    >               reduce using rule 21 (expr -> do .)
    %               reduce using rule 21 (expr -> do .)
    <               reduce using rule 21 (expr -> do .)
    *               reduce using rule 21 (expr -> do .)
    /               reduce using rule 21 (expr -> do .)
    -               reduce using rule 21 (expr -> do .)
    +               reduce using rule 21 (expr -> do .)
    CONCAT          reduce using rule 21 (expr -> do .)
    ENUM            reduce using rule 21 (expr -> do .)
    [               reduce using rule 21 (expr -> do .)
    IDENTIFIER      reduce using rule 21 (expr -> do .)
    LET             reduce using rule 21 (expr -> do .)
    CASE            reduce using rule 21 (expr -> do .)
    IF              reduce using rule 21 (expr -> do .)
    DEF             reduce using rule 21 (expr -> do .)
    STRING          reduce using rule 21 (expr -> do .)
    NUMBER          reduce using rule 21 (expr -> do .)
    DO              reduce using rule 21 (expr -> do .)
    EXTERNAL        reduce using rule 21 (expr -> do .)
    TYPE_IDENTIFIER reduce using rule 21 (expr -> do .)
    $end            reduce using rule 21 (expr -> do .)
    )               reduce using rule 21 (expr -> do .)
    ,               reduce using rule 21 (expr -> do .)
    ]               reduce using rule 21 (expr -> do .)
    OF              reduce using rule 21 (expr -> do .)
    THEN            reduce using rule 21 (expr -> do .)
    END             reduce using rule 21 (expr -> do .)
    ELIF            reduce using rule 21 (expr -> do .)
    ELSE            reduce using rule 21 (expr -> do .)


state 23

    (22) expr -> external .
    (               reduce using rule 22 (expr -> external .)
    INT_DIV         reduce using rule 22 (expr -> external .)
    NOT_MORE        reduce using rule 22 (expr -> external .)
    NUM_NOT_EQUAL   reduce using rule 22 (expr -> external .)
    >               reduce using rule 22 (expr -> external .)
    %               reduce using rule 22 (expr -> external .)
    <               reduce using rule 22 (expr -> external .)
    *               reduce using rule 22 (expr -> external .)
    /               reduce using rule 22 (expr -> external .)
    -               reduce using rule 22 (expr -> external .)
    +               reduce using rule 22 (expr -> external .)
    CONCAT          reduce using rule 22 (expr -> external .)
    ENUM            reduce using rule 22 (expr -> external .)
    [               reduce using rule 22 (expr -> external .)
    IDENTIFIER      reduce using rule 22 (expr -> external .)
    LET             reduce using rule 22 (expr -> external .)
    CASE            reduce using rule 22 (expr -> external .)
    IF              reduce using rule 22 (expr -> external .)
    DEF             reduce using rule 22 (expr -> external .)
    STRING          reduce using rule 22 (expr -> external .)
    NUMBER          reduce using rule 22 (expr -> external .)
    DO              reduce using rule 22 (expr -> external .)
    EXTERNAL        reduce using rule 22 (expr -> external .)
    TYPE_IDENTIFIER reduce using rule 22 (expr -> external .)
    $end            reduce using rule 22 (expr -> external .)
    )               reduce using rule 22 (expr -> external .)
    ,               reduce using rule 22 (expr -> external .)
    ]               reduce using rule 22 (expr -> external .)
    OF              reduce using rule 22 (expr -> external .)
    THEN            reduce using rule 22 (expr -> external .)
    END             reduce using rule 22 (expr -> external .)
    ELIF            reduce using rule 22 (expr -> external .)
    ELSE            reduce using rule 22 (expr -> external .)


state 24

    (120) array -> [ . _20_optional _21_repeat ]
    (121) _20_optional -> . expr
    (122) _20_optional -> .
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 122 (_20_optional -> .)
    ]               reduce using rule 122 (_20_optional -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _20_optional                   shift and go to state 52
    expr                           shift and go to state 53
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 25

    (145) identifier -> IDENTIFIER .
    (               reduce using rule 145 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 145 (identifier -> IDENTIFIER .)
    NOT_MORE        reduce using rule 145 (identifier -> IDENTIFIER .)
    NUM_NOT_EQUAL   reduce using rule 145 (identifier -> IDENTIFIER .)
    >               reduce using rule 145 (identifier -> IDENTIFIER .)
    %               reduce using rule 145 (identifier -> IDENTIFIER .)
    <               reduce using rule 145 (identifier -> IDENTIFIER .)
    *               reduce using rule 145 (identifier -> IDENTIFIER .)
    /               reduce using rule 145 (identifier -> IDENTIFIER .)
    -               reduce using rule 145 (identifier -> IDENTIFIER .)
    +               reduce using rule 145 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 145 (identifier -> IDENTIFIER .)
    ENUM            reduce using rule 145 (identifier -> IDENTIFIER .)
    [               reduce using rule 145 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 145 (identifier -> IDENTIFIER .)
    LET             reduce using rule 145 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 145 (identifier -> IDENTIFIER .)
    IF              reduce using rule 145 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 145 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 145 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 145 (identifier -> IDENTIFIER .)
    DO              reduce using rule 145 (identifier -> IDENTIFIER .)
    EXTERNAL        reduce using rule 145 (identifier -> IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 145 (identifier -> IDENTIFIER .)
    $end            reduce using rule 145 (identifier -> IDENTIFIER .)
    )               reduce using rule 145 (identifier -> IDENTIFIER .)
    ,               reduce using rule 145 (identifier -> IDENTIFIER .)
    ]               reduce using rule 145 (identifier -> IDENTIFIER .)
    OF              reduce using rule 145 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 145 (identifier -> IDENTIFIER .)
    END             reduce using rule 145 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 145 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 145 (identifier -> IDENTIFIER .)
    :               reduce using rule 145 (identifier -> IDENTIFIER .)
    =               reduce using rule 145 (identifier -> IDENTIFIER .)


state 26

    (147) variable_declaration -> LET . identifier _26_optional = expr
    (145) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 54

state 27

    (102) case_of -> CASE . expr OF _17_repeat END
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 55
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 28

    (93) if_expr -> IF . expr THEN _14_optional block_statement _15_optional END
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 56
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 29

    (49) def_expr -> DEF . identifier ( _5_optional _6_repeat ) _7_optional do
    (145) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 57

state 30

    (150) literal -> STRING .
    (               reduce using rule 150 (literal -> STRING .)
    INT_DIV         reduce using rule 150 (literal -> STRING .)
    NOT_MORE        reduce using rule 150 (literal -> STRING .)
    NUM_NOT_EQUAL   reduce using rule 150 (literal -> STRING .)
    >               reduce using rule 150 (literal -> STRING .)
    %               reduce using rule 150 (literal -> STRING .)
    <               reduce using rule 150 (literal -> STRING .)
    *               reduce using rule 150 (literal -> STRING .)
    /               reduce using rule 150 (literal -> STRING .)
    -               reduce using rule 150 (literal -> STRING .)
    +               reduce using rule 150 (literal -> STRING .)
    CONCAT          reduce using rule 150 (literal -> STRING .)
    ENUM            reduce using rule 150 (literal -> STRING .)
    [               reduce using rule 150 (literal -> STRING .)
    IDENTIFIER      reduce using rule 150 (literal -> STRING .)
    LET             reduce using rule 150 (literal -> STRING .)
    CASE            reduce using rule 150 (literal -> STRING .)
    IF              reduce using rule 150 (literal -> STRING .)
    DEF             reduce using rule 150 (literal -> STRING .)
    STRING          reduce using rule 150 (literal -> STRING .)
    NUMBER          reduce using rule 150 (literal -> STRING .)
    DO              reduce using rule 150 (literal -> STRING .)
    EXTERNAL        reduce using rule 150 (literal -> STRING .)
    TYPE_IDENTIFIER reduce using rule 150 (literal -> STRING .)
    $end            reduce using rule 150 (literal -> STRING .)
    )               reduce using rule 150 (literal -> STRING .)
    ,               reduce using rule 150 (literal -> STRING .)
    ]               reduce using rule 150 (literal -> STRING .)
    OF              reduce using rule 150 (literal -> STRING .)
    THEN            reduce using rule 150 (literal -> STRING .)
    END             reduce using rule 150 (literal -> STRING .)
    ELIF            reduce using rule 150 (literal -> STRING .)
    ELSE            reduce using rule 150 (literal -> STRING .)


state 31

    (151) literal -> NUMBER .
    (               reduce using rule 151 (literal -> NUMBER .)
    INT_DIV         reduce using rule 151 (literal -> NUMBER .)
    NOT_MORE        reduce using rule 151 (literal -> NUMBER .)
    NUM_NOT_EQUAL   reduce using rule 151 (literal -> NUMBER .)
    >               reduce using rule 151 (literal -> NUMBER .)
    %               reduce using rule 151 (literal -> NUMBER .)
    <               reduce using rule 151 (literal -> NUMBER .)
    *               reduce using rule 151 (literal -> NUMBER .)
    /               reduce using rule 151 (literal -> NUMBER .)
    -               reduce using rule 151 (literal -> NUMBER .)
    +               reduce using rule 151 (literal -> NUMBER .)
    CONCAT          reduce using rule 151 (literal -> NUMBER .)
    ENUM            reduce using rule 151 (literal -> NUMBER .)
    [               reduce using rule 151 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 151 (literal -> NUMBER .)
    LET             reduce using rule 151 (literal -> NUMBER .)
    CASE            reduce using rule 151 (literal -> NUMBER .)
    IF              reduce using rule 151 (literal -> NUMBER .)
    DEF             reduce using rule 151 (literal -> NUMBER .)
    STRING          reduce using rule 151 (literal -> NUMBER .)
    NUMBER          reduce using rule 151 (literal -> NUMBER .)
    DO              reduce using rule 151 (literal -> NUMBER .)
    EXTERNAL        reduce using rule 151 (literal -> NUMBER .)
    TYPE_IDENTIFIER reduce using rule 151 (literal -> NUMBER .)
    $end            reduce using rule 151 (literal -> NUMBER .)
    )               reduce using rule 151 (literal -> NUMBER .)
    ,               reduce using rule 151 (literal -> NUMBER .)
    ]               reduce using rule 151 (literal -> NUMBER .)
    OF              reduce using rule 151 (literal -> NUMBER .)
    THEN            reduce using rule 151 (literal -> NUMBER .)
    END             reduce using rule 151 (literal -> NUMBER .)
    ELIF            reduce using rule 151 (literal -> NUMBER .)
    ELSE            reduce using rule 151 (literal -> NUMBER .)


state 32

    (35) do -> DO . _2_optional _3_repeat END
    (36) _2_optional -> . : type
    (37) _2_optional -> .
    :               shift and go to state 59
    (               reduce using rule 37 (_2_optional -> .)
    -               reduce using rule 37 (_2_optional -> .)
    [               reduce using rule 37 (_2_optional -> .)
    IDENTIFIER      reduce using rule 37 (_2_optional -> .)
    LET             reduce using rule 37 (_2_optional -> .)
    CASE            reduce using rule 37 (_2_optional -> .)
    IF              reduce using rule 37 (_2_optional -> .)
    DEF             reduce using rule 37 (_2_optional -> .)
    STRING          reduce using rule 37 (_2_optional -> .)
    NUMBER          reduce using rule 37 (_2_optional -> .)
    DO              reduce using rule 37 (_2_optional -> .)
    EXTERNAL        reduce using rule 37 (_2_optional -> .)
    TYPE_IDENTIFIER reduce using rule 37 (_2_optional -> .)
    END             reduce using rule 37 (_2_optional -> .)

    _2_optional                    shift and go to state 58

state 33

    (23) external -> EXTERNAL .
    (               reduce using rule 23 (external -> EXTERNAL .)
    INT_DIV         reduce using rule 23 (external -> EXTERNAL .)
    NOT_MORE        reduce using rule 23 (external -> EXTERNAL .)
    NUM_NOT_EQUAL   reduce using rule 23 (external -> EXTERNAL .)
    >               reduce using rule 23 (external -> EXTERNAL .)
    %               reduce using rule 23 (external -> EXTERNAL .)
    <               reduce using rule 23 (external -> EXTERNAL .)
    *               reduce using rule 23 (external -> EXTERNAL .)
    /               reduce using rule 23 (external -> EXTERNAL .)
    -               reduce using rule 23 (external -> EXTERNAL .)
    +               reduce using rule 23 (external -> EXTERNAL .)
    CONCAT          reduce using rule 23 (external -> EXTERNAL .)
    ENUM            reduce using rule 23 (external -> EXTERNAL .)
    [               reduce using rule 23 (external -> EXTERNAL .)
    IDENTIFIER      reduce using rule 23 (external -> EXTERNAL .)
    LET             reduce using rule 23 (external -> EXTERNAL .)
    CASE            reduce using rule 23 (external -> EXTERNAL .)
    IF              reduce using rule 23 (external -> EXTERNAL .)
    DEF             reduce using rule 23 (external -> EXTERNAL .)
    STRING          reduce using rule 23 (external -> EXTERNAL .)
    NUMBER          reduce using rule 23 (external -> EXTERNAL .)
    DO              reduce using rule 23 (external -> EXTERNAL .)
    EXTERNAL        reduce using rule 23 (external -> EXTERNAL .)
    TYPE_IDENTIFIER reduce using rule 23 (external -> EXTERNAL .)
    $end            reduce using rule 23 (external -> EXTERNAL .)
    )               reduce using rule 23 (external -> EXTERNAL .)
    ,               reduce using rule 23 (external -> EXTERNAL .)
    ]               reduce using rule 23 (external -> EXTERNAL .)
    OF              reduce using rule 23 (external -> EXTERNAL .)
    THEN            reduce using rule 23 (external -> EXTERNAL .)
    END             reduce using rule 23 (external -> EXTERNAL .)
    ELIF            reduce using rule 23 (external -> EXTERNAL .)
    ELSE            reduce using rule 23 (external -> EXTERNAL .)


state 34

    (146) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    INT_DIV         reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    NOT_MORE        reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    NUM_NOT_EQUAL   reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    %               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    *               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    /               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    +               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    CONCAT          reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    LET             reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    $end            reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    ]               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    OF              reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    THEN            reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 146 (type_identifier -> TYPE_IDENTIFIER .)


state 35

    (4) _1_items -> _1_items _1_item .
    ENUM            reduce using rule 4 (_1_items -> _1_items _1_item .)
    (               reduce using rule 4 (_1_items -> _1_items _1_item .)
    -               reduce using rule 4 (_1_items -> _1_items _1_item .)
    [               reduce using rule 4 (_1_items -> _1_items _1_item .)
    IDENTIFIER      reduce using rule 4 (_1_items -> _1_items _1_item .)
    LET             reduce using rule 4 (_1_items -> _1_items _1_item .)
    CASE            reduce using rule 4 (_1_items -> _1_items _1_item .)
    IF              reduce using rule 4 (_1_items -> _1_items _1_item .)
    DEF             reduce using rule 4 (_1_items -> _1_items _1_item .)
    STRING          reduce using rule 4 (_1_items -> _1_items _1_item .)
    NUMBER          reduce using rule 4 (_1_items -> _1_items _1_item .)
    DO              reduce using rule 4 (_1_items -> _1_items _1_item .)
    EXTERNAL        reduce using rule 4 (_1_items -> _1_items _1_item .)
    TYPE_IDENTIFIER reduce using rule 4 (_1_items -> _1_items _1_item .)
    $end            reduce using rule 4 (_1_items -> _1_items _1_item .)


state 36

    (128) call -> expr ( . _22_optional _23_repeat )
    (129) _22_optional -> . expr
    (130) _22_optional -> .
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 130 (_22_optional -> .)
    )               reduce using rule 130 (_22_optional -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 60
    _22_optional                   shift and go to state 61
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 37

    (24) binary_expr -> expr INT_DIV . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 62
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 38

    (25) binary_expr -> expr NOT_MORE . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 63
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 39

    (26) binary_expr -> expr NUM_NOT_EQUAL . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 64
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 40

    (27) binary_expr -> expr > . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 65
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 41

    (28) binary_expr -> expr % . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 66
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 42

    (29) binary_expr -> expr < . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 67
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 43

    (30) binary_expr -> expr * . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 68
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 44

    (31) binary_expr -> expr / . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 69
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 45

    (32) binary_expr -> expr - . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 70
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 46

    (33) binary_expr -> expr + . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 71
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 47

    (34) binary_expr -> expr CONCAT . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 72
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 48

    (66) enum -> ENUM type_identifier . { _9_repeat }
    (72) enum -> ENUM type_identifier . < type_identifier _10_repeat > { _11_repeat }
    {               shift and go to state 73
    <               shift and go to state 74


state 49

    (137) variant_call -> type_identifier ( . _24_optional _25_repeat )
    (138) _24_optional -> . expr
    (139) _24_optional -> .
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 139 (_24_optional -> .)
    )               reduce using rule 139 (_24_optional -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 9
    _24_optional                   shift and go to state 75
    expr                           shift and go to state 76
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23

state 50

    (9) expr -> ( expr . )
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    )               shift and go to state 77
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 51

    (10) expr -> - expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    (               reduce using rule 10 (expr -> - expr .)
    INT_DIV         reduce using rule 10 (expr -> - expr .)
    NOT_MORE        reduce using rule 10 (expr -> - expr .)
    NUM_NOT_EQUAL   reduce using rule 10 (expr -> - expr .)
    >               reduce using rule 10 (expr -> - expr .)
    %               reduce using rule 10 (expr -> - expr .)
    <               reduce using rule 10 (expr -> - expr .)
    *               reduce using rule 10 (expr -> - expr .)
    /               reduce using rule 10 (expr -> - expr .)
    -               reduce using rule 10 (expr -> - expr .)
    +               reduce using rule 10 (expr -> - expr .)
    CONCAT          reduce using rule 10 (expr -> - expr .)
    ENUM            reduce using rule 10 (expr -> - expr .)
    [               reduce using rule 10 (expr -> - expr .)
    IDENTIFIER      reduce using rule 10 (expr -> - expr .)
    LET             reduce using rule 10 (expr -> - expr .)
    CASE            reduce using rule 10 (expr -> - expr .)
    IF              reduce using rule 10 (expr -> - expr .)
    DEF             reduce using rule 10 (expr -> - expr .)
    STRING          reduce using rule 10 (expr -> - expr .)
    NUMBER          reduce using rule 10 (expr -> - expr .)
    DO              reduce using rule 10 (expr -> - expr .)
    EXTERNAL        reduce using rule 10 (expr -> - expr .)
    TYPE_IDENTIFIER reduce using rule 10 (expr -> - expr .)
    $end            reduce using rule 10 (expr -> - expr .)
    )               reduce using rule 10 (expr -> - expr .)
    ,               reduce using rule 10 (expr -> - expr .)
    ]               reduce using rule 10 (expr -> - expr .)
    OF              reduce using rule 10 (expr -> - expr .)
    THEN            reduce using rule 10 (expr -> - expr .)
    END             reduce using rule 10 (expr -> - expr .)
    ELIF            reduce using rule 10 (expr -> - expr .)
    ELSE            reduce using rule 10 (expr -> - expr .)


state 52

    (120) array -> [ _20_optional . _21_repeat ]
    (123) _21_repeat -> . _21_items
    (124) _21_repeat -> .
    (125) _21_items -> . _21_items _21_item
    (126) _21_items -> . _21_item
    (127) _21_item -> . , expr
    ]               reduce using rule 124 (_21_repeat -> .)
    ,               shift and go to state 81

    _21_repeat                     shift and go to state 78
    _21_items                      shift and go to state 79
    _21_item                       shift and go to state 80

state 53

    (121) _20_optional -> expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 121 (_20_optional -> expr .)
    ]               reduce using rule 121 (_20_optional -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 54

    (147) variable_declaration -> LET identifier . _26_optional = expr
    (148) _26_optional -> . : type
    (149) _26_optional -> .
    :               shift and go to state 83
    =               reduce using rule 149 (_26_optional -> .)

    _26_optional                   shift and go to state 82

state 55

    (102) case_of -> CASE expr . OF _17_repeat END
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 84
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 56

    (93) if_expr -> IF expr . THEN _14_optional block_statement _15_optional END
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 85
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 57

    (49) def_expr -> DEF identifier . ( _5_optional _6_repeat ) _7_optional do
    (               shift and go to state 86


state 58

    (35) do -> DO _2_optional . _3_repeat END
    (38) _3_repeat -> . _3_items
    (39) _3_repeat -> .
    (40) _3_items -> . _3_items _3_item
    (41) _3_items -> . _3_item
    (42) _3_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 39 (_3_repeat -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _3_repeat                      shift and go to state 87
    _3_items                       shift and go to state 88
    _3_item                        shift and go to state 89
    expr                           shift and go to state 90
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 59

    (36) _2_optional -> : . type
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 91
    type_identifier                shift and go to state 92

state 60

    (129) _22_optional -> expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 129 (_22_optional -> expr .)
    )               reduce using rule 129 (_22_optional -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 61

    (128) call -> expr ( _22_optional . _23_repeat )
    (131) _23_repeat -> . _23_items
    (132) _23_repeat -> .
    (133) _23_items -> . _23_items _23_item
    (134) _23_items -> . _23_item
    (135) _23_item -> . , expr
    )               reduce using rule 132 (_23_repeat -> .)
    ,               shift and go to state 96

    _23_repeat                     shift and go to state 93
    _23_items                      shift and go to state 94
    _23_item                       shift and go to state 95

state 62

    (24) binary_expr -> expr INT_DIV expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    NOT_MORE        reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    NUM_NOT_EQUAL   reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    %               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ENUM            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    [               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    IDENTIFIER      reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    LET             reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    CASE            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    IF              reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    DEF             reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    STRING          reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    NUMBER          reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    DO              reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    EXTERNAL        reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    TYPE_IDENTIFIER reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    (               shift and go to state 36


state 63

    (25) binary_expr -> expr NOT_MORE expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    NUM_NOT_EQUAL   reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    >               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    <               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ENUM            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    [               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    IDENTIFIER      reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    LET             reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    CASE            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    IF              reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    DEF             reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    STRING          reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    NUMBER          reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    DO              reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    EXTERNAL        reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    TYPE_IDENTIFIER reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    $end            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    )               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ,               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ]               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    OF              reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    THEN            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    END             reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ELIF            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ELSE            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 64

    (26) binary_expr -> expr NUM_NOT_EQUAL expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    NUM_NOT_EQUAL   reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    >               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    <               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ENUM            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    [               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    IDENTIFIER      reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    LET             reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    CASE            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    IF              reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    DEF             reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    STRING          reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    NUMBER          reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    DO              reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    EXTERNAL        reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    TYPE_IDENTIFIER reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    $end            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    )               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ,               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ]               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    OF              reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    THEN            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    END             reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 65

    (27) binary_expr -> expr > expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 27 (binary_expr -> expr > expr .)
    NUM_NOT_EQUAL   reduce using rule 27 (binary_expr -> expr > expr .)
    >               reduce using rule 27 (binary_expr -> expr > expr .)
    <               reduce using rule 27 (binary_expr -> expr > expr .)
    ENUM            reduce using rule 27 (binary_expr -> expr > expr .)
    [               reduce using rule 27 (binary_expr -> expr > expr .)
    IDENTIFIER      reduce using rule 27 (binary_expr -> expr > expr .)
    LET             reduce using rule 27 (binary_expr -> expr > expr .)
    CASE            reduce using rule 27 (binary_expr -> expr > expr .)
    IF              reduce using rule 27 (binary_expr -> expr > expr .)
    DEF             reduce using rule 27 (binary_expr -> expr > expr .)
    STRING          reduce using rule 27 (binary_expr -> expr > expr .)
    NUMBER          reduce using rule 27 (binary_expr -> expr > expr .)
    DO              reduce using rule 27 (binary_expr -> expr > expr .)
    EXTERNAL        reduce using rule 27 (binary_expr -> expr > expr .)
    TYPE_IDENTIFIER reduce using rule 27 (binary_expr -> expr > expr .)
    $end            reduce using rule 27 (binary_expr -> expr > expr .)
    )               reduce using rule 27 (binary_expr -> expr > expr .)
    ,               reduce using rule 27 (binary_expr -> expr > expr .)
    ]               reduce using rule 27 (binary_expr -> expr > expr .)
    OF              reduce using rule 27 (binary_expr -> expr > expr .)
    THEN            reduce using rule 27 (binary_expr -> expr > expr .)
    END             reduce using rule 27 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr > expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 66

    (28) binary_expr -> expr % expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 28 (binary_expr -> expr % expr .)
    NUM_NOT_EQUAL   reduce using rule 28 (binary_expr -> expr % expr .)
    >               reduce using rule 28 (binary_expr -> expr % expr .)
    %               reduce using rule 28 (binary_expr -> expr % expr .)
    <               reduce using rule 28 (binary_expr -> expr % expr .)
    CONCAT          reduce using rule 28 (binary_expr -> expr % expr .)
    ENUM            reduce using rule 28 (binary_expr -> expr % expr .)
    [               reduce using rule 28 (binary_expr -> expr % expr .)
    IDENTIFIER      reduce using rule 28 (binary_expr -> expr % expr .)
    LET             reduce using rule 28 (binary_expr -> expr % expr .)
    CASE            reduce using rule 28 (binary_expr -> expr % expr .)
    IF              reduce using rule 28 (binary_expr -> expr % expr .)
    DEF             reduce using rule 28 (binary_expr -> expr % expr .)
    STRING          reduce using rule 28 (binary_expr -> expr % expr .)
    NUMBER          reduce using rule 28 (binary_expr -> expr % expr .)
    DO              reduce using rule 28 (binary_expr -> expr % expr .)
    EXTERNAL        reduce using rule 28 (binary_expr -> expr % expr .)
    TYPE_IDENTIFIER reduce using rule 28 (binary_expr -> expr % expr .)
    $end            reduce using rule 28 (binary_expr -> expr % expr .)
    )               reduce using rule 28 (binary_expr -> expr % expr .)
    ,               reduce using rule 28 (binary_expr -> expr % expr .)
    ]               reduce using rule 28 (binary_expr -> expr % expr .)
    OF              reduce using rule 28 (binary_expr -> expr % expr .)
    THEN            reduce using rule 28 (binary_expr -> expr % expr .)
    END             reduce using rule 28 (binary_expr -> expr % expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr % expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr % expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 67

    (29) binary_expr -> expr < expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 29 (binary_expr -> expr < expr .)
    NUM_NOT_EQUAL   reduce using rule 29 (binary_expr -> expr < expr .)
    >               reduce using rule 29 (binary_expr -> expr < expr .)
    <               reduce using rule 29 (binary_expr -> expr < expr .)
    ENUM            reduce using rule 29 (binary_expr -> expr < expr .)
    [               reduce using rule 29 (binary_expr -> expr < expr .)
    IDENTIFIER      reduce using rule 29 (binary_expr -> expr < expr .)
    LET             reduce using rule 29 (binary_expr -> expr < expr .)
    CASE            reduce using rule 29 (binary_expr -> expr < expr .)
    IF              reduce using rule 29 (binary_expr -> expr < expr .)
    DEF             reduce using rule 29 (binary_expr -> expr < expr .)
    STRING          reduce using rule 29 (binary_expr -> expr < expr .)
    NUMBER          reduce using rule 29 (binary_expr -> expr < expr .)
    DO              reduce using rule 29 (binary_expr -> expr < expr .)
    EXTERNAL        reduce using rule 29 (binary_expr -> expr < expr .)
    TYPE_IDENTIFIER reduce using rule 29 (binary_expr -> expr < expr .)
    $end            reduce using rule 29 (binary_expr -> expr < expr .)
    )               reduce using rule 29 (binary_expr -> expr < expr .)
    ,               reduce using rule 29 (binary_expr -> expr < expr .)
    ]               reduce using rule 29 (binary_expr -> expr < expr .)
    OF              reduce using rule 29 (binary_expr -> expr < expr .)
    THEN            reduce using rule 29 (binary_expr -> expr < expr .)
    END             reduce using rule 29 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr < expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 68

    (30) binary_expr -> expr * expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 30 (binary_expr -> expr * expr .)
    NOT_MORE        reduce using rule 30 (binary_expr -> expr * expr .)
    NUM_NOT_EQUAL   reduce using rule 30 (binary_expr -> expr * expr .)
    >               reduce using rule 30 (binary_expr -> expr * expr .)
    %               reduce using rule 30 (binary_expr -> expr * expr .)
    <               reduce using rule 30 (binary_expr -> expr * expr .)
    *               reduce using rule 30 (binary_expr -> expr * expr .)
    /               reduce using rule 30 (binary_expr -> expr * expr .)
    -               reduce using rule 30 (binary_expr -> expr * expr .)
    +               reduce using rule 30 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 30 (binary_expr -> expr * expr .)
    ENUM            reduce using rule 30 (binary_expr -> expr * expr .)
    [               reduce using rule 30 (binary_expr -> expr * expr .)
    IDENTIFIER      reduce using rule 30 (binary_expr -> expr * expr .)
    LET             reduce using rule 30 (binary_expr -> expr * expr .)
    CASE            reduce using rule 30 (binary_expr -> expr * expr .)
    IF              reduce using rule 30 (binary_expr -> expr * expr .)
    DEF             reduce using rule 30 (binary_expr -> expr * expr .)
    STRING          reduce using rule 30 (binary_expr -> expr * expr .)
    NUMBER          reduce using rule 30 (binary_expr -> expr * expr .)
    DO              reduce using rule 30 (binary_expr -> expr * expr .)
    EXTERNAL        reduce using rule 30 (binary_expr -> expr * expr .)
    TYPE_IDENTIFIER reduce using rule 30 (binary_expr -> expr * expr .)
    $end            reduce using rule 30 (binary_expr -> expr * expr .)
    )               reduce using rule 30 (binary_expr -> expr * expr .)
    ,               reduce using rule 30 (binary_expr -> expr * expr .)
    ]               reduce using rule 30 (binary_expr -> expr * expr .)
    OF              reduce using rule 30 (binary_expr -> expr * expr .)
    THEN            reduce using rule 30 (binary_expr -> expr * expr .)
    END             reduce using rule 30 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr * expr .)
    (               shift and go to state 36


state 69

    (31) binary_expr -> expr / expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 31 (binary_expr -> expr / expr .)
    NOT_MORE        reduce using rule 31 (binary_expr -> expr / expr .)
    NUM_NOT_EQUAL   reduce using rule 31 (binary_expr -> expr / expr .)
    >               reduce using rule 31 (binary_expr -> expr / expr .)
    %               reduce using rule 31 (binary_expr -> expr / expr .)
    <               reduce using rule 31 (binary_expr -> expr / expr .)
    *               reduce using rule 31 (binary_expr -> expr / expr .)
    /               reduce using rule 31 (binary_expr -> expr / expr .)
    -               reduce using rule 31 (binary_expr -> expr / expr .)
    +               reduce using rule 31 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 31 (binary_expr -> expr / expr .)
    ENUM            reduce using rule 31 (binary_expr -> expr / expr .)
    [               reduce using rule 31 (binary_expr -> expr / expr .)
    IDENTIFIER      reduce using rule 31 (binary_expr -> expr / expr .)
    LET             reduce using rule 31 (binary_expr -> expr / expr .)
    CASE            reduce using rule 31 (binary_expr -> expr / expr .)
    IF              reduce using rule 31 (binary_expr -> expr / expr .)
    DEF             reduce using rule 31 (binary_expr -> expr / expr .)
    STRING          reduce using rule 31 (binary_expr -> expr / expr .)
    NUMBER          reduce using rule 31 (binary_expr -> expr / expr .)
    DO              reduce using rule 31 (binary_expr -> expr / expr .)
    EXTERNAL        reduce using rule 31 (binary_expr -> expr / expr .)
    TYPE_IDENTIFIER reduce using rule 31 (binary_expr -> expr / expr .)
    $end            reduce using rule 31 (binary_expr -> expr / expr .)
    )               reduce using rule 31 (binary_expr -> expr / expr .)
    ,               reduce using rule 31 (binary_expr -> expr / expr .)
    ]               reduce using rule 31 (binary_expr -> expr / expr .)
    OF              reduce using rule 31 (binary_expr -> expr / expr .)
    THEN            reduce using rule 31 (binary_expr -> expr / expr .)
    END             reduce using rule 31 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr / expr .)
    (               shift and go to state 36


state 70

    (32) binary_expr -> expr - expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 32 (binary_expr -> expr - expr .)
    NUM_NOT_EQUAL   reduce using rule 32 (binary_expr -> expr - expr .)
    >               reduce using rule 32 (binary_expr -> expr - expr .)
    %               reduce using rule 32 (binary_expr -> expr - expr .)
    <               reduce using rule 32 (binary_expr -> expr - expr .)
    -               reduce using rule 32 (binary_expr -> expr - expr .)
    +               reduce using rule 32 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 32 (binary_expr -> expr - expr .)
    ENUM            reduce using rule 32 (binary_expr -> expr - expr .)
    [               reduce using rule 32 (binary_expr -> expr - expr .)
    IDENTIFIER      reduce using rule 32 (binary_expr -> expr - expr .)
    LET             reduce using rule 32 (binary_expr -> expr - expr .)
    CASE            reduce using rule 32 (binary_expr -> expr - expr .)
    IF              reduce using rule 32 (binary_expr -> expr - expr .)
    DEF             reduce using rule 32 (binary_expr -> expr - expr .)
    STRING          reduce using rule 32 (binary_expr -> expr - expr .)
    NUMBER          reduce using rule 32 (binary_expr -> expr - expr .)
    DO              reduce using rule 32 (binary_expr -> expr - expr .)
    EXTERNAL        reduce using rule 32 (binary_expr -> expr - expr .)
    TYPE_IDENTIFIER reduce using rule 32 (binary_expr -> expr - expr .)
    $end            reduce using rule 32 (binary_expr -> expr - expr .)
    )               reduce using rule 32 (binary_expr -> expr - expr .)
    ,               reduce using rule 32 (binary_expr -> expr - expr .)
    ]               reduce using rule 32 (binary_expr -> expr - expr .)
    OF              reduce using rule 32 (binary_expr -> expr - expr .)
    THEN            reduce using rule 32 (binary_expr -> expr - expr .)
    END             reduce using rule 32 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr - expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    *               shift and go to state 43
    /               shift and go to state 44


state 71

    (33) binary_expr -> expr + expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 33 (binary_expr -> expr + expr .)
    NUM_NOT_EQUAL   reduce using rule 33 (binary_expr -> expr + expr .)
    >               reduce using rule 33 (binary_expr -> expr + expr .)
    %               reduce using rule 33 (binary_expr -> expr + expr .)
    <               reduce using rule 33 (binary_expr -> expr + expr .)
    -               reduce using rule 33 (binary_expr -> expr + expr .)
    +               reduce using rule 33 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 33 (binary_expr -> expr + expr .)
    ENUM            reduce using rule 33 (binary_expr -> expr + expr .)
    [               reduce using rule 33 (binary_expr -> expr + expr .)
    IDENTIFIER      reduce using rule 33 (binary_expr -> expr + expr .)
    LET             reduce using rule 33 (binary_expr -> expr + expr .)
    CASE            reduce using rule 33 (binary_expr -> expr + expr .)
    IF              reduce using rule 33 (binary_expr -> expr + expr .)
    DEF             reduce using rule 33 (binary_expr -> expr + expr .)
    STRING          reduce using rule 33 (binary_expr -> expr + expr .)
    NUMBER          reduce using rule 33 (binary_expr -> expr + expr .)
    DO              reduce using rule 33 (binary_expr -> expr + expr .)
    EXTERNAL        reduce using rule 33 (binary_expr -> expr + expr .)
    TYPE_IDENTIFIER reduce using rule 33 (binary_expr -> expr + expr .)
    $end            reduce using rule 33 (binary_expr -> expr + expr .)
    )               reduce using rule 33 (binary_expr -> expr + expr .)
    ,               reduce using rule 33 (binary_expr -> expr + expr .)
    ]               reduce using rule 33 (binary_expr -> expr + expr .)
    OF              reduce using rule 33 (binary_expr -> expr + expr .)
    THEN            reduce using rule 33 (binary_expr -> expr + expr .)
    END             reduce using rule 33 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr + expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    *               shift and go to state 43
    /               shift and go to state 44


state 72

    (34) binary_expr -> expr CONCAT expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    NUM_NOT_EQUAL   reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ENUM            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    [               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    IDENTIFIER      reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    LET             reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    CASE            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    IF              reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    DEF             reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    STRING          reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    NUMBER          reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    DO              reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    EXTERNAL        reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    TYPE_IDENTIFIER reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 73

    (66) enum -> ENUM type_identifier { . _9_repeat }
    (67) _9_repeat -> . _9_items
    (68) _9_repeat -> .
    (69) _9_items -> . _9_items _9_item
    (70) _9_items -> . _9_item
    (71) _9_item -> . variant
    (83) variant -> . type_identifier
    (84) variant -> . type_identifier ( type _12_repeat )
    (146) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 68 (_9_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 97
    _9_repeat                      shift and go to state 98
    _9_items                       shift and go to state 99
    _9_item                        shift and go to state 100
    variant                        shift and go to state 101

state 74

    (72) enum -> ENUM type_identifier < . type_identifier _10_repeat > { _11_repeat }
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 102

state 75

    (137) variant_call -> type_identifier ( _24_optional . _25_repeat )
    (140) _25_repeat -> . _25_items
    (141) _25_repeat -> .
    (142) _25_items -> . _25_items _25_item
    (143) _25_items -> . _25_item
    (144) _25_item -> . , expr
    )               reduce using rule 141 (_25_repeat -> .)
    ,               shift and go to state 106

    _25_repeat                     shift and go to state 103
    _25_items                      shift and go to state 104
    _25_item                       shift and go to state 105

state 76

    (138) _24_optional -> expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 138 (_24_optional -> expr .)
    )               reduce using rule 138 (_24_optional -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 77

    (9) expr -> ( expr ) .
    (               reduce using rule 9 (expr -> ( expr ) .)
    INT_DIV         reduce using rule 9 (expr -> ( expr ) .)
    NOT_MORE        reduce using rule 9 (expr -> ( expr ) .)
    NUM_NOT_EQUAL   reduce using rule 9 (expr -> ( expr ) .)
    >               reduce using rule 9 (expr -> ( expr ) .)
    %               reduce using rule 9 (expr -> ( expr ) .)
    <               reduce using rule 9 (expr -> ( expr ) .)
    *               reduce using rule 9 (expr -> ( expr ) .)
    /               reduce using rule 9 (expr -> ( expr ) .)
    -               reduce using rule 9 (expr -> ( expr ) .)
    +               reduce using rule 9 (expr -> ( expr ) .)
    CONCAT          reduce using rule 9 (expr -> ( expr ) .)
    ENUM            reduce using rule 9 (expr -> ( expr ) .)
    [               reduce using rule 9 (expr -> ( expr ) .)
    IDENTIFIER      reduce using rule 9 (expr -> ( expr ) .)
    LET             reduce using rule 9 (expr -> ( expr ) .)
    CASE            reduce using rule 9 (expr -> ( expr ) .)
    IF              reduce using rule 9 (expr -> ( expr ) .)
    DEF             reduce using rule 9 (expr -> ( expr ) .)
    STRING          reduce using rule 9 (expr -> ( expr ) .)
    NUMBER          reduce using rule 9 (expr -> ( expr ) .)
    DO              reduce using rule 9 (expr -> ( expr ) .)
    EXTERNAL        reduce using rule 9 (expr -> ( expr ) .)
    TYPE_IDENTIFIER reduce using rule 9 (expr -> ( expr ) .)
    $end            reduce using rule 9 (expr -> ( expr ) .)
    )               reduce using rule 9 (expr -> ( expr ) .)
    ,               reduce using rule 9 (expr -> ( expr ) .)
    ]               reduce using rule 9 (expr -> ( expr ) .)
    OF              reduce using rule 9 (expr -> ( expr ) .)
    THEN            reduce using rule 9 (expr -> ( expr ) .)
    END             reduce using rule 9 (expr -> ( expr ) .)
    ELIF            reduce using rule 9 (expr -> ( expr ) .)
    ELSE            reduce using rule 9 (expr -> ( expr ) .)


state 78

    (120) array -> [ _20_optional _21_repeat . ]
    ]               shift and go to state 107


state 79

    (123) _21_repeat -> _21_items .
    (125) _21_items -> _21_items . _21_item
    (127) _21_item -> . , expr
    ]               reduce using rule 123 (_21_repeat -> _21_items .)
    ,               shift and go to state 81

    _21_item                       shift and go to state 108

state 80

    (126) _21_items -> _21_item .
    ,               reduce using rule 126 (_21_items -> _21_item .)
    ]               reduce using rule 126 (_21_items -> _21_item .)


state 81

    (127) _21_item -> , . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 109
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 82

    (147) variable_declaration -> LET identifier _26_optional . = expr
    =               shift and go to state 110


state 83

    (148) _26_optional -> : . type
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 111
    type_identifier                shift and go to state 92

state 84

    (102) case_of -> CASE expr OF . _17_repeat END
    (103) _17_repeat -> . _17_items
    (104) _17_repeat -> .
    (105) _17_items -> . _17_items _17_item
    (106) _17_items -> . _17_item
    (107) _17_item -> . pattern do
    (108) pattern -> . match_variant
    (109) pattern -> . match_as
    (111) match_variant -> . type_identifier
    (112) match_variant -> . type_identifier ( _18_optional _19_repeat )
    (110) match_as -> . identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    (145) identifier -> . IDENTIFIER
    END             reduce using rule 104 (_17_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 25

    _17_repeat                     shift and go to state 112
    _17_items                      shift and go to state 113
    _17_item                       shift and go to state 114
    pattern                        shift and go to state 115
    match_variant                  shift and go to state 116
    match_as                       shift and go to state 117
    type_identifier                shift and go to state 118
    identifier                     shift and go to state 119

state 85

    (93) if_expr -> IF expr THEN . _14_optional block_statement _15_optional END
    (94) _14_optional -> . : type
    (95) _14_optional -> .
    :               shift and go to state 121
    (               reduce using rule 95 (_14_optional -> .)
    -               reduce using rule 95 (_14_optional -> .)
    [               reduce using rule 95 (_14_optional -> .)
    IDENTIFIER      reduce using rule 95 (_14_optional -> .)
    LET             reduce using rule 95 (_14_optional -> .)
    CASE            reduce using rule 95 (_14_optional -> .)
    IF              reduce using rule 95 (_14_optional -> .)
    DEF             reduce using rule 95 (_14_optional -> .)
    STRING          reduce using rule 95 (_14_optional -> .)
    NUMBER          reduce using rule 95 (_14_optional -> .)
    DO              reduce using rule 95 (_14_optional -> .)
    EXTERNAL        reduce using rule 95 (_14_optional -> .)
    TYPE_IDENTIFIER reduce using rule 95 (_14_optional -> .)
    ELIF            reduce using rule 95 (_14_optional -> .)
    ELSE            reduce using rule 95 (_14_optional -> .)
    END             reduce using rule 95 (_14_optional -> .)

    _14_optional                   shift and go to state 120

state 86

    (49) def_expr -> DEF identifier ( . _5_optional _6_repeat ) _7_optional do
    (50) _5_optional -> . param
    (51) _5_optional -> .
    (90) param -> . identifier _13_optional
    (145) identifier -> . IDENTIFIER
    ,               reduce using rule 51 (_5_optional -> .)
    )               reduce using rule 51 (_5_optional -> .)
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 122
    _5_optional                    shift and go to state 123
    param                          shift and go to state 124

state 87

    (35) do -> DO _2_optional _3_repeat . END
    END             shift and go to state 125


state 88

    (38) _3_repeat -> _3_items .
    (40) _3_items -> _3_items . _3_item
    (42) _3_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 38 (_3_repeat -> _3_items .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _3_item                        shift and go to state 126
    expr                           shift and go to state 90
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 89

    (41) _3_items -> _3_item .
    (               reduce using rule 41 (_3_items -> _3_item .)
    -               reduce using rule 41 (_3_items -> _3_item .)
    [               reduce using rule 41 (_3_items -> _3_item .)
    IDENTIFIER      reduce using rule 41 (_3_items -> _3_item .)
    LET             reduce using rule 41 (_3_items -> _3_item .)
    CASE            reduce using rule 41 (_3_items -> _3_item .)
    IF              reduce using rule 41 (_3_items -> _3_item .)
    DEF             reduce using rule 41 (_3_items -> _3_item .)
    STRING          reduce using rule 41 (_3_items -> _3_item .)
    NUMBER          reduce using rule 41 (_3_items -> _3_item .)
    DO              reduce using rule 41 (_3_items -> _3_item .)
    EXTERNAL        reduce using rule 41 (_3_items -> _3_item .)
    TYPE_IDENTIFIER reduce using rule 41 (_3_items -> _3_item .)
    END             reduce using rule 41 (_3_items -> _3_item .)


state 90

    (42) _3_item -> expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    [               reduce using rule 42 (_3_item -> expr .)
    IDENTIFIER      reduce using rule 42 (_3_item -> expr .)
    LET             reduce using rule 42 (_3_item -> expr .)
    CASE            reduce using rule 42 (_3_item -> expr .)
    IF              reduce using rule 42 (_3_item -> expr .)
    DEF             reduce using rule 42 (_3_item -> expr .)
    STRING          reduce using rule 42 (_3_item -> expr .)
    NUMBER          reduce using rule 42 (_3_item -> expr .)
    DO              reduce using rule 42 (_3_item -> expr .)
    EXTERNAL        reduce using rule 42 (_3_item -> expr .)
    TYPE_IDENTIFIER reduce using rule 42 (_3_item -> expr .)
    END             reduce using rule 42 (_3_item -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 91

    (36) _2_optional -> : type .
    (               reduce using rule 36 (_2_optional -> : type .)
    -               reduce using rule 36 (_2_optional -> : type .)
    [               reduce using rule 36 (_2_optional -> : type .)
    IDENTIFIER      reduce using rule 36 (_2_optional -> : type .)
    LET             reduce using rule 36 (_2_optional -> : type .)
    CASE            reduce using rule 36 (_2_optional -> : type .)
    IF              reduce using rule 36 (_2_optional -> : type .)
    DEF             reduce using rule 36 (_2_optional -> : type .)
    STRING          reduce using rule 36 (_2_optional -> : type .)
    NUMBER          reduce using rule 36 (_2_optional -> : type .)
    DO              reduce using rule 36 (_2_optional -> : type .)
    EXTERNAL        reduce using rule 36 (_2_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 36 (_2_optional -> : type .)
    END             reduce using rule 36 (_2_optional -> : type .)


state 92

    (59) type -> type_identifier . < type _8_repeat >
    (65) type -> type_identifier .
    <               shift and go to state 127
    (               reduce using rule 65 (type -> type_identifier .)
    -               reduce using rule 65 (type -> type_identifier .)
    [               reduce using rule 65 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 65 (type -> type_identifier .)
    LET             reduce using rule 65 (type -> type_identifier .)
    CASE            reduce using rule 65 (type -> type_identifier .)
    IF              reduce using rule 65 (type -> type_identifier .)
    DEF             reduce using rule 65 (type -> type_identifier .)
    STRING          reduce using rule 65 (type -> type_identifier .)
    NUMBER          reduce using rule 65 (type -> type_identifier .)
    DO              reduce using rule 65 (type -> type_identifier .)
    EXTERNAL        reduce using rule 65 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 65 (type -> type_identifier .)
    END             reduce using rule 65 (type -> type_identifier .)
    =               reduce using rule 65 (type -> type_identifier .)
    ELIF            reduce using rule 65 (type -> type_identifier .)
    ELSE            reduce using rule 65 (type -> type_identifier .)
    ,               reduce using rule 65 (type -> type_identifier .)
    >               reduce using rule 65 (type -> type_identifier .)
    )               reduce using rule 65 (type -> type_identifier .)


state 93

    (128) call -> expr ( _22_optional _23_repeat . )
    )               shift and go to state 128


state 94

    (131) _23_repeat -> _23_items .
    (133) _23_items -> _23_items . _23_item
    (135) _23_item -> . , expr
    )               reduce using rule 131 (_23_repeat -> _23_items .)
    ,               shift and go to state 96

    _23_item                       shift and go to state 129

state 95

    (134) _23_items -> _23_item .
    ,               reduce using rule 134 (_23_items -> _23_item .)
    )               reduce using rule 134 (_23_items -> _23_item .)


state 96

    (135) _23_item -> , . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 130
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 97

    (83) variant -> type_identifier .
    (84) variant -> type_identifier . ( type _12_repeat )
    TYPE_IDENTIFIER reduce using rule 83 (variant -> type_identifier .)
    }               reduce using rule 83 (variant -> type_identifier .)
    (               shift and go to state 131


state 98

    (66) enum -> ENUM type_identifier { _9_repeat . }
    }               shift and go to state 132


state 99

    (67) _9_repeat -> _9_items .
    (69) _9_items -> _9_items . _9_item
    (71) _9_item -> . variant
    (83) variant -> . type_identifier
    (84) variant -> . type_identifier ( type _12_repeat )
    (146) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 67 (_9_repeat -> _9_items .)
    TYPE_IDENTIFIER shift and go to state 34

    _9_item                        shift and go to state 133
    variant                        shift and go to state 101
    type_identifier                shift and go to state 97

state 100

    (70) _9_items -> _9_item .
    TYPE_IDENTIFIER reduce using rule 70 (_9_items -> _9_item .)
    }               reduce using rule 70 (_9_items -> _9_item .)


state 101

    (71) _9_item -> variant .
    TYPE_IDENTIFIER reduce using rule 71 (_9_item -> variant .)
    }               reduce using rule 71 (_9_item -> variant .)


state 102

    (72) enum -> ENUM type_identifier < type_identifier . _10_repeat > { _11_repeat }
    (73) _10_repeat -> . _10_items
    (74) _10_repeat -> .
    (75) _10_items -> . _10_items _10_item
    (76) _10_items -> . _10_item
    (77) _10_item -> . , type_identifier
    >               reduce using rule 74 (_10_repeat -> .)
    ,               shift and go to state 137

    _10_repeat                     shift and go to state 134
    _10_items                      shift and go to state 135
    _10_item                       shift and go to state 136

state 103

    (137) variant_call -> type_identifier ( _24_optional _25_repeat . )
    )               shift and go to state 138


state 104

    (140) _25_repeat -> _25_items .
    (142) _25_items -> _25_items . _25_item
    (144) _25_item -> . , expr
    )               reduce using rule 140 (_25_repeat -> _25_items .)
    ,               shift and go to state 106

    _25_item                       shift and go to state 139

state 105

    (143) _25_items -> _25_item .
    ,               reduce using rule 143 (_25_items -> _25_item .)
    )               reduce using rule 143 (_25_items -> _25_item .)


state 106

    (144) _25_item -> , . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 140
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 107

    (120) array -> [ _20_optional _21_repeat ] .
    (               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    INT_DIV         reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    NOT_MORE        reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    NUM_NOT_EQUAL   reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    >               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    %               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    <               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    *               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    /               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    -               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    +               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    CONCAT          reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    ENUM            reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    [               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    IDENTIFIER      reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    LET             reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    CASE            reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    IF              reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    DEF             reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    STRING          reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    NUMBER          reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    DO              reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    EXTERNAL        reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    TYPE_IDENTIFIER reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    $end            reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    )               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    ,               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    ]               reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    OF              reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    THEN            reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    END             reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    ELIF            reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)
    ELSE            reduce using rule 120 (array -> [ _20_optional _21_repeat ] .)


state 108

    (125) _21_items -> _21_items _21_item .
    ,               reduce using rule 125 (_21_items -> _21_items _21_item .)
    ]               reduce using rule 125 (_21_items -> _21_items _21_item .)


state 109

    (127) _21_item -> , expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 127 (_21_item -> , expr .)
    ]               reduce using rule 127 (_21_item -> , expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 110

    (147) variable_declaration -> LET identifier _26_optional = . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    identifier                     shift and go to state 14
    expr                           shift and go to state 141
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 111

    (148) _26_optional -> : type .
    =               reduce using rule 148 (_26_optional -> : type .)


state 112

    (102) case_of -> CASE expr OF _17_repeat . END
    END             shift and go to state 142


state 113

    (103) _17_repeat -> _17_items .
    (105) _17_items -> _17_items . _17_item
    (107) _17_item -> . pattern do
    (108) pattern -> . match_variant
    (109) pattern -> . match_as
    (111) match_variant -> . type_identifier
    (112) match_variant -> . type_identifier ( _18_optional _19_repeat )
    (110) match_as -> . identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    (145) identifier -> . IDENTIFIER
    END             reduce using rule 103 (_17_repeat -> _17_items .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 25

    _17_item                       shift and go to state 143
    pattern                        shift and go to state 115
    match_variant                  shift and go to state 116
    match_as                       shift and go to state 117
    type_identifier                shift and go to state 118
    identifier                     shift and go to state 119

state 114

    (106) _17_items -> _17_item .
    TYPE_IDENTIFIER reduce using rule 106 (_17_items -> _17_item .)
    IDENTIFIER      reduce using rule 106 (_17_items -> _17_item .)
    END             reduce using rule 106 (_17_items -> _17_item .)


state 115

    (107) _17_item -> pattern . do
    (35) do -> . DO _2_optional _3_repeat END
    DO              shift and go to state 32

    do                             shift and go to state 144

state 116

    (108) pattern -> match_variant .
    DO              reduce using rule 108 (pattern -> match_variant .)
    ,               reduce using rule 108 (pattern -> match_variant .)
    )               reduce using rule 108 (pattern -> match_variant .)


state 117

    (109) pattern -> match_as .
    DO              reduce using rule 109 (pattern -> match_as .)
    ,               reduce using rule 109 (pattern -> match_as .)
    )               reduce using rule 109 (pattern -> match_as .)


state 118

    (111) match_variant -> type_identifier .
    (112) match_variant -> type_identifier . ( _18_optional _19_repeat )
    DO              reduce using rule 111 (match_variant -> type_identifier .)
    ,               reduce using rule 111 (match_variant -> type_identifier .)
    )               reduce using rule 111 (match_variant -> type_identifier .)
    (               shift and go to state 145


state 119

    (110) match_as -> identifier .
    DO              reduce using rule 110 (match_as -> identifier .)
    ,               reduce using rule 110 (match_as -> identifier .)
    )               reduce using rule 110 (match_as -> identifier .)


state 120

    (93) if_expr -> IF expr THEN _14_optional . block_statement _15_optional END
    (43) block_statement -> . _4_repeat
    (44) _4_repeat -> . _4_items
    (45) _4_repeat -> .
    (46) _4_items -> . _4_items _4_item
    (47) _4_items -> . _4_item
    (48) _4_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 45 (_4_repeat -> .)
    ELSE            reduce using rule 45 (_4_repeat -> .)
    END             reduce using rule 45 (_4_repeat -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 146
    block_statement                shift and go to state 147
    _4_repeat                      shift and go to state 148
    _4_items                       shift and go to state 149
    _4_item                        shift and go to state 150
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 121

    (94) _14_optional -> : . type
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 151
    type_identifier                shift and go to state 92

state 122

    (90) param -> identifier . _13_optional
    (91) _13_optional -> . : type
    (92) _13_optional -> .
    :               shift and go to state 153
    ,               reduce using rule 92 (_13_optional -> .)
    )               reduce using rule 92 (_13_optional -> .)

    _13_optional                   shift and go to state 152

state 123

    (49) def_expr -> DEF identifier ( _5_optional . _6_repeat ) _7_optional do
    (52) _6_repeat -> . _6_items
    (53) _6_repeat -> .
    (54) _6_items -> . _6_items _6_item
    (55) _6_items -> . _6_item
    (56) _6_item -> . , param
    )               reduce using rule 53 (_6_repeat -> .)
    ,               shift and go to state 157

    _6_repeat                      shift and go to state 154
    _6_items                       shift and go to state 155
    _6_item                        shift and go to state 156

state 124

    (50) _5_optional -> param .
    ,               reduce using rule 50 (_5_optional -> param .)
    )               reduce using rule 50 (_5_optional -> param .)


state 125

    (35) do -> DO _2_optional _3_repeat END .
    (               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    INT_DIV         reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    NOT_MORE        reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    NUM_NOT_EQUAL   reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    >               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    %               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    <               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    *               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    /               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    -               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    +               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    CONCAT          reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ENUM            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    [               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    IDENTIFIER      reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    LET             reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    CASE            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    IF              reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    DEF             reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    STRING          reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    NUMBER          reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    DO              reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    EXTERNAL        reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    TYPE_IDENTIFIER reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    $end            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    )               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ,               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ]               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    OF              reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    THEN            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    END             reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ELIF            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ELSE            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)


state 126

    (40) _3_items -> _3_items _3_item .
    (               reduce using rule 40 (_3_items -> _3_items _3_item .)
    -               reduce using rule 40 (_3_items -> _3_items _3_item .)
    [               reduce using rule 40 (_3_items -> _3_items _3_item .)
    IDENTIFIER      reduce using rule 40 (_3_items -> _3_items _3_item .)
    LET             reduce using rule 40 (_3_items -> _3_items _3_item .)
    CASE            reduce using rule 40 (_3_items -> _3_items _3_item .)
    IF              reduce using rule 40 (_3_items -> _3_items _3_item .)
    DEF             reduce using rule 40 (_3_items -> _3_items _3_item .)
    STRING          reduce using rule 40 (_3_items -> _3_items _3_item .)
    NUMBER          reduce using rule 40 (_3_items -> _3_items _3_item .)
    DO              reduce using rule 40 (_3_items -> _3_items _3_item .)
    EXTERNAL        reduce using rule 40 (_3_items -> _3_items _3_item .)
    TYPE_IDENTIFIER reduce using rule 40 (_3_items -> _3_items _3_item .)
    END             reduce using rule 40 (_3_items -> _3_items _3_item .)


state 127

    (59) type -> type_identifier < . type _8_repeat >
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 92
    type                           shift and go to state 158

state 128

    (128) call -> expr ( _22_optional _23_repeat ) .
    (               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    INT_DIV         reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    NOT_MORE        reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    NUM_NOT_EQUAL   reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    >               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    %               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    <               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    *               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    /               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    -               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    +               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    CONCAT          reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    ENUM            reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    [               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    IDENTIFIER      reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    LET             reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    CASE            reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    IF              reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    DEF             reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    STRING          reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    NUMBER          reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    DO              reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    EXTERNAL        reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    $end            reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    )               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    ,               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    ]               reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    OF              reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    THEN            reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    END             reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    ELIF            reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)
    ELSE            reduce using rule 128 (call -> expr ( _22_optional _23_repeat ) .)


state 129

    (133) _23_items -> _23_items _23_item .
    ,               reduce using rule 133 (_23_items -> _23_items _23_item .)
    )               reduce using rule 133 (_23_items -> _23_items _23_item .)


state 130

    (135) _23_item -> , expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 135 (_23_item -> , expr .)
    )               reduce using rule 135 (_23_item -> , expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 131

    (84) variant -> type_identifier ( . type _12_repeat )
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 92
    type                           shift and go to state 159

state 132

    (66) enum -> ENUM type_identifier { _9_repeat } .
    ENUM            reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    (               reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    -               reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    [               reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    IDENTIFIER      reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    LET             reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    CASE            reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    IF              reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    DEF             reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    STRING          reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    NUMBER          reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    DO              reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    EXTERNAL        reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    TYPE_IDENTIFIER reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)
    $end            reduce using rule 66 (enum -> ENUM type_identifier { _9_repeat } .)


state 133

    (69) _9_items -> _9_items _9_item .
    TYPE_IDENTIFIER reduce using rule 69 (_9_items -> _9_items _9_item .)
    }               reduce using rule 69 (_9_items -> _9_items _9_item .)


state 134

    (72) enum -> ENUM type_identifier < type_identifier _10_repeat . > { _11_repeat }
    >               shift and go to state 160


state 135

    (73) _10_repeat -> _10_items .
    (75) _10_items -> _10_items . _10_item
    (77) _10_item -> . , type_identifier
    >               reduce using rule 73 (_10_repeat -> _10_items .)
    ,               shift and go to state 137

    _10_item                       shift and go to state 161

state 136

    (76) _10_items -> _10_item .
    ,               reduce using rule 76 (_10_items -> _10_item .)
    >               reduce using rule 76 (_10_items -> _10_item .)


state 137

    (77) _10_item -> , . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 162

state 138

    (137) variant_call -> type_identifier ( _24_optional _25_repeat ) .
    (               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    INT_DIV         reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    NOT_MORE        reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    NUM_NOT_EQUAL   reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    >               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    %               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    <               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    *               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    /               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    -               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    +               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    CONCAT          reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ENUM            reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    [               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    IDENTIFIER      reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    LET             reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    CASE            reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    IF              reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    DEF             reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    STRING          reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    NUMBER          reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    DO              reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    EXTERNAL        reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    $end            reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    )               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ,               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ]               reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    OF              reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    THEN            reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    END             reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ELIF            reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ELSE            reduce using rule 137 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)


state 139

    (142) _25_items -> _25_items _25_item .
    ,               reduce using rule 142 (_25_items -> _25_items _25_item .)
    )               reduce using rule 142 (_25_items -> _25_items _25_item .)


state 140

    (144) _25_item -> , expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 144 (_25_item -> , expr .)
    )               reduce using rule 144 (_25_item -> , expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 141

    (147) variable_declaration -> LET identifier _26_optional = expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    NUM_NOT_EQUAL   reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    >               reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    <               reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    ENUM            reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    [               reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    IDENTIFIER      reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    LET             reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    CASE            reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    IF              reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    DEF             reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    STRING          reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    NUMBER          reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    DO              reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    EXTERNAL        reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    TYPE_IDENTIFIER reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    $end            reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    )               reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    ,               reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    ]               reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    OF              reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    THEN            reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    END             reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    ELIF            reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    ELSE            reduce using rule 147 (variable_declaration -> LET identifier _26_optional = expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 142

    (102) case_of -> CASE expr OF _17_repeat END .
    (               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    INT_DIV         reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    NOT_MORE        reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    NUM_NOT_EQUAL   reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    >               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    %               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    <               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    *               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    /               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    -               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    +               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    CONCAT          reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    ENUM            reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    [               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    IDENTIFIER      reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    LET             reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    CASE            reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    IF              reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    DEF             reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    STRING          reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    NUMBER          reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    DO              reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    EXTERNAL        reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    TYPE_IDENTIFIER reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    $end            reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    )               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    ,               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    ]               reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    OF              reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    THEN            reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    END             reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    ELIF            reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)
    ELSE            reduce using rule 102 (case_of -> CASE expr OF _17_repeat END .)


state 143

    (105) _17_items -> _17_items _17_item .
    TYPE_IDENTIFIER reduce using rule 105 (_17_items -> _17_items _17_item .)
    IDENTIFIER      reduce using rule 105 (_17_items -> _17_items _17_item .)
    END             reduce using rule 105 (_17_items -> _17_items _17_item .)


state 144

    (107) _17_item -> pattern do .
    TYPE_IDENTIFIER reduce using rule 107 (_17_item -> pattern do .)
    IDENTIFIER      reduce using rule 107 (_17_item -> pattern do .)
    END             reduce using rule 107 (_17_item -> pattern do .)


state 145

    (112) match_variant -> type_identifier ( . _18_optional _19_repeat )
    (113) _18_optional -> . pattern
    (114) _18_optional -> .
    (108) pattern -> . match_variant
    (109) pattern -> . match_as
    (111) match_variant -> . type_identifier
    (112) match_variant -> . type_identifier ( _18_optional _19_repeat )
    (110) match_as -> . identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    (145) identifier -> . IDENTIFIER
    ,               reduce using rule 114 (_18_optional -> .)
    )               reduce using rule 114 (_18_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 25

    type_identifier                shift and go to state 118
    _18_optional                   shift and go to state 163
    pattern                        shift and go to state 164
    match_variant                  shift and go to state 116
    match_as                       shift and go to state 117
    identifier                     shift and go to state 119

state 146

    (48) _4_item -> expr .
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    [               reduce using rule 48 (_4_item -> expr .)
    IDENTIFIER      reduce using rule 48 (_4_item -> expr .)
    LET             reduce using rule 48 (_4_item -> expr .)
    CASE            reduce using rule 48 (_4_item -> expr .)
    IF              reduce using rule 48 (_4_item -> expr .)
    DEF             reduce using rule 48 (_4_item -> expr .)
    STRING          reduce using rule 48 (_4_item -> expr .)
    NUMBER          reduce using rule 48 (_4_item -> expr .)
    DO              reduce using rule 48 (_4_item -> expr .)
    EXTERNAL        reduce using rule 48 (_4_item -> expr .)
    TYPE_IDENTIFIER reduce using rule 48 (_4_item -> expr .)
    ELIF            reduce using rule 48 (_4_item -> expr .)
    ELSE            reduce using rule 48 (_4_item -> expr .)
    END             reduce using rule 48 (_4_item -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 147

    (93) if_expr -> IF expr THEN _14_optional block_statement . _15_optional END
    (96) _15_optional -> . or_else
    (97) _15_optional -> .
    (98) or_else -> . ELIF expr THEN block_statement _16_optional
    (101) or_else -> . ELSE block_statement
    END             reduce using rule 97 (_15_optional -> .)
    ELIF            shift and go to state 167
    ELSE            shift and go to state 168

    _15_optional                   shift and go to state 165
    or_else                        shift and go to state 166

state 148

    (43) block_statement -> _4_repeat .
    ELIF            reduce using rule 43 (block_statement -> _4_repeat .)
    ELSE            reduce using rule 43 (block_statement -> _4_repeat .)
    END             reduce using rule 43 (block_statement -> _4_repeat .)


state 149

    (44) _4_repeat -> _4_items .
    (46) _4_items -> _4_items . _4_item
    (48) _4_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 44 (_4_repeat -> _4_items .)
    ELSE            reduce using rule 44 (_4_repeat -> _4_items .)
    END             reduce using rule 44 (_4_repeat -> _4_items .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _4_item                        shift and go to state 169
    expr                           shift and go to state 146
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 150

    (47) _4_items -> _4_item .
    (               reduce using rule 47 (_4_items -> _4_item .)
    -               reduce using rule 47 (_4_items -> _4_item .)
    [               reduce using rule 47 (_4_items -> _4_item .)
    IDENTIFIER      reduce using rule 47 (_4_items -> _4_item .)
    LET             reduce using rule 47 (_4_items -> _4_item .)
    CASE            reduce using rule 47 (_4_items -> _4_item .)
    IF              reduce using rule 47 (_4_items -> _4_item .)
    DEF             reduce using rule 47 (_4_items -> _4_item .)
    STRING          reduce using rule 47 (_4_items -> _4_item .)
    NUMBER          reduce using rule 47 (_4_items -> _4_item .)
    DO              reduce using rule 47 (_4_items -> _4_item .)
    EXTERNAL        reduce using rule 47 (_4_items -> _4_item .)
    TYPE_IDENTIFIER reduce using rule 47 (_4_items -> _4_item .)
    ELIF            reduce using rule 47 (_4_items -> _4_item .)
    ELSE            reduce using rule 47 (_4_items -> _4_item .)
    END             reduce using rule 47 (_4_items -> _4_item .)


state 151

    (94) _14_optional -> : type .
    (               reduce using rule 94 (_14_optional -> : type .)
    -               reduce using rule 94 (_14_optional -> : type .)
    [               reduce using rule 94 (_14_optional -> : type .)
    IDENTIFIER      reduce using rule 94 (_14_optional -> : type .)
    LET             reduce using rule 94 (_14_optional -> : type .)
    CASE            reduce using rule 94 (_14_optional -> : type .)
    IF              reduce using rule 94 (_14_optional -> : type .)
    DEF             reduce using rule 94 (_14_optional -> : type .)
    STRING          reduce using rule 94 (_14_optional -> : type .)
    NUMBER          reduce using rule 94 (_14_optional -> : type .)
    DO              reduce using rule 94 (_14_optional -> : type .)
    EXTERNAL        reduce using rule 94 (_14_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 94 (_14_optional -> : type .)
    ELIF            reduce using rule 94 (_14_optional -> : type .)
    ELSE            reduce using rule 94 (_14_optional -> : type .)
    END             reduce using rule 94 (_14_optional -> : type .)


state 152

    (90) param -> identifier _13_optional .
    ,               reduce using rule 90 (param -> identifier _13_optional .)
    )               reduce using rule 90 (param -> identifier _13_optional .)


state 153

    (91) _13_optional -> : . type
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 170
    type_identifier                shift and go to state 92

state 154

    (49) def_expr -> DEF identifier ( _5_optional _6_repeat . ) _7_optional do
    )               shift and go to state 171


state 155

    (52) _6_repeat -> _6_items .
    (54) _6_items -> _6_items . _6_item
    (56) _6_item -> . , param
    )               reduce using rule 52 (_6_repeat -> _6_items .)
    ,               shift and go to state 157

    _6_item                        shift and go to state 172

state 156

    (55) _6_items -> _6_item .
    ,               reduce using rule 55 (_6_items -> _6_item .)
    )               reduce using rule 55 (_6_items -> _6_item .)


state 157

    (56) _6_item -> , . param
    (90) param -> . identifier _13_optional
    (145) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    param                          shift and go to state 173
    identifier                     shift and go to state 122

state 158

    (59) type -> type_identifier < type . _8_repeat >
    (60) _8_repeat -> . _8_items
    (61) _8_repeat -> .
    (62) _8_items -> . _8_items _8_item
    (63) _8_items -> . _8_item
    (64) _8_item -> . , type
    >               reduce using rule 61 (_8_repeat -> .)
    ,               shift and go to state 177

    _8_repeat                      shift and go to state 174
    _8_items                       shift and go to state 175
    _8_item                        shift and go to state 176

state 159

    (84) variant -> type_identifier ( type . _12_repeat )
    (85) _12_repeat -> . _12_items
    (86) _12_repeat -> .
    (87) _12_items -> . _12_items _12_item
    (88) _12_items -> . _12_item
    (89) _12_item -> . , type
    )               reduce using rule 86 (_12_repeat -> .)
    ,               shift and go to state 181

    _12_repeat                     shift and go to state 178
    _12_items                      shift and go to state 179
    _12_item                       shift and go to state 180

state 160

    (72) enum -> ENUM type_identifier < type_identifier _10_repeat > . { _11_repeat }
    {               shift and go to state 182


state 161

    (75) _10_items -> _10_items _10_item .
    ,               reduce using rule 75 (_10_items -> _10_items _10_item .)
    >               reduce using rule 75 (_10_items -> _10_items _10_item .)


state 162

    (77) _10_item -> , type_identifier .
    ,               reduce using rule 77 (_10_item -> , type_identifier .)
    >               reduce using rule 77 (_10_item -> , type_identifier .)


state 163

    (112) match_variant -> type_identifier ( _18_optional . _19_repeat )
    (115) _19_repeat -> . _19_items
    (116) _19_repeat -> .
    (117) _19_items -> . _19_items _19_item
    (118) _19_items -> . _19_item
    (119) _19_item -> . , pattern
    )               reduce using rule 116 (_19_repeat -> .)
    ,               shift and go to state 186

    _19_repeat                     shift and go to state 183
    _19_items                      shift and go to state 184
    _19_item                       shift and go to state 185

state 164

    (113) _18_optional -> pattern .
    ,               reduce using rule 113 (_18_optional -> pattern .)
    )               reduce using rule 113 (_18_optional -> pattern .)


state 165

    (93) if_expr -> IF expr THEN _14_optional block_statement _15_optional . END
    END             shift and go to state 187


state 166

    (96) _15_optional -> or_else .
    END             reduce using rule 96 (_15_optional -> or_else .)


state 167

    (98) or_else -> ELIF . expr THEN block_statement _16_optional
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 188
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 168

    (101) or_else -> ELSE . block_statement
    (43) block_statement -> . _4_repeat
    (44) _4_repeat -> . _4_items
    (45) _4_repeat -> .
    (46) _4_items -> . _4_items _4_item
    (47) _4_items -> . _4_item
    (48) _4_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 45 (_4_repeat -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    block_statement                shift and go to state 189
    _4_repeat                      shift and go to state 148
    _4_items                       shift and go to state 149
    _4_item                        shift and go to state 150
    expr                           shift and go to state 146
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 169

    (46) _4_items -> _4_items _4_item .
    (               reduce using rule 46 (_4_items -> _4_items _4_item .)
    -               reduce using rule 46 (_4_items -> _4_items _4_item .)
    [               reduce using rule 46 (_4_items -> _4_items _4_item .)
    IDENTIFIER      reduce using rule 46 (_4_items -> _4_items _4_item .)
    LET             reduce using rule 46 (_4_items -> _4_items _4_item .)
    CASE            reduce using rule 46 (_4_items -> _4_items _4_item .)
    IF              reduce using rule 46 (_4_items -> _4_items _4_item .)
    DEF             reduce using rule 46 (_4_items -> _4_items _4_item .)
    STRING          reduce using rule 46 (_4_items -> _4_items _4_item .)
    NUMBER          reduce using rule 46 (_4_items -> _4_items _4_item .)
    DO              reduce using rule 46 (_4_items -> _4_items _4_item .)
    EXTERNAL        reduce using rule 46 (_4_items -> _4_items _4_item .)
    TYPE_IDENTIFIER reduce using rule 46 (_4_items -> _4_items _4_item .)
    ELIF            reduce using rule 46 (_4_items -> _4_items _4_item .)
    ELSE            reduce using rule 46 (_4_items -> _4_items _4_item .)
    END             reduce using rule 46 (_4_items -> _4_items _4_item .)


state 170

    (91) _13_optional -> : type .
    ,               reduce using rule 91 (_13_optional -> : type .)
    )               reduce using rule 91 (_13_optional -> : type .)


state 171

    (49) def_expr -> DEF identifier ( _5_optional _6_repeat ) . _7_optional do
    (57) _7_optional -> . : type
    (58) _7_optional -> .
    :               shift and go to state 191
    DO              reduce using rule 58 (_7_optional -> .)

    _7_optional                    shift and go to state 190

state 172

    (54) _6_items -> _6_items _6_item .
    ,               reduce using rule 54 (_6_items -> _6_items _6_item .)
    )               reduce using rule 54 (_6_items -> _6_items _6_item .)


state 173

    (56) _6_item -> , param .
    ,               reduce using rule 56 (_6_item -> , param .)
    )               reduce using rule 56 (_6_item -> , param .)


state 174

    (59) type -> type_identifier < type _8_repeat . >
    >               shift and go to state 192


state 175

    (60) _8_repeat -> _8_items .
    (62) _8_items -> _8_items . _8_item
    (64) _8_item -> . , type
    >               reduce using rule 60 (_8_repeat -> _8_items .)
    ,               shift and go to state 177

    _8_item                        shift and go to state 193

state 176

    (63) _8_items -> _8_item .
    ,               reduce using rule 63 (_8_items -> _8_item .)
    >               reduce using rule 63 (_8_items -> _8_item .)


state 177

    (64) _8_item -> , . type
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 194
    type_identifier                shift and go to state 92

state 178

    (84) variant -> type_identifier ( type _12_repeat . )
    )               shift and go to state 195


state 179

    (85) _12_repeat -> _12_items .
    (87) _12_items -> _12_items . _12_item
    (89) _12_item -> . , type
    )               reduce using rule 85 (_12_repeat -> _12_items .)
    ,               shift and go to state 181

    _12_item                       shift and go to state 196

state 180

    (88) _12_items -> _12_item .
    ,               reduce using rule 88 (_12_items -> _12_item .)
    )               reduce using rule 88 (_12_items -> _12_item .)


state 181

    (89) _12_item -> , . type
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 197
    type_identifier                shift and go to state 92

state 182

    (72) enum -> ENUM type_identifier < type_identifier _10_repeat > { . _11_repeat }
    (78) _11_repeat -> . _11_items
    (79) _11_repeat -> .
    (80) _11_items -> . _11_items _11_item
    (81) _11_items -> . _11_item
    (82) _11_item -> . variant
    (83) variant -> . type_identifier
    (84) variant -> . type_identifier ( type _12_repeat )
    (146) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 79 (_11_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 97
    _11_repeat                     shift and go to state 198
    _11_items                      shift and go to state 199
    _11_item                       shift and go to state 200
    variant                        shift and go to state 201

state 183

    (112) match_variant -> type_identifier ( _18_optional _19_repeat . )
    )               shift and go to state 202


state 184

    (115) _19_repeat -> _19_items .
    (117) _19_items -> _19_items . _19_item
    (119) _19_item -> . , pattern
    )               reduce using rule 115 (_19_repeat -> _19_items .)
    ,               shift and go to state 186

    _19_item                       shift and go to state 203

state 185

    (118) _19_items -> _19_item .
    ,               reduce using rule 118 (_19_items -> _19_item .)
    )               reduce using rule 118 (_19_items -> _19_item .)


state 186

    (119) _19_item -> , . pattern
    (108) pattern -> . match_variant
    (109) pattern -> . match_as
    (111) match_variant -> . type_identifier
    (112) match_variant -> . type_identifier ( _18_optional _19_repeat )
    (110) match_as -> . identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    (145) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 25

    pattern                        shift and go to state 204
    match_variant                  shift and go to state 116
    match_as                       shift and go to state 117
    type_identifier                shift and go to state 118
    identifier                     shift and go to state 119

state 187

    (93) if_expr -> IF expr THEN _14_optional block_statement _15_optional END .
    (               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    INT_DIV         reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    NOT_MORE        reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    NUM_NOT_EQUAL   reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    >               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    %               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    <               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    *               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    /               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    -               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    +               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    CONCAT          reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ENUM            reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    [               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    IDENTIFIER      reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    LET             reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    CASE            reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    IF              reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    DEF             reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    STRING          reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    NUMBER          reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    DO              reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    EXTERNAL        reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    TYPE_IDENTIFIER reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    $end            reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    )               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ,               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ]               reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    OF              reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    THEN            reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    END             reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ELIF            reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ELSE            reduce using rule 93 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)


state 188

    (98) or_else -> ELIF expr . THEN block_statement _16_optional
    (128) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 205
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 189

    (101) or_else -> ELSE block_statement .
    END             reduce using rule 101 (or_else -> ELSE block_statement .)


state 190

    (49) def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional . do
    (35) do -> . DO _2_optional _3_repeat END
    DO              shift and go to state 32

    do                             shift and go to state 206

state 191

    (57) _7_optional -> : . type
    (59) type -> . type_identifier < type _8_repeat >
    (65) type -> . type_identifier
    (146) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 207
    type_identifier                shift and go to state 92

state 192

    (59) type -> type_identifier < type _8_repeat > .
    (               reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    -               reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    [               reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    IDENTIFIER      reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    LET             reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    CASE            reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    IF              reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    DEF             reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    STRING          reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    NUMBER          reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    DO              reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    EXTERNAL        reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    TYPE_IDENTIFIER reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    END             reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    =               reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    ELIF            reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    ELSE            reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    ,               reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    >               reduce using rule 59 (type -> type_identifier < type _8_repeat > .)
    )               reduce using rule 59 (type -> type_identifier < type _8_repeat > .)


state 193

    (62) _8_items -> _8_items _8_item .
    ,               reduce using rule 62 (_8_items -> _8_items _8_item .)
    >               reduce using rule 62 (_8_items -> _8_items _8_item .)


state 194

    (64) _8_item -> , type .
    ,               reduce using rule 64 (_8_item -> , type .)
    >               reduce using rule 64 (_8_item -> , type .)


state 195

    (84) variant -> type_identifier ( type _12_repeat ) .
    TYPE_IDENTIFIER reduce using rule 84 (variant -> type_identifier ( type _12_repeat ) .)
    }               reduce using rule 84 (variant -> type_identifier ( type _12_repeat ) .)


state 196

    (87) _12_items -> _12_items _12_item .
    ,               reduce using rule 87 (_12_items -> _12_items _12_item .)
    )               reduce using rule 87 (_12_items -> _12_items _12_item .)


state 197

    (89) _12_item -> , type .
    ,               reduce using rule 89 (_12_item -> , type .)
    )               reduce using rule 89 (_12_item -> , type .)


state 198

    (72) enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat . }
    }               shift and go to state 208


state 199

    (78) _11_repeat -> _11_items .
    (80) _11_items -> _11_items . _11_item
    (82) _11_item -> . variant
    (83) variant -> . type_identifier
    (84) variant -> . type_identifier ( type _12_repeat )
    (146) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 78 (_11_repeat -> _11_items .)
    TYPE_IDENTIFIER shift and go to state 34

    _11_item                       shift and go to state 209
    variant                        shift and go to state 201
    type_identifier                shift and go to state 97

state 200

    (81) _11_items -> _11_item .
    TYPE_IDENTIFIER reduce using rule 81 (_11_items -> _11_item .)
    }               reduce using rule 81 (_11_items -> _11_item .)


state 201

    (82) _11_item -> variant .
    TYPE_IDENTIFIER reduce using rule 82 (_11_item -> variant .)
    }               reduce using rule 82 (_11_item -> variant .)


state 202

    (112) match_variant -> type_identifier ( _18_optional _19_repeat ) .
    DO              reduce using rule 112 (match_variant -> type_identifier ( _18_optional _19_repeat ) .)
    ,               reduce using rule 112 (match_variant -> type_identifier ( _18_optional _19_repeat ) .)
    )               reduce using rule 112 (match_variant -> type_identifier ( _18_optional _19_repeat ) .)


state 203

    (117) _19_items -> _19_items _19_item .
    ,               reduce using rule 117 (_19_items -> _19_items _19_item .)
    )               reduce using rule 117 (_19_items -> _19_items _19_item .)


state 204

    (119) _19_item -> , pattern .
    ,               reduce using rule 119 (_19_item -> , pattern .)
    )               reduce using rule 119 (_19_item -> , pattern .)


state 205

    (98) or_else -> ELIF expr THEN . block_statement _16_optional
    (43) block_statement -> . _4_repeat
    (44) _4_repeat -> . _4_items
    (45) _4_repeat -> .
    (46) _4_items -> . _4_items _4_item
    (47) _4_items -> . _4_item
    (48) _4_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (120) array -> . [ _20_optional _21_repeat ]
    (136) variant_call -> . type_identifier
    (137) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (145) identifier -> . IDENTIFIER
    (147) variable_declaration -> . LET identifier _26_optional = expr
    (128) call -> . expr ( _22_optional _23_repeat )
    (102) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (93) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (150) literal -> . STRING
    (151) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (146) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 45 (_4_repeat -> .)
    ELSE            reduce using rule 45 (_4_repeat -> .)
    END             reduce using rule 45 (_4_repeat -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 146
    block_statement                shift and go to state 210
    _4_repeat                      shift and go to state 148
    _4_items                       shift and go to state 149
    _4_item                        shift and go to state 150
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 206

    (49) def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .
    (               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    INT_DIV         reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    NOT_MORE        reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    NUM_NOT_EQUAL   reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    >               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    %               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    <               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    *               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    /               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    -               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    +               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    CONCAT          reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ENUM            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    [               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    IDENTIFIER      reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    LET             reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    CASE            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    IF              reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    DEF             reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    STRING          reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    NUMBER          reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    DO              reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    EXTERNAL        reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    TYPE_IDENTIFIER reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    $end            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    )               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ,               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ]               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    OF              reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    THEN            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    END             reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ELIF            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ELSE            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)


state 207

    (57) _7_optional -> : type .
    DO              reduce using rule 57 (_7_optional -> : type .)


state 208

    (72) enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .
    ENUM            reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    (               reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    -               reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    [               reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    IDENTIFIER      reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    LET             reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    CASE            reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    IF              reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    DEF             reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    STRING          reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    NUMBER          reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    DO              reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    EXTERNAL        reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    TYPE_IDENTIFIER reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    $end            reduce using rule 72 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)


state 209

    (80) _11_items -> _11_items _11_item .
    TYPE_IDENTIFIER reduce using rule 80 (_11_items -> _11_items _11_item .)
    }               reduce using rule 80 (_11_items -> _11_items _11_item .)


state 210

    (98) or_else -> ELIF expr THEN block_statement . _16_optional
    (99) _16_optional -> . or_else
    (100) _16_optional -> .
    (98) or_else -> . ELIF expr THEN block_statement _16_optional
    (101) or_else -> . ELSE block_statement
    END             reduce using rule 100 (_16_optional -> .)
    ELIF            shift and go to state 167
    ELSE            shift and go to state 168

    _16_optional                   shift and go to state 211
    or_else                        shift and go to state 212

state 211

    (98) or_else -> ELIF expr THEN block_statement _16_optional .
    END             reduce using rule 98 (or_else -> ELIF expr THEN block_statement _16_optional .)


state 212

    (99) _16_optional -> or_else .
    END             reduce using rule 99 (_16_optional -> or_else .)


Conflicts:

shift/reduce conflict for ( in state 7 resolved as shift
shift/reduce conflict for - in state 7 resolved as shift
shift/reduce conflict for ( in state 9 resolved as shift
shift/reduce conflict for ( in state 90 resolved as shift
shift/reduce conflict for - in state 90 resolved as shift
shift/reduce conflict for ( in state 146 resolved as shift
shift/reduce conflict for - in state 146 resolved as shift