Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_optional _2_repeat
Rule 2     _1_optional -> stmt
Rule 3     _1_optional -> <empty>
Rule 4     _2_repeat -> _2_items
Rule 5     _2_repeat -> <empty>
Rule 6     _2_items -> _2_items _2_item
Rule 7     _2_items -> _2_item
Rule 8     _2_item -> NEWLINE stmt
Rule 9     stmt -> enum
Rule 10    stmt -> struct
Rule 11    stmt -> expr
Rule 12    expr -> ( expr )
Rule 13    expr -> - expr  [precedence=right, level=6]
Rule 14    expr -> tuple
Rule 15    expr -> array
Rule 16    expr -> binary_expr
Rule 17    expr -> type_identifier
Rule 18    expr -> identifier
Rule 19    expr -> variable_declaration
Rule 20    expr -> case_of
Rule 21    expr -> call
Rule 22    expr -> if_expr
Rule 23    expr -> def_expr
Rule 24    expr -> literal
Rule 25    expr -> do
Rule 26    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 27    binary_expr -> expr NOT_MORE expr  [precedence=left, level=2]
Rule 28    binary_expr -> expr NOT_LESS expr  [precedence=left, level=2]
Rule 29    binary_expr -> expr > expr  [precedence=left, level=2]
Rule 30    binary_expr -> expr < expr  [precedence=left, level=2]
Rule 31    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 32    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 33    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 34    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 35    binary_expr -> expr CONCAT expr  [precedence=left, level=3]
Rule 36    do -> DO hint _3_optional _4_repeat END
Rule 37    _3_optional -> expr
Rule 38    _3_optional -> <empty>
Rule 39    _4_repeat -> _4_items
Rule 40    _4_repeat -> <empty>
Rule 41    _4_items -> _4_items _4_item
Rule 42    _4_items -> _4_item
Rule 43    _4_item -> NEWLINE expr
Rule 44    block_statement -> _5_optional _6_repeat
Rule 45    _5_optional -> expr
Rule 46    _5_optional -> <empty>
Rule 47    _6_repeat -> _6_items
Rule 48    _6_repeat -> <empty>
Rule 49    _6_items -> _6_items _6_item
Rule 50    _6_items -> _6_item
Rule 51    _6_item -> NEWLINE expr
Rule 52    def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do
Rule 53    _7_optional -> param
Rule 54    _7_optional -> <empty>
Rule 55    _8_repeat -> _8_items
Rule 56    _8_repeat -> <empty>
Rule 57    _8_items -> _8_items _8_item
Rule 58    _8_items -> _8_item
Rule 59    _8_item -> , param
Rule 60    type -> type_identifier _9_optional
Rule 61    _9_optional -> < type _10_repeat >  [precedence=left, level=2]
Rule 62    _10_repeat -> _10_items
Rule 63    _10_repeat -> <empty>
Rule 64    _10_items -> _10_items _10_item
Rule 65    _10_items -> _10_item
Rule 66    _10_item -> , type
Rule 67    _9_optional -> <empty>
Rule 68    hint -> <empty>
Rule 69    hint -> : type
Rule 70    struct -> STRUCT type_identifier _11_optional { _13_repeat }
Rule 71    _11_optional -> < identifier _12_repeat >  [precedence=left, level=2]
Rule 72    _12_repeat -> _12_items
Rule 73    _12_repeat -> <empty>
Rule 74    _12_items -> _12_items _12_item
Rule 75    _12_items -> _12_item
Rule 76    _12_item -> , identifier
Rule 77    _11_optional -> <empty>
Rule 78    _13_repeat -> _13_items
Rule 79    _13_repeat -> <empty>
Rule 80    _13_items -> _13_items _13_item
Rule 81    _13_items -> _13_item
Rule 82    _13_item -> identifier : type
Rule 83    enum -> ENUM type_identifier _14_optional { _15_repeat }
Rule 84    _14_optional -> < fields_unnamed >  [precedence=left, level=2]
Rule 85    _14_optional -> <empty>
Rule 86    _15_repeat -> _15_items
Rule 87    _15_repeat -> <empty>
Rule 88    _15_items -> _15_items _15_item
Rule 89    _15_items -> _15_item
Rule 90    _15_item -> variant
Rule 91    variant -> type_identifier _16_optional
Rule 92    _16_optional -> ( fields_unnamed )
Rule 93    _16_optional -> <empty>
Rule 94    fields_unnamed -> identifier _17_repeat
Rule 95    _17_repeat -> _17_items
Rule 96    _17_repeat -> <empty>
Rule 97    _17_items -> _17_items _17_item
Rule 98    _17_items -> _17_item
Rule 99    _17_item -> , identifier
Rule 100   param -> identifier hint
Rule 101   if_expr -> IF expr THEN hint block_statement _18_optional END
Rule 102   _18_optional -> or_else
Rule 103   _18_optional -> <empty>
Rule 104   or_else -> ELIF expr THEN block_statement _19_optional
Rule 105   _19_optional -> or_else
Rule 106   _19_optional -> <empty>
Rule 107   or_else -> ELSE block_statement
Rule 108   case_of -> CASE expr OF case _20_repeat END
Rule 109   _20_repeat -> _20_items
Rule 110   _20_repeat -> <empty>
Rule 111   _20_items -> _20_items _20_item
Rule 112   _20_items -> _20_item
Rule 113   _20_item -> case
Rule 114   case -> pattern do
Rule 115   pattern -> array_pattern
Rule 116   pattern -> enum_pattern
Rule 117   pattern -> param_pattern
Rule 118   param_pattern -> identifier
Rule 119   array_pattern -> [ _21_optional _22_optional ]
Rule 120   _21_optional -> patterns
Rule 121   _21_optional -> <empty>
Rule 122   _22_optional -> spread
Rule 123   _22_optional -> <empty>
Rule 124   spread -> SPREAD identifier _23_repeat
Rule 125   _23_repeat -> _23_items
Rule 126   _23_repeat -> <empty>
Rule 127   _23_items -> _23_items _23_item
Rule 128   _23_items -> _23_item
Rule 129   _23_item -> , pattern
Rule 130   patterns -> pattern _24_repeat
Rule 131   _24_repeat -> _24_items
Rule 132   _24_repeat -> <empty>
Rule 133   _24_items -> _24_items _24_item
Rule 134   _24_items -> _24_item
Rule 135   _24_item -> , pattern
Rule 136   enum_pattern -> type_identifier ( _25_optional )
Rule 137   _25_optional -> patterns
Rule 138   _25_optional -> <empty>
Rule 139   type_identifier -> TYPE_IDENTIFIER
Rule 140   array -> [ _26_optional _27_repeat ]
Rule 141   _26_optional -> expr
Rule 142   _26_optional -> <empty>
Rule 143   _27_repeat -> _27_items
Rule 144   _27_repeat -> <empty>
Rule 145   _27_items -> _27_items _27_item
Rule 146   _27_items -> _27_item
Rule 147   _27_item -> , expr
Rule 148   tuple -> { _28_optional _29_repeat }
Rule 149   _28_optional -> expr
Rule 150   _28_optional -> <empty>
Rule 151   _29_repeat -> _29_items
Rule 152   _29_repeat -> <empty>
Rule 153   _29_items -> _29_items _29_item
Rule 154   _29_items -> _29_item
Rule 155   _29_item -> , expr
Rule 156   call -> callee ( _30_optional _31_repeat )
Rule 157   _30_optional -> expr
Rule 158   _30_optional -> <empty>
Rule 159   _31_repeat -> _31_items
Rule 160   _31_repeat -> <empty>
Rule 161   _31_items -> _31_items _31_item
Rule 162   _31_items -> _31_item
Rule 163   _31_item -> , expr
Rule 164   callee -> type_identifier
Rule 165   callee -> identifier
Rule 166   identifier -> IDENTIFIER
Rule 167   variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr  [precedence=left, level=2]
Rule 168   _32_repeat -> _32_items
Rule 169   _32_repeat -> <empty>
Rule 170   _32_items -> _32_items _32_item
Rule 171   _32_items -> _32_item
Rule 172   _32_item -> , type
Rule 173   variable_declaration -> identifier hint = expr  [precedence=left, level=1]
Rule 174   literal -> STRING
Rule 175   literal -> NUMBER

Terminals, with rules where they appear:

(                    : 12 52 92 136 156
)                    : 12 52 92 136 156
*                    : 31
+                    : 34
,                    : 59 66 76 99 129 135 147 155 163 172
-                    : 13 33
/                    : 32
:                    : 69 82 167
<                    : 30 61 71 84 167
=                    : 173
>                    : 29 61 71 84
CASE                 : 108
CONCAT               : 35
DEF                  : 52
DO                   : 36
ELIF                 : 104
ELSE                 : 107
END                  : 36 101 108
ENUM                 : 83
IDENTIFIER           : 166
IF                   : 101
INT_DIV              : 26
NEWLINE              : 8 43 51
NOT_LESS             : 28 167
NOT_MORE             : 27
NUMBER               : 175
OF                   : 108
SPREAD               : 124
STRING               : 174
STRUCT               : 70
THEN                 : 101 104
TYPE_IDENTIFIER      : 139
[                    : 119 140
]                    : 119 140
error                : 
{                    : 70 83 148
}                    : 70 83 148

Nonterminals, with rules where they appear:

_10_item             : 64 65
_10_items            : 62 64
_10_repeat           : 61
_11_optional         : 70
_12_item             : 74 75
_12_items            : 72 74
_12_repeat           : 71
_13_item             : 80 81
_13_items            : 78 80
_13_repeat           : 70
_14_optional         : 83
_15_item             : 88 89
_15_items            : 86 88
_15_repeat           : 83
_16_optional         : 91
_17_item             : 97 98
_17_items            : 95 97
_17_repeat           : 94
_18_optional         : 101
_19_optional         : 104
_1_optional          : 1
_20_item             : 111 112
_20_items            : 109 111
_20_repeat           : 108
_21_optional         : 119
_22_optional         : 119
_23_item             : 127 128
_23_items            : 125 127
_23_repeat           : 124
_24_item             : 133 134
_24_items            : 131 133
_24_repeat           : 130
_25_optional         : 136
_26_optional         : 140
_27_item             : 145 146
_27_items            : 143 145
_27_repeat           : 140
_28_optional         : 148
_29_item             : 153 154
_29_items            : 151 153
_29_repeat           : 148
_2_item              : 6 7
_2_items             : 4 6
_2_repeat            : 1
_30_optional         : 156
_31_item             : 161 162
_31_items            : 159 161
_31_repeat           : 156
_32_item             : 170 171
_32_items            : 168 170
_32_repeat           : 167
_3_optional          : 36
_4_item              : 41 42
_4_items             : 39 41
_4_repeat            : 36
_5_optional          : 44
_6_item              : 49 50
_6_items             : 47 49
_6_repeat            : 44
_7_optional          : 52
_8_item              : 57 58
_8_items             : 55 57
_8_repeat            : 52
_9_optional          : 60
array                : 15
array_pattern        : 115
binary_expr          : 16
block_statement      : 101 104 107
call                 : 21
callee               : 156
case                 : 108 113
case_of              : 20
def_expr             : 23
do                   : 25 52 114
enum                 : 9
enum_pattern         : 116
expr                 : 11 12 13 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 37 43 45 51 101 104 108 141 147 149 155 157 163 167 173
fields_unnamed       : 84 92
hint                 : 36 52 100 101 173
identifier           : 18 52 71 76 82 94 99 100 118 124 165 167 173
if_expr              : 22
literal              : 24
or_else              : 102 105
param                : 53 59
param_pattern        : 117
pattern              : 114 129 130 135
patterns             : 120 137
program              : 0
spread               : 122
stmt                 : 2 8
struct               : 10
tuple                : 14
type                 : 61 66 69 82 167 172
type_identifier      : 17 60 70 83 91 136 164 167
variable_declaration : 19
variant              : 90


state 0

    (0) S' -> . program
    (1) program -> . _1_optional _2_repeat
    (2) _1_optional -> . stmt
    (3) _1_optional -> .
    (9) stmt -> . enum
    (10) stmt -> . struct
    (11) stmt -> . expr
    (83) enum -> . ENUM type_identifier _14_optional { _15_repeat }
    (70) struct -> . STRUCT type_identifier _11_optional { _13_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    NEWLINE         reduce using rule 3 (_1_optional -> .)
    $end            reduce using rule 3 (_1_optional -> .)
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    program                        shift and go to state 1
    _1_optional                    shift and go to state 2
    stmt                           shift and go to state 3
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    type_identifier                shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_optional . _2_repeat
    (4) _2_repeat -> . _2_items
    (5) _2_repeat -> .
    (6) _2_items -> . _2_items _2_item
    (7) _2_items -> . _2_item
    (8) _2_item -> . NEWLINE stmt
    $end            reduce using rule 5 (_2_repeat -> .)
    NEWLINE         shift and go to state 37

    _2_repeat                      shift and go to state 34
    _2_items                       shift and go to state 35
    _2_item                        shift and go to state 36

state 3

    (2) _1_optional -> stmt .
    NEWLINE         reduce using rule 2 (_1_optional -> stmt .)
    $end            reduce using rule 2 (_1_optional -> stmt .)


state 4

    (9) stmt -> enum .
    NEWLINE         reduce using rule 9 (stmt -> enum .)
    $end            reduce using rule 9 (stmt -> enum .)


state 5

    (10) stmt -> struct .
    NEWLINE         reduce using rule 10 (stmt -> struct .)
    $end            reduce using rule 10 (stmt -> struct .)


state 6

    (11) stmt -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 11 (stmt -> expr .)
    $end            reduce using rule 11 (stmt -> expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 7

    (83) enum -> ENUM . type_identifier _14_optional { _15_repeat }
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 48

state 8

    (17) expr -> type_identifier .
    (164) callee -> type_identifier .
    INT_DIV         reduce using rule 17 (expr -> type_identifier .)
    NOT_MORE        reduce using rule 17 (expr -> type_identifier .)
    NOT_LESS        reduce using rule 17 (expr -> type_identifier .)
    >               reduce using rule 17 (expr -> type_identifier .)
    <               reduce using rule 17 (expr -> type_identifier .)
    *               reduce using rule 17 (expr -> type_identifier .)
    /               reduce using rule 17 (expr -> type_identifier .)
    -               reduce using rule 17 (expr -> type_identifier .)
    +               reduce using rule 17 (expr -> type_identifier .)
    CONCAT          reduce using rule 17 (expr -> type_identifier .)
    NEWLINE         reduce using rule 17 (expr -> type_identifier .)
    $end            reduce using rule 17 (expr -> type_identifier .)
    ,               reduce using rule 17 (expr -> type_identifier .)
    }               reduce using rule 17 (expr -> type_identifier .)
    )               reduce using rule 17 (expr -> type_identifier .)
    ]               reduce using rule 17 (expr -> type_identifier .)
    OF              reduce using rule 17 (expr -> type_identifier .)
    THEN            reduce using rule 17 (expr -> type_identifier .)
    END             reduce using rule 17 (expr -> type_identifier .)
    ELIF            reduce using rule 17 (expr -> type_identifier .)
    ELSE            reduce using rule 17 (expr -> type_identifier .)
    (               reduce using rule 164 (callee -> type_identifier .)


state 9

    (148) tuple -> { . _28_optional _29_repeat }
    (149) _28_optional -> . expr
    (150) _28_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    ,               reduce using rule 150 (_28_optional -> .)
    }               reduce using rule 150 (_28_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    _28_optional                   shift and go to state 49
    expr                           shift and go to state 50
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 10

    (70) struct -> STRUCT . type_identifier _11_optional { _13_repeat }
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 51

state 11

    (12) expr -> ( . expr )
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 52
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 12

    (13) expr -> - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 53
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 13

    (14) expr -> tuple .
    INT_DIV         reduce using rule 14 (expr -> tuple .)
    NOT_MORE        reduce using rule 14 (expr -> tuple .)
    NOT_LESS        reduce using rule 14 (expr -> tuple .)
    >               reduce using rule 14 (expr -> tuple .)
    <               reduce using rule 14 (expr -> tuple .)
    *               reduce using rule 14 (expr -> tuple .)
    /               reduce using rule 14 (expr -> tuple .)
    -               reduce using rule 14 (expr -> tuple .)
    +               reduce using rule 14 (expr -> tuple .)
    CONCAT          reduce using rule 14 (expr -> tuple .)
    NEWLINE         reduce using rule 14 (expr -> tuple .)
    $end            reduce using rule 14 (expr -> tuple .)
    ,               reduce using rule 14 (expr -> tuple .)
    }               reduce using rule 14 (expr -> tuple .)
    )               reduce using rule 14 (expr -> tuple .)
    ]               reduce using rule 14 (expr -> tuple .)
    OF              reduce using rule 14 (expr -> tuple .)
    THEN            reduce using rule 14 (expr -> tuple .)
    END             reduce using rule 14 (expr -> tuple .)
    ELIF            reduce using rule 14 (expr -> tuple .)
    ELSE            reduce using rule 14 (expr -> tuple .)


state 14

    (15) expr -> array .
    INT_DIV         reduce using rule 15 (expr -> array .)
    NOT_MORE        reduce using rule 15 (expr -> array .)
    NOT_LESS        reduce using rule 15 (expr -> array .)
    >               reduce using rule 15 (expr -> array .)
    <               reduce using rule 15 (expr -> array .)
    *               reduce using rule 15 (expr -> array .)
    /               reduce using rule 15 (expr -> array .)
    -               reduce using rule 15 (expr -> array .)
    +               reduce using rule 15 (expr -> array .)
    CONCAT          reduce using rule 15 (expr -> array .)
    NEWLINE         reduce using rule 15 (expr -> array .)
    $end            reduce using rule 15 (expr -> array .)
    ,               reduce using rule 15 (expr -> array .)
    }               reduce using rule 15 (expr -> array .)
    )               reduce using rule 15 (expr -> array .)
    ]               reduce using rule 15 (expr -> array .)
    OF              reduce using rule 15 (expr -> array .)
    THEN            reduce using rule 15 (expr -> array .)
    END             reduce using rule 15 (expr -> array .)
    ELIF            reduce using rule 15 (expr -> array .)
    ELSE            reduce using rule 15 (expr -> array .)


state 15

    (16) expr -> binary_expr .
    INT_DIV         reduce using rule 16 (expr -> binary_expr .)
    NOT_MORE        reduce using rule 16 (expr -> binary_expr .)
    NOT_LESS        reduce using rule 16 (expr -> binary_expr .)
    >               reduce using rule 16 (expr -> binary_expr .)
    <               reduce using rule 16 (expr -> binary_expr .)
    *               reduce using rule 16 (expr -> binary_expr .)
    /               reduce using rule 16 (expr -> binary_expr .)
    -               reduce using rule 16 (expr -> binary_expr .)
    +               reduce using rule 16 (expr -> binary_expr .)
    CONCAT          reduce using rule 16 (expr -> binary_expr .)
    NEWLINE         reduce using rule 16 (expr -> binary_expr .)
    $end            reduce using rule 16 (expr -> binary_expr .)
    ,               reduce using rule 16 (expr -> binary_expr .)
    }               reduce using rule 16 (expr -> binary_expr .)
    )               reduce using rule 16 (expr -> binary_expr .)
    ]               reduce using rule 16 (expr -> binary_expr .)
    OF              reduce using rule 16 (expr -> binary_expr .)
    THEN            reduce using rule 16 (expr -> binary_expr .)
    END             reduce using rule 16 (expr -> binary_expr .)
    ELIF            reduce using rule 16 (expr -> binary_expr .)
    ELSE            reduce using rule 16 (expr -> binary_expr .)


state 16

    (18) expr -> identifier .
    (167) variable_declaration -> identifier . : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> identifier . hint = expr
    (165) callee -> identifier .
    (68) hint -> .
    (69) hint -> . : type
    INT_DIV         reduce using rule 18 (expr -> identifier .)
    NOT_MORE        reduce using rule 18 (expr -> identifier .)
    NOT_LESS        reduce using rule 18 (expr -> identifier .)
    >               reduce using rule 18 (expr -> identifier .)
    <               reduce using rule 18 (expr -> identifier .)
    *               reduce using rule 18 (expr -> identifier .)
    /               reduce using rule 18 (expr -> identifier .)
    -               reduce using rule 18 (expr -> identifier .)
    +               reduce using rule 18 (expr -> identifier .)
    CONCAT          reduce using rule 18 (expr -> identifier .)
    NEWLINE         reduce using rule 18 (expr -> identifier .)
    $end            reduce using rule 18 (expr -> identifier .)
    ,               reduce using rule 18 (expr -> identifier .)
    }               reduce using rule 18 (expr -> identifier .)
    )               reduce using rule 18 (expr -> identifier .)
    ]               reduce using rule 18 (expr -> identifier .)
    OF              reduce using rule 18 (expr -> identifier .)
    THEN            reduce using rule 18 (expr -> identifier .)
    END             reduce using rule 18 (expr -> identifier .)
    ELIF            reduce using rule 18 (expr -> identifier .)
    ELSE            reduce using rule 18 (expr -> identifier .)
    :               shift and go to state 54
    (               reduce using rule 165 (callee -> identifier .)
    =               reduce using rule 68 (hint -> .)

    hint                           shift and go to state 55

state 17

    (19) expr -> variable_declaration .
    INT_DIV         reduce using rule 19 (expr -> variable_declaration .)
    NOT_MORE        reduce using rule 19 (expr -> variable_declaration .)
    NOT_LESS        reduce using rule 19 (expr -> variable_declaration .)
    >               reduce using rule 19 (expr -> variable_declaration .)
    <               reduce using rule 19 (expr -> variable_declaration .)
    *               reduce using rule 19 (expr -> variable_declaration .)
    /               reduce using rule 19 (expr -> variable_declaration .)
    -               reduce using rule 19 (expr -> variable_declaration .)
    +               reduce using rule 19 (expr -> variable_declaration .)
    CONCAT          reduce using rule 19 (expr -> variable_declaration .)
    NEWLINE         reduce using rule 19 (expr -> variable_declaration .)
    $end            reduce using rule 19 (expr -> variable_declaration .)
    ,               reduce using rule 19 (expr -> variable_declaration .)
    }               reduce using rule 19 (expr -> variable_declaration .)
    )               reduce using rule 19 (expr -> variable_declaration .)
    ]               reduce using rule 19 (expr -> variable_declaration .)
    OF              reduce using rule 19 (expr -> variable_declaration .)
    THEN            reduce using rule 19 (expr -> variable_declaration .)
    END             reduce using rule 19 (expr -> variable_declaration .)
    ELIF            reduce using rule 19 (expr -> variable_declaration .)
    ELSE            reduce using rule 19 (expr -> variable_declaration .)


state 18

    (20) expr -> case_of .
    INT_DIV         reduce using rule 20 (expr -> case_of .)
    NOT_MORE        reduce using rule 20 (expr -> case_of .)
    NOT_LESS        reduce using rule 20 (expr -> case_of .)
    >               reduce using rule 20 (expr -> case_of .)
    <               reduce using rule 20 (expr -> case_of .)
    *               reduce using rule 20 (expr -> case_of .)
    /               reduce using rule 20 (expr -> case_of .)
    -               reduce using rule 20 (expr -> case_of .)
    +               reduce using rule 20 (expr -> case_of .)
    CONCAT          reduce using rule 20 (expr -> case_of .)
    NEWLINE         reduce using rule 20 (expr -> case_of .)
    $end            reduce using rule 20 (expr -> case_of .)
    ,               reduce using rule 20 (expr -> case_of .)
    }               reduce using rule 20 (expr -> case_of .)
    )               reduce using rule 20 (expr -> case_of .)
    ]               reduce using rule 20 (expr -> case_of .)
    OF              reduce using rule 20 (expr -> case_of .)
    THEN            reduce using rule 20 (expr -> case_of .)
    END             reduce using rule 20 (expr -> case_of .)
    ELIF            reduce using rule 20 (expr -> case_of .)
    ELSE            reduce using rule 20 (expr -> case_of .)


state 19

    (21) expr -> call .
    INT_DIV         reduce using rule 21 (expr -> call .)
    NOT_MORE        reduce using rule 21 (expr -> call .)
    NOT_LESS        reduce using rule 21 (expr -> call .)
    >               reduce using rule 21 (expr -> call .)
    <               reduce using rule 21 (expr -> call .)
    *               reduce using rule 21 (expr -> call .)
    /               reduce using rule 21 (expr -> call .)
    -               reduce using rule 21 (expr -> call .)
    +               reduce using rule 21 (expr -> call .)
    CONCAT          reduce using rule 21 (expr -> call .)
    NEWLINE         reduce using rule 21 (expr -> call .)
    $end            reduce using rule 21 (expr -> call .)
    ,               reduce using rule 21 (expr -> call .)
    }               reduce using rule 21 (expr -> call .)
    )               reduce using rule 21 (expr -> call .)
    ]               reduce using rule 21 (expr -> call .)
    OF              reduce using rule 21 (expr -> call .)
    THEN            reduce using rule 21 (expr -> call .)
    END             reduce using rule 21 (expr -> call .)
    ELIF            reduce using rule 21 (expr -> call .)
    ELSE            reduce using rule 21 (expr -> call .)


state 20

    (22) expr -> if_expr .
    INT_DIV         reduce using rule 22 (expr -> if_expr .)
    NOT_MORE        reduce using rule 22 (expr -> if_expr .)
    NOT_LESS        reduce using rule 22 (expr -> if_expr .)
    >               reduce using rule 22 (expr -> if_expr .)
    <               reduce using rule 22 (expr -> if_expr .)
    *               reduce using rule 22 (expr -> if_expr .)
    /               reduce using rule 22 (expr -> if_expr .)
    -               reduce using rule 22 (expr -> if_expr .)
    +               reduce using rule 22 (expr -> if_expr .)
    CONCAT          reduce using rule 22 (expr -> if_expr .)
    NEWLINE         reduce using rule 22 (expr -> if_expr .)
    $end            reduce using rule 22 (expr -> if_expr .)
    ,               reduce using rule 22 (expr -> if_expr .)
    }               reduce using rule 22 (expr -> if_expr .)
    )               reduce using rule 22 (expr -> if_expr .)
    ]               reduce using rule 22 (expr -> if_expr .)
    OF              reduce using rule 22 (expr -> if_expr .)
    THEN            reduce using rule 22 (expr -> if_expr .)
    END             reduce using rule 22 (expr -> if_expr .)
    ELIF            reduce using rule 22 (expr -> if_expr .)
    ELSE            reduce using rule 22 (expr -> if_expr .)


state 21

    (23) expr -> def_expr .
    INT_DIV         reduce using rule 23 (expr -> def_expr .)
    NOT_MORE        reduce using rule 23 (expr -> def_expr .)
    NOT_LESS        reduce using rule 23 (expr -> def_expr .)
    >               reduce using rule 23 (expr -> def_expr .)
    <               reduce using rule 23 (expr -> def_expr .)
    *               reduce using rule 23 (expr -> def_expr .)
    /               reduce using rule 23 (expr -> def_expr .)
    -               reduce using rule 23 (expr -> def_expr .)
    +               reduce using rule 23 (expr -> def_expr .)
    CONCAT          reduce using rule 23 (expr -> def_expr .)
    NEWLINE         reduce using rule 23 (expr -> def_expr .)
    $end            reduce using rule 23 (expr -> def_expr .)
    ,               reduce using rule 23 (expr -> def_expr .)
    }               reduce using rule 23 (expr -> def_expr .)
    )               reduce using rule 23 (expr -> def_expr .)
    ]               reduce using rule 23 (expr -> def_expr .)
    OF              reduce using rule 23 (expr -> def_expr .)
    THEN            reduce using rule 23 (expr -> def_expr .)
    END             reduce using rule 23 (expr -> def_expr .)
    ELIF            reduce using rule 23 (expr -> def_expr .)
    ELSE            reduce using rule 23 (expr -> def_expr .)


state 22

    (24) expr -> literal .
    INT_DIV         reduce using rule 24 (expr -> literal .)
    NOT_MORE        reduce using rule 24 (expr -> literal .)
    NOT_LESS        reduce using rule 24 (expr -> literal .)
    >               reduce using rule 24 (expr -> literal .)
    <               reduce using rule 24 (expr -> literal .)
    *               reduce using rule 24 (expr -> literal .)
    /               reduce using rule 24 (expr -> literal .)
    -               reduce using rule 24 (expr -> literal .)
    +               reduce using rule 24 (expr -> literal .)
    CONCAT          reduce using rule 24 (expr -> literal .)
    NEWLINE         reduce using rule 24 (expr -> literal .)
    $end            reduce using rule 24 (expr -> literal .)
    ,               reduce using rule 24 (expr -> literal .)
    }               reduce using rule 24 (expr -> literal .)
    )               reduce using rule 24 (expr -> literal .)
    ]               reduce using rule 24 (expr -> literal .)
    OF              reduce using rule 24 (expr -> literal .)
    THEN            reduce using rule 24 (expr -> literal .)
    END             reduce using rule 24 (expr -> literal .)
    ELIF            reduce using rule 24 (expr -> literal .)
    ELSE            reduce using rule 24 (expr -> literal .)


state 23

    (25) expr -> do .
    INT_DIV         reduce using rule 25 (expr -> do .)
    NOT_MORE        reduce using rule 25 (expr -> do .)
    NOT_LESS        reduce using rule 25 (expr -> do .)
    >               reduce using rule 25 (expr -> do .)
    <               reduce using rule 25 (expr -> do .)
    *               reduce using rule 25 (expr -> do .)
    /               reduce using rule 25 (expr -> do .)
    -               reduce using rule 25 (expr -> do .)
    +               reduce using rule 25 (expr -> do .)
    CONCAT          reduce using rule 25 (expr -> do .)
    NEWLINE         reduce using rule 25 (expr -> do .)
    $end            reduce using rule 25 (expr -> do .)
    ,               reduce using rule 25 (expr -> do .)
    }               reduce using rule 25 (expr -> do .)
    )               reduce using rule 25 (expr -> do .)
    ]               reduce using rule 25 (expr -> do .)
    OF              reduce using rule 25 (expr -> do .)
    THEN            reduce using rule 25 (expr -> do .)
    END             reduce using rule 25 (expr -> do .)
    ELIF            reduce using rule 25 (expr -> do .)
    ELSE            reduce using rule 25 (expr -> do .)


state 24

    (140) array -> [ . _26_optional _27_repeat ]
    (141) _26_optional -> . expr
    (142) _26_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    ,               reduce using rule 142 (_26_optional -> .)
    ]               reduce using rule 142 (_26_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    _26_optional                   shift and go to state 56
    expr                           shift and go to state 57
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 25

    (139) type_identifier -> TYPE_IDENTIFIER .
    INT_DIV         reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    NOT_MORE        reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    NOT_LESS        reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    *               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    /               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    +               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    CONCAT          reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    $end            reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    (               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    ]               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    OF              reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    THEN            reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 139 (type_identifier -> TYPE_IDENTIFIER .)


state 26

    (166) identifier -> IDENTIFIER .
    :               reduce using rule 166 (identifier -> IDENTIFIER .)
    =               reduce using rule 166 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 166 (identifier -> IDENTIFIER .)
    NOT_MORE        reduce using rule 166 (identifier -> IDENTIFIER .)
    NOT_LESS        reduce using rule 166 (identifier -> IDENTIFIER .)
    >               reduce using rule 166 (identifier -> IDENTIFIER .)
    <               reduce using rule 166 (identifier -> IDENTIFIER .)
    *               reduce using rule 166 (identifier -> IDENTIFIER .)
    /               reduce using rule 166 (identifier -> IDENTIFIER .)
    -               reduce using rule 166 (identifier -> IDENTIFIER .)
    +               reduce using rule 166 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 166 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 166 (identifier -> IDENTIFIER .)
    $end            reduce using rule 166 (identifier -> IDENTIFIER .)
    (               reduce using rule 166 (identifier -> IDENTIFIER .)
    ,               reduce using rule 166 (identifier -> IDENTIFIER .)
    }               reduce using rule 166 (identifier -> IDENTIFIER .)
    )               reduce using rule 166 (identifier -> IDENTIFIER .)
    ]               reduce using rule 166 (identifier -> IDENTIFIER .)
    OF              reduce using rule 166 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 166 (identifier -> IDENTIFIER .)
    END             reduce using rule 166 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 166 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 166 (identifier -> IDENTIFIER .)
    DO              reduce using rule 166 (identifier -> IDENTIFIER .)
    SPREAD          reduce using rule 166 (identifier -> IDENTIFIER .)


state 27

    (108) case_of -> CASE . expr OF case _20_repeat END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 58
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 28

    (156) call -> callee . ( _30_optional _31_repeat )
    (               shift and go to state 59


state 29

    (101) if_expr -> IF . expr THEN hint block_statement _18_optional END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 60
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 30

    (52) def_expr -> DEF . identifier ( _7_optional _8_repeat ) hint do
    (166) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 61

state 31

    (174) literal -> STRING .
    INT_DIV         reduce using rule 174 (literal -> STRING .)
    NOT_MORE        reduce using rule 174 (literal -> STRING .)
    NOT_LESS        reduce using rule 174 (literal -> STRING .)
    >               reduce using rule 174 (literal -> STRING .)
    <               reduce using rule 174 (literal -> STRING .)
    *               reduce using rule 174 (literal -> STRING .)
    /               reduce using rule 174 (literal -> STRING .)
    -               reduce using rule 174 (literal -> STRING .)
    +               reduce using rule 174 (literal -> STRING .)
    CONCAT          reduce using rule 174 (literal -> STRING .)
    NEWLINE         reduce using rule 174 (literal -> STRING .)
    $end            reduce using rule 174 (literal -> STRING .)
    ,               reduce using rule 174 (literal -> STRING .)
    }               reduce using rule 174 (literal -> STRING .)
    )               reduce using rule 174 (literal -> STRING .)
    ]               reduce using rule 174 (literal -> STRING .)
    OF              reduce using rule 174 (literal -> STRING .)
    THEN            reduce using rule 174 (literal -> STRING .)
    END             reduce using rule 174 (literal -> STRING .)
    ELIF            reduce using rule 174 (literal -> STRING .)
    ELSE            reduce using rule 174 (literal -> STRING .)


state 32

    (175) literal -> NUMBER .
    INT_DIV         reduce using rule 175 (literal -> NUMBER .)
    NOT_MORE        reduce using rule 175 (literal -> NUMBER .)
    NOT_LESS        reduce using rule 175 (literal -> NUMBER .)
    >               reduce using rule 175 (literal -> NUMBER .)
    <               reduce using rule 175 (literal -> NUMBER .)
    *               reduce using rule 175 (literal -> NUMBER .)
    /               reduce using rule 175 (literal -> NUMBER .)
    -               reduce using rule 175 (literal -> NUMBER .)
    +               reduce using rule 175 (literal -> NUMBER .)
    CONCAT          reduce using rule 175 (literal -> NUMBER .)
    NEWLINE         reduce using rule 175 (literal -> NUMBER .)
    $end            reduce using rule 175 (literal -> NUMBER .)
    ,               reduce using rule 175 (literal -> NUMBER .)
    }               reduce using rule 175 (literal -> NUMBER .)
    )               reduce using rule 175 (literal -> NUMBER .)
    ]               reduce using rule 175 (literal -> NUMBER .)
    OF              reduce using rule 175 (literal -> NUMBER .)
    THEN            reduce using rule 175 (literal -> NUMBER .)
    END             reduce using rule 175 (literal -> NUMBER .)
    ELIF            reduce using rule 175 (literal -> NUMBER .)
    ELSE            reduce using rule 175 (literal -> NUMBER .)


state 33

    (36) do -> DO . hint _3_optional _4_repeat END
    (68) hint -> .
    (69) hint -> . : type
    (               reduce using rule 68 (hint -> .)
    -               reduce using rule 68 (hint -> .)
    {               reduce using rule 68 (hint -> .)
    [               reduce using rule 68 (hint -> .)
    TYPE_IDENTIFIER reduce using rule 68 (hint -> .)
    IDENTIFIER      reduce using rule 68 (hint -> .)
    CASE            reduce using rule 68 (hint -> .)
    IF              reduce using rule 68 (hint -> .)
    DEF             reduce using rule 68 (hint -> .)
    STRING          reduce using rule 68 (hint -> .)
    NUMBER          reduce using rule 68 (hint -> .)
    DO              reduce using rule 68 (hint -> .)
    NEWLINE         reduce using rule 68 (hint -> .)
    END             reduce using rule 68 (hint -> .)
    :               shift and go to state 63

    hint                           shift and go to state 62

state 34

    (1) program -> _1_optional _2_repeat .
    $end            reduce using rule 1 (program -> _1_optional _2_repeat .)


state 35

    (4) _2_repeat -> _2_items .
    (6) _2_items -> _2_items . _2_item
    (8) _2_item -> . NEWLINE stmt
    $end            reduce using rule 4 (_2_repeat -> _2_items .)
    NEWLINE         shift and go to state 37

    _2_item                        shift and go to state 64

state 36

    (7) _2_items -> _2_item .
    NEWLINE         reduce using rule 7 (_2_items -> _2_item .)
    $end            reduce using rule 7 (_2_items -> _2_item .)


state 37

    (8) _2_item -> NEWLINE . stmt
    (9) stmt -> . enum
    (10) stmt -> . struct
    (11) stmt -> . expr
    (83) enum -> . ENUM type_identifier _14_optional { _15_repeat }
    (70) struct -> . STRUCT type_identifier _11_optional { _13_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    stmt                           shift and go to state 65
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    type_identifier                shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 38

    (26) binary_expr -> expr INT_DIV . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 66
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 39

    (27) binary_expr -> expr NOT_MORE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 67
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 40

    (28) binary_expr -> expr NOT_LESS . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 68
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 41

    (29) binary_expr -> expr > . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 69
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 42

    (30) binary_expr -> expr < . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 70
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 43

    (31) binary_expr -> expr * . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 71
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 44

    (32) binary_expr -> expr / . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 72
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 45

    (33) binary_expr -> expr - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 73
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 46

    (34) binary_expr -> expr + . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 74
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 47

    (35) binary_expr -> expr CONCAT . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 75
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 48

    (83) enum -> ENUM type_identifier . _14_optional { _15_repeat }
    (84) _14_optional -> . < fields_unnamed >
    (85) _14_optional -> .
    <               shift and go to state 77
    {               reduce using rule 85 (_14_optional -> .)

    _14_optional                   shift and go to state 76

state 49

    (148) tuple -> { _28_optional . _29_repeat }
    (151) _29_repeat -> . _29_items
    (152) _29_repeat -> .
    (153) _29_items -> . _29_items _29_item
    (154) _29_items -> . _29_item
    (155) _29_item -> . , expr
    }               reduce using rule 152 (_29_repeat -> .)
    ,               shift and go to state 81

    _29_repeat                     shift and go to state 78
    _29_items                      shift and go to state 79
    _29_item                       shift and go to state 80

state 50

    (149) _28_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 149 (_28_optional -> expr .)
    }               reduce using rule 149 (_28_optional -> expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 51

    (70) struct -> STRUCT type_identifier . _11_optional { _13_repeat }
    (71) _11_optional -> . < identifier _12_repeat >
    (77) _11_optional -> .
    <               shift and go to state 83
    {               reduce using rule 77 (_11_optional -> .)

    _11_optional                   shift and go to state 82

state 52

    (12) expr -> ( expr . )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    )               shift and go to state 84
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 53

    (13) expr -> - expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 13 (expr -> - expr .)
    NOT_MORE        reduce using rule 13 (expr -> - expr .)
    NOT_LESS        reduce using rule 13 (expr -> - expr .)
    >               reduce using rule 13 (expr -> - expr .)
    <               reduce using rule 13 (expr -> - expr .)
    *               reduce using rule 13 (expr -> - expr .)
    /               reduce using rule 13 (expr -> - expr .)
    -               reduce using rule 13 (expr -> - expr .)
    +               reduce using rule 13 (expr -> - expr .)
    CONCAT          reduce using rule 13 (expr -> - expr .)
    NEWLINE         reduce using rule 13 (expr -> - expr .)
    $end            reduce using rule 13 (expr -> - expr .)
    ,               reduce using rule 13 (expr -> - expr .)
    }               reduce using rule 13 (expr -> - expr .)
    )               reduce using rule 13 (expr -> - expr .)
    ]               reduce using rule 13 (expr -> - expr .)
    OF              reduce using rule 13 (expr -> - expr .)
    THEN            reduce using rule 13 (expr -> - expr .)
    END             reduce using rule 13 (expr -> - expr .)
    ELIF            reduce using rule 13 (expr -> - expr .)
    ELSE            reduce using rule 13 (expr -> - expr .)


state 54

    (167) variable_declaration -> identifier : . type_identifier < type _32_repeat NOT_LESS expr
    (69) hint -> : . type
    (139) type_identifier -> . TYPE_IDENTIFIER
    (60) type -> . type_identifier _9_optional
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 85
    type                           shift and go to state 86

state 55

    (173) variable_declaration -> identifier hint . = expr
    =               shift and go to state 87


state 56

    (140) array -> [ _26_optional . _27_repeat ]
    (143) _27_repeat -> . _27_items
    (144) _27_repeat -> .
    (145) _27_items -> . _27_items _27_item
    (146) _27_items -> . _27_item
    (147) _27_item -> . , expr
    ]               reduce using rule 144 (_27_repeat -> .)
    ,               shift and go to state 91

    _27_repeat                     shift and go to state 88
    _27_items                      shift and go to state 89
    _27_item                       shift and go to state 90

state 57

    (141) _26_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 141 (_26_optional -> expr .)
    ]               reduce using rule 141 (_26_optional -> expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 58

    (108) case_of -> CASE expr . OF case _20_repeat END
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 92
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 59

    (156) call -> callee ( . _30_optional _31_repeat )
    (157) _30_optional -> . expr
    (158) _30_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    ,               reduce using rule 158 (_30_optional -> .)
    )               reduce using rule 158 (_30_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    callee                         shift and go to state 28
    _30_optional                   shift and go to state 93
    expr                           shift and go to state 94
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23

state 60

    (101) if_expr -> IF expr . THEN hint block_statement _18_optional END
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 95
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 61

    (52) def_expr -> DEF identifier . ( _7_optional _8_repeat ) hint do
    (               shift and go to state 96


state 62

    (36) do -> DO hint . _3_optional _4_repeat END
    (37) _3_optional -> . expr
    (38) _3_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    NEWLINE         reduce using rule 38 (_3_optional -> .)
    END             reduce using rule 38 (_3_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    _3_optional                    shift and go to state 97
    expr                           shift and go to state 98
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 63

    (69) hint -> : . type
    (60) type -> . type_identifier _9_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 86
    type_identifier                shift and go to state 99

state 64

    (6) _2_items -> _2_items _2_item .
    NEWLINE         reduce using rule 6 (_2_items -> _2_items _2_item .)
    $end            reduce using rule 6 (_2_items -> _2_items _2_item .)


state 65

    (8) _2_item -> NEWLINE stmt .
    NEWLINE         reduce using rule 8 (_2_item -> NEWLINE stmt .)
    $end            reduce using rule 8 (_2_item -> NEWLINE stmt .)


state 66

    (26) binary_expr -> expr INT_DIV expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    NOT_MORE        reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    NOT_LESS        reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    NEWLINE         reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    }               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)


state 67

    (27) binary_expr -> expr NOT_MORE expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    NOT_LESS        reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    >               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    <               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    NEWLINE         reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    $end            reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    ,               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    }               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    )               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    ]               reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    OF              reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    THEN            reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    END             reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr NOT_MORE expr .)
    INT_DIV         shift and go to state 38
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 68

    (28) binary_expr -> expr NOT_LESS expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    NOT_LESS        reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    >               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    <               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    NEWLINE         reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    $end            reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    ,               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    }               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    )               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    ]               reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    OF              reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    THEN            reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    END             reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr NOT_LESS expr .)
    INT_DIV         shift and go to state 38
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 69

    (29) binary_expr -> expr > expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 29 (binary_expr -> expr > expr .)
    NOT_LESS        reduce using rule 29 (binary_expr -> expr > expr .)
    >               reduce using rule 29 (binary_expr -> expr > expr .)
    <               reduce using rule 29 (binary_expr -> expr > expr .)
    NEWLINE         reduce using rule 29 (binary_expr -> expr > expr .)
    $end            reduce using rule 29 (binary_expr -> expr > expr .)
    ,               reduce using rule 29 (binary_expr -> expr > expr .)
    }               reduce using rule 29 (binary_expr -> expr > expr .)
    )               reduce using rule 29 (binary_expr -> expr > expr .)
    ]               reduce using rule 29 (binary_expr -> expr > expr .)
    OF              reduce using rule 29 (binary_expr -> expr > expr .)
    THEN            reduce using rule 29 (binary_expr -> expr > expr .)
    END             reduce using rule 29 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr > expr .)
    INT_DIV         shift and go to state 38
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 70

    (30) binary_expr -> expr < expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 30 (binary_expr -> expr < expr .)
    NOT_LESS        reduce using rule 30 (binary_expr -> expr < expr .)
    >               reduce using rule 30 (binary_expr -> expr < expr .)
    <               reduce using rule 30 (binary_expr -> expr < expr .)
    NEWLINE         reduce using rule 30 (binary_expr -> expr < expr .)
    $end            reduce using rule 30 (binary_expr -> expr < expr .)
    ,               reduce using rule 30 (binary_expr -> expr < expr .)
    }               reduce using rule 30 (binary_expr -> expr < expr .)
    )               reduce using rule 30 (binary_expr -> expr < expr .)
    ]               reduce using rule 30 (binary_expr -> expr < expr .)
    OF              reduce using rule 30 (binary_expr -> expr < expr .)
    THEN            reduce using rule 30 (binary_expr -> expr < expr .)
    END             reduce using rule 30 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr < expr .)
    INT_DIV         shift and go to state 38
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 71

    (31) binary_expr -> expr * expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 31 (binary_expr -> expr * expr .)
    NOT_MORE        reduce using rule 31 (binary_expr -> expr * expr .)
    NOT_LESS        reduce using rule 31 (binary_expr -> expr * expr .)
    >               reduce using rule 31 (binary_expr -> expr * expr .)
    <               reduce using rule 31 (binary_expr -> expr * expr .)
    *               reduce using rule 31 (binary_expr -> expr * expr .)
    /               reduce using rule 31 (binary_expr -> expr * expr .)
    -               reduce using rule 31 (binary_expr -> expr * expr .)
    +               reduce using rule 31 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 31 (binary_expr -> expr * expr .)
    NEWLINE         reduce using rule 31 (binary_expr -> expr * expr .)
    $end            reduce using rule 31 (binary_expr -> expr * expr .)
    ,               reduce using rule 31 (binary_expr -> expr * expr .)
    }               reduce using rule 31 (binary_expr -> expr * expr .)
    )               reduce using rule 31 (binary_expr -> expr * expr .)
    ]               reduce using rule 31 (binary_expr -> expr * expr .)
    OF              reduce using rule 31 (binary_expr -> expr * expr .)
    THEN            reduce using rule 31 (binary_expr -> expr * expr .)
    END             reduce using rule 31 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr * expr .)


state 72

    (32) binary_expr -> expr / expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 32 (binary_expr -> expr / expr .)
    NOT_MORE        reduce using rule 32 (binary_expr -> expr / expr .)
    NOT_LESS        reduce using rule 32 (binary_expr -> expr / expr .)
    >               reduce using rule 32 (binary_expr -> expr / expr .)
    <               reduce using rule 32 (binary_expr -> expr / expr .)
    *               reduce using rule 32 (binary_expr -> expr / expr .)
    /               reduce using rule 32 (binary_expr -> expr / expr .)
    -               reduce using rule 32 (binary_expr -> expr / expr .)
    +               reduce using rule 32 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 32 (binary_expr -> expr / expr .)
    NEWLINE         reduce using rule 32 (binary_expr -> expr / expr .)
    $end            reduce using rule 32 (binary_expr -> expr / expr .)
    ,               reduce using rule 32 (binary_expr -> expr / expr .)
    }               reduce using rule 32 (binary_expr -> expr / expr .)
    )               reduce using rule 32 (binary_expr -> expr / expr .)
    ]               reduce using rule 32 (binary_expr -> expr / expr .)
    OF              reduce using rule 32 (binary_expr -> expr / expr .)
    THEN            reduce using rule 32 (binary_expr -> expr / expr .)
    END             reduce using rule 32 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr / expr .)


state 73

    (33) binary_expr -> expr - expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 33 (binary_expr -> expr - expr .)
    NOT_LESS        reduce using rule 33 (binary_expr -> expr - expr .)
    >               reduce using rule 33 (binary_expr -> expr - expr .)
    <               reduce using rule 33 (binary_expr -> expr - expr .)
    -               reduce using rule 33 (binary_expr -> expr - expr .)
    +               reduce using rule 33 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 33 (binary_expr -> expr - expr .)
    NEWLINE         reduce using rule 33 (binary_expr -> expr - expr .)
    $end            reduce using rule 33 (binary_expr -> expr - expr .)
    ,               reduce using rule 33 (binary_expr -> expr - expr .)
    }               reduce using rule 33 (binary_expr -> expr - expr .)
    )               reduce using rule 33 (binary_expr -> expr - expr .)
    ]               reduce using rule 33 (binary_expr -> expr - expr .)
    OF              reduce using rule 33 (binary_expr -> expr - expr .)
    THEN            reduce using rule 33 (binary_expr -> expr - expr .)
    END             reduce using rule 33 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr - expr .)
    INT_DIV         shift and go to state 38
    *               shift and go to state 43
    /               shift and go to state 44


state 74

    (34) binary_expr -> expr + expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 34 (binary_expr -> expr + expr .)
    NOT_LESS        reduce using rule 34 (binary_expr -> expr + expr .)
    >               reduce using rule 34 (binary_expr -> expr + expr .)
    <               reduce using rule 34 (binary_expr -> expr + expr .)
    -               reduce using rule 34 (binary_expr -> expr + expr .)
    +               reduce using rule 34 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr + expr .)
    NEWLINE         reduce using rule 34 (binary_expr -> expr + expr .)
    $end            reduce using rule 34 (binary_expr -> expr + expr .)
    ,               reduce using rule 34 (binary_expr -> expr + expr .)
    }               reduce using rule 34 (binary_expr -> expr + expr .)
    )               reduce using rule 34 (binary_expr -> expr + expr .)
    ]               reduce using rule 34 (binary_expr -> expr + expr .)
    OF              reduce using rule 34 (binary_expr -> expr + expr .)
    THEN            reduce using rule 34 (binary_expr -> expr + expr .)
    END             reduce using rule 34 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr + expr .)
    INT_DIV         shift and go to state 38
    *               shift and go to state 43
    /               shift and go to state 44


state 75

    (35) binary_expr -> expr CONCAT expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    NOT_LESS        reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    NEWLINE         reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    }               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr CONCAT expr .)
    INT_DIV         shift and go to state 38
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 76

    (83) enum -> ENUM type_identifier _14_optional . { _15_repeat }
    {               shift and go to state 100


state 77

    (84) _14_optional -> < . fields_unnamed >
    (94) fields_unnamed -> . identifier _17_repeat
    (166) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    fields_unnamed                 shift and go to state 101
    identifier                     shift and go to state 102

state 78

    (148) tuple -> { _28_optional _29_repeat . }
    }               shift and go to state 103


state 79

    (151) _29_repeat -> _29_items .
    (153) _29_items -> _29_items . _29_item
    (155) _29_item -> . , expr
    }               reduce using rule 151 (_29_repeat -> _29_items .)
    ,               shift and go to state 81

    _29_item                       shift and go to state 104

state 80

    (154) _29_items -> _29_item .
    ,               reduce using rule 154 (_29_items -> _29_item .)
    }               reduce using rule 154 (_29_items -> _29_item .)


state 81

    (155) _29_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 105
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 82

    (70) struct -> STRUCT type_identifier _11_optional . { _13_repeat }
    {               shift and go to state 106


state 83

    (71) _11_optional -> < . identifier _12_repeat >
    (166) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 107

state 84

    (12) expr -> ( expr ) .
    INT_DIV         reduce using rule 12 (expr -> ( expr ) .)
    NOT_MORE        reduce using rule 12 (expr -> ( expr ) .)
    NOT_LESS        reduce using rule 12 (expr -> ( expr ) .)
    >               reduce using rule 12 (expr -> ( expr ) .)
    <               reduce using rule 12 (expr -> ( expr ) .)
    *               reduce using rule 12 (expr -> ( expr ) .)
    /               reduce using rule 12 (expr -> ( expr ) .)
    -               reduce using rule 12 (expr -> ( expr ) .)
    +               reduce using rule 12 (expr -> ( expr ) .)
    CONCAT          reduce using rule 12 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 12 (expr -> ( expr ) .)
    $end            reduce using rule 12 (expr -> ( expr ) .)
    ,               reduce using rule 12 (expr -> ( expr ) .)
    }               reduce using rule 12 (expr -> ( expr ) .)
    )               reduce using rule 12 (expr -> ( expr ) .)
    ]               reduce using rule 12 (expr -> ( expr ) .)
    OF              reduce using rule 12 (expr -> ( expr ) .)
    THEN            reduce using rule 12 (expr -> ( expr ) .)
    END             reduce using rule 12 (expr -> ( expr ) .)
    ELIF            reduce using rule 12 (expr -> ( expr ) .)
    ELSE            reduce using rule 12 (expr -> ( expr ) .)


state 85

    (167) variable_declaration -> identifier : type_identifier . < type _32_repeat NOT_LESS expr
    (60) type -> type_identifier . _9_optional
    (61) _9_optional -> . < type _10_repeat >
    (67) _9_optional -> .
    <               shift and go to state 108
    =               reduce using rule 67 (_9_optional -> .)

    _9_optional                    shift and go to state 109

state 86

    (69) hint -> : type .
    =               reduce using rule 69 (hint -> : type .)
    (               reduce using rule 69 (hint -> : type .)
    -               reduce using rule 69 (hint -> : type .)
    {               reduce using rule 69 (hint -> : type .)
    [               reduce using rule 69 (hint -> : type .)
    TYPE_IDENTIFIER reduce using rule 69 (hint -> : type .)
    IDENTIFIER      reduce using rule 69 (hint -> : type .)
    CASE            reduce using rule 69 (hint -> : type .)
    IF              reduce using rule 69 (hint -> : type .)
    DEF             reduce using rule 69 (hint -> : type .)
    STRING          reduce using rule 69 (hint -> : type .)
    NUMBER          reduce using rule 69 (hint -> : type .)
    DO              reduce using rule 69 (hint -> : type .)
    NEWLINE         reduce using rule 69 (hint -> : type .)
    END             reduce using rule 69 (hint -> : type .)
    ELIF            reduce using rule 69 (hint -> : type .)
    ELSE            reduce using rule 69 (hint -> : type .)
    ,               reduce using rule 69 (hint -> : type .)
    )               reduce using rule 69 (hint -> : type .)


state 87

    (173) variable_declaration -> identifier hint = . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    identifier                     shift and go to state 16
    expr                           shift and go to state 110
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 88

    (140) array -> [ _26_optional _27_repeat . ]
    ]               shift and go to state 111


state 89

    (143) _27_repeat -> _27_items .
    (145) _27_items -> _27_items . _27_item
    (147) _27_item -> . , expr
    ]               reduce using rule 143 (_27_repeat -> _27_items .)
    ,               shift and go to state 91

    _27_item                       shift and go to state 112

state 90

    (146) _27_items -> _27_item .
    ,               reduce using rule 146 (_27_items -> _27_item .)
    ]               reduce using rule 146 (_27_items -> _27_item .)


state 91

    (147) _27_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 113
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 92

    (108) case_of -> CASE expr OF . case _20_repeat END
    (114) case -> . pattern do
    (115) pattern -> . array_pattern
    (116) pattern -> . enum_pattern
    (117) pattern -> . param_pattern
    (119) array_pattern -> . [ _21_optional _22_optional ]
    (136) enum_pattern -> . type_identifier ( _25_optional )
    (118) param_pattern -> . identifier
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    [               shift and go to state 119
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    case                           shift and go to state 114
    pattern                        shift and go to state 115
    array_pattern                  shift and go to state 116
    enum_pattern                   shift and go to state 117
    param_pattern                  shift and go to state 118
    type_identifier                shift and go to state 120
    identifier                     shift and go to state 121

state 93

    (156) call -> callee ( _30_optional . _31_repeat )
    (159) _31_repeat -> . _31_items
    (160) _31_repeat -> .
    (161) _31_items -> . _31_items _31_item
    (162) _31_items -> . _31_item
    (163) _31_item -> . , expr
    )               reduce using rule 160 (_31_repeat -> .)
    ,               shift and go to state 125

    _31_repeat                     shift and go to state 122
    _31_items                      shift and go to state 123
    _31_item                       shift and go to state 124

state 94

    (157) _30_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 157 (_30_optional -> expr .)
    )               reduce using rule 157 (_30_optional -> expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 95

    (101) if_expr -> IF expr THEN . hint block_statement _18_optional END
    (68) hint -> .
    (69) hint -> . : type
    (               reduce using rule 68 (hint -> .)
    -               reduce using rule 68 (hint -> .)
    {               reduce using rule 68 (hint -> .)
    [               reduce using rule 68 (hint -> .)
    TYPE_IDENTIFIER reduce using rule 68 (hint -> .)
    IDENTIFIER      reduce using rule 68 (hint -> .)
    CASE            reduce using rule 68 (hint -> .)
    IF              reduce using rule 68 (hint -> .)
    DEF             reduce using rule 68 (hint -> .)
    STRING          reduce using rule 68 (hint -> .)
    NUMBER          reduce using rule 68 (hint -> .)
    DO              reduce using rule 68 (hint -> .)
    ELIF            reduce using rule 68 (hint -> .)
    ELSE            reduce using rule 68 (hint -> .)
    END             reduce using rule 68 (hint -> .)
    NEWLINE         reduce using rule 68 (hint -> .)
    :               shift and go to state 63

    hint                           shift and go to state 126

state 96

    (52) def_expr -> DEF identifier ( . _7_optional _8_repeat ) hint do
    (53) _7_optional -> . param
    (54) _7_optional -> .
    (100) param -> . identifier hint
    (166) identifier -> . IDENTIFIER
    ,               reduce using rule 54 (_7_optional -> .)
    )               reduce using rule 54 (_7_optional -> .)
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 127
    _7_optional                    shift and go to state 128
    param                          shift and go to state 129

state 97

    (36) do -> DO hint _3_optional . _4_repeat END
    (39) _4_repeat -> . _4_items
    (40) _4_repeat -> .
    (41) _4_items -> . _4_items _4_item
    (42) _4_items -> . _4_item
    (43) _4_item -> . NEWLINE expr
    END             reduce using rule 40 (_4_repeat -> .)
    NEWLINE         shift and go to state 133

    _4_repeat                      shift and go to state 130
    _4_items                       shift and go to state 131
    _4_item                        shift and go to state 132

state 98

    (37) _3_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 37 (_3_optional -> expr .)
    END             reduce using rule 37 (_3_optional -> expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 99

    (60) type -> type_identifier . _9_optional
    (61) _9_optional -> . < type _10_repeat >
    (67) _9_optional -> .
    <               shift and go to state 134
    (               reduce using rule 67 (_9_optional -> .)
    -               reduce using rule 67 (_9_optional -> .)
    {               reduce using rule 67 (_9_optional -> .)
    [               reduce using rule 67 (_9_optional -> .)
    TYPE_IDENTIFIER reduce using rule 67 (_9_optional -> .)
    IDENTIFIER      reduce using rule 67 (_9_optional -> .)
    CASE            reduce using rule 67 (_9_optional -> .)
    IF              reduce using rule 67 (_9_optional -> .)
    DEF             reduce using rule 67 (_9_optional -> .)
    STRING          reduce using rule 67 (_9_optional -> .)
    NUMBER          reduce using rule 67 (_9_optional -> .)
    DO              reduce using rule 67 (_9_optional -> .)
    NEWLINE         reduce using rule 67 (_9_optional -> .)
    END             reduce using rule 67 (_9_optional -> .)
    ELIF            reduce using rule 67 (_9_optional -> .)
    ELSE            reduce using rule 67 (_9_optional -> .)
    ,               reduce using rule 67 (_9_optional -> .)
    )               reduce using rule 67 (_9_optional -> .)
    NOT_LESS        reduce using rule 67 (_9_optional -> .)
    >               reduce using rule 67 (_9_optional -> .)
    }               reduce using rule 67 (_9_optional -> .)

    _9_optional                    shift and go to state 109

state 100

    (83) enum -> ENUM type_identifier _14_optional { . _15_repeat }
    (86) _15_repeat -> . _15_items
    (87) _15_repeat -> .
    (88) _15_items -> . _15_items _15_item
    (89) _15_items -> . _15_item
    (90) _15_item -> . variant
    (91) variant -> . type_identifier _16_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 87 (_15_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 135
    _15_repeat                     shift and go to state 136
    _15_items                      shift and go to state 137
    _15_item                       shift and go to state 138
    variant                        shift and go to state 139

state 101

    (84) _14_optional -> < fields_unnamed . >
    >               shift and go to state 140


state 102

    (94) fields_unnamed -> identifier . _17_repeat
    (95) _17_repeat -> . _17_items
    (96) _17_repeat -> .
    (97) _17_items -> . _17_items _17_item
    (98) _17_items -> . _17_item
    (99) _17_item -> . , identifier
    >               reduce using rule 96 (_17_repeat -> .)
    )               reduce using rule 96 (_17_repeat -> .)
    ,               shift and go to state 144

    _17_repeat                     shift and go to state 141
    _17_items                      shift and go to state 142
    _17_item                       shift and go to state 143

state 103

    (148) tuple -> { _28_optional _29_repeat } .
    INT_DIV         reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    NOT_MORE        reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    NOT_LESS        reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    >               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    <               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    *               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    /               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    -               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    +               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    CONCAT          reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    NEWLINE         reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    $end            reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    ,               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    }               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    )               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    ]               reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    OF              reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    THEN            reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    END             reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    ELIF            reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)
    ELSE            reduce using rule 148 (tuple -> { _28_optional _29_repeat } .)


state 104

    (153) _29_items -> _29_items _29_item .
    ,               reduce using rule 153 (_29_items -> _29_items _29_item .)
    }               reduce using rule 153 (_29_items -> _29_items _29_item .)


state 105

    (155) _29_item -> , expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 155 (_29_item -> , expr .)
    }               reduce using rule 155 (_29_item -> , expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 106

    (70) struct -> STRUCT type_identifier _11_optional { . _13_repeat }
    (78) _13_repeat -> . _13_items
    (79) _13_repeat -> .
    (80) _13_items -> . _13_items _13_item
    (81) _13_items -> . _13_item
    (82) _13_item -> . identifier : type
    (166) identifier -> . IDENTIFIER
    }               reduce using rule 79 (_13_repeat -> .)
    IDENTIFIER      shift and go to state 26

    _13_repeat                     shift and go to state 145
    _13_items                      shift and go to state 146
    _13_item                       shift and go to state 147
    identifier                     shift and go to state 148

state 107

    (71) _11_optional -> < identifier . _12_repeat >
    (72) _12_repeat -> . _12_items
    (73) _12_repeat -> .
    (74) _12_items -> . _12_items _12_item
    (75) _12_items -> . _12_item
    (76) _12_item -> . , identifier
    >               reduce using rule 73 (_12_repeat -> .)
    ,               shift and go to state 152

    _12_repeat                     shift and go to state 149
    _12_items                      shift and go to state 150
    _12_item                       shift and go to state 151

state 108

    (167) variable_declaration -> identifier : type_identifier < . type _32_repeat NOT_LESS expr
    (61) _9_optional -> < . type _10_repeat >
    (60) type -> . type_identifier _9_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type_identifier                shift and go to state 99
    type                           shift and go to state 153

state 109

    (60) type -> type_identifier _9_optional .
    =               reduce using rule 60 (type -> type_identifier _9_optional .)
    (               reduce using rule 60 (type -> type_identifier _9_optional .)
    -               reduce using rule 60 (type -> type_identifier _9_optional .)
    {               reduce using rule 60 (type -> type_identifier _9_optional .)
    [               reduce using rule 60 (type -> type_identifier _9_optional .)
    TYPE_IDENTIFIER reduce using rule 60 (type -> type_identifier _9_optional .)
    IDENTIFIER      reduce using rule 60 (type -> type_identifier _9_optional .)
    CASE            reduce using rule 60 (type -> type_identifier _9_optional .)
    IF              reduce using rule 60 (type -> type_identifier _9_optional .)
    DEF             reduce using rule 60 (type -> type_identifier _9_optional .)
    STRING          reduce using rule 60 (type -> type_identifier _9_optional .)
    NUMBER          reduce using rule 60 (type -> type_identifier _9_optional .)
    DO              reduce using rule 60 (type -> type_identifier _9_optional .)
    NEWLINE         reduce using rule 60 (type -> type_identifier _9_optional .)
    END             reduce using rule 60 (type -> type_identifier _9_optional .)
    ELIF            reduce using rule 60 (type -> type_identifier _9_optional .)
    ELSE            reduce using rule 60 (type -> type_identifier _9_optional .)
    ,               reduce using rule 60 (type -> type_identifier _9_optional .)
    )               reduce using rule 60 (type -> type_identifier _9_optional .)
    NOT_LESS        reduce using rule 60 (type -> type_identifier _9_optional .)
    >               reduce using rule 60 (type -> type_identifier _9_optional .)
    }               reduce using rule 60 (type -> type_identifier _9_optional .)


state 110

    (173) variable_declaration -> identifier hint = expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    $end            reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    ,               reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    }               reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    )               reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    ]               reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    OF              reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    THEN            reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    END             reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    ELIF            reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    ELSE            reduce using rule 173 (variable_declaration -> identifier hint = expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 111

    (140) array -> [ _26_optional _27_repeat ] .
    INT_DIV         reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    NOT_MORE        reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    NOT_LESS        reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    >               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    <               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    *               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    /               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    -               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    +               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    CONCAT          reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    NEWLINE         reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    $end            reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    ,               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    }               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    )               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    ]               reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    OF              reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    THEN            reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    END             reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    ELIF            reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)
    ELSE            reduce using rule 140 (array -> [ _26_optional _27_repeat ] .)


state 112

    (145) _27_items -> _27_items _27_item .
    ,               reduce using rule 145 (_27_items -> _27_items _27_item .)
    ]               reduce using rule 145 (_27_items -> _27_items _27_item .)


state 113

    (147) _27_item -> , expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 147 (_27_item -> , expr .)
    ]               reduce using rule 147 (_27_item -> , expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 114

    (108) case_of -> CASE expr OF case . _20_repeat END
    (109) _20_repeat -> . _20_items
    (110) _20_repeat -> .
    (111) _20_items -> . _20_items _20_item
    (112) _20_items -> . _20_item
    (113) _20_item -> . case
    (114) case -> . pattern do
    (115) pattern -> . array_pattern
    (116) pattern -> . enum_pattern
    (117) pattern -> . param_pattern
    (119) array_pattern -> . [ _21_optional _22_optional ]
    (136) enum_pattern -> . type_identifier ( _25_optional )
    (118) param_pattern -> . identifier
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    END             reduce using rule 110 (_20_repeat -> .)
    [               shift and go to state 119
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    case                           shift and go to state 154
    _20_repeat                     shift and go to state 155
    _20_items                      shift and go to state 156
    _20_item                       shift and go to state 157
    pattern                        shift and go to state 115
    array_pattern                  shift and go to state 116
    enum_pattern                   shift and go to state 117
    param_pattern                  shift and go to state 118
    type_identifier                shift and go to state 120
    identifier                     shift and go to state 121

state 115

    (114) case -> pattern . do
    (36) do -> . DO hint _3_optional _4_repeat END
    DO              shift and go to state 33

    do                             shift and go to state 158

state 116

    (115) pattern -> array_pattern .
    DO              reduce using rule 115 (pattern -> array_pattern .)
    ,               reduce using rule 115 (pattern -> array_pattern .)
    SPREAD          reduce using rule 115 (pattern -> array_pattern .)
    ]               reduce using rule 115 (pattern -> array_pattern .)
    )               reduce using rule 115 (pattern -> array_pattern .)


state 117

    (116) pattern -> enum_pattern .
    DO              reduce using rule 116 (pattern -> enum_pattern .)
    ,               reduce using rule 116 (pattern -> enum_pattern .)
    SPREAD          reduce using rule 116 (pattern -> enum_pattern .)
    ]               reduce using rule 116 (pattern -> enum_pattern .)
    )               reduce using rule 116 (pattern -> enum_pattern .)


state 118

    (117) pattern -> param_pattern .
    DO              reduce using rule 117 (pattern -> param_pattern .)
    ,               reduce using rule 117 (pattern -> param_pattern .)
    SPREAD          reduce using rule 117 (pattern -> param_pattern .)
    ]               reduce using rule 117 (pattern -> param_pattern .)
    )               reduce using rule 117 (pattern -> param_pattern .)


state 119

    (119) array_pattern -> [ . _21_optional _22_optional ]
    (120) _21_optional -> . patterns
    (121) _21_optional -> .
    (130) patterns -> . pattern _24_repeat
    (115) pattern -> . array_pattern
    (116) pattern -> . enum_pattern
    (117) pattern -> . param_pattern
    (119) array_pattern -> . [ _21_optional _22_optional ]
    (136) enum_pattern -> . type_identifier ( _25_optional )
    (118) param_pattern -> . identifier
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    SPREAD          reduce using rule 121 (_21_optional -> .)
    ]               reduce using rule 121 (_21_optional -> .)
    [               shift and go to state 119
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    _21_optional                   shift and go to state 159
    patterns                       shift and go to state 160
    pattern                        shift and go to state 161
    array_pattern                  shift and go to state 116
    enum_pattern                   shift and go to state 117
    param_pattern                  shift and go to state 118
    type_identifier                shift and go to state 120
    identifier                     shift and go to state 121

state 120

    (136) enum_pattern -> type_identifier . ( _25_optional )
    (               shift and go to state 162


state 121

    (118) param_pattern -> identifier .
    DO              reduce using rule 118 (param_pattern -> identifier .)
    ,               reduce using rule 118 (param_pattern -> identifier .)
    SPREAD          reduce using rule 118 (param_pattern -> identifier .)
    ]               reduce using rule 118 (param_pattern -> identifier .)
    )               reduce using rule 118 (param_pattern -> identifier .)


state 122

    (156) call -> callee ( _30_optional _31_repeat . )
    )               shift and go to state 163


state 123

    (159) _31_repeat -> _31_items .
    (161) _31_items -> _31_items . _31_item
    (163) _31_item -> . , expr
    )               reduce using rule 159 (_31_repeat -> _31_items .)
    ,               shift and go to state 125

    _31_item                       shift and go to state 164

state 124

    (162) _31_items -> _31_item .
    ,               reduce using rule 162 (_31_items -> _31_item .)
    )               reduce using rule 162 (_31_items -> _31_item .)


state 125

    (163) _31_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 165
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 126

    (101) if_expr -> IF expr THEN hint . block_statement _18_optional END
    (44) block_statement -> . _5_optional _6_repeat
    (45) _5_optional -> . expr
    (46) _5_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    NEWLINE         reduce using rule 46 (_5_optional -> .)
    ELIF            reduce using rule 46 (_5_optional -> .)
    ELSE            reduce using rule 46 (_5_optional -> .)
    END             reduce using rule 46 (_5_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 166
    block_statement                shift and go to state 167
    _5_optional                    shift and go to state 168
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 127

    (100) param -> identifier . hint
    (68) hint -> .
    (69) hint -> . : type
    ,               reduce using rule 68 (hint -> .)
    )               reduce using rule 68 (hint -> .)
    :               shift and go to state 63

    hint                           shift and go to state 169

state 128

    (52) def_expr -> DEF identifier ( _7_optional . _8_repeat ) hint do
    (55) _8_repeat -> . _8_items
    (56) _8_repeat -> .
    (57) _8_items -> . _8_items _8_item
    (58) _8_items -> . _8_item
    (59) _8_item -> . , param
    )               reduce using rule 56 (_8_repeat -> .)
    ,               shift and go to state 173

    _8_repeat                      shift and go to state 170
    _8_items                       shift and go to state 171
    _8_item                        shift and go to state 172

state 129

    (53) _7_optional -> param .
    ,               reduce using rule 53 (_7_optional -> param .)
    )               reduce using rule 53 (_7_optional -> param .)


state 130

    (36) do -> DO hint _3_optional _4_repeat . END
    END             shift and go to state 174


state 131

    (39) _4_repeat -> _4_items .
    (41) _4_items -> _4_items . _4_item
    (43) _4_item -> . NEWLINE expr
    END             reduce using rule 39 (_4_repeat -> _4_items .)
    NEWLINE         shift and go to state 133

    _4_item                        shift and go to state 175

state 132

    (42) _4_items -> _4_item .
    NEWLINE         reduce using rule 42 (_4_items -> _4_item .)
    END             reduce using rule 42 (_4_items -> _4_item .)


state 133

    (43) _4_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 176
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 134

    (61) _9_optional -> < . type _10_repeat >
    (60) type -> . type_identifier _9_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 177
    type_identifier                shift and go to state 99

state 135

    (91) variant -> type_identifier . _16_optional
    (92) _16_optional -> . ( fields_unnamed )
    (93) _16_optional -> .
    (               shift and go to state 179
    TYPE_IDENTIFIER reduce using rule 93 (_16_optional -> .)
    }               reduce using rule 93 (_16_optional -> .)

    _16_optional                   shift and go to state 178

state 136

    (83) enum -> ENUM type_identifier _14_optional { _15_repeat . }
    }               shift and go to state 180


state 137

    (86) _15_repeat -> _15_items .
    (88) _15_items -> _15_items . _15_item
    (90) _15_item -> . variant
    (91) variant -> . type_identifier _16_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 86 (_15_repeat -> _15_items .)
    TYPE_IDENTIFIER shift and go to state 25

    _15_item                       shift and go to state 181
    variant                        shift and go to state 139
    type_identifier                shift and go to state 135

state 138

    (89) _15_items -> _15_item .
    TYPE_IDENTIFIER reduce using rule 89 (_15_items -> _15_item .)
    }               reduce using rule 89 (_15_items -> _15_item .)


state 139

    (90) _15_item -> variant .
    TYPE_IDENTIFIER reduce using rule 90 (_15_item -> variant .)
    }               reduce using rule 90 (_15_item -> variant .)


state 140

    (84) _14_optional -> < fields_unnamed > .
    {               reduce using rule 84 (_14_optional -> < fields_unnamed > .)


state 141

    (94) fields_unnamed -> identifier _17_repeat .
    >               reduce using rule 94 (fields_unnamed -> identifier _17_repeat .)
    )               reduce using rule 94 (fields_unnamed -> identifier _17_repeat .)


state 142

    (95) _17_repeat -> _17_items .
    (97) _17_items -> _17_items . _17_item
    (99) _17_item -> . , identifier
    >               reduce using rule 95 (_17_repeat -> _17_items .)
    )               reduce using rule 95 (_17_repeat -> _17_items .)
    ,               shift and go to state 144

    _17_item                       shift and go to state 182

state 143

    (98) _17_items -> _17_item .
    ,               reduce using rule 98 (_17_items -> _17_item .)
    >               reduce using rule 98 (_17_items -> _17_item .)
    )               reduce using rule 98 (_17_items -> _17_item .)


state 144

    (99) _17_item -> , . identifier
    (166) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 183

state 145

    (70) struct -> STRUCT type_identifier _11_optional { _13_repeat . }
    }               shift and go to state 184


state 146

    (78) _13_repeat -> _13_items .
    (80) _13_items -> _13_items . _13_item
    (82) _13_item -> . identifier : type
    (166) identifier -> . IDENTIFIER
    }               reduce using rule 78 (_13_repeat -> _13_items .)
    IDENTIFIER      shift and go to state 26

    _13_item                       shift and go to state 185
    identifier                     shift and go to state 148

state 147

    (81) _13_items -> _13_item .
    IDENTIFIER      reduce using rule 81 (_13_items -> _13_item .)
    }               reduce using rule 81 (_13_items -> _13_item .)


state 148

    (82) _13_item -> identifier . : type
    :               shift and go to state 186


state 149

    (71) _11_optional -> < identifier _12_repeat . >
    >               shift and go to state 187


state 150

    (72) _12_repeat -> _12_items .
    (74) _12_items -> _12_items . _12_item
    (76) _12_item -> . , identifier
    >               reduce using rule 72 (_12_repeat -> _12_items .)
    ,               shift and go to state 152

    _12_item                       shift and go to state 188

state 151

    (75) _12_items -> _12_item .
    ,               reduce using rule 75 (_12_items -> _12_item .)
    >               reduce using rule 75 (_12_items -> _12_item .)


state 152

    (76) _12_item -> , . identifier
    (166) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 189

state 153

    (167) variable_declaration -> identifier : type_identifier < type . _32_repeat NOT_LESS expr
    (61) _9_optional -> < type . _10_repeat >
    (168) _32_repeat -> . _32_items
    (169) _32_repeat -> .
    (62) _10_repeat -> . _10_items
    (63) _10_repeat -> .
    (170) _32_items -> . _32_items _32_item
    (171) _32_items -> . _32_item
    (64) _10_items -> . _10_items _10_item
    (65) _10_items -> . _10_item
    (172) _32_item -> . , type
    (66) _10_item -> . , type
    NOT_LESS        reduce using rule 169 (_32_repeat -> .)
    >               reduce using rule 63 (_10_repeat -> .)
    ,               shift and go to state 196

    _32_repeat                     shift and go to state 190
    _10_repeat                     shift and go to state 191
    _32_items                      shift and go to state 192
    _10_items                      shift and go to state 193
    _32_item                       shift and go to state 194
    _10_item                       shift and go to state 195

state 154

    (113) _20_item -> case .
    [               reduce using rule 113 (_20_item -> case .)
    TYPE_IDENTIFIER reduce using rule 113 (_20_item -> case .)
    IDENTIFIER      reduce using rule 113 (_20_item -> case .)
    END             reduce using rule 113 (_20_item -> case .)


state 155

    (108) case_of -> CASE expr OF case _20_repeat . END
    END             shift and go to state 197


state 156

    (109) _20_repeat -> _20_items .
    (111) _20_items -> _20_items . _20_item
    (113) _20_item -> . case
    (114) case -> . pattern do
    (115) pattern -> . array_pattern
    (116) pattern -> . enum_pattern
    (117) pattern -> . param_pattern
    (119) array_pattern -> . [ _21_optional _22_optional ]
    (136) enum_pattern -> . type_identifier ( _25_optional )
    (118) param_pattern -> . identifier
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    END             reduce using rule 109 (_20_repeat -> _20_items .)
    [               shift and go to state 119
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    _20_item                       shift and go to state 198
    case                           shift and go to state 154
    pattern                        shift and go to state 115
    array_pattern                  shift and go to state 116
    enum_pattern                   shift and go to state 117
    param_pattern                  shift and go to state 118
    type_identifier                shift and go to state 120
    identifier                     shift and go to state 121

state 157

    (112) _20_items -> _20_item .
    [               reduce using rule 112 (_20_items -> _20_item .)
    TYPE_IDENTIFIER reduce using rule 112 (_20_items -> _20_item .)
    IDENTIFIER      reduce using rule 112 (_20_items -> _20_item .)
    END             reduce using rule 112 (_20_items -> _20_item .)


state 158

    (114) case -> pattern do .
    [               reduce using rule 114 (case -> pattern do .)
    TYPE_IDENTIFIER reduce using rule 114 (case -> pattern do .)
    IDENTIFIER      reduce using rule 114 (case -> pattern do .)
    END             reduce using rule 114 (case -> pattern do .)


state 159

    (119) array_pattern -> [ _21_optional . _22_optional ]
    (122) _22_optional -> . spread
    (123) _22_optional -> .
    (124) spread -> . SPREAD identifier _23_repeat
    ]               reduce using rule 123 (_22_optional -> .)
    SPREAD          shift and go to state 201

    _22_optional                   shift and go to state 199
    spread                         shift and go to state 200

state 160

    (120) _21_optional -> patterns .
    SPREAD          reduce using rule 120 (_21_optional -> patterns .)
    ]               reduce using rule 120 (_21_optional -> patterns .)


state 161

    (130) patterns -> pattern . _24_repeat
    (131) _24_repeat -> . _24_items
    (132) _24_repeat -> .
    (133) _24_items -> . _24_items _24_item
    (134) _24_items -> . _24_item
    (135) _24_item -> . , pattern
    SPREAD          reduce using rule 132 (_24_repeat -> .)
    ]               reduce using rule 132 (_24_repeat -> .)
    )               reduce using rule 132 (_24_repeat -> .)
    ,               shift and go to state 205

    _24_repeat                     shift and go to state 202
    _24_items                      shift and go to state 203
    _24_item                       shift and go to state 204

state 162

    (136) enum_pattern -> type_identifier ( . _25_optional )
    (137) _25_optional -> . patterns
    (138) _25_optional -> .
    (130) patterns -> . pattern _24_repeat
    (115) pattern -> . array_pattern
    (116) pattern -> . enum_pattern
    (117) pattern -> . param_pattern
    (119) array_pattern -> . [ _21_optional _22_optional ]
    (136) enum_pattern -> . type_identifier ( _25_optional )
    (118) param_pattern -> . identifier
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    )               reduce using rule 138 (_25_optional -> .)
    [               shift and go to state 119
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    type_identifier                shift and go to state 120
    _25_optional                   shift and go to state 206
    patterns                       shift and go to state 207
    pattern                        shift and go to state 161
    array_pattern                  shift and go to state 116
    enum_pattern                   shift and go to state 117
    param_pattern                  shift and go to state 118
    identifier                     shift and go to state 121

state 163

    (156) call -> callee ( _30_optional _31_repeat ) .
    INT_DIV         reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    NOT_MORE        reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    NOT_LESS        reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    >               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    <               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    *               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    /               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    -               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    +               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    CONCAT          reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    NEWLINE         reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    $end            reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    ,               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    }               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    )               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    ]               reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    OF              reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    THEN            reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    END             reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    ELIF            reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)
    ELSE            reduce using rule 156 (call -> callee ( _30_optional _31_repeat ) .)


state 164

    (161) _31_items -> _31_items _31_item .
    ,               reduce using rule 161 (_31_items -> _31_items _31_item .)
    )               reduce using rule 161 (_31_items -> _31_items _31_item .)


state 165

    (163) _31_item -> , expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 163 (_31_item -> , expr .)
    )               reduce using rule 163 (_31_item -> , expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 166

    (45) _5_optional -> expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 45 (_5_optional -> expr .)
    ELIF            reduce using rule 45 (_5_optional -> expr .)
    ELSE            reduce using rule 45 (_5_optional -> expr .)
    END             reduce using rule 45 (_5_optional -> expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 167

    (101) if_expr -> IF expr THEN hint block_statement . _18_optional END
    (102) _18_optional -> . or_else
    (103) _18_optional -> .
    (104) or_else -> . ELIF expr THEN block_statement _19_optional
    (107) or_else -> . ELSE block_statement
    END             reduce using rule 103 (_18_optional -> .)
    ELIF            shift and go to state 210
    ELSE            shift and go to state 211

    _18_optional                   shift and go to state 208
    or_else                        shift and go to state 209

state 168

    (44) block_statement -> _5_optional . _6_repeat
    (47) _6_repeat -> . _6_items
    (48) _6_repeat -> .
    (49) _6_items -> . _6_items _6_item
    (50) _6_items -> . _6_item
    (51) _6_item -> . NEWLINE expr
    ELIF            reduce using rule 48 (_6_repeat -> .)
    ELSE            reduce using rule 48 (_6_repeat -> .)
    END             reduce using rule 48 (_6_repeat -> .)
    NEWLINE         shift and go to state 215

    _6_repeat                      shift and go to state 212
    _6_items                       shift and go to state 213
    _6_item                        shift and go to state 214

state 169

    (100) param -> identifier hint .
    ,               reduce using rule 100 (param -> identifier hint .)
    )               reduce using rule 100 (param -> identifier hint .)


state 170

    (52) def_expr -> DEF identifier ( _7_optional _8_repeat . ) hint do
    )               shift and go to state 216


state 171

    (55) _8_repeat -> _8_items .
    (57) _8_items -> _8_items . _8_item
    (59) _8_item -> . , param
    )               reduce using rule 55 (_8_repeat -> _8_items .)
    ,               shift and go to state 173

    _8_item                        shift and go to state 217

state 172

    (58) _8_items -> _8_item .
    ,               reduce using rule 58 (_8_items -> _8_item .)
    )               reduce using rule 58 (_8_items -> _8_item .)


state 173

    (59) _8_item -> , . param
    (100) param -> . identifier hint
    (166) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    param                          shift and go to state 218
    identifier                     shift and go to state 127

state 174

    (36) do -> DO hint _3_optional _4_repeat END .
    INT_DIV         reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    NOT_MORE        reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    NOT_LESS        reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    >               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    <               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    *               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    /               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    -               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    +               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    CONCAT          reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    NEWLINE         reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    $end            reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    ,               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    }               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    )               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    ]               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    OF              reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    THEN            reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    END             reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    ELIF            reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    ELSE            reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    [               reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    TYPE_IDENTIFIER reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)
    IDENTIFIER      reduce using rule 36 (do -> DO hint _3_optional _4_repeat END .)


state 175

    (41) _4_items -> _4_items _4_item .
    NEWLINE         reduce using rule 41 (_4_items -> _4_items _4_item .)
    END             reduce using rule 41 (_4_items -> _4_items _4_item .)


state 176

    (43) _4_item -> NEWLINE expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 43 (_4_item -> NEWLINE expr .)
    END             reduce using rule 43 (_4_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 177

    (61) _9_optional -> < type . _10_repeat >
    (62) _10_repeat -> . _10_items
    (63) _10_repeat -> .
    (64) _10_items -> . _10_items _10_item
    (65) _10_items -> . _10_item
    (66) _10_item -> . , type
    >               reduce using rule 63 (_10_repeat -> .)
    ,               shift and go to state 219

    _10_repeat                     shift and go to state 191
    _10_items                      shift and go to state 193
    _10_item                       shift and go to state 195

state 178

    (91) variant -> type_identifier _16_optional .
    TYPE_IDENTIFIER reduce using rule 91 (variant -> type_identifier _16_optional .)
    }               reduce using rule 91 (variant -> type_identifier _16_optional .)


state 179

    (92) _16_optional -> ( . fields_unnamed )
    (94) fields_unnamed -> . identifier _17_repeat
    (166) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    fields_unnamed                 shift and go to state 220
    identifier                     shift and go to state 102

state 180

    (83) enum -> ENUM type_identifier _14_optional { _15_repeat } .
    NEWLINE         reduce using rule 83 (enum -> ENUM type_identifier _14_optional { _15_repeat } .)
    $end            reduce using rule 83 (enum -> ENUM type_identifier _14_optional { _15_repeat } .)


state 181

    (88) _15_items -> _15_items _15_item .
    TYPE_IDENTIFIER reduce using rule 88 (_15_items -> _15_items _15_item .)
    }               reduce using rule 88 (_15_items -> _15_items _15_item .)


state 182

    (97) _17_items -> _17_items _17_item .
    ,               reduce using rule 97 (_17_items -> _17_items _17_item .)
    >               reduce using rule 97 (_17_items -> _17_items _17_item .)
    )               reduce using rule 97 (_17_items -> _17_items _17_item .)


state 183

    (99) _17_item -> , identifier .
    ,               reduce using rule 99 (_17_item -> , identifier .)
    >               reduce using rule 99 (_17_item -> , identifier .)
    )               reduce using rule 99 (_17_item -> , identifier .)


state 184

    (70) struct -> STRUCT type_identifier _11_optional { _13_repeat } .
    NEWLINE         reduce using rule 70 (struct -> STRUCT type_identifier _11_optional { _13_repeat } .)
    $end            reduce using rule 70 (struct -> STRUCT type_identifier _11_optional { _13_repeat } .)


state 185

    (80) _13_items -> _13_items _13_item .
    IDENTIFIER      reduce using rule 80 (_13_items -> _13_items _13_item .)
    }               reduce using rule 80 (_13_items -> _13_items _13_item .)


state 186

    (82) _13_item -> identifier : . type
    (60) type -> . type_identifier _9_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 221
    type_identifier                shift and go to state 99

state 187

    (71) _11_optional -> < identifier _12_repeat > .
    {               reduce using rule 71 (_11_optional -> < identifier _12_repeat > .)


state 188

    (74) _12_items -> _12_items _12_item .
    ,               reduce using rule 74 (_12_items -> _12_items _12_item .)
    >               reduce using rule 74 (_12_items -> _12_items _12_item .)


state 189

    (76) _12_item -> , identifier .
    ,               reduce using rule 76 (_12_item -> , identifier .)
    >               reduce using rule 76 (_12_item -> , identifier .)


state 190

    (167) variable_declaration -> identifier : type_identifier < type _32_repeat . NOT_LESS expr
    NOT_LESS        shift and go to state 222


state 191

    (61) _9_optional -> < type _10_repeat . >
    >               shift and go to state 223


state 192

    (168) _32_repeat -> _32_items .
    (170) _32_items -> _32_items . _32_item
    (172) _32_item -> . , type
    NOT_LESS        reduce using rule 168 (_32_repeat -> _32_items .)
    ,               shift and go to state 225

    _32_item                       shift and go to state 224

state 193

    (62) _10_repeat -> _10_items .
    (64) _10_items -> _10_items . _10_item
    (66) _10_item -> . , type
    >               reduce using rule 62 (_10_repeat -> _10_items .)
    ,               shift and go to state 219

    _10_item                       shift and go to state 226

state 194

    (171) _32_items -> _32_item .
    ,               reduce using rule 171 (_32_items -> _32_item .)
    NOT_LESS        reduce using rule 171 (_32_items -> _32_item .)


state 195

    (65) _10_items -> _10_item .
    ,               reduce using rule 65 (_10_items -> _10_item .)
    >               reduce using rule 65 (_10_items -> _10_item .)


state 196

    (172) _32_item -> , . type
    (66) _10_item -> , . type
    (60) type -> . type_identifier _9_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 227
    type_identifier                shift and go to state 99

state 197

    (108) case_of -> CASE expr OF case _20_repeat END .
    INT_DIV         reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    NOT_MORE        reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    NOT_LESS        reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    >               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    <               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    *               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    /               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    -               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    +               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    CONCAT          reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    NEWLINE         reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    $end            reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    ,               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    }               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    )               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    ]               reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    OF              reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    THEN            reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    END             reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    ELIF            reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)
    ELSE            reduce using rule 108 (case_of -> CASE expr OF case _20_repeat END .)


state 198

    (111) _20_items -> _20_items _20_item .
    [               reduce using rule 111 (_20_items -> _20_items _20_item .)
    TYPE_IDENTIFIER reduce using rule 111 (_20_items -> _20_items _20_item .)
    IDENTIFIER      reduce using rule 111 (_20_items -> _20_items _20_item .)
    END             reduce using rule 111 (_20_items -> _20_items _20_item .)


state 199

    (119) array_pattern -> [ _21_optional _22_optional . ]
    ]               shift and go to state 228


state 200

    (122) _22_optional -> spread .
    ]               reduce using rule 122 (_22_optional -> spread .)


state 201

    (124) spread -> SPREAD . identifier _23_repeat
    (166) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 229

state 202

    (130) patterns -> pattern _24_repeat .
    SPREAD          reduce using rule 130 (patterns -> pattern _24_repeat .)
    ]               reduce using rule 130 (patterns -> pattern _24_repeat .)
    )               reduce using rule 130 (patterns -> pattern _24_repeat .)


state 203

    (131) _24_repeat -> _24_items .
    (133) _24_items -> _24_items . _24_item
    (135) _24_item -> . , pattern
    SPREAD          reduce using rule 131 (_24_repeat -> _24_items .)
    ]               reduce using rule 131 (_24_repeat -> _24_items .)
    )               reduce using rule 131 (_24_repeat -> _24_items .)
    ,               shift and go to state 205

    _24_item                       shift and go to state 230

state 204

    (134) _24_items -> _24_item .
    ,               reduce using rule 134 (_24_items -> _24_item .)
    SPREAD          reduce using rule 134 (_24_items -> _24_item .)
    ]               reduce using rule 134 (_24_items -> _24_item .)
    )               reduce using rule 134 (_24_items -> _24_item .)


state 205

    (135) _24_item -> , . pattern
    (115) pattern -> . array_pattern
    (116) pattern -> . enum_pattern
    (117) pattern -> . param_pattern
    (119) array_pattern -> . [ _21_optional _22_optional ]
    (136) enum_pattern -> . type_identifier ( _25_optional )
    (118) param_pattern -> . identifier
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    [               shift and go to state 119
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    pattern                        shift and go to state 231
    array_pattern                  shift and go to state 116
    enum_pattern                   shift and go to state 117
    param_pattern                  shift and go to state 118
    type_identifier                shift and go to state 120
    identifier                     shift and go to state 121

state 206

    (136) enum_pattern -> type_identifier ( _25_optional . )
    )               shift and go to state 232


state 207

    (137) _25_optional -> patterns .
    )               reduce using rule 137 (_25_optional -> patterns .)


state 208

    (101) if_expr -> IF expr THEN hint block_statement _18_optional . END
    END             shift and go to state 233


state 209

    (102) _18_optional -> or_else .
    END             reduce using rule 102 (_18_optional -> or_else .)


state 210

    (104) or_else -> ELIF . expr THEN block_statement _19_optional
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 234
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 211

    (107) or_else -> ELSE . block_statement
    (44) block_statement -> . _5_optional _6_repeat
    (45) _5_optional -> . expr
    (46) _5_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    NEWLINE         reduce using rule 46 (_5_optional -> .)
    END             reduce using rule 46 (_5_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    block_statement                shift and go to state 235
    _5_optional                    shift and go to state 168
    expr                           shift and go to state 166
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 212

    (44) block_statement -> _5_optional _6_repeat .
    ELIF            reduce using rule 44 (block_statement -> _5_optional _6_repeat .)
    ELSE            reduce using rule 44 (block_statement -> _5_optional _6_repeat .)
    END             reduce using rule 44 (block_statement -> _5_optional _6_repeat .)


state 213

    (47) _6_repeat -> _6_items .
    (49) _6_items -> _6_items . _6_item
    (51) _6_item -> . NEWLINE expr
    ELIF            reduce using rule 47 (_6_repeat -> _6_items .)
    ELSE            reduce using rule 47 (_6_repeat -> _6_items .)
    END             reduce using rule 47 (_6_repeat -> _6_items .)
    NEWLINE         shift and go to state 215

    _6_item                        shift and go to state 236

state 214

    (50) _6_items -> _6_item .
    NEWLINE         reduce using rule 50 (_6_items -> _6_item .)
    ELIF            reduce using rule 50 (_6_items -> _6_item .)
    ELSE            reduce using rule 50 (_6_items -> _6_item .)
    END             reduce using rule 50 (_6_items -> _6_item .)


state 215

    (51) _6_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 237
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 216

    (52) def_expr -> DEF identifier ( _7_optional _8_repeat ) . hint do
    (68) hint -> .
    (69) hint -> . : type
    DO              reduce using rule 68 (hint -> .)
    :               shift and go to state 63

    hint                           shift and go to state 238

state 217

    (57) _8_items -> _8_items _8_item .
    ,               reduce using rule 57 (_8_items -> _8_items _8_item .)
    )               reduce using rule 57 (_8_items -> _8_items _8_item .)


state 218

    (59) _8_item -> , param .
    ,               reduce using rule 59 (_8_item -> , param .)
    )               reduce using rule 59 (_8_item -> , param .)


state 219

    (66) _10_item -> , . type
    (60) type -> . type_identifier _9_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 239
    type_identifier                shift and go to state 99

state 220

    (92) _16_optional -> ( fields_unnamed . )
    )               shift and go to state 240


state 221

    (82) _13_item -> identifier : type .
    IDENTIFIER      reduce using rule 82 (_13_item -> identifier : type .)
    }               reduce using rule 82 (_13_item -> identifier : type .)


state 222

    (167) variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    identifier                     shift and go to state 16
    type_identifier                shift and go to state 8
    expr                           shift and go to state 241
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 223

    (61) _9_optional -> < type _10_repeat > .
    =               reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    (               reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    -               reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    {               reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    [               reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    TYPE_IDENTIFIER reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    IDENTIFIER      reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    CASE            reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    IF              reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    DEF             reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    STRING          reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    NUMBER          reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    DO              reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    NEWLINE         reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    END             reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    ELIF            reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    ELSE            reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    ,               reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    )               reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    NOT_LESS        reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    >               reduce using rule 61 (_9_optional -> < type _10_repeat > .)
    }               reduce using rule 61 (_9_optional -> < type _10_repeat > .)


state 224

    (170) _32_items -> _32_items _32_item .
    ,               reduce using rule 170 (_32_items -> _32_items _32_item .)
    NOT_LESS        reduce using rule 170 (_32_items -> _32_items _32_item .)


state 225

    (172) _32_item -> , . type
    (60) type -> . type_identifier _9_optional
    (139) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 25

    type                           shift and go to state 242
    type_identifier                shift and go to state 99

state 226

    (64) _10_items -> _10_items _10_item .
    ,               reduce using rule 64 (_10_items -> _10_items _10_item .)
    >               reduce using rule 64 (_10_items -> _10_items _10_item .)


state 227

    (172) _32_item -> , type .
    (66) _10_item -> , type .
  ! reduce/reduce conflict for , resolved using rule 172 (_32_item -> , type .)
    ,               reduce using rule 172 (_32_item -> , type .)
    NOT_LESS        reduce using rule 172 (_32_item -> , type .)
    >               reduce using rule 66 (_10_item -> , type .)


state 228

    (119) array_pattern -> [ _21_optional _22_optional ] .
    DO              reduce using rule 119 (array_pattern -> [ _21_optional _22_optional ] .)
    ,               reduce using rule 119 (array_pattern -> [ _21_optional _22_optional ] .)
    SPREAD          reduce using rule 119 (array_pattern -> [ _21_optional _22_optional ] .)
    ]               reduce using rule 119 (array_pattern -> [ _21_optional _22_optional ] .)
    )               reduce using rule 119 (array_pattern -> [ _21_optional _22_optional ] .)


state 229

    (124) spread -> SPREAD identifier . _23_repeat
    (125) _23_repeat -> . _23_items
    (126) _23_repeat -> .
    (127) _23_items -> . _23_items _23_item
    (128) _23_items -> . _23_item
    (129) _23_item -> . , pattern
    ]               reduce using rule 126 (_23_repeat -> .)
    ,               shift and go to state 246

    _23_repeat                     shift and go to state 243
    _23_items                      shift and go to state 244
    _23_item                       shift and go to state 245

state 230

    (133) _24_items -> _24_items _24_item .
    ,               reduce using rule 133 (_24_items -> _24_items _24_item .)
    SPREAD          reduce using rule 133 (_24_items -> _24_items _24_item .)
    ]               reduce using rule 133 (_24_items -> _24_items _24_item .)
    )               reduce using rule 133 (_24_items -> _24_items _24_item .)


state 231

    (135) _24_item -> , pattern .
    ,               reduce using rule 135 (_24_item -> , pattern .)
    SPREAD          reduce using rule 135 (_24_item -> , pattern .)
    ]               reduce using rule 135 (_24_item -> , pattern .)
    )               reduce using rule 135 (_24_item -> , pattern .)


state 232

    (136) enum_pattern -> type_identifier ( _25_optional ) .
    DO              reduce using rule 136 (enum_pattern -> type_identifier ( _25_optional ) .)
    ,               reduce using rule 136 (enum_pattern -> type_identifier ( _25_optional ) .)
    SPREAD          reduce using rule 136 (enum_pattern -> type_identifier ( _25_optional ) .)
    ]               reduce using rule 136 (enum_pattern -> type_identifier ( _25_optional ) .)
    )               reduce using rule 136 (enum_pattern -> type_identifier ( _25_optional ) .)


state 233

    (101) if_expr -> IF expr THEN hint block_statement _18_optional END .
    INT_DIV         reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    NOT_MORE        reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    NOT_LESS        reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    >               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    <               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    *               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    /               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    -               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    +               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    CONCAT          reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    NEWLINE         reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    $end            reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    ,               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    }               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    )               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    ]               reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    OF              reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    THEN            reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    END             reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    ELIF            reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)
    ELSE            reduce using rule 101 (if_expr -> IF expr THEN hint block_statement _18_optional END .)


state 234

    (104) or_else -> ELIF expr . THEN block_statement _19_optional
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 247
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 235

    (107) or_else -> ELSE block_statement .
    END             reduce using rule 107 (or_else -> ELSE block_statement .)


state 236

    (49) _6_items -> _6_items _6_item .
    NEWLINE         reduce using rule 49 (_6_items -> _6_items _6_item .)
    ELIF            reduce using rule 49 (_6_items -> _6_items _6_item .)
    ELSE            reduce using rule 49 (_6_items -> _6_items _6_item .)
    END             reduce using rule 49 (_6_items -> _6_items _6_item .)


state 237

    (51) _6_item -> NEWLINE expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 51 (_6_item -> NEWLINE expr .)
    ELIF            reduce using rule 51 (_6_item -> NEWLINE expr .)
    ELSE            reduce using rule 51 (_6_item -> NEWLINE expr .)
    END             reduce using rule 51 (_6_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 38
    NOT_MORE        shift and go to state 39
    NOT_LESS        shift and go to state 40
    >               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 238

    (52) def_expr -> DEF identifier ( _7_optional _8_repeat ) hint . do
    (36) do -> . DO hint _3_optional _4_repeat END
    DO              shift and go to state 33

    do                             shift and go to state 248

state 239

    (66) _10_item -> , type .
    ,               reduce using rule 66 (_10_item -> , type .)
    >               reduce using rule 66 (_10_item -> , type .)


state 240

    (92) _16_optional -> ( fields_unnamed ) .
    TYPE_IDENTIFIER reduce using rule 92 (_16_optional -> ( fields_unnamed ) .)
    }               reduce using rule 92 (_16_optional -> ( fields_unnamed ) .)


state 241

    (167) variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . NOT_MORE expr
    (28) binary_expr -> expr . NOT_LESS expr
    (29) binary_expr -> expr . > expr
    (30) binary_expr -> expr . < expr
    (31) binary_expr -> expr . * expr
    (32) binary_expr -> expr . / expr
    (33) binary_expr -> expr . - expr
    (34) binary_expr -> expr . + expr
    (35) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    NOT_LESS        reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    >               reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    <               reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    NEWLINE         reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    $end            reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    ,               reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    }               reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    )               reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    ]               reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    OF              reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    THEN            reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    END             reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    ELIF            reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    ELSE            reduce using rule 167 (variable_declaration -> identifier : type_identifier < type _32_repeat NOT_LESS expr .)
    INT_DIV         shift and go to state 38
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 242

    (172) _32_item -> , type .
    ,               reduce using rule 172 (_32_item -> , type .)
    NOT_LESS        reduce using rule 172 (_32_item -> , type .)


state 243

    (124) spread -> SPREAD identifier _23_repeat .
    ]               reduce using rule 124 (spread -> SPREAD identifier _23_repeat .)


state 244

    (125) _23_repeat -> _23_items .
    (127) _23_items -> _23_items . _23_item
    (129) _23_item -> . , pattern
    ]               reduce using rule 125 (_23_repeat -> _23_items .)
    ,               shift and go to state 246

    _23_item                       shift and go to state 249

state 245

    (128) _23_items -> _23_item .
    ,               reduce using rule 128 (_23_items -> _23_item .)
    ]               reduce using rule 128 (_23_items -> _23_item .)


state 246

    (129) _23_item -> , . pattern
    (115) pattern -> . array_pattern
    (116) pattern -> . enum_pattern
    (117) pattern -> . param_pattern
    (119) array_pattern -> . [ _21_optional _22_optional ]
    (136) enum_pattern -> . type_identifier ( _25_optional )
    (118) param_pattern -> . identifier
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    [               shift and go to state 119
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26

    pattern                        shift and go to state 250
    array_pattern                  shift and go to state 116
    enum_pattern                   shift and go to state 117
    param_pattern                  shift and go to state 118
    type_identifier                shift and go to state 120
    identifier                     shift and go to state 121

state 247

    (104) or_else -> ELIF expr THEN . block_statement _19_optional
    (44) block_statement -> . _5_optional _6_repeat
    (45) _5_optional -> . expr
    (46) _5_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . type_identifier
    (18) expr -> . identifier
    (19) expr -> . variable_declaration
    (20) expr -> . case_of
    (21) expr -> . call
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . literal
    (25) expr -> . do
    (148) tuple -> . { _28_optional _29_repeat }
    (140) array -> . [ _26_optional _27_repeat ]
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr NOT_MORE expr
    (28) binary_expr -> . expr NOT_LESS expr
    (29) binary_expr -> . expr > expr
    (30) binary_expr -> . expr < expr
    (31) binary_expr -> . expr * expr
    (32) binary_expr -> . expr / expr
    (33) binary_expr -> . expr - expr
    (34) binary_expr -> . expr + expr
    (35) binary_expr -> . expr CONCAT expr
    (139) type_identifier -> . TYPE_IDENTIFIER
    (166) identifier -> . IDENTIFIER
    (167) variable_declaration -> . identifier : type_identifier < type _32_repeat NOT_LESS expr
    (173) variable_declaration -> . identifier hint = expr
    (108) case_of -> . CASE expr OF case _20_repeat END
    (156) call -> . callee ( _30_optional _31_repeat )
    (101) if_expr -> . IF expr THEN hint block_statement _18_optional END
    (52) def_expr -> . DEF identifier ( _7_optional _8_repeat ) hint do
    (174) literal -> . STRING
    (175) literal -> . NUMBER
    (36) do -> . DO hint _3_optional _4_repeat END
    (164) callee -> . type_identifier
    (165) callee -> . identifier
    NEWLINE         reduce using rule 46 (_5_optional -> .)
    ELIF            reduce using rule 46 (_5_optional -> .)
    ELSE            reduce using rule 46 (_5_optional -> .)
    END             reduce using rule 46 (_5_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 24
    TYPE_IDENTIFIER shift and go to state 25
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 29
    DEF             shift and go to state 30
    STRING          shift and go to state 31
    NUMBER          shift and go to state 32
    DO              shift and go to state 33

    expr                           shift and go to state 166
    block_statement                shift and go to state 251
    _5_optional                    shift and go to state 168
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    type_identifier                shift and go to state 8
    identifier                     shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 23
    callee                         shift and go to state 28

state 248

    (52) def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .
    INT_DIV         reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    NOT_MORE        reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    NOT_LESS        reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    >               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    <               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    *               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    /               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    -               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    +               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    CONCAT          reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    NEWLINE         reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    $end            reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    ,               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    }               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    )               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    ]               reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    OF              reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    THEN            reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    END             reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    ELIF            reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)
    ELSE            reduce using rule 52 (def_expr -> DEF identifier ( _7_optional _8_repeat ) hint do .)


state 249

    (127) _23_items -> _23_items _23_item .
    ,               reduce using rule 127 (_23_items -> _23_items _23_item .)
    ]               reduce using rule 127 (_23_items -> _23_items _23_item .)


state 250

    (129) _23_item -> , pattern .
    ,               reduce using rule 129 (_23_item -> , pattern .)
    ]               reduce using rule 129 (_23_item -> , pattern .)


state 251

    (104) or_else -> ELIF expr THEN block_statement . _19_optional
    (105) _19_optional -> . or_else
    (106) _19_optional -> .
    (104) or_else -> . ELIF expr THEN block_statement _19_optional
    (107) or_else -> . ELSE block_statement
    END             reduce using rule 106 (_19_optional -> .)
    ELIF            shift and go to state 210
    ELSE            shift and go to state 211

    _19_optional                   shift and go to state 252
    or_else                        shift and go to state 253

state 252

    (104) or_else -> ELIF expr THEN block_statement _19_optional .
    END             reduce using rule 104 (or_else -> ELIF expr THEN block_statement _19_optional .)


state 253

    (105) _19_optional -> or_else .
    END             reduce using rule 105 (_19_optional -> or_else .)


Conflicts:

reduce/reduce conflict in state 227 resolved using rule _32_item -> , type
rejected rule (_10_item -> , type) in state 227