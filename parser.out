Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_NEWLINE_optional _2_do_exprs_optional
Rule 2     _1_NEWLINE_optional -> NEWLINE
Rule 3     _1_NEWLINE_optional -> <empty>
Rule 4     _2_do_exprs_optional -> do_exprs
Rule 5     _2_do_exprs_optional -> <empty>
Rule 6     do_exprs -> expr _3_NEWLINE_optional
Rule 7     _3_NEWLINE_optional -> NEWLINE
Rule 8     _3_NEWLINE_optional -> <empty>
Rule 9     do_exprs -> expr NEWLINE do_exprs
Rule 10    expr -> - expr  [precedence=right, level=6]
Rule 11    expr -> ( expr )  [precedence=left, level=7]
Rule 12    expr -> str_literal
Rule 13    expr -> num_literal
Rule 14    expr -> array
Rule 15    expr -> variant_call
Rule 16    expr -> identifier
Rule 17    expr -> let
Rule 18    expr -> call
Rule 19    expr -> case_of
Rule 20    expr -> binary_expr
Rule 21    expr -> if_expr
Rule 22    expr -> def_expr
Rule 23    expr -> do
Rule 24    expr -> external
Rule 25    expr -> enum
Rule 26    external -> EXTERNAL
Rule 27    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 28    binary_expr -> expr EQUAL expr  [precedence=left, level=2]
Rule 29    binary_expr -> expr NOT_EQUAL expr  [precedence=left, level=2]
Rule 30    binary_expr -> expr | expr  [precedence=left, level=4]
Rule 31    binary_expr -> expr > expr  [precedence=left, level=3]
Rule 32    binary_expr -> expr % expr  [precedence=left, level=5]
Rule 33    binary_expr -> expr < expr  [precedence=left, level=3]
Rule 34    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 35    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 36    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 37    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 38    binary_expr -> expr CONCAT expr  [precedence=left, level=4]
Rule 39    do -> DO _4_0x3a_type_optional block_statement END
Rule 40    _4_0x3a_type_optional -> : type
Rule 41    _4_0x3a_type_optional -> <empty>
Rule 42    block_statement -> _5_NEWLINE_optional _6_do_exprs_optional
Rule 43    _5_NEWLINE_optional -> NEWLINE
Rule 44    _5_NEWLINE_optional -> <empty>
Rule 45    _6_do_exprs_optional -> do_exprs
Rule 46    _6_do_exprs_optional -> <empty>
Rule 47    def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do  [precedence=left, level=7]
Rule 48    _7_NEWLINE_optional -> NEWLINE
Rule 49    _7_NEWLINE_optional -> <empty>
Rule 50    _8_params_optional -> params
Rule 51    _8_params_optional -> <empty>
Rule 52    _9_0x3a_type_optional -> : type
Rule 53    _9_0x3a_type_optional -> <empty>
Rule 54    def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do  [precedence=left, level=7]
Rule 55    _10_0x2c_type_identifier_repeat -> _10_0x2c_type_identifier_items
Rule 56    _10_0x2c_type_identifier_repeat -> <empty>
Rule 57    _10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_items _10_0x2c_type_identifier_item
Rule 58    _10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_item
Rule 59    _10_0x2c_type_identifier_item -> , type_identifier
Rule 60    _11_NEWLINE_optional -> NEWLINE
Rule 61    _11_NEWLINE_optional -> <empty>
Rule 62    _12_params_optional -> params
Rule 63    _12_params_optional -> <empty>
Rule 64    _13_0x3a_type_optional -> : type
Rule 65    _13_0x3a_type_optional -> <empty>
Rule 66    params -> param _14_NEWLINE_optional
Rule 67    _14_NEWLINE_optional -> NEWLINE
Rule 68    _14_NEWLINE_optional -> <empty>
Rule 69    params -> params , _15_NEWLINE_optional param _16_NEWLINE_optional
Rule 70    _15_NEWLINE_optional -> NEWLINE
Rule 71    _15_NEWLINE_optional -> <empty>
Rule 72    _16_NEWLINE_optional -> NEWLINE
Rule 73    _16_NEWLINE_optional -> <empty>
Rule 74    type -> type_identifier < type _17_0x2c_type_repeat >  [precedence=left, level=3]
Rule 75    _17_0x2c_type_repeat -> _17_0x2c_type_items
Rule 76    _17_0x2c_type_repeat -> <empty>
Rule 77    _17_0x2c_type_items -> _17_0x2c_type_items _17_0x2c_type_item
Rule 78    _17_0x2c_type_items -> _17_0x2c_type_item
Rule 79    _17_0x2c_type_item -> , type
Rule 80    type -> type_identifier
Rule 81    enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
Rule 82    _18_NEWLINE_optional -> NEWLINE
Rule 83    _18_NEWLINE_optional -> <empty>
Rule 84    _19_variants_optional -> variants
Rule 85    _19_variants_optional -> <empty>
Rule 86    enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
Rule 87    _20_0x2c_type_identifier_repeat -> _20_0x2c_type_identifier_items
Rule 88    _20_0x2c_type_identifier_repeat -> <empty>
Rule 89    _20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_items _20_0x2c_type_identifier_item
Rule 90    _20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_item
Rule 91    _20_0x2c_type_identifier_item -> , type_identifier
Rule 92    _21_NEWLINE_optional -> NEWLINE
Rule 93    _21_NEWLINE_optional -> <empty>
Rule 94    _22_variants_optional -> variants
Rule 95    _22_variants_optional -> <empty>
Rule 96    variants -> variant _23_NEWLINE_optional
Rule 97    _23_NEWLINE_optional -> NEWLINE
Rule 98    _23_NEWLINE_optional -> <empty>
Rule 99    variants -> variants variant _24_NEWLINE_optional
Rule 100   _24_NEWLINE_optional -> NEWLINE
Rule 101   _24_NEWLINE_optional -> <empty>
Rule 102   variant -> type_identifier
Rule 103   variant -> type_identifier ( type _25_0x2c_type_repeat )  [precedence=left, level=7]
Rule 104   _25_0x2c_type_repeat -> _25_0x2c_type_items
Rule 105   _25_0x2c_type_repeat -> <empty>
Rule 106   _25_0x2c_type_items -> _25_0x2c_type_items _25_0x2c_type_item
Rule 107   _25_0x2c_type_items -> _25_0x2c_type_item
Rule 108   _25_0x2c_type_item -> , type
Rule 109   param -> identifier _26_0x3a_type_optional
Rule 110   _26_0x3a_type_optional -> : type
Rule 111   _26_0x3a_type_optional -> <empty>
Rule 112   if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
Rule 113   _27_0x3a_type_optional -> : type
Rule 114   _27_0x3a_type_optional -> <empty>
Rule 115   _28_or_else_optional -> or_else
Rule 116   _28_or_else_optional -> <empty>
Rule 117   or_else -> ELIF expr THEN block_statement _29_or_else_optional
Rule 118   _29_or_else_optional -> or_else
Rule 119   _29_or_else_optional -> <empty>
Rule 120   or_else -> ELSE block_statement
Rule 121   case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END
Rule 122   _30_NEWLINE_optional -> NEWLINE
Rule 123   _30_NEWLINE_optional -> <empty>
Rule 124   _31_cases_optional -> cases
Rule 125   _31_cases_optional -> <empty>
Rule 126   cases -> pattern do _32_NEWLINE_optional
Rule 127   _32_NEWLINE_optional -> NEWLINE
Rule 128   _32_NEWLINE_optional -> <empty>
Rule 129   cases -> cases pattern do _33_NEWLINE_optional
Rule 130   _33_NEWLINE_optional -> NEWLINE
Rule 131   _33_NEWLINE_optional -> <empty>
Rule 132   pattern -> match_variant
Rule 133   pattern -> match_as
Rule 134   match_as -> identifier
Rule 135   match_variant -> type_identifier
Rule 136   match_variant -> type_identifier ( _34_NEWLINE_optional _35_patterns_optional )  [precedence=left, level=7]
Rule 137   _34_NEWLINE_optional -> NEWLINE
Rule 138   _34_NEWLINE_optional -> <empty>
Rule 139   _35_patterns_optional -> patterns
Rule 140   _35_patterns_optional -> <empty>
Rule 141   patterns -> pattern _36_NEWLINE_optional
Rule 142   _36_NEWLINE_optional -> NEWLINE
Rule 143   _36_NEWLINE_optional -> <empty>
Rule 144   patterns -> patterns , _37_NEWLINE_optional pattern _38_NEWLINE_optional
Rule 145   _37_NEWLINE_optional -> NEWLINE
Rule 146   _37_NEWLINE_optional -> <empty>
Rule 147   _38_NEWLINE_optional -> NEWLINE
Rule 148   _38_NEWLINE_optional -> <empty>
Rule 149   array -> [ _39_NEWLINE_optional _40_exprs_optional ]
Rule 150   _39_NEWLINE_optional -> NEWLINE
Rule 151   _39_NEWLINE_optional -> <empty>
Rule 152   _40_exprs_optional -> exprs
Rule 153   _40_exprs_optional -> <empty>
Rule 154   call -> expr ( _41_NEWLINE_optional _42_exprs_optional )  [precedence=left, level=7]
Rule 155   _41_NEWLINE_optional -> NEWLINE
Rule 156   _41_NEWLINE_optional -> <empty>
Rule 157   _42_exprs_optional -> exprs
Rule 158   _42_exprs_optional -> <empty>
Rule 159   variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional )  [precedence=left, level=7]
Rule 160   _43_NEWLINE_optional -> NEWLINE
Rule 161   _43_NEWLINE_optional -> <empty>
Rule 162   _44_exprs_optional -> exprs
Rule 163   _44_exprs_optional -> <empty>
Rule 164   exprs -> expr _45_NEWLINE_optional
Rule 165   _45_NEWLINE_optional -> NEWLINE
Rule 166   _45_NEWLINE_optional -> <empty>
Rule 167   exprs -> exprs , _46_NEWLINE_optional expr _47_NEWLINE_optional
Rule 168   _46_NEWLINE_optional -> NEWLINE
Rule 169   _46_NEWLINE_optional -> <empty>
Rule 170   _47_NEWLINE_optional -> NEWLINE
Rule 171   _47_NEWLINE_optional -> <empty>
Rule 172   identifier -> IDENTIFIER
Rule 173   type_identifier -> TYPE_IDENTIFIER
Rule 174   let -> identifier _48_0x3a_type_optional = expr  [precedence=left, level=1]
Rule 175   _48_0x3a_type_optional -> : type
Rule 176   _48_0x3a_type_optional -> <empty>
Rule 177   num_literal -> NUMBER
Rule 178   str_literal -> STRING

Terminals, with rules where they appear:

%                    : 32
(                    : 11 47 54 103 136 154 159
)                    : 11 47 54 103 136 154 159
*                    : 34
+                    : 37
,                    : 59 69 79 91 108 144 167
-                    : 10 36
/                    : 35
:                    : 40 52 64 110 113 175
<                    : 33 54 74 86
=                    : 174
>                    : 31 54 74 86
CASE                 : 121
CONCAT               : 38
DEF                  : 47 54
DO                   : 39
ELIF                 : 117
ELSE                 : 120
END                  : 39 112 121
ENUM                 : 81 86
EQUAL                : 28
EXTERNAL             : 26
IDENTIFIER           : 172
IF                   : 112
INT_DIV              : 27
NEWLINE              : 2 7 9 43 48 60 67 70 72 82 92 97 100 122 127 130 137 142 145 147 150 155 160 165 168 170
NOT_EQUAL            : 29
NUMBER               : 177
OF                   : 121
STRING               : 178
THEN                 : 112 117
TYPE_IDENTIFIER      : 173
[                    : 149
]                    : 149
error                : 
{                    : 81 86
|                    : 30
}                    : 81 86

Nonterminals, with rules where they appear:

_10_0x2c_type_identifier_item : 57 58
_10_0x2c_type_identifier_items : 55 57
_10_0x2c_type_identifier_repeat : 54
_11_NEWLINE_optional : 54
_12_params_optional  : 54
_13_0x3a_type_optional : 54
_14_NEWLINE_optional : 66
_15_NEWLINE_optional : 69
_16_NEWLINE_optional : 69
_17_0x2c_type_item   : 77 78
_17_0x2c_type_items  : 75 77
_17_0x2c_type_repeat : 74
_18_NEWLINE_optional : 81
_19_variants_optional : 81
_1_NEWLINE_optional  : 1
_20_0x2c_type_identifier_item : 89 90
_20_0x2c_type_identifier_items : 87 89
_20_0x2c_type_identifier_repeat : 86
_21_NEWLINE_optional : 86
_22_variants_optional : 86
_23_NEWLINE_optional : 96
_24_NEWLINE_optional : 99
_25_0x2c_type_item   : 106 107
_25_0x2c_type_items  : 104 106
_25_0x2c_type_repeat : 103
_26_0x3a_type_optional : 109
_27_0x3a_type_optional : 112
_28_or_else_optional : 112
_29_or_else_optional : 117
_2_do_exprs_optional : 1
_30_NEWLINE_optional : 121
_31_cases_optional   : 121
_32_NEWLINE_optional : 126
_33_NEWLINE_optional : 129
_34_NEWLINE_optional : 136
_35_patterns_optional : 136
_36_NEWLINE_optional : 141
_37_NEWLINE_optional : 144
_38_NEWLINE_optional : 144
_39_NEWLINE_optional : 149
_3_NEWLINE_optional  : 6
_40_exprs_optional   : 149
_41_NEWLINE_optional : 154
_42_exprs_optional   : 154
_43_NEWLINE_optional : 159
_44_exprs_optional   : 159
_45_NEWLINE_optional : 164
_46_NEWLINE_optional : 167
_47_NEWLINE_optional : 167
_48_0x3a_type_optional : 174
_4_0x3a_type_optional : 39
_5_NEWLINE_optional  : 42
_6_do_exprs_optional : 42
_7_NEWLINE_optional  : 47
_8_params_optional   : 47
_9_0x3a_type_optional : 47
array                : 14
binary_expr          : 20
block_statement      : 39 112 117 120
call                 : 18
case_of              : 19
cases                : 124 129
def_expr             : 22
do                   : 23 47 54 126 129
do_exprs             : 4 9 45
enum                 : 25
expr                 : 6 9 10 11 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 112 117 121 154 164 167 174
exprs                : 152 157 162 167
external             : 24
identifier           : 16 47 54 109 134 174
if_expr              : 21
let                  : 17
match_as             : 133
match_variant        : 132
num_literal          : 13
or_else              : 115 118
param                : 66 69
params               : 50 62 69
pattern              : 126 129 141 144
patterns             : 139 144
program              : 0
str_literal          : 12
type                 : 40 52 64 74 79 103 108 110 113 175
type_identifier      : 54 59 74 80 81 86 86 91 102 103 135 136 159
variant              : 96 99
variant_call         : 15
variants             : 84 94 99


state 0

    (0) S' -> . program
    (1) program -> . _1_NEWLINE_optional _2_do_exprs_optional
    (2) _1_NEWLINE_optional -> . NEWLINE
    (3) _1_NEWLINE_optional -> .
    NEWLINE         shift and go to state 3
    -               reduce using rule 3 (_1_NEWLINE_optional -> .)
    (               reduce using rule 3 (_1_NEWLINE_optional -> .)
    STRING          reduce using rule 3 (_1_NEWLINE_optional -> .)
    NUMBER          reduce using rule 3 (_1_NEWLINE_optional -> .)
    [               reduce using rule 3 (_1_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 3 (_1_NEWLINE_optional -> .)
    CASE            reduce using rule 3 (_1_NEWLINE_optional -> .)
    IF              reduce using rule 3 (_1_NEWLINE_optional -> .)
    DEF             reduce using rule 3 (_1_NEWLINE_optional -> .)
    DO              reduce using rule 3 (_1_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 3 (_1_NEWLINE_optional -> .)
    ENUM            reduce using rule 3 (_1_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 3 (_1_NEWLINE_optional -> .)
    $end            reduce using rule 3 (_1_NEWLINE_optional -> .)

    program                        shift and go to state 1
    _1_NEWLINE_optional            shift and go to state 2

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_NEWLINE_optional . _2_do_exprs_optional
    (4) _2_do_exprs_optional -> . do_exprs
    (5) _2_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 5 (_2_do_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _2_do_exprs_optional           shift and go to state 4
    do_exprs                       shift and go to state 5
    expr                           shift and go to state 6
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 3

    (2) _1_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    $end            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)


state 4

    (1) program -> _1_NEWLINE_optional _2_do_exprs_optional .
    $end            reduce using rule 1 (program -> _1_NEWLINE_optional _2_do_exprs_optional .)


state 5

    (4) _2_do_exprs_optional -> do_exprs .
    $end            reduce using rule 4 (_2_do_exprs_optional -> do_exprs .)


state 6

    (6) do_exprs -> expr . _3_NEWLINE_optional
    (9) do_exprs -> expr . NEWLINE do_exprs
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    (7) _3_NEWLINE_optional -> . NEWLINE
    (8) _3_NEWLINE_optional -> .
    NEWLINE         shift and go to state 36
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49
    $end            reduce using rule 8 (_3_NEWLINE_optional -> .)
    END             reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELIF            reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELSE            reduce using rule 8 (_3_NEWLINE_optional -> .)

    _3_NEWLINE_optional            shift and go to state 35

state 7

    (10) expr -> - . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 50
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 8

    (11) expr -> ( . expr )
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 51
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 9

    (12) expr -> str_literal .
    NEWLINE         reduce using rule 12 (expr -> str_literal .)
    (               reduce using rule 12 (expr -> str_literal .)
    INT_DIV         reduce using rule 12 (expr -> str_literal .)
    EQUAL           reduce using rule 12 (expr -> str_literal .)
    NOT_EQUAL       reduce using rule 12 (expr -> str_literal .)
    |               reduce using rule 12 (expr -> str_literal .)
    >               reduce using rule 12 (expr -> str_literal .)
    %               reduce using rule 12 (expr -> str_literal .)
    <               reduce using rule 12 (expr -> str_literal .)
    *               reduce using rule 12 (expr -> str_literal .)
    /               reduce using rule 12 (expr -> str_literal .)
    -               reduce using rule 12 (expr -> str_literal .)
    +               reduce using rule 12 (expr -> str_literal .)
    CONCAT          reduce using rule 12 (expr -> str_literal .)
    $end            reduce using rule 12 (expr -> str_literal .)
    )               reduce using rule 12 (expr -> str_literal .)
    OF              reduce using rule 12 (expr -> str_literal .)
    THEN            reduce using rule 12 (expr -> str_literal .)
    END             reduce using rule 12 (expr -> str_literal .)
    ELIF            reduce using rule 12 (expr -> str_literal .)
    ELSE            reduce using rule 12 (expr -> str_literal .)
    ,               reduce using rule 12 (expr -> str_literal .)
    ]               reduce using rule 12 (expr -> str_literal .)


state 10

    (13) expr -> num_literal .
    NEWLINE         reduce using rule 13 (expr -> num_literal .)
    (               reduce using rule 13 (expr -> num_literal .)
    INT_DIV         reduce using rule 13 (expr -> num_literal .)
    EQUAL           reduce using rule 13 (expr -> num_literal .)
    NOT_EQUAL       reduce using rule 13 (expr -> num_literal .)
    |               reduce using rule 13 (expr -> num_literal .)
    >               reduce using rule 13 (expr -> num_literal .)
    %               reduce using rule 13 (expr -> num_literal .)
    <               reduce using rule 13 (expr -> num_literal .)
    *               reduce using rule 13 (expr -> num_literal .)
    /               reduce using rule 13 (expr -> num_literal .)
    -               reduce using rule 13 (expr -> num_literal .)
    +               reduce using rule 13 (expr -> num_literal .)
    CONCAT          reduce using rule 13 (expr -> num_literal .)
    $end            reduce using rule 13 (expr -> num_literal .)
    )               reduce using rule 13 (expr -> num_literal .)
    OF              reduce using rule 13 (expr -> num_literal .)
    THEN            reduce using rule 13 (expr -> num_literal .)
    END             reduce using rule 13 (expr -> num_literal .)
    ELIF            reduce using rule 13 (expr -> num_literal .)
    ELSE            reduce using rule 13 (expr -> num_literal .)
    ,               reduce using rule 13 (expr -> num_literal .)
    ]               reduce using rule 13 (expr -> num_literal .)


state 11

    (14) expr -> array .
    NEWLINE         reduce using rule 14 (expr -> array .)
    (               reduce using rule 14 (expr -> array .)
    INT_DIV         reduce using rule 14 (expr -> array .)
    EQUAL           reduce using rule 14 (expr -> array .)
    NOT_EQUAL       reduce using rule 14 (expr -> array .)
    |               reduce using rule 14 (expr -> array .)
    >               reduce using rule 14 (expr -> array .)
    %               reduce using rule 14 (expr -> array .)
    <               reduce using rule 14 (expr -> array .)
    *               reduce using rule 14 (expr -> array .)
    /               reduce using rule 14 (expr -> array .)
    -               reduce using rule 14 (expr -> array .)
    +               reduce using rule 14 (expr -> array .)
    CONCAT          reduce using rule 14 (expr -> array .)
    $end            reduce using rule 14 (expr -> array .)
    )               reduce using rule 14 (expr -> array .)
    OF              reduce using rule 14 (expr -> array .)
    THEN            reduce using rule 14 (expr -> array .)
    END             reduce using rule 14 (expr -> array .)
    ELIF            reduce using rule 14 (expr -> array .)
    ELSE            reduce using rule 14 (expr -> array .)
    ,               reduce using rule 14 (expr -> array .)
    ]               reduce using rule 14 (expr -> array .)


state 12

    (15) expr -> variant_call .
    NEWLINE         reduce using rule 15 (expr -> variant_call .)
    (               reduce using rule 15 (expr -> variant_call .)
    INT_DIV         reduce using rule 15 (expr -> variant_call .)
    EQUAL           reduce using rule 15 (expr -> variant_call .)
    NOT_EQUAL       reduce using rule 15 (expr -> variant_call .)
    |               reduce using rule 15 (expr -> variant_call .)
    >               reduce using rule 15 (expr -> variant_call .)
    %               reduce using rule 15 (expr -> variant_call .)
    <               reduce using rule 15 (expr -> variant_call .)
    *               reduce using rule 15 (expr -> variant_call .)
    /               reduce using rule 15 (expr -> variant_call .)
    -               reduce using rule 15 (expr -> variant_call .)
    +               reduce using rule 15 (expr -> variant_call .)
    CONCAT          reduce using rule 15 (expr -> variant_call .)
    $end            reduce using rule 15 (expr -> variant_call .)
    )               reduce using rule 15 (expr -> variant_call .)
    OF              reduce using rule 15 (expr -> variant_call .)
    THEN            reduce using rule 15 (expr -> variant_call .)
    END             reduce using rule 15 (expr -> variant_call .)
    ELIF            reduce using rule 15 (expr -> variant_call .)
    ELSE            reduce using rule 15 (expr -> variant_call .)
    ,               reduce using rule 15 (expr -> variant_call .)
    ]               reduce using rule 15 (expr -> variant_call .)


state 13

    (16) expr -> identifier .
    (174) let -> identifier . _48_0x3a_type_optional = expr
    (175) _48_0x3a_type_optional -> . : type
    (176) _48_0x3a_type_optional -> .
    NEWLINE         reduce using rule 16 (expr -> identifier .)
    (               reduce using rule 16 (expr -> identifier .)
    INT_DIV         reduce using rule 16 (expr -> identifier .)
    EQUAL           reduce using rule 16 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 16 (expr -> identifier .)
    |               reduce using rule 16 (expr -> identifier .)
    >               reduce using rule 16 (expr -> identifier .)
    %               reduce using rule 16 (expr -> identifier .)
    <               reduce using rule 16 (expr -> identifier .)
    *               reduce using rule 16 (expr -> identifier .)
    /               reduce using rule 16 (expr -> identifier .)
    -               reduce using rule 16 (expr -> identifier .)
    +               reduce using rule 16 (expr -> identifier .)
    CONCAT          reduce using rule 16 (expr -> identifier .)
    $end            reduce using rule 16 (expr -> identifier .)
    )               reduce using rule 16 (expr -> identifier .)
    OF              reduce using rule 16 (expr -> identifier .)
    THEN            reduce using rule 16 (expr -> identifier .)
    END             reduce using rule 16 (expr -> identifier .)
    ELIF            reduce using rule 16 (expr -> identifier .)
    ELSE            reduce using rule 16 (expr -> identifier .)
    ,               reduce using rule 16 (expr -> identifier .)
    ]               reduce using rule 16 (expr -> identifier .)
    :               shift and go to state 53
    =               reduce using rule 176 (_48_0x3a_type_optional -> .)

    _48_0x3a_type_optional         shift and go to state 52

state 14

    (17) expr -> let .
    NEWLINE         reduce using rule 17 (expr -> let .)
    (               reduce using rule 17 (expr -> let .)
    INT_DIV         reduce using rule 17 (expr -> let .)
    EQUAL           reduce using rule 17 (expr -> let .)
    NOT_EQUAL       reduce using rule 17 (expr -> let .)
    |               reduce using rule 17 (expr -> let .)
    >               reduce using rule 17 (expr -> let .)
    %               reduce using rule 17 (expr -> let .)
    <               reduce using rule 17 (expr -> let .)
    *               reduce using rule 17 (expr -> let .)
    /               reduce using rule 17 (expr -> let .)
    -               reduce using rule 17 (expr -> let .)
    +               reduce using rule 17 (expr -> let .)
    CONCAT          reduce using rule 17 (expr -> let .)
    $end            reduce using rule 17 (expr -> let .)
    )               reduce using rule 17 (expr -> let .)
    OF              reduce using rule 17 (expr -> let .)
    THEN            reduce using rule 17 (expr -> let .)
    END             reduce using rule 17 (expr -> let .)
    ELIF            reduce using rule 17 (expr -> let .)
    ELSE            reduce using rule 17 (expr -> let .)
    ,               reduce using rule 17 (expr -> let .)
    ]               reduce using rule 17 (expr -> let .)


state 15

    (18) expr -> call .
    NEWLINE         reduce using rule 18 (expr -> call .)
    (               reduce using rule 18 (expr -> call .)
    INT_DIV         reduce using rule 18 (expr -> call .)
    EQUAL           reduce using rule 18 (expr -> call .)
    NOT_EQUAL       reduce using rule 18 (expr -> call .)
    |               reduce using rule 18 (expr -> call .)
    >               reduce using rule 18 (expr -> call .)
    %               reduce using rule 18 (expr -> call .)
    <               reduce using rule 18 (expr -> call .)
    *               reduce using rule 18 (expr -> call .)
    /               reduce using rule 18 (expr -> call .)
    -               reduce using rule 18 (expr -> call .)
    +               reduce using rule 18 (expr -> call .)
    CONCAT          reduce using rule 18 (expr -> call .)
    $end            reduce using rule 18 (expr -> call .)
    )               reduce using rule 18 (expr -> call .)
    OF              reduce using rule 18 (expr -> call .)
    THEN            reduce using rule 18 (expr -> call .)
    END             reduce using rule 18 (expr -> call .)
    ELIF            reduce using rule 18 (expr -> call .)
    ELSE            reduce using rule 18 (expr -> call .)
    ,               reduce using rule 18 (expr -> call .)
    ]               reduce using rule 18 (expr -> call .)


state 16

    (19) expr -> case_of .
    NEWLINE         reduce using rule 19 (expr -> case_of .)
    (               reduce using rule 19 (expr -> case_of .)
    INT_DIV         reduce using rule 19 (expr -> case_of .)
    EQUAL           reduce using rule 19 (expr -> case_of .)
    NOT_EQUAL       reduce using rule 19 (expr -> case_of .)
    |               reduce using rule 19 (expr -> case_of .)
    >               reduce using rule 19 (expr -> case_of .)
    %               reduce using rule 19 (expr -> case_of .)
    <               reduce using rule 19 (expr -> case_of .)
    *               reduce using rule 19 (expr -> case_of .)
    /               reduce using rule 19 (expr -> case_of .)
    -               reduce using rule 19 (expr -> case_of .)
    +               reduce using rule 19 (expr -> case_of .)
    CONCAT          reduce using rule 19 (expr -> case_of .)
    $end            reduce using rule 19 (expr -> case_of .)
    )               reduce using rule 19 (expr -> case_of .)
    OF              reduce using rule 19 (expr -> case_of .)
    THEN            reduce using rule 19 (expr -> case_of .)
    END             reduce using rule 19 (expr -> case_of .)
    ELIF            reduce using rule 19 (expr -> case_of .)
    ELSE            reduce using rule 19 (expr -> case_of .)
    ,               reduce using rule 19 (expr -> case_of .)
    ]               reduce using rule 19 (expr -> case_of .)


state 17

    (20) expr -> binary_expr .
    NEWLINE         reduce using rule 20 (expr -> binary_expr .)
    (               reduce using rule 20 (expr -> binary_expr .)
    INT_DIV         reduce using rule 20 (expr -> binary_expr .)
    EQUAL           reduce using rule 20 (expr -> binary_expr .)
    NOT_EQUAL       reduce using rule 20 (expr -> binary_expr .)
    |               reduce using rule 20 (expr -> binary_expr .)
    >               reduce using rule 20 (expr -> binary_expr .)
    %               reduce using rule 20 (expr -> binary_expr .)
    <               reduce using rule 20 (expr -> binary_expr .)
    *               reduce using rule 20 (expr -> binary_expr .)
    /               reduce using rule 20 (expr -> binary_expr .)
    -               reduce using rule 20 (expr -> binary_expr .)
    +               reduce using rule 20 (expr -> binary_expr .)
    CONCAT          reduce using rule 20 (expr -> binary_expr .)
    $end            reduce using rule 20 (expr -> binary_expr .)
    )               reduce using rule 20 (expr -> binary_expr .)
    OF              reduce using rule 20 (expr -> binary_expr .)
    THEN            reduce using rule 20 (expr -> binary_expr .)
    END             reduce using rule 20 (expr -> binary_expr .)
    ELIF            reduce using rule 20 (expr -> binary_expr .)
    ELSE            reduce using rule 20 (expr -> binary_expr .)
    ,               reduce using rule 20 (expr -> binary_expr .)
    ]               reduce using rule 20 (expr -> binary_expr .)


state 18

    (21) expr -> if_expr .
    NEWLINE         reduce using rule 21 (expr -> if_expr .)
    (               reduce using rule 21 (expr -> if_expr .)
    INT_DIV         reduce using rule 21 (expr -> if_expr .)
    EQUAL           reduce using rule 21 (expr -> if_expr .)
    NOT_EQUAL       reduce using rule 21 (expr -> if_expr .)
    |               reduce using rule 21 (expr -> if_expr .)
    >               reduce using rule 21 (expr -> if_expr .)
    %               reduce using rule 21 (expr -> if_expr .)
    <               reduce using rule 21 (expr -> if_expr .)
    *               reduce using rule 21 (expr -> if_expr .)
    /               reduce using rule 21 (expr -> if_expr .)
    -               reduce using rule 21 (expr -> if_expr .)
    +               reduce using rule 21 (expr -> if_expr .)
    CONCAT          reduce using rule 21 (expr -> if_expr .)
    $end            reduce using rule 21 (expr -> if_expr .)
    )               reduce using rule 21 (expr -> if_expr .)
    OF              reduce using rule 21 (expr -> if_expr .)
    THEN            reduce using rule 21 (expr -> if_expr .)
    END             reduce using rule 21 (expr -> if_expr .)
    ELIF            reduce using rule 21 (expr -> if_expr .)
    ELSE            reduce using rule 21 (expr -> if_expr .)
    ,               reduce using rule 21 (expr -> if_expr .)
    ]               reduce using rule 21 (expr -> if_expr .)


state 19

    (22) expr -> def_expr .
    NEWLINE         reduce using rule 22 (expr -> def_expr .)
    (               reduce using rule 22 (expr -> def_expr .)
    INT_DIV         reduce using rule 22 (expr -> def_expr .)
    EQUAL           reduce using rule 22 (expr -> def_expr .)
    NOT_EQUAL       reduce using rule 22 (expr -> def_expr .)
    |               reduce using rule 22 (expr -> def_expr .)
    >               reduce using rule 22 (expr -> def_expr .)
    %               reduce using rule 22 (expr -> def_expr .)
    <               reduce using rule 22 (expr -> def_expr .)
    *               reduce using rule 22 (expr -> def_expr .)
    /               reduce using rule 22 (expr -> def_expr .)
    -               reduce using rule 22 (expr -> def_expr .)
    +               reduce using rule 22 (expr -> def_expr .)
    CONCAT          reduce using rule 22 (expr -> def_expr .)
    $end            reduce using rule 22 (expr -> def_expr .)
    )               reduce using rule 22 (expr -> def_expr .)
    OF              reduce using rule 22 (expr -> def_expr .)
    THEN            reduce using rule 22 (expr -> def_expr .)
    END             reduce using rule 22 (expr -> def_expr .)
    ELIF            reduce using rule 22 (expr -> def_expr .)
    ELSE            reduce using rule 22 (expr -> def_expr .)
    ,               reduce using rule 22 (expr -> def_expr .)
    ]               reduce using rule 22 (expr -> def_expr .)


state 20

    (23) expr -> do .
    NEWLINE         reduce using rule 23 (expr -> do .)
    (               reduce using rule 23 (expr -> do .)
    INT_DIV         reduce using rule 23 (expr -> do .)
    EQUAL           reduce using rule 23 (expr -> do .)
    NOT_EQUAL       reduce using rule 23 (expr -> do .)
    |               reduce using rule 23 (expr -> do .)
    >               reduce using rule 23 (expr -> do .)
    %               reduce using rule 23 (expr -> do .)
    <               reduce using rule 23 (expr -> do .)
    *               reduce using rule 23 (expr -> do .)
    /               reduce using rule 23 (expr -> do .)
    -               reduce using rule 23 (expr -> do .)
    +               reduce using rule 23 (expr -> do .)
    CONCAT          reduce using rule 23 (expr -> do .)
    $end            reduce using rule 23 (expr -> do .)
    )               reduce using rule 23 (expr -> do .)
    OF              reduce using rule 23 (expr -> do .)
    THEN            reduce using rule 23 (expr -> do .)
    END             reduce using rule 23 (expr -> do .)
    ELIF            reduce using rule 23 (expr -> do .)
    ELSE            reduce using rule 23 (expr -> do .)
    ,               reduce using rule 23 (expr -> do .)
    ]               reduce using rule 23 (expr -> do .)


state 21

    (24) expr -> external .
    NEWLINE         reduce using rule 24 (expr -> external .)
    (               reduce using rule 24 (expr -> external .)
    INT_DIV         reduce using rule 24 (expr -> external .)
    EQUAL           reduce using rule 24 (expr -> external .)
    NOT_EQUAL       reduce using rule 24 (expr -> external .)
    |               reduce using rule 24 (expr -> external .)
    >               reduce using rule 24 (expr -> external .)
    %               reduce using rule 24 (expr -> external .)
    <               reduce using rule 24 (expr -> external .)
    *               reduce using rule 24 (expr -> external .)
    /               reduce using rule 24 (expr -> external .)
    -               reduce using rule 24 (expr -> external .)
    +               reduce using rule 24 (expr -> external .)
    CONCAT          reduce using rule 24 (expr -> external .)
    $end            reduce using rule 24 (expr -> external .)
    )               reduce using rule 24 (expr -> external .)
    OF              reduce using rule 24 (expr -> external .)
    THEN            reduce using rule 24 (expr -> external .)
    END             reduce using rule 24 (expr -> external .)
    ELIF            reduce using rule 24 (expr -> external .)
    ELSE            reduce using rule 24 (expr -> external .)
    ,               reduce using rule 24 (expr -> external .)
    ]               reduce using rule 24 (expr -> external .)


state 22

    (25) expr -> enum .
    NEWLINE         reduce using rule 25 (expr -> enum .)
    (               reduce using rule 25 (expr -> enum .)
    INT_DIV         reduce using rule 25 (expr -> enum .)
    EQUAL           reduce using rule 25 (expr -> enum .)
    NOT_EQUAL       reduce using rule 25 (expr -> enum .)
    |               reduce using rule 25 (expr -> enum .)
    >               reduce using rule 25 (expr -> enum .)
    %               reduce using rule 25 (expr -> enum .)
    <               reduce using rule 25 (expr -> enum .)
    *               reduce using rule 25 (expr -> enum .)
    /               reduce using rule 25 (expr -> enum .)
    -               reduce using rule 25 (expr -> enum .)
    +               reduce using rule 25 (expr -> enum .)
    CONCAT          reduce using rule 25 (expr -> enum .)
    $end            reduce using rule 25 (expr -> enum .)
    )               reduce using rule 25 (expr -> enum .)
    OF              reduce using rule 25 (expr -> enum .)
    THEN            reduce using rule 25 (expr -> enum .)
    END             reduce using rule 25 (expr -> enum .)
    ELIF            reduce using rule 25 (expr -> enum .)
    ELSE            reduce using rule 25 (expr -> enum .)
    ,               reduce using rule 25 (expr -> enum .)
    ]               reduce using rule 25 (expr -> enum .)


state 23

    (178) str_literal -> STRING .
    NEWLINE         reduce using rule 178 (str_literal -> STRING .)
    (               reduce using rule 178 (str_literal -> STRING .)
    INT_DIV         reduce using rule 178 (str_literal -> STRING .)
    EQUAL           reduce using rule 178 (str_literal -> STRING .)
    NOT_EQUAL       reduce using rule 178 (str_literal -> STRING .)
    |               reduce using rule 178 (str_literal -> STRING .)
    >               reduce using rule 178 (str_literal -> STRING .)
    %               reduce using rule 178 (str_literal -> STRING .)
    <               reduce using rule 178 (str_literal -> STRING .)
    *               reduce using rule 178 (str_literal -> STRING .)
    /               reduce using rule 178 (str_literal -> STRING .)
    -               reduce using rule 178 (str_literal -> STRING .)
    +               reduce using rule 178 (str_literal -> STRING .)
    CONCAT          reduce using rule 178 (str_literal -> STRING .)
    $end            reduce using rule 178 (str_literal -> STRING .)
    )               reduce using rule 178 (str_literal -> STRING .)
    OF              reduce using rule 178 (str_literal -> STRING .)
    THEN            reduce using rule 178 (str_literal -> STRING .)
    END             reduce using rule 178 (str_literal -> STRING .)
    ELIF            reduce using rule 178 (str_literal -> STRING .)
    ELSE            reduce using rule 178 (str_literal -> STRING .)
    ,               reduce using rule 178 (str_literal -> STRING .)
    ]               reduce using rule 178 (str_literal -> STRING .)


state 24

    (177) num_literal -> NUMBER .
    NEWLINE         reduce using rule 177 (num_literal -> NUMBER .)
    (               reduce using rule 177 (num_literal -> NUMBER .)
    INT_DIV         reduce using rule 177 (num_literal -> NUMBER .)
    EQUAL           reduce using rule 177 (num_literal -> NUMBER .)
    NOT_EQUAL       reduce using rule 177 (num_literal -> NUMBER .)
    |               reduce using rule 177 (num_literal -> NUMBER .)
    >               reduce using rule 177 (num_literal -> NUMBER .)
    %               reduce using rule 177 (num_literal -> NUMBER .)
    <               reduce using rule 177 (num_literal -> NUMBER .)
    *               reduce using rule 177 (num_literal -> NUMBER .)
    /               reduce using rule 177 (num_literal -> NUMBER .)
    -               reduce using rule 177 (num_literal -> NUMBER .)
    +               reduce using rule 177 (num_literal -> NUMBER .)
    CONCAT          reduce using rule 177 (num_literal -> NUMBER .)
    $end            reduce using rule 177 (num_literal -> NUMBER .)
    )               reduce using rule 177 (num_literal -> NUMBER .)
    OF              reduce using rule 177 (num_literal -> NUMBER .)
    THEN            reduce using rule 177 (num_literal -> NUMBER .)
    END             reduce using rule 177 (num_literal -> NUMBER .)
    ELIF            reduce using rule 177 (num_literal -> NUMBER .)
    ELSE            reduce using rule 177 (num_literal -> NUMBER .)
    ,               reduce using rule 177 (num_literal -> NUMBER .)
    ]               reduce using rule 177 (num_literal -> NUMBER .)


state 25

    (149) array -> [ . _39_NEWLINE_optional _40_exprs_optional ]
    (150) _39_NEWLINE_optional -> . NEWLINE
    (151) _39_NEWLINE_optional -> .
    NEWLINE         shift and go to state 55
    -               reduce using rule 151 (_39_NEWLINE_optional -> .)
    (               reduce using rule 151 (_39_NEWLINE_optional -> .)
    STRING          reduce using rule 151 (_39_NEWLINE_optional -> .)
    NUMBER          reduce using rule 151 (_39_NEWLINE_optional -> .)
    [               reduce using rule 151 (_39_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 151 (_39_NEWLINE_optional -> .)
    CASE            reduce using rule 151 (_39_NEWLINE_optional -> .)
    IF              reduce using rule 151 (_39_NEWLINE_optional -> .)
    DEF             reduce using rule 151 (_39_NEWLINE_optional -> .)
    DO              reduce using rule 151 (_39_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 151 (_39_NEWLINE_optional -> .)
    ENUM            reduce using rule 151 (_39_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 151 (_39_NEWLINE_optional -> .)
    ]               reduce using rule 151 (_39_NEWLINE_optional -> .)

    _39_NEWLINE_optional           shift and go to state 54

state 26

    (159) variant_call -> type_identifier . ( _43_NEWLINE_optional _44_exprs_optional )
    (               shift and go to state 56


state 27

    (172) identifier -> IDENTIFIER .
    :               reduce using rule 172 (identifier -> IDENTIFIER .)
    =               reduce using rule 172 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 172 (identifier -> IDENTIFIER .)
    (               reduce using rule 172 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 172 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 172 (identifier -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 172 (identifier -> IDENTIFIER .)
    |               reduce using rule 172 (identifier -> IDENTIFIER .)
    >               reduce using rule 172 (identifier -> IDENTIFIER .)
    %               reduce using rule 172 (identifier -> IDENTIFIER .)
    <               reduce using rule 172 (identifier -> IDENTIFIER .)
    *               reduce using rule 172 (identifier -> IDENTIFIER .)
    /               reduce using rule 172 (identifier -> IDENTIFIER .)
    -               reduce using rule 172 (identifier -> IDENTIFIER .)
    +               reduce using rule 172 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 172 (identifier -> IDENTIFIER .)
    $end            reduce using rule 172 (identifier -> IDENTIFIER .)
    )               reduce using rule 172 (identifier -> IDENTIFIER .)
    OF              reduce using rule 172 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 172 (identifier -> IDENTIFIER .)
    END             reduce using rule 172 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 172 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 172 (identifier -> IDENTIFIER .)
    ,               reduce using rule 172 (identifier -> IDENTIFIER .)
    ]               reduce using rule 172 (identifier -> IDENTIFIER .)
    DO              reduce using rule 172 (identifier -> IDENTIFIER .)


state 28

    (121) case_of -> CASE . expr OF _30_NEWLINE_optional _31_cases_optional END
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 57
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 29

    (112) if_expr -> IF . expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 58
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 30

    (47) def_expr -> DEF . identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> DEF . identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 27

    identifier                     shift and go to state 59

state 31

    (39) do -> DO . _4_0x3a_type_optional block_statement END
    (40) _4_0x3a_type_optional -> . : type
    (41) _4_0x3a_type_optional -> .
    :               shift and go to state 61
    NEWLINE         reduce using rule 41 (_4_0x3a_type_optional -> .)
    END             reduce using rule 41 (_4_0x3a_type_optional -> .)
    -               reduce using rule 41 (_4_0x3a_type_optional -> .)
    (               reduce using rule 41 (_4_0x3a_type_optional -> .)
    STRING          reduce using rule 41 (_4_0x3a_type_optional -> .)
    NUMBER          reduce using rule 41 (_4_0x3a_type_optional -> .)
    [               reduce using rule 41 (_4_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 41 (_4_0x3a_type_optional -> .)
    CASE            reduce using rule 41 (_4_0x3a_type_optional -> .)
    IF              reduce using rule 41 (_4_0x3a_type_optional -> .)
    DEF             reduce using rule 41 (_4_0x3a_type_optional -> .)
    DO              reduce using rule 41 (_4_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 41 (_4_0x3a_type_optional -> .)
    ENUM            reduce using rule 41 (_4_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 41 (_4_0x3a_type_optional -> .)

    _4_0x3a_type_optional          shift and go to state 60

state 32

    (26) external -> EXTERNAL .
    NEWLINE         reduce using rule 26 (external -> EXTERNAL .)
    (               reduce using rule 26 (external -> EXTERNAL .)
    INT_DIV         reduce using rule 26 (external -> EXTERNAL .)
    EQUAL           reduce using rule 26 (external -> EXTERNAL .)
    NOT_EQUAL       reduce using rule 26 (external -> EXTERNAL .)
    |               reduce using rule 26 (external -> EXTERNAL .)
    >               reduce using rule 26 (external -> EXTERNAL .)
    %               reduce using rule 26 (external -> EXTERNAL .)
    <               reduce using rule 26 (external -> EXTERNAL .)
    *               reduce using rule 26 (external -> EXTERNAL .)
    /               reduce using rule 26 (external -> EXTERNAL .)
    -               reduce using rule 26 (external -> EXTERNAL .)
    +               reduce using rule 26 (external -> EXTERNAL .)
    CONCAT          reduce using rule 26 (external -> EXTERNAL .)
    $end            reduce using rule 26 (external -> EXTERNAL .)
    )               reduce using rule 26 (external -> EXTERNAL .)
    OF              reduce using rule 26 (external -> EXTERNAL .)
    THEN            reduce using rule 26 (external -> EXTERNAL .)
    END             reduce using rule 26 (external -> EXTERNAL .)
    ELIF            reduce using rule 26 (external -> EXTERNAL .)
    ELSE            reduce using rule 26 (external -> EXTERNAL .)
    ,               reduce using rule 26 (external -> EXTERNAL .)
    ]               reduce using rule 26 (external -> EXTERNAL .)


state 33

    (81) enum -> ENUM . type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> ENUM . type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 62

state 34

    (173) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 173 (type_identifier -> TYPE_IDENTIFIER .)


state 35

    (6) do_exprs -> expr _3_NEWLINE_optional .
    $end            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    END             reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    ELIF            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    ELSE            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)


state 36

    (9) do_exprs -> expr NEWLINE . do_exprs
    (7) _3_NEWLINE_optional -> NEWLINE .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 6
    do_exprs                       shift and go to state 63
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 37

    (154) call -> expr ( . _41_NEWLINE_optional _42_exprs_optional )
    (155) _41_NEWLINE_optional -> . NEWLINE
    (156) _41_NEWLINE_optional -> .
    NEWLINE         shift and go to state 65
    -               reduce using rule 156 (_41_NEWLINE_optional -> .)
    (               reduce using rule 156 (_41_NEWLINE_optional -> .)
    STRING          reduce using rule 156 (_41_NEWLINE_optional -> .)
    NUMBER          reduce using rule 156 (_41_NEWLINE_optional -> .)
    [               reduce using rule 156 (_41_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 156 (_41_NEWLINE_optional -> .)
    CASE            reduce using rule 156 (_41_NEWLINE_optional -> .)
    IF              reduce using rule 156 (_41_NEWLINE_optional -> .)
    DEF             reduce using rule 156 (_41_NEWLINE_optional -> .)
    DO              reduce using rule 156 (_41_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 156 (_41_NEWLINE_optional -> .)
    ENUM            reduce using rule 156 (_41_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 156 (_41_NEWLINE_optional -> .)
    )               reduce using rule 156 (_41_NEWLINE_optional -> .)

    _41_NEWLINE_optional           shift and go to state 64

state 38

    (27) binary_expr -> expr INT_DIV . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 66
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 39

    (28) binary_expr -> expr EQUAL . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 67
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 40

    (29) binary_expr -> expr NOT_EQUAL . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 68
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 41

    (30) binary_expr -> expr | . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 69
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 42

    (31) binary_expr -> expr > . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 70
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 43

    (32) binary_expr -> expr % . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 71
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 44

    (33) binary_expr -> expr < . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 72
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 45

    (34) binary_expr -> expr * . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 73
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 46

    (35) binary_expr -> expr / . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 74
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 47

    (36) binary_expr -> expr - . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 75
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 48

    (37) binary_expr -> expr + . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 76
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 49

    (38) binary_expr -> expr CONCAT . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 77
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 50

    (10) expr -> - expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 10 (expr -> - expr .)
    INT_DIV         reduce using rule 10 (expr -> - expr .)
    EQUAL           reduce using rule 10 (expr -> - expr .)
    NOT_EQUAL       reduce using rule 10 (expr -> - expr .)
    |               reduce using rule 10 (expr -> - expr .)
    >               reduce using rule 10 (expr -> - expr .)
    %               reduce using rule 10 (expr -> - expr .)
    <               reduce using rule 10 (expr -> - expr .)
    *               reduce using rule 10 (expr -> - expr .)
    /               reduce using rule 10 (expr -> - expr .)
    -               reduce using rule 10 (expr -> - expr .)
    +               reduce using rule 10 (expr -> - expr .)
    CONCAT          reduce using rule 10 (expr -> - expr .)
    $end            reduce using rule 10 (expr -> - expr .)
    )               reduce using rule 10 (expr -> - expr .)
    OF              reduce using rule 10 (expr -> - expr .)
    THEN            reduce using rule 10 (expr -> - expr .)
    END             reduce using rule 10 (expr -> - expr .)
    ELIF            reduce using rule 10 (expr -> - expr .)
    ELSE            reduce using rule 10 (expr -> - expr .)
    ,               reduce using rule 10 (expr -> - expr .)
    ]               reduce using rule 10 (expr -> - expr .)
    (               shift and go to state 37


state 51

    (11) expr -> ( expr . )
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    )               shift and go to state 78
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 52

    (174) let -> identifier _48_0x3a_type_optional . = expr
    =               shift and go to state 79


state 53

    (175) _48_0x3a_type_optional -> : . type
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 80
    type_identifier                shift and go to state 81

state 54

    (149) array -> [ _39_NEWLINE_optional . _40_exprs_optional ]
    (152) _40_exprs_optional -> . exprs
    (153) _40_exprs_optional -> .
    (164) exprs -> . expr _45_NEWLINE_optional
    (167) exprs -> . exprs , _46_NEWLINE_optional expr _47_NEWLINE_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    ]               reduce using rule 153 (_40_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _40_exprs_optional             shift and go to state 82
    exprs                          shift and go to state 83
    expr                           shift and go to state 84
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 55

    (150) _39_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 150 (_39_NEWLINE_optional -> NEWLINE .)


state 56

    (159) variant_call -> type_identifier ( . _43_NEWLINE_optional _44_exprs_optional )
    (160) _43_NEWLINE_optional -> . NEWLINE
    (161) _43_NEWLINE_optional -> .
    NEWLINE         shift and go to state 86
    -               reduce using rule 161 (_43_NEWLINE_optional -> .)
    (               reduce using rule 161 (_43_NEWLINE_optional -> .)
    STRING          reduce using rule 161 (_43_NEWLINE_optional -> .)
    NUMBER          reduce using rule 161 (_43_NEWLINE_optional -> .)
    [               reduce using rule 161 (_43_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 161 (_43_NEWLINE_optional -> .)
    CASE            reduce using rule 161 (_43_NEWLINE_optional -> .)
    IF              reduce using rule 161 (_43_NEWLINE_optional -> .)
    DEF             reduce using rule 161 (_43_NEWLINE_optional -> .)
    DO              reduce using rule 161 (_43_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 161 (_43_NEWLINE_optional -> .)
    ENUM            reduce using rule 161 (_43_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 161 (_43_NEWLINE_optional -> .)
    )               reduce using rule 161 (_43_NEWLINE_optional -> .)

    _43_NEWLINE_optional           shift and go to state 85

state 57

    (121) case_of -> CASE expr . OF _30_NEWLINE_optional _31_cases_optional END
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 87
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 58

    (112) if_expr -> IF expr . THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 88
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 59

    (47) def_expr -> DEF identifier . ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> DEF identifier . < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (               shift and go to state 89
    <               shift and go to state 90


state 60

    (39) do -> DO _4_0x3a_type_optional . block_statement END
    (42) block_statement -> . _5_NEWLINE_optional _6_do_exprs_optional
    (43) _5_NEWLINE_optional -> . NEWLINE
    (44) _5_NEWLINE_optional -> .
    NEWLINE         shift and go to state 93
    -               reduce using rule 44 (_5_NEWLINE_optional -> .)
    (               reduce using rule 44 (_5_NEWLINE_optional -> .)
    STRING          reduce using rule 44 (_5_NEWLINE_optional -> .)
    NUMBER          reduce using rule 44 (_5_NEWLINE_optional -> .)
    [               reduce using rule 44 (_5_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 44 (_5_NEWLINE_optional -> .)
    CASE            reduce using rule 44 (_5_NEWLINE_optional -> .)
    IF              reduce using rule 44 (_5_NEWLINE_optional -> .)
    DEF             reduce using rule 44 (_5_NEWLINE_optional -> .)
    DO              reduce using rule 44 (_5_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 44 (_5_NEWLINE_optional -> .)
    ENUM            reduce using rule 44 (_5_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 44 (_5_NEWLINE_optional -> .)
    END             reduce using rule 44 (_5_NEWLINE_optional -> .)

    block_statement                shift and go to state 91
    _5_NEWLINE_optional            shift and go to state 92

state 61

    (40) _4_0x3a_type_optional -> : . type
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 94
    type_identifier                shift and go to state 81

state 62

    (81) enum -> ENUM type_identifier . { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> ENUM type_identifier . < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    {               shift and go to state 95
    <               shift and go to state 96


state 63

    (9) do_exprs -> expr NEWLINE do_exprs .
    $end            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    END             reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELIF            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELSE            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)


state 64

    (154) call -> expr ( _41_NEWLINE_optional . _42_exprs_optional )
    (157) _42_exprs_optional -> . exprs
    (158) _42_exprs_optional -> .
    (164) exprs -> . expr _45_NEWLINE_optional
    (167) exprs -> . exprs , _46_NEWLINE_optional expr _47_NEWLINE_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 158 (_42_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 84
    _42_exprs_optional             shift and go to state 97
    exprs                          shift and go to state 98
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 65

    (155) _41_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 155 (_41_NEWLINE_optional -> NEWLINE .)


state 66

    (27) binary_expr -> expr INT_DIV expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    INT_DIV         reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    EQUAL           reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    NOT_EQUAL       reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    |               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    %               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    (               shift and go to state 37


state 67

    (28) binary_expr -> expr EQUAL expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    $end            reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    )               reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    OF              reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    THEN            reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    END             reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    ,               reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    ]               reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 68

    (29) binary_expr -> expr NOT_EQUAL expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    END             reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    ]               reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 69

    (30) binary_expr -> expr | expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 30 (binary_expr -> expr | expr .)
    EQUAL           reduce using rule 30 (binary_expr -> expr | expr .)
    NOT_EQUAL       reduce using rule 30 (binary_expr -> expr | expr .)
    |               reduce using rule 30 (binary_expr -> expr | expr .)
    >               reduce using rule 30 (binary_expr -> expr | expr .)
    <               reduce using rule 30 (binary_expr -> expr | expr .)
    -               reduce using rule 30 (binary_expr -> expr | expr .)
    +               reduce using rule 30 (binary_expr -> expr | expr .)
    CONCAT          reduce using rule 30 (binary_expr -> expr | expr .)
    $end            reduce using rule 30 (binary_expr -> expr | expr .)
    )               reduce using rule 30 (binary_expr -> expr | expr .)
    OF              reduce using rule 30 (binary_expr -> expr | expr .)
    THEN            reduce using rule 30 (binary_expr -> expr | expr .)
    END             reduce using rule 30 (binary_expr -> expr | expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr | expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr | expr .)
    ,               reduce using rule 30 (binary_expr -> expr | expr .)
    ]               reduce using rule 30 (binary_expr -> expr | expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46


state 70

    (31) binary_expr -> expr > expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 31 (binary_expr -> expr > expr .)
    EQUAL           reduce using rule 31 (binary_expr -> expr > expr .)
    NOT_EQUAL       reduce using rule 31 (binary_expr -> expr > expr .)
    >               reduce using rule 31 (binary_expr -> expr > expr .)
    <               reduce using rule 31 (binary_expr -> expr > expr .)
    $end            reduce using rule 31 (binary_expr -> expr > expr .)
    )               reduce using rule 31 (binary_expr -> expr > expr .)
    OF              reduce using rule 31 (binary_expr -> expr > expr .)
    THEN            reduce using rule 31 (binary_expr -> expr > expr .)
    END             reduce using rule 31 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr > expr .)
    ,               reduce using rule 31 (binary_expr -> expr > expr .)
    ]               reduce using rule 31 (binary_expr -> expr > expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    |               shift and go to state 41
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 71

    (32) binary_expr -> expr % expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 32 (binary_expr -> expr % expr .)
    INT_DIV         reduce using rule 32 (binary_expr -> expr % expr .)
    EQUAL           reduce using rule 32 (binary_expr -> expr % expr .)
    NOT_EQUAL       reduce using rule 32 (binary_expr -> expr % expr .)
    |               reduce using rule 32 (binary_expr -> expr % expr .)
    >               reduce using rule 32 (binary_expr -> expr % expr .)
    %               reduce using rule 32 (binary_expr -> expr % expr .)
    <               reduce using rule 32 (binary_expr -> expr % expr .)
    *               reduce using rule 32 (binary_expr -> expr % expr .)
    /               reduce using rule 32 (binary_expr -> expr % expr .)
    -               reduce using rule 32 (binary_expr -> expr % expr .)
    +               reduce using rule 32 (binary_expr -> expr % expr .)
    CONCAT          reduce using rule 32 (binary_expr -> expr % expr .)
    $end            reduce using rule 32 (binary_expr -> expr % expr .)
    )               reduce using rule 32 (binary_expr -> expr % expr .)
    OF              reduce using rule 32 (binary_expr -> expr % expr .)
    THEN            reduce using rule 32 (binary_expr -> expr % expr .)
    END             reduce using rule 32 (binary_expr -> expr % expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr % expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr % expr .)
    ,               reduce using rule 32 (binary_expr -> expr % expr .)
    ]               reduce using rule 32 (binary_expr -> expr % expr .)
    (               shift and go to state 37


state 72

    (33) binary_expr -> expr < expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 33 (binary_expr -> expr < expr .)
    EQUAL           reduce using rule 33 (binary_expr -> expr < expr .)
    NOT_EQUAL       reduce using rule 33 (binary_expr -> expr < expr .)
    >               reduce using rule 33 (binary_expr -> expr < expr .)
    <               reduce using rule 33 (binary_expr -> expr < expr .)
    $end            reduce using rule 33 (binary_expr -> expr < expr .)
    )               reduce using rule 33 (binary_expr -> expr < expr .)
    OF              reduce using rule 33 (binary_expr -> expr < expr .)
    THEN            reduce using rule 33 (binary_expr -> expr < expr .)
    END             reduce using rule 33 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr < expr .)
    ,               reduce using rule 33 (binary_expr -> expr < expr .)
    ]               reduce using rule 33 (binary_expr -> expr < expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    |               shift and go to state 41
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 73

    (34) binary_expr -> expr * expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 34 (binary_expr -> expr * expr .)
    INT_DIV         reduce using rule 34 (binary_expr -> expr * expr .)
    EQUAL           reduce using rule 34 (binary_expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 34 (binary_expr -> expr * expr .)
    |               reduce using rule 34 (binary_expr -> expr * expr .)
    >               reduce using rule 34 (binary_expr -> expr * expr .)
    %               reduce using rule 34 (binary_expr -> expr * expr .)
    <               reduce using rule 34 (binary_expr -> expr * expr .)
    *               reduce using rule 34 (binary_expr -> expr * expr .)
    /               reduce using rule 34 (binary_expr -> expr * expr .)
    -               reduce using rule 34 (binary_expr -> expr * expr .)
    +               reduce using rule 34 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr * expr .)
    $end            reduce using rule 34 (binary_expr -> expr * expr .)
    )               reduce using rule 34 (binary_expr -> expr * expr .)
    OF              reduce using rule 34 (binary_expr -> expr * expr .)
    THEN            reduce using rule 34 (binary_expr -> expr * expr .)
    END             reduce using rule 34 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr * expr .)
    ,               reduce using rule 34 (binary_expr -> expr * expr .)
    ]               reduce using rule 34 (binary_expr -> expr * expr .)
    (               shift and go to state 37


state 74

    (35) binary_expr -> expr / expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 35 (binary_expr -> expr / expr .)
    INT_DIV         reduce using rule 35 (binary_expr -> expr / expr .)
    EQUAL           reduce using rule 35 (binary_expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 35 (binary_expr -> expr / expr .)
    |               reduce using rule 35 (binary_expr -> expr / expr .)
    >               reduce using rule 35 (binary_expr -> expr / expr .)
    %               reduce using rule 35 (binary_expr -> expr / expr .)
    <               reduce using rule 35 (binary_expr -> expr / expr .)
    *               reduce using rule 35 (binary_expr -> expr / expr .)
    /               reduce using rule 35 (binary_expr -> expr / expr .)
    -               reduce using rule 35 (binary_expr -> expr / expr .)
    +               reduce using rule 35 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 35 (binary_expr -> expr / expr .)
    $end            reduce using rule 35 (binary_expr -> expr / expr .)
    )               reduce using rule 35 (binary_expr -> expr / expr .)
    OF              reduce using rule 35 (binary_expr -> expr / expr .)
    THEN            reduce using rule 35 (binary_expr -> expr / expr .)
    END             reduce using rule 35 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr / expr .)
    ,               reduce using rule 35 (binary_expr -> expr / expr .)
    ]               reduce using rule 35 (binary_expr -> expr / expr .)
    (               shift and go to state 37


state 75

    (36) binary_expr -> expr - expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 36 (binary_expr -> expr - expr .)
    EQUAL           reduce using rule 36 (binary_expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 36 (binary_expr -> expr - expr .)
    |               reduce using rule 36 (binary_expr -> expr - expr .)
    >               reduce using rule 36 (binary_expr -> expr - expr .)
    <               reduce using rule 36 (binary_expr -> expr - expr .)
    -               reduce using rule 36 (binary_expr -> expr - expr .)
    +               reduce using rule 36 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 36 (binary_expr -> expr - expr .)
    $end            reduce using rule 36 (binary_expr -> expr - expr .)
    )               reduce using rule 36 (binary_expr -> expr - expr .)
    OF              reduce using rule 36 (binary_expr -> expr - expr .)
    THEN            reduce using rule 36 (binary_expr -> expr - expr .)
    END             reduce using rule 36 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 36 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 36 (binary_expr -> expr - expr .)
    ,               reduce using rule 36 (binary_expr -> expr - expr .)
    ]               reduce using rule 36 (binary_expr -> expr - expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46


state 76

    (37) binary_expr -> expr + expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 37 (binary_expr -> expr + expr .)
    EQUAL           reduce using rule 37 (binary_expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 37 (binary_expr -> expr + expr .)
    |               reduce using rule 37 (binary_expr -> expr + expr .)
    >               reduce using rule 37 (binary_expr -> expr + expr .)
    <               reduce using rule 37 (binary_expr -> expr + expr .)
    -               reduce using rule 37 (binary_expr -> expr + expr .)
    +               reduce using rule 37 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 37 (binary_expr -> expr + expr .)
    $end            reduce using rule 37 (binary_expr -> expr + expr .)
    )               reduce using rule 37 (binary_expr -> expr + expr .)
    OF              reduce using rule 37 (binary_expr -> expr + expr .)
    THEN            reduce using rule 37 (binary_expr -> expr + expr .)
    END             reduce using rule 37 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 37 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 37 (binary_expr -> expr + expr .)
    ,               reduce using rule 37 (binary_expr -> expr + expr .)
    ]               reduce using rule 37 (binary_expr -> expr + expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46


state 77

    (38) binary_expr -> expr CONCAT expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    EQUAL           reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    NOT_EQUAL       reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    |               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    -               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    +               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46


state 78

    (11) expr -> ( expr ) .
    NEWLINE         reduce using rule 11 (expr -> ( expr ) .)
    (               reduce using rule 11 (expr -> ( expr ) .)
    INT_DIV         reduce using rule 11 (expr -> ( expr ) .)
    EQUAL           reduce using rule 11 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 11 (expr -> ( expr ) .)
    |               reduce using rule 11 (expr -> ( expr ) .)
    >               reduce using rule 11 (expr -> ( expr ) .)
    %               reduce using rule 11 (expr -> ( expr ) .)
    <               reduce using rule 11 (expr -> ( expr ) .)
    *               reduce using rule 11 (expr -> ( expr ) .)
    /               reduce using rule 11 (expr -> ( expr ) .)
    -               reduce using rule 11 (expr -> ( expr ) .)
    +               reduce using rule 11 (expr -> ( expr ) .)
    CONCAT          reduce using rule 11 (expr -> ( expr ) .)
    $end            reduce using rule 11 (expr -> ( expr ) .)
    )               reduce using rule 11 (expr -> ( expr ) .)
    OF              reduce using rule 11 (expr -> ( expr ) .)
    THEN            reduce using rule 11 (expr -> ( expr ) .)
    END             reduce using rule 11 (expr -> ( expr ) .)
    ELIF            reduce using rule 11 (expr -> ( expr ) .)
    ELSE            reduce using rule 11 (expr -> ( expr ) .)
    ,               reduce using rule 11 (expr -> ( expr ) .)
    ]               reduce using rule 11 (expr -> ( expr ) .)


state 79

    (174) let -> identifier _48_0x3a_type_optional = . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    identifier                     shift and go to state 13
    expr                           shift and go to state 99
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 80

    (175) _48_0x3a_type_optional -> : type .
    =               reduce using rule 175 (_48_0x3a_type_optional -> : type .)


state 81

    (74) type -> type_identifier . < type _17_0x2c_type_repeat >
    (80) type -> type_identifier .
    <               shift and go to state 100
    =               reduce using rule 80 (type -> type_identifier .)
    NEWLINE         reduce using rule 80 (type -> type_identifier .)
    END             reduce using rule 80 (type -> type_identifier .)
    -               reduce using rule 80 (type -> type_identifier .)
    (               reduce using rule 80 (type -> type_identifier .)
    STRING          reduce using rule 80 (type -> type_identifier .)
    NUMBER          reduce using rule 80 (type -> type_identifier .)
    [               reduce using rule 80 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 80 (type -> type_identifier .)
    CASE            reduce using rule 80 (type -> type_identifier .)
    IF              reduce using rule 80 (type -> type_identifier .)
    DEF             reduce using rule 80 (type -> type_identifier .)
    DO              reduce using rule 80 (type -> type_identifier .)
    EXTERNAL        reduce using rule 80 (type -> type_identifier .)
    ENUM            reduce using rule 80 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 80 (type -> type_identifier .)
    ,               reduce using rule 80 (type -> type_identifier .)
    >               reduce using rule 80 (type -> type_identifier .)
    ELIF            reduce using rule 80 (type -> type_identifier .)
    ELSE            reduce using rule 80 (type -> type_identifier .)
    )               reduce using rule 80 (type -> type_identifier .)


state 82

    (149) array -> [ _39_NEWLINE_optional _40_exprs_optional . ]
    ]               shift and go to state 101


state 83

    (152) _40_exprs_optional -> exprs .
    (167) exprs -> exprs . , _46_NEWLINE_optional expr _47_NEWLINE_optional
    ]               reduce using rule 152 (_40_exprs_optional -> exprs .)
    ,               shift and go to state 102


state 84

    (164) exprs -> expr . _45_NEWLINE_optional
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    (165) _45_NEWLINE_optional -> . NEWLINE
    (166) _45_NEWLINE_optional -> .
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49
    NEWLINE         shift and go to state 104
    ,               reduce using rule 166 (_45_NEWLINE_optional -> .)
    ]               reduce using rule 166 (_45_NEWLINE_optional -> .)
    )               reduce using rule 166 (_45_NEWLINE_optional -> .)

    _45_NEWLINE_optional           shift and go to state 103

state 85

    (159) variant_call -> type_identifier ( _43_NEWLINE_optional . _44_exprs_optional )
    (162) _44_exprs_optional -> . exprs
    (163) _44_exprs_optional -> .
    (164) exprs -> . expr _45_NEWLINE_optional
    (167) exprs -> . exprs , _46_NEWLINE_optional expr _47_NEWLINE_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 163 (_44_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 26
    _44_exprs_optional             shift and go to state 105
    exprs                          shift and go to state 106
    expr                           shift and go to state 84
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22

state 86

    (160) _43_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 160 (_43_NEWLINE_optional -> NEWLINE .)


state 87

    (121) case_of -> CASE expr OF . _30_NEWLINE_optional _31_cases_optional END
    (122) _30_NEWLINE_optional -> . NEWLINE
    (123) _30_NEWLINE_optional -> .
    NEWLINE         shift and go to state 108
    TYPE_IDENTIFIER reduce using rule 123 (_30_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 123 (_30_NEWLINE_optional -> .)
    END             reduce using rule 123 (_30_NEWLINE_optional -> .)

    _30_NEWLINE_optional           shift and go to state 107

state 88

    (112) if_expr -> IF expr THEN . _27_0x3a_type_optional block_statement _28_or_else_optional END
    (113) _27_0x3a_type_optional -> . : type
    (114) _27_0x3a_type_optional -> .
    :               shift and go to state 110
    NEWLINE         reduce using rule 114 (_27_0x3a_type_optional -> .)
    ELIF            reduce using rule 114 (_27_0x3a_type_optional -> .)
    ELSE            reduce using rule 114 (_27_0x3a_type_optional -> .)
    END             reduce using rule 114 (_27_0x3a_type_optional -> .)
    -               reduce using rule 114 (_27_0x3a_type_optional -> .)
    (               reduce using rule 114 (_27_0x3a_type_optional -> .)
    STRING          reduce using rule 114 (_27_0x3a_type_optional -> .)
    NUMBER          reduce using rule 114 (_27_0x3a_type_optional -> .)
    [               reduce using rule 114 (_27_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 114 (_27_0x3a_type_optional -> .)
    CASE            reduce using rule 114 (_27_0x3a_type_optional -> .)
    IF              reduce using rule 114 (_27_0x3a_type_optional -> .)
    DEF             reduce using rule 114 (_27_0x3a_type_optional -> .)
    DO              reduce using rule 114 (_27_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 114 (_27_0x3a_type_optional -> .)
    ENUM            reduce using rule 114 (_27_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 114 (_27_0x3a_type_optional -> .)

    _27_0x3a_type_optional         shift and go to state 109

state 89

    (47) def_expr -> DEF identifier ( . _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (48) _7_NEWLINE_optional -> . NEWLINE
    (49) _7_NEWLINE_optional -> .
    NEWLINE         shift and go to state 112
    IDENTIFIER      reduce using rule 49 (_7_NEWLINE_optional -> .)
    )               reduce using rule 49 (_7_NEWLINE_optional -> .)

    _7_NEWLINE_optional            shift and go to state 111

state 90

    (54) def_expr -> DEF identifier < . type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 113

state 91

    (39) do -> DO _4_0x3a_type_optional block_statement . END
    END             shift and go to state 114


state 92

    (42) block_statement -> _5_NEWLINE_optional . _6_do_exprs_optional
    (45) _6_do_exprs_optional -> . do_exprs
    (46) _6_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 46 (_6_do_exprs_optional -> .)
    ELIF            reduce using rule 46 (_6_do_exprs_optional -> .)
    ELSE            reduce using rule 46 (_6_do_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _6_do_exprs_optional           shift and go to state 115
    do_exprs                       shift and go to state 116
    expr                           shift and go to state 6
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 93

    (43) _5_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 43 (_5_NEWLINE_optional -> NEWLINE .)


state 94

    (40) _4_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    END             reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    -               reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    (               reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    STRING          reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    NUMBER          reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    [               reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    CASE            reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    IF              reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    DEF             reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    DO              reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 40 (_4_0x3a_type_optional -> : type .)


state 95

    (81) enum -> ENUM type_identifier { . _18_NEWLINE_optional _19_variants_optional }
    (82) _18_NEWLINE_optional -> . NEWLINE
    (83) _18_NEWLINE_optional -> .
    NEWLINE         shift and go to state 118
    TYPE_IDENTIFIER reduce using rule 83 (_18_NEWLINE_optional -> .)
    }               reduce using rule 83 (_18_NEWLINE_optional -> .)

    _18_NEWLINE_optional           shift and go to state 117

state 96

    (86) enum -> ENUM type_identifier < . type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 119

state 97

    (154) call -> expr ( _41_NEWLINE_optional _42_exprs_optional . )
    )               shift and go to state 120


state 98

    (157) _42_exprs_optional -> exprs .
    (167) exprs -> exprs . , _46_NEWLINE_optional expr _47_NEWLINE_optional
    )               reduce using rule 157 (_42_exprs_optional -> exprs .)
    ,               shift and go to state 102


state 99

    (174) let -> identifier _48_0x3a_type_optional = expr .
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    $end            reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    )               reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    OF              reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    THEN            reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    END             reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    ELIF            reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    ELSE            reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    ,               reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    ]               reduce using rule 174 (let -> identifier _48_0x3a_type_optional = expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 100

    (74) type -> type_identifier < . type _17_0x2c_type_repeat >
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 81
    type                           shift and go to state 121

state 101

    (149) array -> [ _39_NEWLINE_optional _40_exprs_optional ] .
    NEWLINE         reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    (               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    INT_DIV         reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    EQUAL           reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    NOT_EQUAL       reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    |               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    >               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    %               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    <               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    *               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    /               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    -               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    +               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    CONCAT          reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    $end            reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    )               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    OF              reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    THEN            reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    END             reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    ELIF            reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    ELSE            reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    ,               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)
    ]               reduce using rule 149 (array -> [ _39_NEWLINE_optional _40_exprs_optional ] .)


state 102

    (167) exprs -> exprs , . _46_NEWLINE_optional expr _47_NEWLINE_optional
    (168) _46_NEWLINE_optional -> . NEWLINE
    (169) _46_NEWLINE_optional -> .
    NEWLINE         shift and go to state 123
    -               reduce using rule 169 (_46_NEWLINE_optional -> .)
    (               reduce using rule 169 (_46_NEWLINE_optional -> .)
    STRING          reduce using rule 169 (_46_NEWLINE_optional -> .)
    NUMBER          reduce using rule 169 (_46_NEWLINE_optional -> .)
    [               reduce using rule 169 (_46_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 169 (_46_NEWLINE_optional -> .)
    CASE            reduce using rule 169 (_46_NEWLINE_optional -> .)
    IF              reduce using rule 169 (_46_NEWLINE_optional -> .)
    DEF             reduce using rule 169 (_46_NEWLINE_optional -> .)
    DO              reduce using rule 169 (_46_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 169 (_46_NEWLINE_optional -> .)
    ENUM            reduce using rule 169 (_46_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 169 (_46_NEWLINE_optional -> .)

    _46_NEWLINE_optional           shift and go to state 122

state 103

    (164) exprs -> expr _45_NEWLINE_optional .
    ,               reduce using rule 164 (exprs -> expr _45_NEWLINE_optional .)
    ]               reduce using rule 164 (exprs -> expr _45_NEWLINE_optional .)
    )               reduce using rule 164 (exprs -> expr _45_NEWLINE_optional .)


state 104

    (165) _45_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 165 (_45_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 165 (_45_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 165 (_45_NEWLINE_optional -> NEWLINE .)


state 105

    (159) variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional . )
    )               shift and go to state 124


state 106

    (162) _44_exprs_optional -> exprs .
    (167) exprs -> exprs . , _46_NEWLINE_optional expr _47_NEWLINE_optional
    )               reduce using rule 162 (_44_exprs_optional -> exprs .)
    ,               shift and go to state 102


state 107

    (121) case_of -> CASE expr OF _30_NEWLINE_optional . _31_cases_optional END
    (124) _31_cases_optional -> . cases
    (125) _31_cases_optional -> .
    (126) cases -> . pattern do _32_NEWLINE_optional
    (129) cases -> . cases pattern do _33_NEWLINE_optional
    (132) pattern -> . match_variant
    (133) pattern -> . match_as
    (135) match_variant -> . type_identifier
    (136) match_variant -> . type_identifier ( _34_NEWLINE_optional _35_patterns_optional )
    (134) match_as -> . identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    (172) identifier -> . IDENTIFIER
    END             reduce using rule 125 (_31_cases_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 27

    _31_cases_optional             shift and go to state 125
    cases                          shift and go to state 126
    pattern                        shift and go to state 127
    match_variant                  shift and go to state 128
    match_as                       shift and go to state 129
    type_identifier                shift and go to state 130
    identifier                     shift and go to state 131

state 108

    (122) _30_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 122 (_30_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 122 (_30_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 122 (_30_NEWLINE_optional -> NEWLINE .)


state 109

    (112) if_expr -> IF expr THEN _27_0x3a_type_optional . block_statement _28_or_else_optional END
    (42) block_statement -> . _5_NEWLINE_optional _6_do_exprs_optional
    (43) _5_NEWLINE_optional -> . NEWLINE
    (44) _5_NEWLINE_optional -> .
    NEWLINE         shift and go to state 93
    -               reduce using rule 44 (_5_NEWLINE_optional -> .)
    (               reduce using rule 44 (_5_NEWLINE_optional -> .)
    STRING          reduce using rule 44 (_5_NEWLINE_optional -> .)
    NUMBER          reduce using rule 44 (_5_NEWLINE_optional -> .)
    [               reduce using rule 44 (_5_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 44 (_5_NEWLINE_optional -> .)
    CASE            reduce using rule 44 (_5_NEWLINE_optional -> .)
    IF              reduce using rule 44 (_5_NEWLINE_optional -> .)
    DEF             reduce using rule 44 (_5_NEWLINE_optional -> .)
    DO              reduce using rule 44 (_5_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 44 (_5_NEWLINE_optional -> .)
    ENUM            reduce using rule 44 (_5_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 44 (_5_NEWLINE_optional -> .)
    ELIF            reduce using rule 44 (_5_NEWLINE_optional -> .)
    ELSE            reduce using rule 44 (_5_NEWLINE_optional -> .)
    END             reduce using rule 44 (_5_NEWLINE_optional -> .)

    block_statement                shift and go to state 132
    _5_NEWLINE_optional            shift and go to state 92

state 110

    (113) _27_0x3a_type_optional -> : . type
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 133
    type_identifier                shift and go to state 81

state 111

    (47) def_expr -> DEF identifier ( _7_NEWLINE_optional . _8_params_optional ) _9_0x3a_type_optional do
    (50) _8_params_optional -> . params
    (51) _8_params_optional -> .
    (66) params -> . param _14_NEWLINE_optional
    (69) params -> . params , _15_NEWLINE_optional param _16_NEWLINE_optional
    (109) param -> . identifier _26_0x3a_type_optional
    (172) identifier -> . IDENTIFIER
    )               reduce using rule 51 (_8_params_optional -> .)
    IDENTIFIER      shift and go to state 27

    identifier                     shift and go to state 134
    _8_params_optional             shift and go to state 135
    params                         shift and go to state 136
    param                          shift and go to state 137

state 112

    (48) _7_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 48 (_7_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 48 (_7_NEWLINE_optional -> NEWLINE .)


state 113

    (54) def_expr -> DEF identifier < type_identifier . _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (55) _10_0x2c_type_identifier_repeat -> . _10_0x2c_type_identifier_items
    (56) _10_0x2c_type_identifier_repeat -> .
    (57) _10_0x2c_type_identifier_items -> . _10_0x2c_type_identifier_items _10_0x2c_type_identifier_item
    (58) _10_0x2c_type_identifier_items -> . _10_0x2c_type_identifier_item
    (59) _10_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 56 (_10_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 141

    _10_0x2c_type_identifier_repeat shift and go to state 138
    _10_0x2c_type_identifier_items shift and go to state 139
    _10_0x2c_type_identifier_item  shift and go to state 140

state 114

    (39) do -> DO _4_0x3a_type_optional block_statement END .
    NEWLINE         reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    (               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    INT_DIV         reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    EQUAL           reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    NOT_EQUAL       reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    |               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    >               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    %               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    <               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    *               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    /               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    -               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    +               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    CONCAT          reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    $end            reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    )               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    OF              reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    THEN            reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    END             reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    ELIF            reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    ELSE            reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    ,               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    ]               reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    TYPE_IDENTIFIER reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)
    IDENTIFIER      reduce using rule 39 (do -> DO _4_0x3a_type_optional block_statement END .)


state 115

    (42) block_statement -> _5_NEWLINE_optional _6_do_exprs_optional .
    END             reduce using rule 42 (block_statement -> _5_NEWLINE_optional _6_do_exprs_optional .)
    ELIF            reduce using rule 42 (block_statement -> _5_NEWLINE_optional _6_do_exprs_optional .)
    ELSE            reduce using rule 42 (block_statement -> _5_NEWLINE_optional _6_do_exprs_optional .)


state 116

    (45) _6_do_exprs_optional -> do_exprs .
    END             reduce using rule 45 (_6_do_exprs_optional -> do_exprs .)
    ELIF            reduce using rule 45 (_6_do_exprs_optional -> do_exprs .)
    ELSE            reduce using rule 45 (_6_do_exprs_optional -> do_exprs .)


state 117

    (81) enum -> ENUM type_identifier { _18_NEWLINE_optional . _19_variants_optional }
    (84) _19_variants_optional -> . variants
    (85) _19_variants_optional -> .
    (96) variants -> . variant _23_NEWLINE_optional
    (99) variants -> . variants variant _24_NEWLINE_optional
    (102) variant -> . type_identifier
    (103) variant -> . type_identifier ( type _25_0x2c_type_repeat )
    (173) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 85 (_19_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 142
    _19_variants_optional          shift and go to state 143
    variants                       shift and go to state 144
    variant                        shift and go to state 145

state 118

    (82) _18_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 82 (_18_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 82 (_18_NEWLINE_optional -> NEWLINE .)


state 119

    (86) enum -> ENUM type_identifier < type_identifier . _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (87) _20_0x2c_type_identifier_repeat -> . _20_0x2c_type_identifier_items
    (88) _20_0x2c_type_identifier_repeat -> .
    (89) _20_0x2c_type_identifier_items -> . _20_0x2c_type_identifier_items _20_0x2c_type_identifier_item
    (90) _20_0x2c_type_identifier_items -> . _20_0x2c_type_identifier_item
    (91) _20_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 88 (_20_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 149

    _20_0x2c_type_identifier_repeat shift and go to state 146
    _20_0x2c_type_identifier_items shift and go to state 147
    _20_0x2c_type_identifier_item  shift and go to state 148

state 120

    (154) call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .
    NEWLINE         reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    (               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    INT_DIV         reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    EQUAL           reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    |               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    >               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    %               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    <               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    *               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    /               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    -               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    +               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    CONCAT          reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    $end            reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    )               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    OF              reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    THEN            reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    END             reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    ELIF            reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    ELSE            reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    ,               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)
    ]               reduce using rule 154 (call -> expr ( _41_NEWLINE_optional _42_exprs_optional ) .)


state 121

    (74) type -> type_identifier < type . _17_0x2c_type_repeat >
    (75) _17_0x2c_type_repeat -> . _17_0x2c_type_items
    (76) _17_0x2c_type_repeat -> .
    (77) _17_0x2c_type_items -> . _17_0x2c_type_items _17_0x2c_type_item
    (78) _17_0x2c_type_items -> . _17_0x2c_type_item
    (79) _17_0x2c_type_item -> . , type
    >               reduce using rule 76 (_17_0x2c_type_repeat -> .)
    ,               shift and go to state 153

    _17_0x2c_type_repeat           shift and go to state 150
    _17_0x2c_type_items            shift and go to state 151
    _17_0x2c_type_item             shift and go to state 152

state 122

    (167) exprs -> exprs , _46_NEWLINE_optional . expr _47_NEWLINE_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 154
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 123

    (168) _46_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 168 (_46_NEWLINE_optional -> NEWLINE .)


state 124

    (159) variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .
    NEWLINE         reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    (               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    INT_DIV         reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    EQUAL           reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    |               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    >               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    %               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    <               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    *               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    /               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    -               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    +               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    CONCAT          reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    $end            reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    )               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    OF              reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    THEN            reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    END             reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ELIF            reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ELSE            reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ,               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ]               reduce using rule 159 (variant_call -> type_identifier ( _43_NEWLINE_optional _44_exprs_optional ) .)


state 125

    (121) case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional . END
    END             shift and go to state 155


state 126

    (124) _31_cases_optional -> cases .
    (129) cases -> cases . pattern do _33_NEWLINE_optional
    (132) pattern -> . match_variant
    (133) pattern -> . match_as
    (135) match_variant -> . type_identifier
    (136) match_variant -> . type_identifier ( _34_NEWLINE_optional _35_patterns_optional )
    (134) match_as -> . identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    (172) identifier -> . IDENTIFIER
    END             reduce using rule 124 (_31_cases_optional -> cases .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 27

    pattern                        shift and go to state 156
    match_variant                  shift and go to state 128
    match_as                       shift and go to state 129
    type_identifier                shift and go to state 130
    identifier                     shift and go to state 131

state 127

    (126) cases -> pattern . do _32_NEWLINE_optional
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    DO              shift and go to state 31

    do                             shift and go to state 157

state 128

    (132) pattern -> match_variant .
    DO              reduce using rule 132 (pattern -> match_variant .)
    NEWLINE         reduce using rule 132 (pattern -> match_variant .)
    ,               reduce using rule 132 (pattern -> match_variant .)
    )               reduce using rule 132 (pattern -> match_variant .)


state 129

    (133) pattern -> match_as .
    DO              reduce using rule 133 (pattern -> match_as .)
    NEWLINE         reduce using rule 133 (pattern -> match_as .)
    ,               reduce using rule 133 (pattern -> match_as .)
    )               reduce using rule 133 (pattern -> match_as .)


state 130

    (135) match_variant -> type_identifier .
    (136) match_variant -> type_identifier . ( _34_NEWLINE_optional _35_patterns_optional )
    DO              reduce using rule 135 (match_variant -> type_identifier .)
    NEWLINE         reduce using rule 135 (match_variant -> type_identifier .)
    ,               reduce using rule 135 (match_variant -> type_identifier .)
    )               reduce using rule 135 (match_variant -> type_identifier .)
    (               shift and go to state 158


state 131

    (134) match_as -> identifier .
    DO              reduce using rule 134 (match_as -> identifier .)
    NEWLINE         reduce using rule 134 (match_as -> identifier .)
    ,               reduce using rule 134 (match_as -> identifier .)
    )               reduce using rule 134 (match_as -> identifier .)


state 132

    (112) if_expr -> IF expr THEN _27_0x3a_type_optional block_statement . _28_or_else_optional END
    (115) _28_or_else_optional -> . or_else
    (116) _28_or_else_optional -> .
    (117) or_else -> . ELIF expr THEN block_statement _29_or_else_optional
    (120) or_else -> . ELSE block_statement
    END             reduce using rule 116 (_28_or_else_optional -> .)
    ELIF            shift and go to state 161
    ELSE            shift and go to state 162

    _28_or_else_optional           shift and go to state 159
    or_else                        shift and go to state 160

state 133

    (113) _27_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    ELIF            reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    ELSE            reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    END             reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    -               reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    (               reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    STRING          reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    NUMBER          reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    [               reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    CASE            reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    IF              reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    DEF             reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    DO              reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 113 (_27_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 113 (_27_0x3a_type_optional -> : type .)


state 134

    (109) param -> identifier . _26_0x3a_type_optional
    (110) _26_0x3a_type_optional -> . : type
    (111) _26_0x3a_type_optional -> .
    :               shift and go to state 164
    NEWLINE         reduce using rule 111 (_26_0x3a_type_optional -> .)
    ,               reduce using rule 111 (_26_0x3a_type_optional -> .)
    )               reduce using rule 111 (_26_0x3a_type_optional -> .)

    _26_0x3a_type_optional         shift and go to state 163

state 135

    (47) def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional . ) _9_0x3a_type_optional do
    )               shift and go to state 165


state 136

    (50) _8_params_optional -> params .
    (69) params -> params . , _15_NEWLINE_optional param _16_NEWLINE_optional
    )               reduce using rule 50 (_8_params_optional -> params .)
    ,               shift and go to state 166


state 137

    (66) params -> param . _14_NEWLINE_optional
    (67) _14_NEWLINE_optional -> . NEWLINE
    (68) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 168
    ,               reduce using rule 68 (_14_NEWLINE_optional -> .)
    )               reduce using rule 68 (_14_NEWLINE_optional -> .)

    _14_NEWLINE_optional           shift and go to state 167

state 138

    (54) def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat . > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    >               shift and go to state 169


state 139

    (55) _10_0x2c_type_identifier_repeat -> _10_0x2c_type_identifier_items .
    (57) _10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_items . _10_0x2c_type_identifier_item
    (59) _10_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 55 (_10_0x2c_type_identifier_repeat -> _10_0x2c_type_identifier_items .)
    ,               shift and go to state 141

    _10_0x2c_type_identifier_item  shift and go to state 170

state 140

    (58) _10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_item .
    ,               reduce using rule 58 (_10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_item .)
    >               reduce using rule 58 (_10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_item .)


state 141

    (59) _10_0x2c_type_identifier_item -> , . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 171

state 142

    (102) variant -> type_identifier .
    (103) variant -> type_identifier . ( type _25_0x2c_type_repeat )
    NEWLINE         reduce using rule 102 (variant -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 102 (variant -> type_identifier .)
    }               reduce using rule 102 (variant -> type_identifier .)
    (               shift and go to state 172


state 143

    (81) enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional . }
    }               shift and go to state 173


state 144

    (84) _19_variants_optional -> variants .
    (99) variants -> variants . variant _24_NEWLINE_optional
    (102) variant -> . type_identifier
    (103) variant -> . type_identifier ( type _25_0x2c_type_repeat )
    (173) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 84 (_19_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 34

    variant                        shift and go to state 174
    type_identifier                shift and go to state 142

state 145

    (96) variants -> variant . _23_NEWLINE_optional
    (97) _23_NEWLINE_optional -> . NEWLINE
    (98) _23_NEWLINE_optional -> .
    NEWLINE         shift and go to state 176
    TYPE_IDENTIFIER reduce using rule 98 (_23_NEWLINE_optional -> .)
    }               reduce using rule 98 (_23_NEWLINE_optional -> .)

    _23_NEWLINE_optional           shift and go to state 175

state 146

    (86) enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat . > { _21_NEWLINE_optional _22_variants_optional }
    >               shift and go to state 177


state 147

    (87) _20_0x2c_type_identifier_repeat -> _20_0x2c_type_identifier_items .
    (89) _20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_items . _20_0x2c_type_identifier_item
    (91) _20_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 87 (_20_0x2c_type_identifier_repeat -> _20_0x2c_type_identifier_items .)
    ,               shift and go to state 149

    _20_0x2c_type_identifier_item  shift and go to state 178

state 148

    (90) _20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_item .
    ,               reduce using rule 90 (_20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_item .)
    >               reduce using rule 90 (_20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_item .)


state 149

    (91) _20_0x2c_type_identifier_item -> , . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 179

state 150

    (74) type -> type_identifier < type _17_0x2c_type_repeat . >
    >               shift and go to state 180


state 151

    (75) _17_0x2c_type_repeat -> _17_0x2c_type_items .
    (77) _17_0x2c_type_items -> _17_0x2c_type_items . _17_0x2c_type_item
    (79) _17_0x2c_type_item -> . , type
    >               reduce using rule 75 (_17_0x2c_type_repeat -> _17_0x2c_type_items .)
    ,               shift and go to state 153

    _17_0x2c_type_item             shift and go to state 181

state 152

    (78) _17_0x2c_type_items -> _17_0x2c_type_item .
    ,               reduce using rule 78 (_17_0x2c_type_items -> _17_0x2c_type_item .)
    >               reduce using rule 78 (_17_0x2c_type_items -> _17_0x2c_type_item .)


state 153

    (79) _17_0x2c_type_item -> , . type
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 182
    type_identifier                shift and go to state 81

state 154

    (167) exprs -> exprs , _46_NEWLINE_optional expr . _47_NEWLINE_optional
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    (170) _47_NEWLINE_optional -> . NEWLINE
    (171) _47_NEWLINE_optional -> .
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49
    NEWLINE         shift and go to state 184
    ,               reduce using rule 171 (_47_NEWLINE_optional -> .)
    ]               reduce using rule 171 (_47_NEWLINE_optional -> .)
    )               reduce using rule 171 (_47_NEWLINE_optional -> .)

    _47_NEWLINE_optional           shift and go to state 183

state 155

    (121) case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .
    NEWLINE         reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    (               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    INT_DIV         reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    EQUAL           reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    NOT_EQUAL       reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    |               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    >               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    %               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    <               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    *               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    /               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    -               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    +               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    CONCAT          reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    $end            reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    )               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    OF              reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    THEN            reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    END             reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    ELIF            reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    ELSE            reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    ,               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)
    ]               reduce using rule 121 (case_of -> CASE expr OF _30_NEWLINE_optional _31_cases_optional END .)


state 156

    (129) cases -> cases pattern . do _33_NEWLINE_optional
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    DO              shift and go to state 31

    do                             shift and go to state 185

state 157

    (126) cases -> pattern do . _32_NEWLINE_optional
    (127) _32_NEWLINE_optional -> . NEWLINE
    (128) _32_NEWLINE_optional -> .
    NEWLINE         shift and go to state 187
    TYPE_IDENTIFIER reduce using rule 128 (_32_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 128 (_32_NEWLINE_optional -> .)
    END             reduce using rule 128 (_32_NEWLINE_optional -> .)

    _32_NEWLINE_optional           shift and go to state 186

state 158

    (136) match_variant -> type_identifier ( . _34_NEWLINE_optional _35_patterns_optional )
    (137) _34_NEWLINE_optional -> . NEWLINE
    (138) _34_NEWLINE_optional -> .
    NEWLINE         shift and go to state 189
    TYPE_IDENTIFIER reduce using rule 138 (_34_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 138 (_34_NEWLINE_optional -> .)
    )               reduce using rule 138 (_34_NEWLINE_optional -> .)

    _34_NEWLINE_optional           shift and go to state 188

state 159

    (112) if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional . END
    END             shift and go to state 190


state 160

    (115) _28_or_else_optional -> or_else .
    END             reduce using rule 115 (_28_or_else_optional -> or_else .)


state 161

    (117) or_else -> ELIF . expr THEN block_statement _29_or_else_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . str_literal
    (13) expr -> . num_literal
    (14) expr -> . array
    (15) expr -> . variant_call
    (16) expr -> . identifier
    (17) expr -> . let
    (18) expr -> . call
    (19) expr -> . case_of
    (20) expr -> . binary_expr
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . do
    (24) expr -> . external
    (25) expr -> . enum
    (178) str_literal -> . STRING
    (177) num_literal -> . NUMBER
    (149) array -> . [ _39_NEWLINE_optional _40_exprs_optional ]
    (159) variant_call -> . type_identifier ( _43_NEWLINE_optional _44_exprs_optional )
    (172) identifier -> . IDENTIFIER
    (174) let -> . identifier _48_0x3a_type_optional = expr
    (154) call -> . expr ( _41_NEWLINE_optional _42_exprs_optional )
    (121) case_of -> . CASE expr OF _30_NEWLINE_optional _31_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (112) if_expr -> . IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END
    (47) def_expr -> . DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do
    (54) def_expr -> . DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    (26) external -> . EXTERNAL
    (81) enum -> . ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional }
    (86) enum -> . ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional }
    (173) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    STRING          shift and go to state 23
    NUMBER          shift and go to state 24
    [               shift and go to state 25
    IDENTIFIER      shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    DEF             shift and go to state 30
    DO              shift and go to state 31
    EXTERNAL        shift and go to state 32
    ENUM            shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 191
    str_literal                    shift and go to state 9
    num_literal                    shift and go to state 10
    array                          shift and go to state 11
    variant_call                   shift and go to state 12
    identifier                     shift and go to state 13
    let                            shift and go to state 14
    call                           shift and go to state 15
    case_of                        shift and go to state 16
    binary_expr                    shift and go to state 17
    if_expr                        shift and go to state 18
    def_expr                       shift and go to state 19
    do                             shift and go to state 20
    external                       shift and go to state 21
    enum                           shift and go to state 22
    type_identifier                shift and go to state 26

state 162

    (120) or_else -> ELSE . block_statement
    (42) block_statement -> . _5_NEWLINE_optional _6_do_exprs_optional
    (43) _5_NEWLINE_optional -> . NEWLINE
    (44) _5_NEWLINE_optional -> .
    NEWLINE         shift and go to state 93
    -               reduce using rule 44 (_5_NEWLINE_optional -> .)
    (               reduce using rule 44 (_5_NEWLINE_optional -> .)
    STRING          reduce using rule 44 (_5_NEWLINE_optional -> .)
    NUMBER          reduce using rule 44 (_5_NEWLINE_optional -> .)
    [               reduce using rule 44 (_5_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 44 (_5_NEWLINE_optional -> .)
    CASE            reduce using rule 44 (_5_NEWLINE_optional -> .)
    IF              reduce using rule 44 (_5_NEWLINE_optional -> .)
    DEF             reduce using rule 44 (_5_NEWLINE_optional -> .)
    DO              reduce using rule 44 (_5_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 44 (_5_NEWLINE_optional -> .)
    ENUM            reduce using rule 44 (_5_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 44 (_5_NEWLINE_optional -> .)
    END             reduce using rule 44 (_5_NEWLINE_optional -> .)

    block_statement                shift and go to state 192
    _5_NEWLINE_optional            shift and go to state 92

state 163

    (109) param -> identifier _26_0x3a_type_optional .
    NEWLINE         reduce using rule 109 (param -> identifier _26_0x3a_type_optional .)
    ,               reduce using rule 109 (param -> identifier _26_0x3a_type_optional .)
    )               reduce using rule 109 (param -> identifier _26_0x3a_type_optional .)


state 164

    (110) _26_0x3a_type_optional -> : . type
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 193
    type_identifier                shift and go to state 81

state 165

    (47) def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) . _9_0x3a_type_optional do
    (52) _9_0x3a_type_optional -> . : type
    (53) _9_0x3a_type_optional -> .
    :               shift and go to state 195
    DO              reduce using rule 53 (_9_0x3a_type_optional -> .)

    _9_0x3a_type_optional          shift and go to state 194

state 166

    (69) params -> params , . _15_NEWLINE_optional param _16_NEWLINE_optional
    (70) _15_NEWLINE_optional -> . NEWLINE
    (71) _15_NEWLINE_optional -> .
    NEWLINE         shift and go to state 197
    IDENTIFIER      reduce using rule 71 (_15_NEWLINE_optional -> .)

    _15_NEWLINE_optional           shift and go to state 196

state 167

    (66) params -> param _14_NEWLINE_optional .
    ,               reduce using rule 66 (params -> param _14_NEWLINE_optional .)
    )               reduce using rule 66 (params -> param _14_NEWLINE_optional .)


state 168

    (67) _14_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 67 (_14_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 67 (_14_NEWLINE_optional -> NEWLINE .)


state 169

    (54) def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > . ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (               shift and go to state 198


state 170

    (57) _10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_items _10_0x2c_type_identifier_item .
    ,               reduce using rule 57 (_10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_items _10_0x2c_type_identifier_item .)
    >               reduce using rule 57 (_10_0x2c_type_identifier_items -> _10_0x2c_type_identifier_items _10_0x2c_type_identifier_item .)


state 171

    (59) _10_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 59 (_10_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 59 (_10_0x2c_type_identifier_item -> , type_identifier .)


state 172

    (103) variant -> type_identifier ( . type _25_0x2c_type_repeat )
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 81
    type                           shift and go to state 199

state 173

    (81) enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .
    NEWLINE         reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    (               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    INT_DIV         reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    EQUAL           reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    NOT_EQUAL       reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    |               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    >               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    %               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    <               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    *               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    /               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    -               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    +               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    CONCAT          reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    $end            reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    )               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    OF              reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    THEN            reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    END             reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    ELIF            reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    ELSE            reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    ,               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)
    ]               reduce using rule 81 (enum -> ENUM type_identifier { _18_NEWLINE_optional _19_variants_optional } .)


state 174

    (99) variants -> variants variant . _24_NEWLINE_optional
    (100) _24_NEWLINE_optional -> . NEWLINE
    (101) _24_NEWLINE_optional -> .
    NEWLINE         shift and go to state 201
    TYPE_IDENTIFIER reduce using rule 101 (_24_NEWLINE_optional -> .)
    }               reduce using rule 101 (_24_NEWLINE_optional -> .)

    _24_NEWLINE_optional           shift and go to state 200

state 175

    (96) variants -> variant _23_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 96 (variants -> variant _23_NEWLINE_optional .)
    }               reduce using rule 96 (variants -> variant _23_NEWLINE_optional .)


state 176

    (97) _23_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 97 (_23_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 97 (_23_NEWLINE_optional -> NEWLINE .)


state 177

    (86) enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > . { _21_NEWLINE_optional _22_variants_optional }
    {               shift and go to state 202


state 178

    (89) _20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_items _20_0x2c_type_identifier_item .
    ,               reduce using rule 89 (_20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_items _20_0x2c_type_identifier_item .)
    >               reduce using rule 89 (_20_0x2c_type_identifier_items -> _20_0x2c_type_identifier_items _20_0x2c_type_identifier_item .)


state 179

    (91) _20_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 91 (_20_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 91 (_20_0x2c_type_identifier_item -> , type_identifier .)


state 180

    (74) type -> type_identifier < type _17_0x2c_type_repeat > .
    =               reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    NEWLINE         reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    END             reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    -               reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    (               reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    STRING          reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    NUMBER          reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    [               reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    IDENTIFIER      reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    CASE            reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    IF              reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    DEF             reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    DO              reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    EXTERNAL        reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    ENUM            reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    TYPE_IDENTIFIER reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    ,               reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    >               reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    ELIF            reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    ELSE            reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)
    )               reduce using rule 74 (type -> type_identifier < type _17_0x2c_type_repeat > .)


state 181

    (77) _17_0x2c_type_items -> _17_0x2c_type_items _17_0x2c_type_item .
    ,               reduce using rule 77 (_17_0x2c_type_items -> _17_0x2c_type_items _17_0x2c_type_item .)
    >               reduce using rule 77 (_17_0x2c_type_items -> _17_0x2c_type_items _17_0x2c_type_item .)


state 182

    (79) _17_0x2c_type_item -> , type .
    ,               reduce using rule 79 (_17_0x2c_type_item -> , type .)
    >               reduce using rule 79 (_17_0x2c_type_item -> , type .)


state 183

    (167) exprs -> exprs , _46_NEWLINE_optional expr _47_NEWLINE_optional .
    ,               reduce using rule 167 (exprs -> exprs , _46_NEWLINE_optional expr _47_NEWLINE_optional .)
    ]               reduce using rule 167 (exprs -> exprs , _46_NEWLINE_optional expr _47_NEWLINE_optional .)
    )               reduce using rule 167 (exprs -> exprs , _46_NEWLINE_optional expr _47_NEWLINE_optional .)


state 184

    (170) _47_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 170 (_47_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 170 (_47_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 170 (_47_NEWLINE_optional -> NEWLINE .)


state 185

    (129) cases -> cases pattern do . _33_NEWLINE_optional
    (130) _33_NEWLINE_optional -> . NEWLINE
    (131) _33_NEWLINE_optional -> .
    NEWLINE         shift and go to state 204
    TYPE_IDENTIFIER reduce using rule 131 (_33_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 131 (_33_NEWLINE_optional -> .)
    END             reduce using rule 131 (_33_NEWLINE_optional -> .)

    _33_NEWLINE_optional           shift and go to state 203

state 186

    (126) cases -> pattern do _32_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 126 (cases -> pattern do _32_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 126 (cases -> pattern do _32_NEWLINE_optional .)
    END             reduce using rule 126 (cases -> pattern do _32_NEWLINE_optional .)


state 187

    (127) _32_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 127 (_32_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 127 (_32_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 127 (_32_NEWLINE_optional -> NEWLINE .)


state 188

    (136) match_variant -> type_identifier ( _34_NEWLINE_optional . _35_patterns_optional )
    (139) _35_patterns_optional -> . patterns
    (140) _35_patterns_optional -> .
    (141) patterns -> . pattern _36_NEWLINE_optional
    (144) patterns -> . patterns , _37_NEWLINE_optional pattern _38_NEWLINE_optional
    (132) pattern -> . match_variant
    (133) pattern -> . match_as
    (135) match_variant -> . type_identifier
    (136) match_variant -> . type_identifier ( _34_NEWLINE_optional _35_patterns_optional )
    (134) match_as -> . identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    (172) identifier -> . IDENTIFIER
    )               reduce using rule 140 (_35_patterns_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 27

    type_identifier                shift and go to state 130
    _35_patterns_optional          shift and go to state 205
    patterns                       shift and go to state 206
    pattern                        shift and go to state 207
    match_variant                  shift and go to state 128
    match_as                       shift and go to state 129
    identifier                     shift and go to state 131

state 189

    (137) _34_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 137 (_34_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 137 (_34_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 137 (_34_NEWLINE_optional -> NEWLINE .)


state 190

    (112) if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .
    NEWLINE         reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    (               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    INT_DIV         reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    EQUAL           reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    NOT_EQUAL       reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    |               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    >               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    %               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    <               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    *               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    /               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    -               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    +               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    CONCAT          reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    $end            reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    )               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    OF              reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    THEN            reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    END             reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    ELIF            reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    ELSE            reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    ,               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)
    ]               reduce using rule 112 (if_expr -> IF expr THEN _27_0x3a_type_optional block_statement _28_or_else_optional END .)


state 191

    (117) or_else -> ELIF expr . THEN block_statement _29_or_else_optional
    (154) call -> expr . ( _41_NEWLINE_optional _42_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 208
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 192

    (120) or_else -> ELSE block_statement .
    END             reduce using rule 120 (or_else -> ELSE block_statement .)


state 193

    (110) _26_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 110 (_26_0x3a_type_optional -> : type .)
    ,               reduce using rule 110 (_26_0x3a_type_optional -> : type .)
    )               reduce using rule 110 (_26_0x3a_type_optional -> : type .)


state 194

    (47) def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional . do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    DO              shift and go to state 31

    do                             shift and go to state 209

state 195

    (52) _9_0x3a_type_optional -> : . type
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 210
    type_identifier                shift and go to state 81

state 196

    (69) params -> params , _15_NEWLINE_optional . param _16_NEWLINE_optional
    (109) param -> . identifier _26_0x3a_type_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 27

    param                          shift and go to state 211
    identifier                     shift and go to state 134

state 197

    (70) _15_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 70 (_15_NEWLINE_optional -> NEWLINE .)


state 198

    (54) def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( . _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do
    (60) _11_NEWLINE_optional -> . NEWLINE
    (61) _11_NEWLINE_optional -> .
    NEWLINE         shift and go to state 213
    IDENTIFIER      reduce using rule 61 (_11_NEWLINE_optional -> .)
    )               reduce using rule 61 (_11_NEWLINE_optional -> .)

    _11_NEWLINE_optional           shift and go to state 212

state 199

    (103) variant -> type_identifier ( type . _25_0x2c_type_repeat )
    (104) _25_0x2c_type_repeat -> . _25_0x2c_type_items
    (105) _25_0x2c_type_repeat -> .
    (106) _25_0x2c_type_items -> . _25_0x2c_type_items _25_0x2c_type_item
    (107) _25_0x2c_type_items -> . _25_0x2c_type_item
    (108) _25_0x2c_type_item -> . , type
    )               reduce using rule 105 (_25_0x2c_type_repeat -> .)
    ,               shift and go to state 217

    _25_0x2c_type_repeat           shift and go to state 214
    _25_0x2c_type_items            shift and go to state 215
    _25_0x2c_type_item             shift and go to state 216

state 200

    (99) variants -> variants variant _24_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 99 (variants -> variants variant _24_NEWLINE_optional .)
    }               reduce using rule 99 (variants -> variants variant _24_NEWLINE_optional .)


state 201

    (100) _24_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 100 (_24_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 100 (_24_NEWLINE_optional -> NEWLINE .)


state 202

    (86) enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { . _21_NEWLINE_optional _22_variants_optional }
    (92) _21_NEWLINE_optional -> . NEWLINE
    (93) _21_NEWLINE_optional -> .
    NEWLINE         shift and go to state 219
    TYPE_IDENTIFIER reduce using rule 93 (_21_NEWLINE_optional -> .)
    }               reduce using rule 93 (_21_NEWLINE_optional -> .)

    _21_NEWLINE_optional           shift and go to state 218

state 203

    (129) cases -> cases pattern do _33_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 129 (cases -> cases pattern do _33_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 129 (cases -> cases pattern do _33_NEWLINE_optional .)
    END             reduce using rule 129 (cases -> cases pattern do _33_NEWLINE_optional .)


state 204

    (130) _33_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 130 (_33_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 130 (_33_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 130 (_33_NEWLINE_optional -> NEWLINE .)


state 205

    (136) match_variant -> type_identifier ( _34_NEWLINE_optional _35_patterns_optional . )
    )               shift and go to state 220


state 206

    (139) _35_patterns_optional -> patterns .
    (144) patterns -> patterns . , _37_NEWLINE_optional pattern _38_NEWLINE_optional
    )               reduce using rule 139 (_35_patterns_optional -> patterns .)
    ,               shift and go to state 221


state 207

    (141) patterns -> pattern . _36_NEWLINE_optional
    (142) _36_NEWLINE_optional -> . NEWLINE
    (143) _36_NEWLINE_optional -> .
    NEWLINE         shift and go to state 223
    ,               reduce using rule 143 (_36_NEWLINE_optional -> .)
    )               reduce using rule 143 (_36_NEWLINE_optional -> .)

    _36_NEWLINE_optional           shift and go to state 222

state 208

    (117) or_else -> ELIF expr THEN . block_statement _29_or_else_optional
    (42) block_statement -> . _5_NEWLINE_optional _6_do_exprs_optional
    (43) _5_NEWLINE_optional -> . NEWLINE
    (44) _5_NEWLINE_optional -> .
    NEWLINE         shift and go to state 93
    -               reduce using rule 44 (_5_NEWLINE_optional -> .)
    (               reduce using rule 44 (_5_NEWLINE_optional -> .)
    STRING          reduce using rule 44 (_5_NEWLINE_optional -> .)
    NUMBER          reduce using rule 44 (_5_NEWLINE_optional -> .)
    [               reduce using rule 44 (_5_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 44 (_5_NEWLINE_optional -> .)
    CASE            reduce using rule 44 (_5_NEWLINE_optional -> .)
    IF              reduce using rule 44 (_5_NEWLINE_optional -> .)
    DEF             reduce using rule 44 (_5_NEWLINE_optional -> .)
    DO              reduce using rule 44 (_5_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 44 (_5_NEWLINE_optional -> .)
    ENUM            reduce using rule 44 (_5_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 44 (_5_NEWLINE_optional -> .)
    ELIF            reduce using rule 44 (_5_NEWLINE_optional -> .)
    ELSE            reduce using rule 44 (_5_NEWLINE_optional -> .)
    END             reduce using rule 44 (_5_NEWLINE_optional -> .)

    block_statement                shift and go to state 224
    _5_NEWLINE_optional            shift and go to state 92

state 209

    (47) def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .
    NEWLINE         reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    (               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    INT_DIV         reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    EQUAL           reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    |               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    >               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    %               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    <               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    *               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    /               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    -               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    +               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    CONCAT          reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    $end            reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    )               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    OF              reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    THEN            reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    END             reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    ELIF            reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    ELSE            reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    ,               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)
    ]               reduce using rule 47 (def_expr -> DEF identifier ( _7_NEWLINE_optional _8_params_optional ) _9_0x3a_type_optional do .)


state 210

    (52) _9_0x3a_type_optional -> : type .
    DO              reduce using rule 52 (_9_0x3a_type_optional -> : type .)


state 211

    (69) params -> params , _15_NEWLINE_optional param . _16_NEWLINE_optional
    (72) _16_NEWLINE_optional -> . NEWLINE
    (73) _16_NEWLINE_optional -> .
    NEWLINE         shift and go to state 226
    ,               reduce using rule 73 (_16_NEWLINE_optional -> .)
    )               reduce using rule 73 (_16_NEWLINE_optional -> .)

    _16_NEWLINE_optional           shift and go to state 225

state 212

    (54) def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional . _12_params_optional ) _13_0x3a_type_optional do
    (62) _12_params_optional -> . params
    (63) _12_params_optional -> .
    (66) params -> . param _14_NEWLINE_optional
    (69) params -> . params , _15_NEWLINE_optional param _16_NEWLINE_optional
    (109) param -> . identifier _26_0x3a_type_optional
    (172) identifier -> . IDENTIFIER
    )               reduce using rule 63 (_12_params_optional -> .)
    IDENTIFIER      shift and go to state 27

    identifier                     shift and go to state 134
    _12_params_optional            shift and go to state 227
    params                         shift and go to state 228
    param                          shift and go to state 137

state 213

    (60) _11_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 60 (_11_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 60 (_11_NEWLINE_optional -> NEWLINE .)


state 214

    (103) variant -> type_identifier ( type _25_0x2c_type_repeat . )
    )               shift and go to state 229


state 215

    (104) _25_0x2c_type_repeat -> _25_0x2c_type_items .
    (106) _25_0x2c_type_items -> _25_0x2c_type_items . _25_0x2c_type_item
    (108) _25_0x2c_type_item -> . , type
    )               reduce using rule 104 (_25_0x2c_type_repeat -> _25_0x2c_type_items .)
    ,               shift and go to state 217

    _25_0x2c_type_item             shift and go to state 230

state 216

    (107) _25_0x2c_type_items -> _25_0x2c_type_item .
    ,               reduce using rule 107 (_25_0x2c_type_items -> _25_0x2c_type_item .)
    )               reduce using rule 107 (_25_0x2c_type_items -> _25_0x2c_type_item .)


state 217

    (108) _25_0x2c_type_item -> , . type
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 231
    type_identifier                shift and go to state 81

state 218

    (86) enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional . _22_variants_optional }
    (94) _22_variants_optional -> . variants
    (95) _22_variants_optional -> .
    (96) variants -> . variant _23_NEWLINE_optional
    (99) variants -> . variants variant _24_NEWLINE_optional
    (102) variant -> . type_identifier
    (103) variant -> . type_identifier ( type _25_0x2c_type_repeat )
    (173) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 95 (_22_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 142
    _22_variants_optional          shift and go to state 232
    variants                       shift and go to state 233
    variant                        shift and go to state 145

state 219

    (92) _21_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 92 (_21_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 92 (_21_NEWLINE_optional -> NEWLINE .)


state 220

    (136) match_variant -> type_identifier ( _34_NEWLINE_optional _35_patterns_optional ) .
    DO              reduce using rule 136 (match_variant -> type_identifier ( _34_NEWLINE_optional _35_patterns_optional ) .)
    NEWLINE         reduce using rule 136 (match_variant -> type_identifier ( _34_NEWLINE_optional _35_patterns_optional ) .)
    ,               reduce using rule 136 (match_variant -> type_identifier ( _34_NEWLINE_optional _35_patterns_optional ) .)
    )               reduce using rule 136 (match_variant -> type_identifier ( _34_NEWLINE_optional _35_patterns_optional ) .)


state 221

    (144) patterns -> patterns , . _37_NEWLINE_optional pattern _38_NEWLINE_optional
    (145) _37_NEWLINE_optional -> . NEWLINE
    (146) _37_NEWLINE_optional -> .
    NEWLINE         shift and go to state 235
    TYPE_IDENTIFIER reduce using rule 146 (_37_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 146 (_37_NEWLINE_optional -> .)

    _37_NEWLINE_optional           shift and go to state 234

state 222

    (141) patterns -> pattern _36_NEWLINE_optional .
    ,               reduce using rule 141 (patterns -> pattern _36_NEWLINE_optional .)
    )               reduce using rule 141 (patterns -> pattern _36_NEWLINE_optional .)


state 223

    (142) _36_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 142 (_36_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 142 (_36_NEWLINE_optional -> NEWLINE .)


state 224

    (117) or_else -> ELIF expr THEN block_statement . _29_or_else_optional
    (118) _29_or_else_optional -> . or_else
    (119) _29_or_else_optional -> .
    (117) or_else -> . ELIF expr THEN block_statement _29_or_else_optional
    (120) or_else -> . ELSE block_statement
    END             reduce using rule 119 (_29_or_else_optional -> .)
    ELIF            shift and go to state 161
    ELSE            shift and go to state 162

    _29_or_else_optional           shift and go to state 236
    or_else                        shift and go to state 237

state 225

    (69) params -> params , _15_NEWLINE_optional param _16_NEWLINE_optional .
    ,               reduce using rule 69 (params -> params , _15_NEWLINE_optional param _16_NEWLINE_optional .)
    )               reduce using rule 69 (params -> params , _15_NEWLINE_optional param _16_NEWLINE_optional .)


state 226

    (72) _16_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 72 (_16_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 72 (_16_NEWLINE_optional -> NEWLINE .)


state 227

    (54) def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional . ) _13_0x3a_type_optional do
    )               shift and go to state 238


state 228

    (62) _12_params_optional -> params .
    (69) params -> params . , _15_NEWLINE_optional param _16_NEWLINE_optional
    )               reduce using rule 62 (_12_params_optional -> params .)
    ,               shift and go to state 166


state 229

    (103) variant -> type_identifier ( type _25_0x2c_type_repeat ) .
    NEWLINE         reduce using rule 103 (variant -> type_identifier ( type _25_0x2c_type_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 103 (variant -> type_identifier ( type _25_0x2c_type_repeat ) .)
    }               reduce using rule 103 (variant -> type_identifier ( type _25_0x2c_type_repeat ) .)


state 230

    (106) _25_0x2c_type_items -> _25_0x2c_type_items _25_0x2c_type_item .
    ,               reduce using rule 106 (_25_0x2c_type_items -> _25_0x2c_type_items _25_0x2c_type_item .)
    )               reduce using rule 106 (_25_0x2c_type_items -> _25_0x2c_type_items _25_0x2c_type_item .)


state 231

    (108) _25_0x2c_type_item -> , type .
    ,               reduce using rule 108 (_25_0x2c_type_item -> , type .)
    )               reduce using rule 108 (_25_0x2c_type_item -> , type .)


state 232

    (86) enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional . }
    }               shift and go to state 239


state 233

    (94) _22_variants_optional -> variants .
    (99) variants -> variants . variant _24_NEWLINE_optional
    (102) variant -> . type_identifier
    (103) variant -> . type_identifier ( type _25_0x2c_type_repeat )
    (173) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 94 (_22_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 34

    variant                        shift and go to state 174
    type_identifier                shift and go to state 142

state 234

    (144) patterns -> patterns , _37_NEWLINE_optional . pattern _38_NEWLINE_optional
    (132) pattern -> . match_variant
    (133) pattern -> . match_as
    (135) match_variant -> . type_identifier
    (136) match_variant -> . type_identifier ( _34_NEWLINE_optional _35_patterns_optional )
    (134) match_as -> . identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    (172) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 27

    pattern                        shift and go to state 240
    match_variant                  shift and go to state 128
    match_as                       shift and go to state 129
    type_identifier                shift and go to state 130
    identifier                     shift and go to state 131

state 235

    (145) _37_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 145 (_37_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 145 (_37_NEWLINE_optional -> NEWLINE .)


state 236

    (117) or_else -> ELIF expr THEN block_statement _29_or_else_optional .
    END             reduce using rule 117 (or_else -> ELIF expr THEN block_statement _29_or_else_optional .)


state 237

    (118) _29_or_else_optional -> or_else .
    END             reduce using rule 118 (_29_or_else_optional -> or_else .)


state 238

    (54) def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) . _13_0x3a_type_optional do
    (64) _13_0x3a_type_optional -> . : type
    (65) _13_0x3a_type_optional -> .
    :               shift and go to state 242
    DO              reduce using rule 65 (_13_0x3a_type_optional -> .)

    _13_0x3a_type_optional         shift and go to state 241

state 239

    (86) enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .
    NEWLINE         reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    (               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    INT_DIV         reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    EQUAL           reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    NOT_EQUAL       reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    |               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    >               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    %               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    <               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    *               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    /               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    -               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    +               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    CONCAT          reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    $end            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    )               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    OF              reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    THEN            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    END             reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    ELIF            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    ELSE            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    ,               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)
    ]               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _20_0x2c_type_identifier_repeat > { _21_NEWLINE_optional _22_variants_optional } .)


state 240

    (144) patterns -> patterns , _37_NEWLINE_optional pattern . _38_NEWLINE_optional
    (147) _38_NEWLINE_optional -> . NEWLINE
    (148) _38_NEWLINE_optional -> .
    NEWLINE         shift and go to state 244
    ,               reduce using rule 148 (_38_NEWLINE_optional -> .)
    )               reduce using rule 148 (_38_NEWLINE_optional -> .)

    _38_NEWLINE_optional           shift and go to state 243

state 241

    (54) def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional . do
    (39) do -> . DO _4_0x3a_type_optional block_statement END
    DO              shift and go to state 31

    do                             shift and go to state 245

state 242

    (64) _13_0x3a_type_optional -> : . type
    (74) type -> . type_identifier < type _17_0x2c_type_repeat >
    (80) type -> . type_identifier
    (173) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 246
    type_identifier                shift and go to state 81

state 243

    (144) patterns -> patterns , _37_NEWLINE_optional pattern _38_NEWLINE_optional .
    ,               reduce using rule 144 (patterns -> patterns , _37_NEWLINE_optional pattern _38_NEWLINE_optional .)
    )               reduce using rule 144 (patterns -> patterns , _37_NEWLINE_optional pattern _38_NEWLINE_optional .)


state 244

    (147) _38_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 147 (_38_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 147 (_38_NEWLINE_optional -> NEWLINE .)


state 245

    (54) def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .
    NEWLINE         reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    (               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    INT_DIV         reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    EQUAL           reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    |               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    >               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    %               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    <               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    *               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    /               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    -               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    +               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    CONCAT          reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    $end            reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    )               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    OF              reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    THEN            reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    END             reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    ELIF            reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    ELSE            reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    ,               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)
    ]               reduce using rule 54 (def_expr -> DEF identifier < type_identifier _10_0x2c_type_identifier_repeat > ( _11_NEWLINE_optional _12_params_optional ) _13_0x3a_type_optional do .)


state 246

    (64) _13_0x3a_type_optional -> : type .
    DO              reduce using rule 64 (_13_0x3a_type_optional -> : type .)
