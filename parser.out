Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_NEWLINE_optional _2_stmts_optional
Rule 2     _1_NEWLINE_optional -> NEWLINE
Rule 3     _1_NEWLINE_optional -> <empty>
Rule 4     _2_stmts_optional -> stmts
Rule 5     _2_stmts_optional -> <empty>
Rule 6     stmts -> stmt _3_NEWLINE_optional
Rule 7     _3_NEWLINE_optional -> NEWLINE
Rule 8     _3_NEWLINE_optional -> <empty>
Rule 9     stmts -> stmt NEWLINE stmts
Rule 10    stmt -> def_expr
Rule 11    stmt -> enum
Rule 12    stmt -> variable_declaration
Rule 13    stmt -> expr
Rule 14    expr -> - expr  [precedence=right, level=6]
Rule 15    expr -> ( expr )  [precedence=left, level=7]
Rule 16    expr -> array
Rule 17    expr -> variant_call
Rule 18    expr -> identifier
Rule 19    expr -> call
Rule 20    expr -> case_of
Rule 21    expr -> binary_expr
Rule 22    expr -> if_expr
Rule 23    expr -> literal
Rule 24    expr -> do
Rule 25    expr -> external
Rule 26    external -> EXTERNAL
Rule 27    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 28    binary_expr -> expr EQUAL expr  [precedence=left, level=2]
Rule 29    binary_expr -> expr NOT_EQUAL expr  [precedence=left, level=2]
Rule 30    binary_expr -> expr | expr  [precedence=left, level=4]
Rule 31    binary_expr -> expr > expr  [precedence=left, level=3]
Rule 32    binary_expr -> expr % expr  [precedence=left, level=5]
Rule 33    binary_expr -> expr < expr  [precedence=left, level=3]
Rule 34    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 35    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 36    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 37    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 38    binary_expr -> expr CONCAT expr  [precedence=left, level=4]
Rule 39    do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
Rule 40    _4_0x3a_type_optional -> : type
Rule 41    _4_0x3a_type_optional -> <empty>
Rule 42    _5_NEWLINE_optional -> NEWLINE
Rule 43    _5_NEWLINE_optional -> <empty>
Rule 44    _6_stmts_optional -> stmts
Rule 45    _6_stmts_optional -> <empty>
Rule 46    block_statement -> _7_NEWLINE_optional _8_stmts_optional
Rule 47    _7_NEWLINE_optional -> NEWLINE
Rule 48    _7_NEWLINE_optional -> <empty>
Rule 49    _8_stmts_optional -> stmts
Rule 50    _8_stmts_optional -> <empty>
Rule 51    def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do  [precedence=left, level=7]
Rule 52    _9_NEWLINE_optional -> NEWLINE
Rule 53    _9_NEWLINE_optional -> <empty>
Rule 54    _10_params_optional -> params
Rule 55    _10_params_optional -> <empty>
Rule 56    _11_0x3a_type_optional -> : type
Rule 57    _11_0x3a_type_optional -> <empty>
Rule 58    def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do  [precedence=left, level=7]
Rule 59    _12_0x2c_type_identifier_repeat -> _12_0x2c_type_identifier_items
Rule 60    _12_0x2c_type_identifier_repeat -> <empty>
Rule 61    _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item
Rule 62    _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_item
Rule 63    _12_0x2c_type_identifier_item -> , type_identifier
Rule 64    _13_NEWLINE_optional -> NEWLINE
Rule 65    _13_NEWLINE_optional -> <empty>
Rule 66    _14_params_optional -> params
Rule 67    _14_params_optional -> <empty>
Rule 68    _15_0x3a_type_optional -> : type
Rule 69    _15_0x3a_type_optional -> <empty>
Rule 70    params -> param _16_NEWLINE_optional
Rule 71    _16_NEWLINE_optional -> NEWLINE
Rule 72    _16_NEWLINE_optional -> <empty>
Rule 73    params -> params , _17_NEWLINE_optional param _18_NEWLINE_optional
Rule 74    _17_NEWLINE_optional -> NEWLINE
Rule 75    _17_NEWLINE_optional -> <empty>
Rule 76    _18_NEWLINE_optional -> NEWLINE
Rule 77    _18_NEWLINE_optional -> <empty>
Rule 78    type -> type_identifier < type _19_0x2c_type_repeat >  [precedence=left, level=3]
Rule 79    _19_0x2c_type_repeat -> _19_0x2c_type_items
Rule 80    _19_0x2c_type_repeat -> <empty>
Rule 81    _19_0x2c_type_items -> _19_0x2c_type_items _19_0x2c_type_item
Rule 82    _19_0x2c_type_items -> _19_0x2c_type_item
Rule 83    _19_0x2c_type_item -> , type
Rule 84    type -> type_identifier
Rule 85    enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
Rule 86    _20_NEWLINE_optional -> NEWLINE
Rule 87    _20_NEWLINE_optional -> <empty>
Rule 88    _21_variants_optional -> variants
Rule 89    _21_variants_optional -> <empty>
Rule 90    enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
Rule 91    _22_0x2c_type_identifier_repeat -> _22_0x2c_type_identifier_items
Rule 92    _22_0x2c_type_identifier_repeat -> <empty>
Rule 93    _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item
Rule 94    _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_item
Rule 95    _22_0x2c_type_identifier_item -> , type_identifier
Rule 96    _23_NEWLINE_optional -> NEWLINE
Rule 97    _23_NEWLINE_optional -> <empty>
Rule 98    _24_variants_optional -> variants
Rule 99    _24_variants_optional -> <empty>
Rule 100   variants -> variant _25_NEWLINE_optional
Rule 101   _25_NEWLINE_optional -> NEWLINE
Rule 102   _25_NEWLINE_optional -> <empty>
Rule 103   variants -> variants variant _26_NEWLINE_optional
Rule 104   _26_NEWLINE_optional -> NEWLINE
Rule 105   _26_NEWLINE_optional -> <empty>
Rule 106   variant -> type_identifier
Rule 107   variant -> type_identifier ( type _27_0x2c_type_repeat )  [precedence=left, level=7]
Rule 108   _27_0x2c_type_repeat -> _27_0x2c_type_items
Rule 109   _27_0x2c_type_repeat -> <empty>
Rule 110   _27_0x2c_type_items -> _27_0x2c_type_items _27_0x2c_type_item
Rule 111   _27_0x2c_type_items -> _27_0x2c_type_item
Rule 112   _27_0x2c_type_item -> , type
Rule 113   param -> identifier _28_0x3a_type_optional
Rule 114   _28_0x3a_type_optional -> : type
Rule 115   _28_0x3a_type_optional -> <empty>
Rule 116   if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
Rule 117   _29_0x3a_type_optional -> : type
Rule 118   _29_0x3a_type_optional -> <empty>
Rule 119   _30_or_else_optional -> or_else
Rule 120   _30_or_else_optional -> <empty>
Rule 121   or_else -> ELIF expr THEN block_statement _31_or_else_optional
Rule 122   _31_or_else_optional -> or_else
Rule 123   _31_or_else_optional -> <empty>
Rule 124   or_else -> ELSE block_statement
Rule 125   case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END
Rule 126   _32_NEWLINE_optional -> NEWLINE
Rule 127   _32_NEWLINE_optional -> <empty>
Rule 128   _33_cases_optional -> cases
Rule 129   _33_cases_optional -> <empty>
Rule 130   cases -> pattern do _34_NEWLINE_optional
Rule 131   _34_NEWLINE_optional -> NEWLINE
Rule 132   _34_NEWLINE_optional -> <empty>
Rule 133   cases -> cases pattern do _35_NEWLINE_optional
Rule 134   _35_NEWLINE_optional -> NEWLINE
Rule 135   _35_NEWLINE_optional -> <empty>
Rule 136   pattern -> match_variant
Rule 137   pattern -> match_as
Rule 138   match_as -> identifier
Rule 139   match_variant -> type_identifier
Rule 140   match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional )  [precedence=left, level=7]
Rule 141   _36_NEWLINE_optional -> NEWLINE
Rule 142   _36_NEWLINE_optional -> <empty>
Rule 143   _37_patterns_optional -> patterns
Rule 144   _37_patterns_optional -> <empty>
Rule 145   patterns -> pattern _38_NEWLINE_optional
Rule 146   _38_NEWLINE_optional -> NEWLINE
Rule 147   _38_NEWLINE_optional -> <empty>
Rule 148   patterns -> patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional
Rule 149   _39_NEWLINE_optional -> NEWLINE
Rule 150   _39_NEWLINE_optional -> <empty>
Rule 151   _40_NEWLINE_optional -> NEWLINE
Rule 152   _40_NEWLINE_optional -> <empty>
Rule 153   array -> [ _41_NEWLINE_optional _42_exprs_optional ]
Rule 154   _41_NEWLINE_optional -> NEWLINE
Rule 155   _41_NEWLINE_optional -> <empty>
Rule 156   _42_exprs_optional -> exprs
Rule 157   _42_exprs_optional -> <empty>
Rule 158   call -> expr ( _43_NEWLINE_optional _44_exprs_optional )  [precedence=left, level=7]
Rule 159   _43_NEWLINE_optional -> NEWLINE
Rule 160   _43_NEWLINE_optional -> <empty>
Rule 161   _44_exprs_optional -> exprs
Rule 162   _44_exprs_optional -> <empty>
Rule 163   variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional )  [precedence=left, level=7]
Rule 164   _45_NEWLINE_optional -> NEWLINE
Rule 165   _45_NEWLINE_optional -> <empty>
Rule 166   _46_exprs_optional -> exprs
Rule 167   _46_exprs_optional -> <empty>
Rule 168   exprs -> expr _47_NEWLINE_optional
Rule 169   _47_NEWLINE_optional -> NEWLINE
Rule 170   _47_NEWLINE_optional -> <empty>
Rule 171   exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional
Rule 172   _48_NEWLINE_optional -> NEWLINE
Rule 173   _48_NEWLINE_optional -> <empty>
Rule 174   _49_NEWLINE_optional -> NEWLINE
Rule 175   _49_NEWLINE_optional -> <empty>
Rule 176   identifier -> IDENTIFIER
Rule 177   type_identifier -> TYPE_IDENTIFIER
Rule 178   variable_declaration -> identifier _50_0x3a_type_optional = expr  [precedence=left, level=1]
Rule 179   _50_0x3a_type_optional -> : type
Rule 180   _50_0x3a_type_optional -> <empty>
Rule 181   literal -> STRING
Rule 182   literal -> NUMBER

Terminals, with rules where they appear:

%                    : 32
(                    : 15 51 58 107 140 158 163
)                    : 15 51 58 107 140 158 163
*                    : 34
+                    : 37
,                    : 63 73 83 95 112 148 171
-                    : 14 36
/                    : 35
:                    : 40 56 68 114 117 179
<                    : 33 58 78 90
=                    : 178
>                    : 31 58 78 90
CASE                 : 125
CONCAT               : 38
DEF                  : 51 58
DO                   : 39
ELIF                 : 121
ELSE                 : 124
END                  : 39 116 125
ENUM                 : 85 90
EQUAL                : 28
EXTERNAL             : 26
IDENTIFIER           : 176
IF                   : 116
INT_DIV              : 27
NEWLINE              : 2 7 9 42 47 52 64 71 74 76 86 96 101 104 126 131 134 141 146 149 151 154 159 164 169 172 174
NOT_EQUAL            : 29
NUMBER               : 182
OF                   : 125
STRING               : 181
THEN                 : 116 121
TYPE_IDENTIFIER      : 177
[                    : 153
]                    : 153
error                : 
{                    : 85 90
|                    : 30
}                    : 85 90

Nonterminals, with rules where they appear:

_10_params_optional  : 51
_11_0x3a_type_optional : 51
_12_0x2c_type_identifier_item : 61 62
_12_0x2c_type_identifier_items : 59 61
_12_0x2c_type_identifier_repeat : 58
_13_NEWLINE_optional : 58
_14_params_optional  : 58
_15_0x3a_type_optional : 58
_16_NEWLINE_optional : 70
_17_NEWLINE_optional : 73
_18_NEWLINE_optional : 73
_19_0x2c_type_item   : 81 82
_19_0x2c_type_items  : 79 81
_19_0x2c_type_repeat : 78
_1_NEWLINE_optional  : 1
_20_NEWLINE_optional : 85
_21_variants_optional : 85
_22_0x2c_type_identifier_item : 93 94
_22_0x2c_type_identifier_items : 91 93
_22_0x2c_type_identifier_repeat : 90
_23_NEWLINE_optional : 90
_24_variants_optional : 90
_25_NEWLINE_optional : 100
_26_NEWLINE_optional : 103
_27_0x2c_type_item   : 110 111
_27_0x2c_type_items  : 108 110
_27_0x2c_type_repeat : 107
_28_0x3a_type_optional : 113
_29_0x3a_type_optional : 116
_2_stmts_optional    : 1
_30_or_else_optional : 116
_31_or_else_optional : 121
_32_NEWLINE_optional : 125
_33_cases_optional   : 125
_34_NEWLINE_optional : 130
_35_NEWLINE_optional : 133
_36_NEWLINE_optional : 140
_37_patterns_optional : 140
_38_NEWLINE_optional : 145
_39_NEWLINE_optional : 148
_3_NEWLINE_optional  : 6
_40_NEWLINE_optional : 148
_41_NEWLINE_optional : 153
_42_exprs_optional   : 153
_43_NEWLINE_optional : 158
_44_exprs_optional   : 158
_45_NEWLINE_optional : 163
_46_exprs_optional   : 163
_47_NEWLINE_optional : 168
_48_NEWLINE_optional : 171
_49_NEWLINE_optional : 171
_4_0x3a_type_optional : 39
_50_0x3a_type_optional : 178
_5_NEWLINE_optional  : 39
_6_stmts_optional    : 39
_7_NEWLINE_optional  : 46
_8_stmts_optional    : 46
_9_NEWLINE_optional  : 51
array                : 16
binary_expr          : 21
block_statement      : 116 121 124
call                 : 19
case_of              : 20
cases                : 128 133
def_expr             : 10
do                   : 24 51 58 130 133
enum                 : 11
expr                 : 13 14 15 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 116 121 125 158 168 171 178
exprs                : 156 161 166 171
external             : 25
identifier           : 18 51 58 113 138 178
if_expr              : 22
literal              : 23
match_as             : 137
match_variant        : 136
or_else              : 119 122
param                : 70 73
params               : 54 66 73
pattern              : 130 133 145 148
patterns             : 143 148
program              : 0
stmt                 : 6 9
stmts                : 4 9 44 49
type                 : 40 56 68 78 83 107 112 114 117 179
type_identifier      : 58 63 78 84 85 90 90 95 106 107 139 140 163
variable_declaration : 12
variant              : 100 103
variant_call         : 17
variants             : 88 98 103


state 0

    (0) S' -> . program
    (1) program -> . _1_NEWLINE_optional _2_stmts_optional
    (2) _1_NEWLINE_optional -> . NEWLINE
    (3) _1_NEWLINE_optional -> .
    NEWLINE         shift and go to state 3
    DEF             reduce using rule 3 (_1_NEWLINE_optional -> .)
    ENUM            reduce using rule 3 (_1_NEWLINE_optional -> .)
    -               reduce using rule 3 (_1_NEWLINE_optional -> .)
    (               reduce using rule 3 (_1_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 3 (_1_NEWLINE_optional -> .)
    [               reduce using rule 3 (_1_NEWLINE_optional -> .)
    CASE            reduce using rule 3 (_1_NEWLINE_optional -> .)
    IF              reduce using rule 3 (_1_NEWLINE_optional -> .)
    STRING          reduce using rule 3 (_1_NEWLINE_optional -> .)
    NUMBER          reduce using rule 3 (_1_NEWLINE_optional -> .)
    DO              reduce using rule 3 (_1_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 3 (_1_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 3 (_1_NEWLINE_optional -> .)
    $end            reduce using rule 3 (_1_NEWLINE_optional -> .)

    program                        shift and go to state 1
    _1_NEWLINE_optional            shift and go to state 2

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_NEWLINE_optional . _2_stmts_optional
    (4) _2_stmts_optional -> . stmts
    (5) _2_stmts_optional -> .
    (6) stmts -> . stmt _3_NEWLINE_optional
    (9) stmts -> . stmt NEWLINE stmts
    (10) stmt -> . def_expr
    (11) stmt -> . enum
    (12) stmt -> . variable_declaration
    (13) stmt -> . expr
    (51) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (85) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (178) variable_declaration -> . identifier _50_0x3a_type_optional = expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (176) identifier -> . IDENTIFIER
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 5 (_2_stmts_optional -> .)
    DEF             shift and go to state 11
    ENUM            shift and go to state 16
    -               shift and go to state 17
    (               shift and go to state 13
    IDENTIFIER      shift and go to state 26
    [               shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _2_stmts_optional              shift and go to state 4
    stmts                          shift and go to state 5
    stmt                           shift and go to state 6
    def_expr                       shift and go to state 7
    enum                           shift and go to state 8
    variable_declaration           shift and go to state 9
    expr                           shift and go to state 10
    identifier                     shift and go to state 12
    do                             shift and go to state 14
    type_identifier                shift and go to state 15
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    external                       shift and go to state 25

state 3

    (2) _1_NEWLINE_optional -> NEWLINE .
    DEF             reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    $end            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)


state 4

    (1) program -> _1_NEWLINE_optional _2_stmts_optional .
    $end            reduce using rule 1 (program -> _1_NEWLINE_optional _2_stmts_optional .)


state 5

    (4) _2_stmts_optional -> stmts .
    $end            reduce using rule 4 (_2_stmts_optional -> stmts .)


state 6

    (6) stmts -> stmt . _3_NEWLINE_optional
    (9) stmts -> stmt . NEWLINE stmts
    (7) _3_NEWLINE_optional -> . NEWLINE
    (8) _3_NEWLINE_optional -> .
    NEWLINE         shift and go to state 36
    $end            reduce using rule 8 (_3_NEWLINE_optional -> .)
    END             reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELIF            reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELSE            reduce using rule 8 (_3_NEWLINE_optional -> .)

    _3_NEWLINE_optional            shift and go to state 35

state 7

    (10) stmt -> def_expr .
    NEWLINE         reduce using rule 10 (stmt -> def_expr .)
    $end            reduce using rule 10 (stmt -> def_expr .)
    END             reduce using rule 10 (stmt -> def_expr .)
    ELIF            reduce using rule 10 (stmt -> def_expr .)
    ELSE            reduce using rule 10 (stmt -> def_expr .)


state 8

    (11) stmt -> enum .
    NEWLINE         reduce using rule 11 (stmt -> enum .)
    $end            reduce using rule 11 (stmt -> enum .)
    END             reduce using rule 11 (stmt -> enum .)
    ELIF            reduce using rule 11 (stmt -> enum .)
    ELSE            reduce using rule 11 (stmt -> enum .)


state 9

    (12) stmt -> variable_declaration .
    NEWLINE         reduce using rule 12 (stmt -> variable_declaration .)
    $end            reduce using rule 12 (stmt -> variable_declaration .)
    END             reduce using rule 12 (stmt -> variable_declaration .)
    ELIF            reduce using rule 12 (stmt -> variable_declaration .)
    ELSE            reduce using rule 12 (stmt -> variable_declaration .)


state 10

    (13) stmt -> expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 13 (stmt -> expr .)
    $end            reduce using rule 13 (stmt -> expr .)
    END             reduce using rule 13 (stmt -> expr .)
    ELIF            reduce using rule 13 (stmt -> expr .)
    ELSE            reduce using rule 13 (stmt -> expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 11

    (51) def_expr -> DEF . identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (58) def_expr -> DEF . identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (176) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 50

state 12

    (178) variable_declaration -> identifier . _50_0x3a_type_optional = expr
    (18) expr -> identifier .
    (179) _50_0x3a_type_optional -> . : type
    (180) _50_0x3a_type_optional -> .
    (               reduce using rule 18 (expr -> identifier .)
    INT_DIV         reduce using rule 18 (expr -> identifier .)
    EQUAL           reduce using rule 18 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 18 (expr -> identifier .)
    |               reduce using rule 18 (expr -> identifier .)
    >               reduce using rule 18 (expr -> identifier .)
    %               reduce using rule 18 (expr -> identifier .)
    <               reduce using rule 18 (expr -> identifier .)
    *               reduce using rule 18 (expr -> identifier .)
    /               reduce using rule 18 (expr -> identifier .)
    -               reduce using rule 18 (expr -> identifier .)
    +               reduce using rule 18 (expr -> identifier .)
    CONCAT          reduce using rule 18 (expr -> identifier .)
    NEWLINE         reduce using rule 18 (expr -> identifier .)
    $end            reduce using rule 18 (expr -> identifier .)
    END             reduce using rule 18 (expr -> identifier .)
    ELIF            reduce using rule 18 (expr -> identifier .)
    ELSE            reduce using rule 18 (expr -> identifier .)
    :               shift and go to state 52
    =               reduce using rule 180 (_50_0x3a_type_optional -> .)

    _50_0x3a_type_optional         shift and go to state 51

state 13

    (15) expr -> ( . expr )
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 53
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 14

    (24) expr -> do .
    (               reduce using rule 24 (expr -> do .)
    INT_DIV         reduce using rule 24 (expr -> do .)
    EQUAL           reduce using rule 24 (expr -> do .)
    NOT_EQUAL       reduce using rule 24 (expr -> do .)
    |               reduce using rule 24 (expr -> do .)
    >               reduce using rule 24 (expr -> do .)
    %               reduce using rule 24 (expr -> do .)
    <               reduce using rule 24 (expr -> do .)
    *               reduce using rule 24 (expr -> do .)
    /               reduce using rule 24 (expr -> do .)
    -               reduce using rule 24 (expr -> do .)
    +               reduce using rule 24 (expr -> do .)
    CONCAT          reduce using rule 24 (expr -> do .)
    NEWLINE         reduce using rule 24 (expr -> do .)
    $end            reduce using rule 24 (expr -> do .)
    )               reduce using rule 24 (expr -> do .)
    OF              reduce using rule 24 (expr -> do .)
    THEN            reduce using rule 24 (expr -> do .)
    END             reduce using rule 24 (expr -> do .)
    ELIF            reduce using rule 24 (expr -> do .)
    ELSE            reduce using rule 24 (expr -> do .)
    ,               reduce using rule 24 (expr -> do .)
    ]               reduce using rule 24 (expr -> do .)


state 15

    (163) variant_call -> type_identifier . ( _45_NEWLINE_optional _46_exprs_optional )
    (               shift and go to state 55


state 16

    (85) enum -> ENUM . type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (90) enum -> ENUM . type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 56

state 17

    (14) expr -> - . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 57
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 18

    (16) expr -> array .
    (               reduce using rule 16 (expr -> array .)
    INT_DIV         reduce using rule 16 (expr -> array .)
    EQUAL           reduce using rule 16 (expr -> array .)
    NOT_EQUAL       reduce using rule 16 (expr -> array .)
    |               reduce using rule 16 (expr -> array .)
    >               reduce using rule 16 (expr -> array .)
    %               reduce using rule 16 (expr -> array .)
    <               reduce using rule 16 (expr -> array .)
    *               reduce using rule 16 (expr -> array .)
    /               reduce using rule 16 (expr -> array .)
    -               reduce using rule 16 (expr -> array .)
    +               reduce using rule 16 (expr -> array .)
    CONCAT          reduce using rule 16 (expr -> array .)
    NEWLINE         reduce using rule 16 (expr -> array .)
    $end            reduce using rule 16 (expr -> array .)
    )               reduce using rule 16 (expr -> array .)
    OF              reduce using rule 16 (expr -> array .)
    THEN            reduce using rule 16 (expr -> array .)
    END             reduce using rule 16 (expr -> array .)
    ELIF            reduce using rule 16 (expr -> array .)
    ELSE            reduce using rule 16 (expr -> array .)
    ,               reduce using rule 16 (expr -> array .)
    ]               reduce using rule 16 (expr -> array .)


state 19

    (17) expr -> variant_call .
    (               reduce using rule 17 (expr -> variant_call .)
    INT_DIV         reduce using rule 17 (expr -> variant_call .)
    EQUAL           reduce using rule 17 (expr -> variant_call .)
    NOT_EQUAL       reduce using rule 17 (expr -> variant_call .)
    |               reduce using rule 17 (expr -> variant_call .)
    >               reduce using rule 17 (expr -> variant_call .)
    %               reduce using rule 17 (expr -> variant_call .)
    <               reduce using rule 17 (expr -> variant_call .)
    *               reduce using rule 17 (expr -> variant_call .)
    /               reduce using rule 17 (expr -> variant_call .)
    -               reduce using rule 17 (expr -> variant_call .)
    +               reduce using rule 17 (expr -> variant_call .)
    CONCAT          reduce using rule 17 (expr -> variant_call .)
    NEWLINE         reduce using rule 17 (expr -> variant_call .)
    $end            reduce using rule 17 (expr -> variant_call .)
    )               reduce using rule 17 (expr -> variant_call .)
    OF              reduce using rule 17 (expr -> variant_call .)
    THEN            reduce using rule 17 (expr -> variant_call .)
    END             reduce using rule 17 (expr -> variant_call .)
    ELIF            reduce using rule 17 (expr -> variant_call .)
    ELSE            reduce using rule 17 (expr -> variant_call .)
    ,               reduce using rule 17 (expr -> variant_call .)
    ]               reduce using rule 17 (expr -> variant_call .)


state 20

    (19) expr -> call .
    (               reduce using rule 19 (expr -> call .)
    INT_DIV         reduce using rule 19 (expr -> call .)
    EQUAL           reduce using rule 19 (expr -> call .)
    NOT_EQUAL       reduce using rule 19 (expr -> call .)
    |               reduce using rule 19 (expr -> call .)
    >               reduce using rule 19 (expr -> call .)
    %               reduce using rule 19 (expr -> call .)
    <               reduce using rule 19 (expr -> call .)
    *               reduce using rule 19 (expr -> call .)
    /               reduce using rule 19 (expr -> call .)
    -               reduce using rule 19 (expr -> call .)
    +               reduce using rule 19 (expr -> call .)
    CONCAT          reduce using rule 19 (expr -> call .)
    NEWLINE         reduce using rule 19 (expr -> call .)
    $end            reduce using rule 19 (expr -> call .)
    )               reduce using rule 19 (expr -> call .)
    OF              reduce using rule 19 (expr -> call .)
    THEN            reduce using rule 19 (expr -> call .)
    END             reduce using rule 19 (expr -> call .)
    ELIF            reduce using rule 19 (expr -> call .)
    ELSE            reduce using rule 19 (expr -> call .)
    ,               reduce using rule 19 (expr -> call .)
    ]               reduce using rule 19 (expr -> call .)


state 21

    (20) expr -> case_of .
    (               reduce using rule 20 (expr -> case_of .)
    INT_DIV         reduce using rule 20 (expr -> case_of .)
    EQUAL           reduce using rule 20 (expr -> case_of .)
    NOT_EQUAL       reduce using rule 20 (expr -> case_of .)
    |               reduce using rule 20 (expr -> case_of .)
    >               reduce using rule 20 (expr -> case_of .)
    %               reduce using rule 20 (expr -> case_of .)
    <               reduce using rule 20 (expr -> case_of .)
    *               reduce using rule 20 (expr -> case_of .)
    /               reduce using rule 20 (expr -> case_of .)
    -               reduce using rule 20 (expr -> case_of .)
    +               reduce using rule 20 (expr -> case_of .)
    CONCAT          reduce using rule 20 (expr -> case_of .)
    NEWLINE         reduce using rule 20 (expr -> case_of .)
    $end            reduce using rule 20 (expr -> case_of .)
    )               reduce using rule 20 (expr -> case_of .)
    OF              reduce using rule 20 (expr -> case_of .)
    THEN            reduce using rule 20 (expr -> case_of .)
    END             reduce using rule 20 (expr -> case_of .)
    ELIF            reduce using rule 20 (expr -> case_of .)
    ELSE            reduce using rule 20 (expr -> case_of .)
    ,               reduce using rule 20 (expr -> case_of .)
    ]               reduce using rule 20 (expr -> case_of .)


state 22

    (21) expr -> binary_expr .
    (               reduce using rule 21 (expr -> binary_expr .)
    INT_DIV         reduce using rule 21 (expr -> binary_expr .)
    EQUAL           reduce using rule 21 (expr -> binary_expr .)
    NOT_EQUAL       reduce using rule 21 (expr -> binary_expr .)
    |               reduce using rule 21 (expr -> binary_expr .)
    >               reduce using rule 21 (expr -> binary_expr .)
    %               reduce using rule 21 (expr -> binary_expr .)
    <               reduce using rule 21 (expr -> binary_expr .)
    *               reduce using rule 21 (expr -> binary_expr .)
    /               reduce using rule 21 (expr -> binary_expr .)
    -               reduce using rule 21 (expr -> binary_expr .)
    +               reduce using rule 21 (expr -> binary_expr .)
    CONCAT          reduce using rule 21 (expr -> binary_expr .)
    NEWLINE         reduce using rule 21 (expr -> binary_expr .)
    $end            reduce using rule 21 (expr -> binary_expr .)
    )               reduce using rule 21 (expr -> binary_expr .)
    OF              reduce using rule 21 (expr -> binary_expr .)
    THEN            reduce using rule 21 (expr -> binary_expr .)
    END             reduce using rule 21 (expr -> binary_expr .)
    ELIF            reduce using rule 21 (expr -> binary_expr .)
    ELSE            reduce using rule 21 (expr -> binary_expr .)
    ,               reduce using rule 21 (expr -> binary_expr .)
    ]               reduce using rule 21 (expr -> binary_expr .)


state 23

    (22) expr -> if_expr .
    (               reduce using rule 22 (expr -> if_expr .)
    INT_DIV         reduce using rule 22 (expr -> if_expr .)
    EQUAL           reduce using rule 22 (expr -> if_expr .)
    NOT_EQUAL       reduce using rule 22 (expr -> if_expr .)
    |               reduce using rule 22 (expr -> if_expr .)
    >               reduce using rule 22 (expr -> if_expr .)
    %               reduce using rule 22 (expr -> if_expr .)
    <               reduce using rule 22 (expr -> if_expr .)
    *               reduce using rule 22 (expr -> if_expr .)
    /               reduce using rule 22 (expr -> if_expr .)
    -               reduce using rule 22 (expr -> if_expr .)
    +               reduce using rule 22 (expr -> if_expr .)
    CONCAT          reduce using rule 22 (expr -> if_expr .)
    NEWLINE         reduce using rule 22 (expr -> if_expr .)
    $end            reduce using rule 22 (expr -> if_expr .)
    )               reduce using rule 22 (expr -> if_expr .)
    OF              reduce using rule 22 (expr -> if_expr .)
    THEN            reduce using rule 22 (expr -> if_expr .)
    END             reduce using rule 22 (expr -> if_expr .)
    ELIF            reduce using rule 22 (expr -> if_expr .)
    ELSE            reduce using rule 22 (expr -> if_expr .)
    ,               reduce using rule 22 (expr -> if_expr .)
    ]               reduce using rule 22 (expr -> if_expr .)


state 24

    (23) expr -> literal .
    (               reduce using rule 23 (expr -> literal .)
    INT_DIV         reduce using rule 23 (expr -> literal .)
    EQUAL           reduce using rule 23 (expr -> literal .)
    NOT_EQUAL       reduce using rule 23 (expr -> literal .)
    |               reduce using rule 23 (expr -> literal .)
    >               reduce using rule 23 (expr -> literal .)
    %               reduce using rule 23 (expr -> literal .)
    <               reduce using rule 23 (expr -> literal .)
    *               reduce using rule 23 (expr -> literal .)
    /               reduce using rule 23 (expr -> literal .)
    -               reduce using rule 23 (expr -> literal .)
    +               reduce using rule 23 (expr -> literal .)
    CONCAT          reduce using rule 23 (expr -> literal .)
    NEWLINE         reduce using rule 23 (expr -> literal .)
    $end            reduce using rule 23 (expr -> literal .)
    )               reduce using rule 23 (expr -> literal .)
    OF              reduce using rule 23 (expr -> literal .)
    THEN            reduce using rule 23 (expr -> literal .)
    END             reduce using rule 23 (expr -> literal .)
    ELIF            reduce using rule 23 (expr -> literal .)
    ELSE            reduce using rule 23 (expr -> literal .)
    ,               reduce using rule 23 (expr -> literal .)
    ]               reduce using rule 23 (expr -> literal .)


state 25

    (25) expr -> external .
    (               reduce using rule 25 (expr -> external .)
    INT_DIV         reduce using rule 25 (expr -> external .)
    EQUAL           reduce using rule 25 (expr -> external .)
    NOT_EQUAL       reduce using rule 25 (expr -> external .)
    |               reduce using rule 25 (expr -> external .)
    >               reduce using rule 25 (expr -> external .)
    %               reduce using rule 25 (expr -> external .)
    <               reduce using rule 25 (expr -> external .)
    *               reduce using rule 25 (expr -> external .)
    /               reduce using rule 25 (expr -> external .)
    -               reduce using rule 25 (expr -> external .)
    +               reduce using rule 25 (expr -> external .)
    CONCAT          reduce using rule 25 (expr -> external .)
    NEWLINE         reduce using rule 25 (expr -> external .)
    $end            reduce using rule 25 (expr -> external .)
    )               reduce using rule 25 (expr -> external .)
    OF              reduce using rule 25 (expr -> external .)
    THEN            reduce using rule 25 (expr -> external .)
    END             reduce using rule 25 (expr -> external .)
    ELIF            reduce using rule 25 (expr -> external .)
    ELSE            reduce using rule 25 (expr -> external .)
    ,               reduce using rule 25 (expr -> external .)
    ]               reduce using rule 25 (expr -> external .)


state 26

    (176) identifier -> IDENTIFIER .
    :               reduce using rule 176 (identifier -> IDENTIFIER .)
    =               reduce using rule 176 (identifier -> IDENTIFIER .)
    (               reduce using rule 176 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 176 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 176 (identifier -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 176 (identifier -> IDENTIFIER .)
    |               reduce using rule 176 (identifier -> IDENTIFIER .)
    >               reduce using rule 176 (identifier -> IDENTIFIER .)
    %               reduce using rule 176 (identifier -> IDENTIFIER .)
    <               reduce using rule 176 (identifier -> IDENTIFIER .)
    *               reduce using rule 176 (identifier -> IDENTIFIER .)
    /               reduce using rule 176 (identifier -> IDENTIFIER .)
    -               reduce using rule 176 (identifier -> IDENTIFIER .)
    +               reduce using rule 176 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 176 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 176 (identifier -> IDENTIFIER .)
    $end            reduce using rule 176 (identifier -> IDENTIFIER .)
    )               reduce using rule 176 (identifier -> IDENTIFIER .)
    OF              reduce using rule 176 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 176 (identifier -> IDENTIFIER .)
    END             reduce using rule 176 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 176 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 176 (identifier -> IDENTIFIER .)
    ,               reduce using rule 176 (identifier -> IDENTIFIER .)
    ]               reduce using rule 176 (identifier -> IDENTIFIER .)
    DO              reduce using rule 176 (identifier -> IDENTIFIER .)


state 27

    (153) array -> [ . _41_NEWLINE_optional _42_exprs_optional ]
    (154) _41_NEWLINE_optional -> . NEWLINE
    (155) _41_NEWLINE_optional -> .
    NEWLINE         shift and go to state 59
    -               reduce using rule 155 (_41_NEWLINE_optional -> .)
    (               reduce using rule 155 (_41_NEWLINE_optional -> .)
    [               reduce using rule 155 (_41_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 155 (_41_NEWLINE_optional -> .)
    CASE            reduce using rule 155 (_41_NEWLINE_optional -> .)
    IF              reduce using rule 155 (_41_NEWLINE_optional -> .)
    STRING          reduce using rule 155 (_41_NEWLINE_optional -> .)
    NUMBER          reduce using rule 155 (_41_NEWLINE_optional -> .)
    DO              reduce using rule 155 (_41_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 155 (_41_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 155 (_41_NEWLINE_optional -> .)
    ]               reduce using rule 155 (_41_NEWLINE_optional -> .)

    _41_NEWLINE_optional           shift and go to state 58

state 28

    (125) case_of -> CASE . expr OF _32_NEWLINE_optional _33_cases_optional END
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 60
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 29

    (116) if_expr -> IF . expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 61
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 30

    (181) literal -> STRING .
    (               reduce using rule 181 (literal -> STRING .)
    INT_DIV         reduce using rule 181 (literal -> STRING .)
    EQUAL           reduce using rule 181 (literal -> STRING .)
    NOT_EQUAL       reduce using rule 181 (literal -> STRING .)
    |               reduce using rule 181 (literal -> STRING .)
    >               reduce using rule 181 (literal -> STRING .)
    %               reduce using rule 181 (literal -> STRING .)
    <               reduce using rule 181 (literal -> STRING .)
    *               reduce using rule 181 (literal -> STRING .)
    /               reduce using rule 181 (literal -> STRING .)
    -               reduce using rule 181 (literal -> STRING .)
    +               reduce using rule 181 (literal -> STRING .)
    CONCAT          reduce using rule 181 (literal -> STRING .)
    NEWLINE         reduce using rule 181 (literal -> STRING .)
    $end            reduce using rule 181 (literal -> STRING .)
    )               reduce using rule 181 (literal -> STRING .)
    OF              reduce using rule 181 (literal -> STRING .)
    THEN            reduce using rule 181 (literal -> STRING .)
    END             reduce using rule 181 (literal -> STRING .)
    ELIF            reduce using rule 181 (literal -> STRING .)
    ELSE            reduce using rule 181 (literal -> STRING .)
    ,               reduce using rule 181 (literal -> STRING .)
    ]               reduce using rule 181 (literal -> STRING .)


state 31

    (182) literal -> NUMBER .
    (               reduce using rule 182 (literal -> NUMBER .)
    INT_DIV         reduce using rule 182 (literal -> NUMBER .)
    EQUAL           reduce using rule 182 (literal -> NUMBER .)
    NOT_EQUAL       reduce using rule 182 (literal -> NUMBER .)
    |               reduce using rule 182 (literal -> NUMBER .)
    >               reduce using rule 182 (literal -> NUMBER .)
    %               reduce using rule 182 (literal -> NUMBER .)
    <               reduce using rule 182 (literal -> NUMBER .)
    *               reduce using rule 182 (literal -> NUMBER .)
    /               reduce using rule 182 (literal -> NUMBER .)
    -               reduce using rule 182 (literal -> NUMBER .)
    +               reduce using rule 182 (literal -> NUMBER .)
    CONCAT          reduce using rule 182 (literal -> NUMBER .)
    NEWLINE         reduce using rule 182 (literal -> NUMBER .)
    $end            reduce using rule 182 (literal -> NUMBER .)
    )               reduce using rule 182 (literal -> NUMBER .)
    OF              reduce using rule 182 (literal -> NUMBER .)
    THEN            reduce using rule 182 (literal -> NUMBER .)
    END             reduce using rule 182 (literal -> NUMBER .)
    ELIF            reduce using rule 182 (literal -> NUMBER .)
    ELSE            reduce using rule 182 (literal -> NUMBER .)
    ,               reduce using rule 182 (literal -> NUMBER .)
    ]               reduce using rule 182 (literal -> NUMBER .)


state 32

    (39) do -> DO . _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (40) _4_0x3a_type_optional -> . : type
    (41) _4_0x3a_type_optional -> .
    :               shift and go to state 63
    NEWLINE         reduce using rule 41 (_4_0x3a_type_optional -> .)
    DEF             reduce using rule 41 (_4_0x3a_type_optional -> .)
    ENUM            reduce using rule 41 (_4_0x3a_type_optional -> .)
    -               reduce using rule 41 (_4_0x3a_type_optional -> .)
    (               reduce using rule 41 (_4_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 41 (_4_0x3a_type_optional -> .)
    [               reduce using rule 41 (_4_0x3a_type_optional -> .)
    CASE            reduce using rule 41 (_4_0x3a_type_optional -> .)
    IF              reduce using rule 41 (_4_0x3a_type_optional -> .)
    STRING          reduce using rule 41 (_4_0x3a_type_optional -> .)
    NUMBER          reduce using rule 41 (_4_0x3a_type_optional -> .)
    DO              reduce using rule 41 (_4_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 41 (_4_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 41 (_4_0x3a_type_optional -> .)
    END             reduce using rule 41 (_4_0x3a_type_optional -> .)

    _4_0x3a_type_optional          shift and go to state 62

state 33

    (26) external -> EXTERNAL .
    (               reduce using rule 26 (external -> EXTERNAL .)
    INT_DIV         reduce using rule 26 (external -> EXTERNAL .)
    EQUAL           reduce using rule 26 (external -> EXTERNAL .)
    NOT_EQUAL       reduce using rule 26 (external -> EXTERNAL .)
    |               reduce using rule 26 (external -> EXTERNAL .)
    >               reduce using rule 26 (external -> EXTERNAL .)
    %               reduce using rule 26 (external -> EXTERNAL .)
    <               reduce using rule 26 (external -> EXTERNAL .)
    *               reduce using rule 26 (external -> EXTERNAL .)
    /               reduce using rule 26 (external -> EXTERNAL .)
    -               reduce using rule 26 (external -> EXTERNAL .)
    +               reduce using rule 26 (external -> EXTERNAL .)
    CONCAT          reduce using rule 26 (external -> EXTERNAL .)
    NEWLINE         reduce using rule 26 (external -> EXTERNAL .)
    $end            reduce using rule 26 (external -> EXTERNAL .)
    )               reduce using rule 26 (external -> EXTERNAL .)
    OF              reduce using rule 26 (external -> EXTERNAL .)
    THEN            reduce using rule 26 (external -> EXTERNAL .)
    END             reduce using rule 26 (external -> EXTERNAL .)
    ELIF            reduce using rule 26 (external -> EXTERNAL .)
    ELSE            reduce using rule 26 (external -> EXTERNAL .)
    ,               reduce using rule 26 (external -> EXTERNAL .)
    ]               reduce using rule 26 (external -> EXTERNAL .)


state 34

    (177) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)


state 35

    (6) stmts -> stmt _3_NEWLINE_optional .
    $end            reduce using rule 6 (stmts -> stmt _3_NEWLINE_optional .)
    END             reduce using rule 6 (stmts -> stmt _3_NEWLINE_optional .)
    ELIF            reduce using rule 6 (stmts -> stmt _3_NEWLINE_optional .)
    ELSE            reduce using rule 6 (stmts -> stmt _3_NEWLINE_optional .)


state 36

    (9) stmts -> stmt NEWLINE . stmts
    (7) _3_NEWLINE_optional -> NEWLINE .
    (6) stmts -> . stmt _3_NEWLINE_optional
    (9) stmts -> . stmt NEWLINE stmts
    (10) stmt -> . def_expr
    (11) stmt -> . enum
    (12) stmt -> . variable_declaration
    (13) stmt -> . expr
    (51) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (85) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (178) variable_declaration -> . identifier _50_0x3a_type_optional = expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (176) identifier -> . IDENTIFIER
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    DEF             shift and go to state 11
    ENUM            shift and go to state 16
    -               shift and go to state 17
    (               shift and go to state 13
    IDENTIFIER      shift and go to state 26
    [               shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    stmt                           shift and go to state 6
    stmts                          shift and go to state 64
    def_expr                       shift and go to state 7
    enum                           shift and go to state 8
    variable_declaration           shift and go to state 9
    expr                           shift and go to state 10
    identifier                     shift and go to state 12
    do                             shift and go to state 14
    type_identifier                shift and go to state 15
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    external                       shift and go to state 25

state 37

    (158) call -> expr ( . _43_NEWLINE_optional _44_exprs_optional )
    (159) _43_NEWLINE_optional -> . NEWLINE
    (160) _43_NEWLINE_optional -> .
    NEWLINE         shift and go to state 66
    -               reduce using rule 160 (_43_NEWLINE_optional -> .)
    (               reduce using rule 160 (_43_NEWLINE_optional -> .)
    [               reduce using rule 160 (_43_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 160 (_43_NEWLINE_optional -> .)
    CASE            reduce using rule 160 (_43_NEWLINE_optional -> .)
    IF              reduce using rule 160 (_43_NEWLINE_optional -> .)
    STRING          reduce using rule 160 (_43_NEWLINE_optional -> .)
    NUMBER          reduce using rule 160 (_43_NEWLINE_optional -> .)
    DO              reduce using rule 160 (_43_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 160 (_43_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 160 (_43_NEWLINE_optional -> .)
    )               reduce using rule 160 (_43_NEWLINE_optional -> .)

    _43_NEWLINE_optional           shift and go to state 65

state 38

    (27) binary_expr -> expr INT_DIV . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 67
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 39

    (28) binary_expr -> expr EQUAL . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 68
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 40

    (29) binary_expr -> expr NOT_EQUAL . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 69
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 41

    (30) binary_expr -> expr | . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 70
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 42

    (31) binary_expr -> expr > . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 71
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 43

    (32) binary_expr -> expr % . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 72
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 44

    (33) binary_expr -> expr < . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 73
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 45

    (34) binary_expr -> expr * . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 74
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 46

    (35) binary_expr -> expr / . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 75
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 47

    (36) binary_expr -> expr - . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 76
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 48

    (37) binary_expr -> expr + . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 77
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 49

    (38) binary_expr -> expr CONCAT . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 78
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 50

    (51) def_expr -> DEF identifier . ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (58) def_expr -> DEF identifier . < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (               shift and go to state 79
    <               shift and go to state 80


state 51

    (178) variable_declaration -> identifier _50_0x3a_type_optional . = expr
    =               shift and go to state 81


state 52

    (179) _50_0x3a_type_optional -> : . type
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 82
    type_identifier                shift and go to state 83

state 53

    (15) expr -> ( expr . )
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    )               shift and go to state 84
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 54

    (18) expr -> identifier .
    )               reduce using rule 18 (expr -> identifier .)
    (               reduce using rule 18 (expr -> identifier .)
    INT_DIV         reduce using rule 18 (expr -> identifier .)
    EQUAL           reduce using rule 18 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 18 (expr -> identifier .)
    |               reduce using rule 18 (expr -> identifier .)
    >               reduce using rule 18 (expr -> identifier .)
    %               reduce using rule 18 (expr -> identifier .)
    <               reduce using rule 18 (expr -> identifier .)
    *               reduce using rule 18 (expr -> identifier .)
    /               reduce using rule 18 (expr -> identifier .)
    -               reduce using rule 18 (expr -> identifier .)
    +               reduce using rule 18 (expr -> identifier .)
    CONCAT          reduce using rule 18 (expr -> identifier .)
    NEWLINE         reduce using rule 18 (expr -> identifier .)
    $end            reduce using rule 18 (expr -> identifier .)
    OF              reduce using rule 18 (expr -> identifier .)
    THEN            reduce using rule 18 (expr -> identifier .)
    END             reduce using rule 18 (expr -> identifier .)
    ELIF            reduce using rule 18 (expr -> identifier .)
    ELSE            reduce using rule 18 (expr -> identifier .)
    ,               reduce using rule 18 (expr -> identifier .)
    ]               reduce using rule 18 (expr -> identifier .)


state 55

    (163) variant_call -> type_identifier ( . _45_NEWLINE_optional _46_exprs_optional )
    (164) _45_NEWLINE_optional -> . NEWLINE
    (165) _45_NEWLINE_optional -> .
    NEWLINE         shift and go to state 86
    -               reduce using rule 165 (_45_NEWLINE_optional -> .)
    (               reduce using rule 165 (_45_NEWLINE_optional -> .)
    [               reduce using rule 165 (_45_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 165 (_45_NEWLINE_optional -> .)
    CASE            reduce using rule 165 (_45_NEWLINE_optional -> .)
    IF              reduce using rule 165 (_45_NEWLINE_optional -> .)
    STRING          reduce using rule 165 (_45_NEWLINE_optional -> .)
    NUMBER          reduce using rule 165 (_45_NEWLINE_optional -> .)
    DO              reduce using rule 165 (_45_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 165 (_45_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 165 (_45_NEWLINE_optional -> .)
    )               reduce using rule 165 (_45_NEWLINE_optional -> .)

    _45_NEWLINE_optional           shift and go to state 85

state 56

    (85) enum -> ENUM type_identifier . { _20_NEWLINE_optional _21_variants_optional }
    (90) enum -> ENUM type_identifier . < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    {               shift and go to state 87
    <               shift and go to state 88


state 57

    (14) expr -> - expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 14 (expr -> - expr .)
    EQUAL           reduce using rule 14 (expr -> - expr .)
    NOT_EQUAL       reduce using rule 14 (expr -> - expr .)
    |               reduce using rule 14 (expr -> - expr .)
    >               reduce using rule 14 (expr -> - expr .)
    %               reduce using rule 14 (expr -> - expr .)
    <               reduce using rule 14 (expr -> - expr .)
    *               reduce using rule 14 (expr -> - expr .)
    /               reduce using rule 14 (expr -> - expr .)
    -               reduce using rule 14 (expr -> - expr .)
    +               reduce using rule 14 (expr -> - expr .)
    CONCAT          reduce using rule 14 (expr -> - expr .)
    NEWLINE         reduce using rule 14 (expr -> - expr .)
    $end            reduce using rule 14 (expr -> - expr .)
    )               reduce using rule 14 (expr -> - expr .)
    OF              reduce using rule 14 (expr -> - expr .)
    THEN            reduce using rule 14 (expr -> - expr .)
    END             reduce using rule 14 (expr -> - expr .)
    ELIF            reduce using rule 14 (expr -> - expr .)
    ELSE            reduce using rule 14 (expr -> - expr .)
    ,               reduce using rule 14 (expr -> - expr .)
    ]               reduce using rule 14 (expr -> - expr .)
    (               shift and go to state 37


state 58

    (153) array -> [ _41_NEWLINE_optional . _42_exprs_optional ]
    (156) _42_exprs_optional -> . exprs
    (157) _42_exprs_optional -> .
    (168) exprs -> . expr _47_NEWLINE_optional
    (171) exprs -> . exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    ]               reduce using rule 157 (_42_exprs_optional -> .)
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _42_exprs_optional             shift and go to state 89
    exprs                          shift and go to state 90
    expr                           shift and go to state 91
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 59

    (154) _41_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 154 (_41_NEWLINE_optional -> NEWLINE .)


state 60

    (125) case_of -> CASE expr . OF _32_NEWLINE_optional _33_cases_optional END
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 92
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 61

    (116) if_expr -> IF expr . THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 93
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 62

    (39) do -> DO _4_0x3a_type_optional . _5_NEWLINE_optional _6_stmts_optional END
    (42) _5_NEWLINE_optional -> . NEWLINE
    (43) _5_NEWLINE_optional -> .
    NEWLINE         shift and go to state 95
    DEF             reduce using rule 43 (_5_NEWLINE_optional -> .)
    ENUM            reduce using rule 43 (_5_NEWLINE_optional -> .)
    -               reduce using rule 43 (_5_NEWLINE_optional -> .)
    (               reduce using rule 43 (_5_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 43 (_5_NEWLINE_optional -> .)
    [               reduce using rule 43 (_5_NEWLINE_optional -> .)
    CASE            reduce using rule 43 (_5_NEWLINE_optional -> .)
    IF              reduce using rule 43 (_5_NEWLINE_optional -> .)
    STRING          reduce using rule 43 (_5_NEWLINE_optional -> .)
    NUMBER          reduce using rule 43 (_5_NEWLINE_optional -> .)
    DO              reduce using rule 43 (_5_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 43 (_5_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 43 (_5_NEWLINE_optional -> .)
    END             reduce using rule 43 (_5_NEWLINE_optional -> .)

    _5_NEWLINE_optional            shift and go to state 94

state 63

    (40) _4_0x3a_type_optional -> : . type
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 96
    type_identifier                shift and go to state 83

state 64

    (9) stmts -> stmt NEWLINE stmts .
    $end            reduce using rule 9 (stmts -> stmt NEWLINE stmts .)
    END             reduce using rule 9 (stmts -> stmt NEWLINE stmts .)
    ELIF            reduce using rule 9 (stmts -> stmt NEWLINE stmts .)
    ELSE            reduce using rule 9 (stmts -> stmt NEWLINE stmts .)


state 65

    (158) call -> expr ( _43_NEWLINE_optional . _44_exprs_optional )
    (161) _44_exprs_optional -> . exprs
    (162) _44_exprs_optional -> .
    (168) exprs -> . expr _47_NEWLINE_optional
    (171) exprs -> . exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 162 (_44_exprs_optional -> .)
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 91
    _44_exprs_optional             shift and go to state 97
    exprs                          shift and go to state 98
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 66

    (159) _43_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 159 (_43_NEWLINE_optional -> NEWLINE .)


state 67

    (27) binary_expr -> expr INT_DIV expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    EQUAL           reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    NOT_EQUAL       reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    |               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    %               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    NEWLINE         reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 27 (binary_expr -> expr INT_DIV expr .)
    (               shift and go to state 37


state 68

    (28) binary_expr -> expr EQUAL expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    EQUAL           reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    NEWLINE         reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    $end            reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    )               reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    OF              reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    THEN            reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    END             reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    ,               reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    ]               reduce using rule 28 (binary_expr -> expr EQUAL expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 69

    (29) binary_expr -> expr NOT_EQUAL expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    EQUAL           reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    NEWLINE         reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    END             reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    ]               reduce using rule 29 (binary_expr -> expr NOT_EQUAL expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 70

    (30) binary_expr -> expr | expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    EQUAL           reduce using rule 30 (binary_expr -> expr | expr .)
    NOT_EQUAL       reduce using rule 30 (binary_expr -> expr | expr .)
    |               reduce using rule 30 (binary_expr -> expr | expr .)
    >               reduce using rule 30 (binary_expr -> expr | expr .)
    <               reduce using rule 30 (binary_expr -> expr | expr .)
    -               reduce using rule 30 (binary_expr -> expr | expr .)
    +               reduce using rule 30 (binary_expr -> expr | expr .)
    CONCAT          reduce using rule 30 (binary_expr -> expr | expr .)
    NEWLINE         reduce using rule 30 (binary_expr -> expr | expr .)
    $end            reduce using rule 30 (binary_expr -> expr | expr .)
    )               reduce using rule 30 (binary_expr -> expr | expr .)
    OF              reduce using rule 30 (binary_expr -> expr | expr .)
    THEN            reduce using rule 30 (binary_expr -> expr | expr .)
    END             reduce using rule 30 (binary_expr -> expr | expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr | expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr | expr .)
    ,               reduce using rule 30 (binary_expr -> expr | expr .)
    ]               reduce using rule 30 (binary_expr -> expr | expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46


state 71

    (31) binary_expr -> expr > expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    EQUAL           reduce using rule 31 (binary_expr -> expr > expr .)
    NOT_EQUAL       reduce using rule 31 (binary_expr -> expr > expr .)
    >               reduce using rule 31 (binary_expr -> expr > expr .)
    <               reduce using rule 31 (binary_expr -> expr > expr .)
    NEWLINE         reduce using rule 31 (binary_expr -> expr > expr .)
    $end            reduce using rule 31 (binary_expr -> expr > expr .)
    )               reduce using rule 31 (binary_expr -> expr > expr .)
    OF              reduce using rule 31 (binary_expr -> expr > expr .)
    THEN            reduce using rule 31 (binary_expr -> expr > expr .)
    END             reduce using rule 31 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr > expr .)
    ,               reduce using rule 31 (binary_expr -> expr > expr .)
    ]               reduce using rule 31 (binary_expr -> expr > expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    |               shift and go to state 41
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 72

    (32) binary_expr -> expr % expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 32 (binary_expr -> expr % expr .)
    EQUAL           reduce using rule 32 (binary_expr -> expr % expr .)
    NOT_EQUAL       reduce using rule 32 (binary_expr -> expr % expr .)
    |               reduce using rule 32 (binary_expr -> expr % expr .)
    >               reduce using rule 32 (binary_expr -> expr % expr .)
    %               reduce using rule 32 (binary_expr -> expr % expr .)
    <               reduce using rule 32 (binary_expr -> expr % expr .)
    *               reduce using rule 32 (binary_expr -> expr % expr .)
    /               reduce using rule 32 (binary_expr -> expr % expr .)
    -               reduce using rule 32 (binary_expr -> expr % expr .)
    +               reduce using rule 32 (binary_expr -> expr % expr .)
    CONCAT          reduce using rule 32 (binary_expr -> expr % expr .)
    NEWLINE         reduce using rule 32 (binary_expr -> expr % expr .)
    $end            reduce using rule 32 (binary_expr -> expr % expr .)
    )               reduce using rule 32 (binary_expr -> expr % expr .)
    OF              reduce using rule 32 (binary_expr -> expr % expr .)
    THEN            reduce using rule 32 (binary_expr -> expr % expr .)
    END             reduce using rule 32 (binary_expr -> expr % expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr % expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr % expr .)
    ,               reduce using rule 32 (binary_expr -> expr % expr .)
    ]               reduce using rule 32 (binary_expr -> expr % expr .)
    (               shift and go to state 37


state 73

    (33) binary_expr -> expr < expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    EQUAL           reduce using rule 33 (binary_expr -> expr < expr .)
    NOT_EQUAL       reduce using rule 33 (binary_expr -> expr < expr .)
    >               reduce using rule 33 (binary_expr -> expr < expr .)
    <               reduce using rule 33 (binary_expr -> expr < expr .)
    NEWLINE         reduce using rule 33 (binary_expr -> expr < expr .)
    $end            reduce using rule 33 (binary_expr -> expr < expr .)
    )               reduce using rule 33 (binary_expr -> expr < expr .)
    OF              reduce using rule 33 (binary_expr -> expr < expr .)
    THEN            reduce using rule 33 (binary_expr -> expr < expr .)
    END             reduce using rule 33 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr < expr .)
    ,               reduce using rule 33 (binary_expr -> expr < expr .)
    ]               reduce using rule 33 (binary_expr -> expr < expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    |               shift and go to state 41
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 74

    (34) binary_expr -> expr * expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 34 (binary_expr -> expr * expr .)
    EQUAL           reduce using rule 34 (binary_expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 34 (binary_expr -> expr * expr .)
    |               reduce using rule 34 (binary_expr -> expr * expr .)
    >               reduce using rule 34 (binary_expr -> expr * expr .)
    %               reduce using rule 34 (binary_expr -> expr * expr .)
    <               reduce using rule 34 (binary_expr -> expr * expr .)
    *               reduce using rule 34 (binary_expr -> expr * expr .)
    /               reduce using rule 34 (binary_expr -> expr * expr .)
    -               reduce using rule 34 (binary_expr -> expr * expr .)
    +               reduce using rule 34 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr * expr .)
    NEWLINE         reduce using rule 34 (binary_expr -> expr * expr .)
    $end            reduce using rule 34 (binary_expr -> expr * expr .)
    )               reduce using rule 34 (binary_expr -> expr * expr .)
    OF              reduce using rule 34 (binary_expr -> expr * expr .)
    THEN            reduce using rule 34 (binary_expr -> expr * expr .)
    END             reduce using rule 34 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr * expr .)
    ,               reduce using rule 34 (binary_expr -> expr * expr .)
    ]               reduce using rule 34 (binary_expr -> expr * expr .)
    (               shift and go to state 37


state 75

    (35) binary_expr -> expr / expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 35 (binary_expr -> expr / expr .)
    EQUAL           reduce using rule 35 (binary_expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 35 (binary_expr -> expr / expr .)
    |               reduce using rule 35 (binary_expr -> expr / expr .)
    >               reduce using rule 35 (binary_expr -> expr / expr .)
    %               reduce using rule 35 (binary_expr -> expr / expr .)
    <               reduce using rule 35 (binary_expr -> expr / expr .)
    *               reduce using rule 35 (binary_expr -> expr / expr .)
    /               reduce using rule 35 (binary_expr -> expr / expr .)
    -               reduce using rule 35 (binary_expr -> expr / expr .)
    +               reduce using rule 35 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 35 (binary_expr -> expr / expr .)
    NEWLINE         reduce using rule 35 (binary_expr -> expr / expr .)
    $end            reduce using rule 35 (binary_expr -> expr / expr .)
    )               reduce using rule 35 (binary_expr -> expr / expr .)
    OF              reduce using rule 35 (binary_expr -> expr / expr .)
    THEN            reduce using rule 35 (binary_expr -> expr / expr .)
    END             reduce using rule 35 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr / expr .)
    ,               reduce using rule 35 (binary_expr -> expr / expr .)
    ]               reduce using rule 35 (binary_expr -> expr / expr .)
    (               shift and go to state 37


state 76

    (36) binary_expr -> expr - expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    EQUAL           reduce using rule 36 (binary_expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 36 (binary_expr -> expr - expr .)
    |               reduce using rule 36 (binary_expr -> expr - expr .)
    >               reduce using rule 36 (binary_expr -> expr - expr .)
    <               reduce using rule 36 (binary_expr -> expr - expr .)
    -               reduce using rule 36 (binary_expr -> expr - expr .)
    +               reduce using rule 36 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 36 (binary_expr -> expr - expr .)
    NEWLINE         reduce using rule 36 (binary_expr -> expr - expr .)
    $end            reduce using rule 36 (binary_expr -> expr - expr .)
    )               reduce using rule 36 (binary_expr -> expr - expr .)
    OF              reduce using rule 36 (binary_expr -> expr - expr .)
    THEN            reduce using rule 36 (binary_expr -> expr - expr .)
    END             reduce using rule 36 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 36 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 36 (binary_expr -> expr - expr .)
    ,               reduce using rule 36 (binary_expr -> expr - expr .)
    ]               reduce using rule 36 (binary_expr -> expr - expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46


state 77

    (37) binary_expr -> expr + expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    EQUAL           reduce using rule 37 (binary_expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 37 (binary_expr -> expr + expr .)
    |               reduce using rule 37 (binary_expr -> expr + expr .)
    >               reduce using rule 37 (binary_expr -> expr + expr .)
    <               reduce using rule 37 (binary_expr -> expr + expr .)
    -               reduce using rule 37 (binary_expr -> expr + expr .)
    +               reduce using rule 37 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 37 (binary_expr -> expr + expr .)
    NEWLINE         reduce using rule 37 (binary_expr -> expr + expr .)
    $end            reduce using rule 37 (binary_expr -> expr + expr .)
    )               reduce using rule 37 (binary_expr -> expr + expr .)
    OF              reduce using rule 37 (binary_expr -> expr + expr .)
    THEN            reduce using rule 37 (binary_expr -> expr + expr .)
    END             reduce using rule 37 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 37 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 37 (binary_expr -> expr + expr .)
    ,               reduce using rule 37 (binary_expr -> expr + expr .)
    ]               reduce using rule 37 (binary_expr -> expr + expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46


state 78

    (38) binary_expr -> expr CONCAT expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    EQUAL           reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    NOT_EQUAL       reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    |               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    -               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    +               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    NEWLINE         reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 38 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    %               shift and go to state 43
    *               shift and go to state 45
    /               shift and go to state 46


state 79

    (51) def_expr -> DEF identifier ( . _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (52) _9_NEWLINE_optional -> . NEWLINE
    (53) _9_NEWLINE_optional -> .
    NEWLINE         shift and go to state 100
    IDENTIFIER      reduce using rule 53 (_9_NEWLINE_optional -> .)
    )               reduce using rule 53 (_9_NEWLINE_optional -> .)

    _9_NEWLINE_optional            shift and go to state 99

state 80

    (58) def_expr -> DEF identifier < . type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 101

state 81

    (178) variable_declaration -> identifier _50_0x3a_type_optional = . expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    identifier                     shift and go to state 54
    expr                           shift and go to state 102
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 82

    (179) _50_0x3a_type_optional -> : type .
    =               reduce using rule 179 (_50_0x3a_type_optional -> : type .)


state 83

    (78) type -> type_identifier . < type _19_0x2c_type_repeat >
    (84) type -> type_identifier .
    <               shift and go to state 103
    =               reduce using rule 84 (type -> type_identifier .)
    NEWLINE         reduce using rule 84 (type -> type_identifier .)
    DEF             reduce using rule 84 (type -> type_identifier .)
    ENUM            reduce using rule 84 (type -> type_identifier .)
    -               reduce using rule 84 (type -> type_identifier .)
    (               reduce using rule 84 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 84 (type -> type_identifier .)
    [               reduce using rule 84 (type -> type_identifier .)
    CASE            reduce using rule 84 (type -> type_identifier .)
    IF              reduce using rule 84 (type -> type_identifier .)
    STRING          reduce using rule 84 (type -> type_identifier .)
    NUMBER          reduce using rule 84 (type -> type_identifier .)
    DO              reduce using rule 84 (type -> type_identifier .)
    EXTERNAL        reduce using rule 84 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 84 (type -> type_identifier .)
    END             reduce using rule 84 (type -> type_identifier .)
    ,               reduce using rule 84 (type -> type_identifier .)
    >               reduce using rule 84 (type -> type_identifier .)
    ELIF            reduce using rule 84 (type -> type_identifier .)
    ELSE            reduce using rule 84 (type -> type_identifier .)
    )               reduce using rule 84 (type -> type_identifier .)


state 84

    (15) expr -> ( expr ) .
    (               reduce using rule 15 (expr -> ( expr ) .)
    INT_DIV         reduce using rule 15 (expr -> ( expr ) .)
    EQUAL           reduce using rule 15 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 15 (expr -> ( expr ) .)
    |               reduce using rule 15 (expr -> ( expr ) .)
    >               reduce using rule 15 (expr -> ( expr ) .)
    %               reduce using rule 15 (expr -> ( expr ) .)
    <               reduce using rule 15 (expr -> ( expr ) .)
    *               reduce using rule 15 (expr -> ( expr ) .)
    /               reduce using rule 15 (expr -> ( expr ) .)
    -               reduce using rule 15 (expr -> ( expr ) .)
    +               reduce using rule 15 (expr -> ( expr ) .)
    CONCAT          reduce using rule 15 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 15 (expr -> ( expr ) .)
    $end            reduce using rule 15 (expr -> ( expr ) .)
    )               reduce using rule 15 (expr -> ( expr ) .)
    OF              reduce using rule 15 (expr -> ( expr ) .)
    THEN            reduce using rule 15 (expr -> ( expr ) .)
    END             reduce using rule 15 (expr -> ( expr ) .)
    ELIF            reduce using rule 15 (expr -> ( expr ) .)
    ELSE            reduce using rule 15 (expr -> ( expr ) .)
    ,               reduce using rule 15 (expr -> ( expr ) .)
    ]               reduce using rule 15 (expr -> ( expr ) .)


state 85

    (163) variant_call -> type_identifier ( _45_NEWLINE_optional . _46_exprs_optional )
    (166) _46_exprs_optional -> . exprs
    (167) _46_exprs_optional -> .
    (168) exprs -> . expr _47_NEWLINE_optional
    (171) exprs -> . exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 167 (_46_exprs_optional -> .)
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 15
    _46_exprs_optional             shift and go to state 104
    exprs                          shift and go to state 105
    expr                           shift and go to state 91
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25

state 86

    (164) _45_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 164 (_45_NEWLINE_optional -> NEWLINE .)


state 87

    (85) enum -> ENUM type_identifier { . _20_NEWLINE_optional _21_variants_optional }
    (86) _20_NEWLINE_optional -> . NEWLINE
    (87) _20_NEWLINE_optional -> .
    NEWLINE         shift and go to state 107
    TYPE_IDENTIFIER reduce using rule 87 (_20_NEWLINE_optional -> .)
    }               reduce using rule 87 (_20_NEWLINE_optional -> .)

    _20_NEWLINE_optional           shift and go to state 106

state 88

    (90) enum -> ENUM type_identifier < . type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 108

state 89

    (153) array -> [ _41_NEWLINE_optional _42_exprs_optional . ]
    ]               shift and go to state 109


state 90

    (156) _42_exprs_optional -> exprs .
    (171) exprs -> exprs . , _48_NEWLINE_optional expr _49_NEWLINE_optional
    ]               reduce using rule 156 (_42_exprs_optional -> exprs .)
    ,               shift and go to state 110


state 91

    (168) exprs -> expr . _47_NEWLINE_optional
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    (169) _47_NEWLINE_optional -> . NEWLINE
    (170) _47_NEWLINE_optional -> .
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49
    NEWLINE         shift and go to state 112
    ,               reduce using rule 170 (_47_NEWLINE_optional -> .)
    ]               reduce using rule 170 (_47_NEWLINE_optional -> .)
    )               reduce using rule 170 (_47_NEWLINE_optional -> .)

    _47_NEWLINE_optional           shift and go to state 111

state 92

    (125) case_of -> CASE expr OF . _32_NEWLINE_optional _33_cases_optional END
    (126) _32_NEWLINE_optional -> . NEWLINE
    (127) _32_NEWLINE_optional -> .
    NEWLINE         shift and go to state 114
    TYPE_IDENTIFIER reduce using rule 127 (_32_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 127 (_32_NEWLINE_optional -> .)
    END             reduce using rule 127 (_32_NEWLINE_optional -> .)

    _32_NEWLINE_optional           shift and go to state 113

state 93

    (116) if_expr -> IF expr THEN . _29_0x3a_type_optional block_statement _30_or_else_optional END
    (117) _29_0x3a_type_optional -> . : type
    (118) _29_0x3a_type_optional -> .
    :               shift and go to state 116
    NEWLINE         reduce using rule 118 (_29_0x3a_type_optional -> .)
    ELIF            reduce using rule 118 (_29_0x3a_type_optional -> .)
    ELSE            reduce using rule 118 (_29_0x3a_type_optional -> .)
    END             reduce using rule 118 (_29_0x3a_type_optional -> .)
    DEF             reduce using rule 118 (_29_0x3a_type_optional -> .)
    ENUM            reduce using rule 118 (_29_0x3a_type_optional -> .)
    -               reduce using rule 118 (_29_0x3a_type_optional -> .)
    (               reduce using rule 118 (_29_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 118 (_29_0x3a_type_optional -> .)
    [               reduce using rule 118 (_29_0x3a_type_optional -> .)
    CASE            reduce using rule 118 (_29_0x3a_type_optional -> .)
    IF              reduce using rule 118 (_29_0x3a_type_optional -> .)
    STRING          reduce using rule 118 (_29_0x3a_type_optional -> .)
    NUMBER          reduce using rule 118 (_29_0x3a_type_optional -> .)
    DO              reduce using rule 118 (_29_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 118 (_29_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 118 (_29_0x3a_type_optional -> .)

    _29_0x3a_type_optional         shift and go to state 115

state 94

    (39) do -> DO _4_0x3a_type_optional _5_NEWLINE_optional . _6_stmts_optional END
    (44) _6_stmts_optional -> . stmts
    (45) _6_stmts_optional -> .
    (6) stmts -> . stmt _3_NEWLINE_optional
    (9) stmts -> . stmt NEWLINE stmts
    (10) stmt -> . def_expr
    (11) stmt -> . enum
    (12) stmt -> . variable_declaration
    (13) stmt -> . expr
    (51) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (85) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (178) variable_declaration -> . identifier _50_0x3a_type_optional = expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (176) identifier -> . IDENTIFIER
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 45 (_6_stmts_optional -> .)
    DEF             shift and go to state 11
    ENUM            shift and go to state 16
    -               shift and go to state 17
    (               shift and go to state 13
    IDENTIFIER      shift and go to state 26
    [               shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _6_stmts_optional              shift and go to state 117
    stmts                          shift and go to state 118
    stmt                           shift and go to state 6
    def_expr                       shift and go to state 7
    enum                           shift and go to state 8
    variable_declaration           shift and go to state 9
    expr                           shift and go to state 10
    identifier                     shift and go to state 12
    do                             shift and go to state 14
    type_identifier                shift and go to state 15
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    external                       shift and go to state 25

state 95

    (42) _5_NEWLINE_optional -> NEWLINE .
    DEF             reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 42 (_5_NEWLINE_optional -> NEWLINE .)


state 96

    (40) _4_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    DEF             reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    -               reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    (               reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    [               reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    CASE            reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    IF              reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    STRING          reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    NUMBER          reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    DO              reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 40 (_4_0x3a_type_optional -> : type .)
    END             reduce using rule 40 (_4_0x3a_type_optional -> : type .)


state 97

    (158) call -> expr ( _43_NEWLINE_optional _44_exprs_optional . )
    )               shift and go to state 119


state 98

    (161) _44_exprs_optional -> exprs .
    (171) exprs -> exprs . , _48_NEWLINE_optional expr _49_NEWLINE_optional
    )               reduce using rule 161 (_44_exprs_optional -> exprs .)
    ,               shift and go to state 110


state 99

    (51) def_expr -> DEF identifier ( _9_NEWLINE_optional . _10_params_optional ) _11_0x3a_type_optional do
    (54) _10_params_optional -> . params
    (55) _10_params_optional -> .
    (70) params -> . param _16_NEWLINE_optional
    (73) params -> . params , _17_NEWLINE_optional param _18_NEWLINE_optional
    (113) param -> . identifier _28_0x3a_type_optional
    (176) identifier -> . IDENTIFIER
    )               reduce using rule 55 (_10_params_optional -> .)
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 120
    _10_params_optional            shift and go to state 121
    params                         shift and go to state 122
    param                          shift and go to state 123

state 100

    (52) _9_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 52 (_9_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 52 (_9_NEWLINE_optional -> NEWLINE .)


state 101

    (58) def_expr -> DEF identifier < type_identifier . _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (59) _12_0x2c_type_identifier_repeat -> . _12_0x2c_type_identifier_items
    (60) _12_0x2c_type_identifier_repeat -> .
    (61) _12_0x2c_type_identifier_items -> . _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item
    (62) _12_0x2c_type_identifier_items -> . _12_0x2c_type_identifier_item
    (63) _12_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 60 (_12_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 127

    _12_0x2c_type_identifier_repeat shift and go to state 124
    _12_0x2c_type_identifier_items shift and go to state 125
    _12_0x2c_type_identifier_item  shift and go to state 126

state 102

    (178) variable_declaration -> identifier _50_0x3a_type_optional = expr .
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 178 (variable_declaration -> identifier _50_0x3a_type_optional = expr .)
    $end            reduce using rule 178 (variable_declaration -> identifier _50_0x3a_type_optional = expr .)
    END             reduce using rule 178 (variable_declaration -> identifier _50_0x3a_type_optional = expr .)
    ELIF            reduce using rule 178 (variable_declaration -> identifier _50_0x3a_type_optional = expr .)
    ELSE            reduce using rule 178 (variable_declaration -> identifier _50_0x3a_type_optional = expr .)
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 103

    (78) type -> type_identifier < . type _19_0x2c_type_repeat >
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 83
    type                           shift and go to state 128

state 104

    (163) variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional . )
    )               shift and go to state 129


state 105

    (166) _46_exprs_optional -> exprs .
    (171) exprs -> exprs . , _48_NEWLINE_optional expr _49_NEWLINE_optional
    )               reduce using rule 166 (_46_exprs_optional -> exprs .)
    ,               shift and go to state 110


state 106

    (85) enum -> ENUM type_identifier { _20_NEWLINE_optional . _21_variants_optional }
    (88) _21_variants_optional -> . variants
    (89) _21_variants_optional -> .
    (100) variants -> . variant _25_NEWLINE_optional
    (103) variants -> . variants variant _26_NEWLINE_optional
    (106) variant -> . type_identifier
    (107) variant -> . type_identifier ( type _27_0x2c_type_repeat )
    (177) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 89 (_21_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 130
    _21_variants_optional          shift and go to state 131
    variants                       shift and go to state 132
    variant                        shift and go to state 133

state 107

    (86) _20_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 86 (_20_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 86 (_20_NEWLINE_optional -> NEWLINE .)


state 108

    (90) enum -> ENUM type_identifier < type_identifier . _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (91) _22_0x2c_type_identifier_repeat -> . _22_0x2c_type_identifier_items
    (92) _22_0x2c_type_identifier_repeat -> .
    (93) _22_0x2c_type_identifier_items -> . _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item
    (94) _22_0x2c_type_identifier_items -> . _22_0x2c_type_identifier_item
    (95) _22_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 92 (_22_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 137

    _22_0x2c_type_identifier_repeat shift and go to state 134
    _22_0x2c_type_identifier_items shift and go to state 135
    _22_0x2c_type_identifier_item  shift and go to state 136

state 109

    (153) array -> [ _41_NEWLINE_optional _42_exprs_optional ] .
    (               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    INT_DIV         reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    EQUAL           reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    NOT_EQUAL       reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    |               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    >               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    %               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    <               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    *               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    /               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    -               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    +               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    CONCAT          reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    NEWLINE         reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    $end            reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    )               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    OF              reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    THEN            reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    END             reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    ELIF            reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    ELSE            reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    ,               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    ]               reduce using rule 153 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)


state 110

    (171) exprs -> exprs , . _48_NEWLINE_optional expr _49_NEWLINE_optional
    (172) _48_NEWLINE_optional -> . NEWLINE
    (173) _48_NEWLINE_optional -> .
    NEWLINE         shift and go to state 139
    -               reduce using rule 173 (_48_NEWLINE_optional -> .)
    (               reduce using rule 173 (_48_NEWLINE_optional -> .)
    [               reduce using rule 173 (_48_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 173 (_48_NEWLINE_optional -> .)
    CASE            reduce using rule 173 (_48_NEWLINE_optional -> .)
    IF              reduce using rule 173 (_48_NEWLINE_optional -> .)
    STRING          reduce using rule 173 (_48_NEWLINE_optional -> .)
    NUMBER          reduce using rule 173 (_48_NEWLINE_optional -> .)
    DO              reduce using rule 173 (_48_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 173 (_48_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 173 (_48_NEWLINE_optional -> .)

    _48_NEWLINE_optional           shift and go to state 138

state 111

    (168) exprs -> expr _47_NEWLINE_optional .
    ,               reduce using rule 168 (exprs -> expr _47_NEWLINE_optional .)
    ]               reduce using rule 168 (exprs -> expr _47_NEWLINE_optional .)
    )               reduce using rule 168 (exprs -> expr _47_NEWLINE_optional .)


state 112

    (169) _47_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 169 (_47_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 169 (_47_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 169 (_47_NEWLINE_optional -> NEWLINE .)


state 113

    (125) case_of -> CASE expr OF _32_NEWLINE_optional . _33_cases_optional END
    (128) _33_cases_optional -> . cases
    (129) _33_cases_optional -> .
    (130) cases -> . pattern do _34_NEWLINE_optional
    (133) cases -> . cases pattern do _35_NEWLINE_optional
    (136) pattern -> . match_variant
    (137) pattern -> . match_as
    (139) match_variant -> . type_identifier
    (140) match_variant -> . type_identifier ( _36_NEWLINE_optional _37_patterns_optional )
    (138) match_as -> . identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    (176) identifier -> . IDENTIFIER
    END             reduce using rule 129 (_33_cases_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 26

    _33_cases_optional             shift and go to state 140
    cases                          shift and go to state 141
    pattern                        shift and go to state 142
    match_variant                  shift and go to state 143
    match_as                       shift and go to state 144
    type_identifier                shift and go to state 145
    identifier                     shift and go to state 146

state 114

    (126) _32_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 126 (_32_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 126 (_32_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 126 (_32_NEWLINE_optional -> NEWLINE .)


state 115

    (116) if_expr -> IF expr THEN _29_0x3a_type_optional . block_statement _30_or_else_optional END
    (46) block_statement -> . _7_NEWLINE_optional _8_stmts_optional
    (47) _7_NEWLINE_optional -> . NEWLINE
    (48) _7_NEWLINE_optional -> .
    NEWLINE         shift and go to state 149
    DEF             reduce using rule 48 (_7_NEWLINE_optional -> .)
    ENUM            reduce using rule 48 (_7_NEWLINE_optional -> .)
    -               reduce using rule 48 (_7_NEWLINE_optional -> .)
    (               reduce using rule 48 (_7_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 48 (_7_NEWLINE_optional -> .)
    [               reduce using rule 48 (_7_NEWLINE_optional -> .)
    CASE            reduce using rule 48 (_7_NEWLINE_optional -> .)
    IF              reduce using rule 48 (_7_NEWLINE_optional -> .)
    STRING          reduce using rule 48 (_7_NEWLINE_optional -> .)
    NUMBER          reduce using rule 48 (_7_NEWLINE_optional -> .)
    DO              reduce using rule 48 (_7_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 48 (_7_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 48 (_7_NEWLINE_optional -> .)
    ELIF            reduce using rule 48 (_7_NEWLINE_optional -> .)
    ELSE            reduce using rule 48 (_7_NEWLINE_optional -> .)
    END             reduce using rule 48 (_7_NEWLINE_optional -> .)

    block_statement                shift and go to state 147
    _7_NEWLINE_optional            shift and go to state 148

state 116

    (117) _29_0x3a_type_optional -> : . type
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 150
    type_identifier                shift and go to state 83

state 117

    (39) do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional . END
    END             shift and go to state 151


state 118

    (44) _6_stmts_optional -> stmts .
    END             reduce using rule 44 (_6_stmts_optional -> stmts .)


state 119

    (158) call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .
    (               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    INT_DIV         reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    EQUAL           reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    |               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    >               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    %               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    <               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    *               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    /               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    -               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    +               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    CONCAT          reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    NEWLINE         reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    $end            reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    )               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    OF              reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    THEN            reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    END             reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ELIF            reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ELSE            reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ,               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ]               reduce using rule 158 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)


state 120

    (113) param -> identifier . _28_0x3a_type_optional
    (114) _28_0x3a_type_optional -> . : type
    (115) _28_0x3a_type_optional -> .
    :               shift and go to state 153
    NEWLINE         reduce using rule 115 (_28_0x3a_type_optional -> .)
    ,               reduce using rule 115 (_28_0x3a_type_optional -> .)
    )               reduce using rule 115 (_28_0x3a_type_optional -> .)

    _28_0x3a_type_optional         shift and go to state 152

state 121

    (51) def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional . ) _11_0x3a_type_optional do
    )               shift and go to state 154


state 122

    (54) _10_params_optional -> params .
    (73) params -> params . , _17_NEWLINE_optional param _18_NEWLINE_optional
    )               reduce using rule 54 (_10_params_optional -> params .)
    ,               shift and go to state 155


state 123

    (70) params -> param . _16_NEWLINE_optional
    (71) _16_NEWLINE_optional -> . NEWLINE
    (72) _16_NEWLINE_optional -> .
    NEWLINE         shift and go to state 157
    ,               reduce using rule 72 (_16_NEWLINE_optional -> .)
    )               reduce using rule 72 (_16_NEWLINE_optional -> .)

    _16_NEWLINE_optional           shift and go to state 156

state 124

    (58) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat . > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    >               shift and go to state 158


state 125

    (59) _12_0x2c_type_identifier_repeat -> _12_0x2c_type_identifier_items .
    (61) _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items . _12_0x2c_type_identifier_item
    (63) _12_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 59 (_12_0x2c_type_identifier_repeat -> _12_0x2c_type_identifier_items .)
    ,               shift and go to state 127

    _12_0x2c_type_identifier_item  shift and go to state 159

state 126

    (62) _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_item .
    ,               reduce using rule 62 (_12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_item .)
    >               reduce using rule 62 (_12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_item .)


state 127

    (63) _12_0x2c_type_identifier_item -> , . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 160

state 128

    (78) type -> type_identifier < type . _19_0x2c_type_repeat >
    (79) _19_0x2c_type_repeat -> . _19_0x2c_type_items
    (80) _19_0x2c_type_repeat -> .
    (81) _19_0x2c_type_items -> . _19_0x2c_type_items _19_0x2c_type_item
    (82) _19_0x2c_type_items -> . _19_0x2c_type_item
    (83) _19_0x2c_type_item -> . , type
    >               reduce using rule 80 (_19_0x2c_type_repeat -> .)
    ,               shift and go to state 164

    _19_0x2c_type_repeat           shift and go to state 161
    _19_0x2c_type_items            shift and go to state 162
    _19_0x2c_type_item             shift and go to state 163

state 129

    (163) variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .
    (               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    INT_DIV         reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    EQUAL           reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    |               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    >               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    %               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    <               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    *               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    /               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    -               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    +               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    CONCAT          reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    NEWLINE         reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    $end            reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    )               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    OF              reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    THEN            reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    END             reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    ELIF            reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    ELSE            reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    ,               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    ]               reduce using rule 163 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)


state 130

    (106) variant -> type_identifier .
    (107) variant -> type_identifier . ( type _27_0x2c_type_repeat )
    NEWLINE         reduce using rule 106 (variant -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 106 (variant -> type_identifier .)
    }               reduce using rule 106 (variant -> type_identifier .)
    (               shift and go to state 165


state 131

    (85) enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional . }
    }               shift and go to state 166


state 132

    (88) _21_variants_optional -> variants .
    (103) variants -> variants . variant _26_NEWLINE_optional
    (106) variant -> . type_identifier
    (107) variant -> . type_identifier ( type _27_0x2c_type_repeat )
    (177) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 88 (_21_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 34

    variant                        shift and go to state 167
    type_identifier                shift and go to state 130

state 133

    (100) variants -> variant . _25_NEWLINE_optional
    (101) _25_NEWLINE_optional -> . NEWLINE
    (102) _25_NEWLINE_optional -> .
    NEWLINE         shift and go to state 169
    TYPE_IDENTIFIER reduce using rule 102 (_25_NEWLINE_optional -> .)
    }               reduce using rule 102 (_25_NEWLINE_optional -> .)

    _25_NEWLINE_optional           shift and go to state 168

state 134

    (90) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat . > { _23_NEWLINE_optional _24_variants_optional }
    >               shift and go to state 170


state 135

    (91) _22_0x2c_type_identifier_repeat -> _22_0x2c_type_identifier_items .
    (93) _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items . _22_0x2c_type_identifier_item
    (95) _22_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 91 (_22_0x2c_type_identifier_repeat -> _22_0x2c_type_identifier_items .)
    ,               shift and go to state 137

    _22_0x2c_type_identifier_item  shift and go to state 171

state 136

    (94) _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_item .
    ,               reduce using rule 94 (_22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_item .)
    >               reduce using rule 94 (_22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_item .)


state 137

    (95) _22_0x2c_type_identifier_item -> , . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 172

state 138

    (171) exprs -> exprs , _48_NEWLINE_optional . expr _49_NEWLINE_optional
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 173
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 139

    (172) _48_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 172 (_48_NEWLINE_optional -> NEWLINE .)


state 140

    (125) case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional . END
    END             shift and go to state 174


state 141

    (128) _33_cases_optional -> cases .
    (133) cases -> cases . pattern do _35_NEWLINE_optional
    (136) pattern -> . match_variant
    (137) pattern -> . match_as
    (139) match_variant -> . type_identifier
    (140) match_variant -> . type_identifier ( _36_NEWLINE_optional _37_patterns_optional )
    (138) match_as -> . identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    (176) identifier -> . IDENTIFIER
    END             reduce using rule 128 (_33_cases_optional -> cases .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 26

    pattern                        shift and go to state 175
    match_variant                  shift and go to state 143
    match_as                       shift and go to state 144
    type_identifier                shift and go to state 145
    identifier                     shift and go to state 146

state 142

    (130) cases -> pattern . do _34_NEWLINE_optional
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    DO              shift and go to state 32

    do                             shift and go to state 176

state 143

    (136) pattern -> match_variant .
    DO              reduce using rule 136 (pattern -> match_variant .)
    NEWLINE         reduce using rule 136 (pattern -> match_variant .)
    ,               reduce using rule 136 (pattern -> match_variant .)
    )               reduce using rule 136 (pattern -> match_variant .)


state 144

    (137) pattern -> match_as .
    DO              reduce using rule 137 (pattern -> match_as .)
    NEWLINE         reduce using rule 137 (pattern -> match_as .)
    ,               reduce using rule 137 (pattern -> match_as .)
    )               reduce using rule 137 (pattern -> match_as .)


state 145

    (139) match_variant -> type_identifier .
    (140) match_variant -> type_identifier . ( _36_NEWLINE_optional _37_patterns_optional )
    DO              reduce using rule 139 (match_variant -> type_identifier .)
    NEWLINE         reduce using rule 139 (match_variant -> type_identifier .)
    ,               reduce using rule 139 (match_variant -> type_identifier .)
    )               reduce using rule 139 (match_variant -> type_identifier .)
    (               shift and go to state 177


state 146

    (138) match_as -> identifier .
    DO              reduce using rule 138 (match_as -> identifier .)
    NEWLINE         reduce using rule 138 (match_as -> identifier .)
    ,               reduce using rule 138 (match_as -> identifier .)
    )               reduce using rule 138 (match_as -> identifier .)


state 147

    (116) if_expr -> IF expr THEN _29_0x3a_type_optional block_statement . _30_or_else_optional END
    (119) _30_or_else_optional -> . or_else
    (120) _30_or_else_optional -> .
    (121) or_else -> . ELIF expr THEN block_statement _31_or_else_optional
    (124) or_else -> . ELSE block_statement
    END             reduce using rule 120 (_30_or_else_optional -> .)
    ELIF            shift and go to state 180
    ELSE            shift and go to state 181

    _30_or_else_optional           shift and go to state 178
    or_else                        shift and go to state 179

state 148

    (46) block_statement -> _7_NEWLINE_optional . _8_stmts_optional
    (49) _8_stmts_optional -> . stmts
    (50) _8_stmts_optional -> .
    (6) stmts -> . stmt _3_NEWLINE_optional
    (9) stmts -> . stmt NEWLINE stmts
    (10) stmt -> . def_expr
    (11) stmt -> . enum
    (12) stmt -> . variable_declaration
    (13) stmt -> . expr
    (51) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (85) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (178) variable_declaration -> . identifier _50_0x3a_type_optional = expr
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (176) identifier -> . IDENTIFIER
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 50 (_8_stmts_optional -> .)
    ELSE            reduce using rule 50 (_8_stmts_optional -> .)
    END             reduce using rule 50 (_8_stmts_optional -> .)
    DEF             shift and go to state 11
    ENUM            shift and go to state 16
    -               shift and go to state 17
    (               shift and go to state 13
    IDENTIFIER      shift and go to state 26
    [               shift and go to state 27
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _8_stmts_optional              shift and go to state 182
    stmts                          shift and go to state 183
    stmt                           shift and go to state 6
    def_expr                       shift and go to state 7
    enum                           shift and go to state 8
    variable_declaration           shift and go to state 9
    expr                           shift and go to state 10
    identifier                     shift and go to state 12
    do                             shift and go to state 14
    type_identifier                shift and go to state 15
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    external                       shift and go to state 25

state 149

    (47) _7_NEWLINE_optional -> NEWLINE .
    DEF             reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 47 (_7_NEWLINE_optional -> NEWLINE .)


state 150

    (117) _29_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    ELIF            reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    ELSE            reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    END             reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    DEF             reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    -               reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    (               reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    [               reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    CASE            reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    IF              reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    STRING          reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    NUMBER          reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    DO              reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 117 (_29_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 117 (_29_0x3a_type_optional -> : type .)


state 151

    (39) do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .
    (               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    INT_DIV         reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    EQUAL           reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    NOT_EQUAL       reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    |               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    >               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    %               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    <               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    *               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    /               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    -               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    +               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    CONCAT          reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    NEWLINE         reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    $end            reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    )               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    OF              reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    THEN            reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    END             reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    ELIF            reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    ELSE            reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    ,               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    ]               reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    TYPE_IDENTIFIER reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)
    IDENTIFIER      reduce using rule 39 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END .)


state 152

    (113) param -> identifier _28_0x3a_type_optional .
    NEWLINE         reduce using rule 113 (param -> identifier _28_0x3a_type_optional .)
    ,               reduce using rule 113 (param -> identifier _28_0x3a_type_optional .)
    )               reduce using rule 113 (param -> identifier _28_0x3a_type_optional .)


state 153

    (114) _28_0x3a_type_optional -> : . type
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 184
    type_identifier                shift and go to state 83

state 154

    (51) def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) . _11_0x3a_type_optional do
    (56) _11_0x3a_type_optional -> . : type
    (57) _11_0x3a_type_optional -> .
    :               shift and go to state 186
    DO              reduce using rule 57 (_11_0x3a_type_optional -> .)

    _11_0x3a_type_optional         shift and go to state 185

state 155

    (73) params -> params , . _17_NEWLINE_optional param _18_NEWLINE_optional
    (74) _17_NEWLINE_optional -> . NEWLINE
    (75) _17_NEWLINE_optional -> .
    NEWLINE         shift and go to state 188
    IDENTIFIER      reduce using rule 75 (_17_NEWLINE_optional -> .)

    _17_NEWLINE_optional           shift and go to state 187

state 156

    (70) params -> param _16_NEWLINE_optional .
    ,               reduce using rule 70 (params -> param _16_NEWLINE_optional .)
    )               reduce using rule 70 (params -> param _16_NEWLINE_optional .)


state 157

    (71) _16_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 71 (_16_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 71 (_16_NEWLINE_optional -> NEWLINE .)


state 158

    (58) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > . ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (               shift and go to state 189


state 159

    (61) _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item .
    ,               reduce using rule 61 (_12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item .)
    >               reduce using rule 61 (_12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item .)


state 160

    (63) _12_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 63 (_12_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 63 (_12_0x2c_type_identifier_item -> , type_identifier .)


state 161

    (78) type -> type_identifier < type _19_0x2c_type_repeat . >
    >               shift and go to state 190


state 162

    (79) _19_0x2c_type_repeat -> _19_0x2c_type_items .
    (81) _19_0x2c_type_items -> _19_0x2c_type_items . _19_0x2c_type_item
    (83) _19_0x2c_type_item -> . , type
    >               reduce using rule 79 (_19_0x2c_type_repeat -> _19_0x2c_type_items .)
    ,               shift and go to state 164

    _19_0x2c_type_item             shift and go to state 191

state 163

    (82) _19_0x2c_type_items -> _19_0x2c_type_item .
    ,               reduce using rule 82 (_19_0x2c_type_items -> _19_0x2c_type_item .)
    >               reduce using rule 82 (_19_0x2c_type_items -> _19_0x2c_type_item .)


state 164

    (83) _19_0x2c_type_item -> , . type
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 192
    type_identifier                shift and go to state 83

state 165

    (107) variant -> type_identifier ( . type _27_0x2c_type_repeat )
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 83
    type                           shift and go to state 193

state 166

    (85) enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .
    NEWLINE         reduce using rule 85 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    $end            reduce using rule 85 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    END             reduce using rule 85 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    ELIF            reduce using rule 85 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    ELSE            reduce using rule 85 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)


state 167

    (103) variants -> variants variant . _26_NEWLINE_optional
    (104) _26_NEWLINE_optional -> . NEWLINE
    (105) _26_NEWLINE_optional -> .
    NEWLINE         shift and go to state 195
    TYPE_IDENTIFIER reduce using rule 105 (_26_NEWLINE_optional -> .)
    }               reduce using rule 105 (_26_NEWLINE_optional -> .)

    _26_NEWLINE_optional           shift and go to state 194

state 168

    (100) variants -> variant _25_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 100 (variants -> variant _25_NEWLINE_optional .)
    }               reduce using rule 100 (variants -> variant _25_NEWLINE_optional .)


state 169

    (101) _25_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 101 (_25_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 101 (_25_NEWLINE_optional -> NEWLINE .)


state 170

    (90) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > . { _23_NEWLINE_optional _24_variants_optional }
    {               shift and go to state 196


state 171

    (93) _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item .
    ,               reduce using rule 93 (_22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item .)
    >               reduce using rule 93 (_22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item .)


state 172

    (95) _22_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 95 (_22_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 95 (_22_0x2c_type_identifier_item -> , type_identifier .)


state 173

    (171) exprs -> exprs , _48_NEWLINE_optional expr . _49_NEWLINE_optional
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    (174) _49_NEWLINE_optional -> . NEWLINE
    (175) _49_NEWLINE_optional -> .
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49
    NEWLINE         shift and go to state 198
    ,               reduce using rule 175 (_49_NEWLINE_optional -> .)
    ]               reduce using rule 175 (_49_NEWLINE_optional -> .)
    )               reduce using rule 175 (_49_NEWLINE_optional -> .)

    _49_NEWLINE_optional           shift and go to state 197

state 174

    (125) case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .
    (               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    INT_DIV         reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    EQUAL           reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    NOT_EQUAL       reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    |               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    >               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    %               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    <               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    *               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    /               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    -               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    +               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    CONCAT          reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    NEWLINE         reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    $end            reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    )               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    OF              reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    THEN            reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    END             reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    ELIF            reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    ELSE            reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    ,               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    ]               reduce using rule 125 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)


state 175

    (133) cases -> cases pattern . do _35_NEWLINE_optional
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    DO              shift and go to state 32

    do                             shift and go to state 199

state 176

    (130) cases -> pattern do . _34_NEWLINE_optional
    (131) _34_NEWLINE_optional -> . NEWLINE
    (132) _34_NEWLINE_optional -> .
    NEWLINE         shift and go to state 201
    TYPE_IDENTIFIER reduce using rule 132 (_34_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 132 (_34_NEWLINE_optional -> .)
    END             reduce using rule 132 (_34_NEWLINE_optional -> .)

    _34_NEWLINE_optional           shift and go to state 200

state 177

    (140) match_variant -> type_identifier ( . _36_NEWLINE_optional _37_patterns_optional )
    (141) _36_NEWLINE_optional -> . NEWLINE
    (142) _36_NEWLINE_optional -> .
    NEWLINE         shift and go to state 203
    TYPE_IDENTIFIER reduce using rule 142 (_36_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 142 (_36_NEWLINE_optional -> .)
    )               reduce using rule 142 (_36_NEWLINE_optional -> .)

    _36_NEWLINE_optional           shift and go to state 202

state 178

    (116) if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional . END
    END             shift and go to state 204


state 179

    (119) _30_or_else_optional -> or_else .
    END             reduce using rule 119 (_30_or_else_optional -> or_else .)


state 180

    (121) or_else -> ELIF . expr THEN block_statement _31_or_else_optional
    (14) expr -> . - expr
    (15) expr -> . ( expr )
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . literal
    (24) expr -> . do
    (25) expr -> . external
    (153) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (163) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (176) identifier -> . IDENTIFIER
    (158) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (125) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (27) binary_expr -> . expr INT_DIV expr
    (28) binary_expr -> . expr EQUAL expr
    (29) binary_expr -> . expr NOT_EQUAL expr
    (30) binary_expr -> . expr | expr
    (31) binary_expr -> . expr > expr
    (32) binary_expr -> . expr % expr
    (33) binary_expr -> . expr < expr
    (34) binary_expr -> . expr * expr
    (35) binary_expr -> . expr / expr
    (36) binary_expr -> . expr - expr
    (37) binary_expr -> . expr + expr
    (38) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (181) literal -> . STRING
    (182) literal -> . NUMBER
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    (26) external -> . EXTERNAL
    (177) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 17
    (               shift and go to state 13
    [               shift and go to state 27
    IDENTIFIER      shift and go to state 26
    CASE            shift and go to state 28
    IF              shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 205
    array                          shift and go to state 18
    variant_call                   shift and go to state 19
    identifier                     shift and go to state 54
    call                           shift and go to state 20
    case_of                        shift and go to state 21
    binary_expr                    shift and go to state 22
    if_expr                        shift and go to state 23
    literal                        shift and go to state 24
    do                             shift and go to state 14
    external                       shift and go to state 25
    type_identifier                shift and go to state 15

state 181

    (124) or_else -> ELSE . block_statement
    (46) block_statement -> . _7_NEWLINE_optional _8_stmts_optional
    (47) _7_NEWLINE_optional -> . NEWLINE
    (48) _7_NEWLINE_optional -> .
    NEWLINE         shift and go to state 149
    DEF             reduce using rule 48 (_7_NEWLINE_optional -> .)
    ENUM            reduce using rule 48 (_7_NEWLINE_optional -> .)
    -               reduce using rule 48 (_7_NEWLINE_optional -> .)
    (               reduce using rule 48 (_7_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 48 (_7_NEWLINE_optional -> .)
    [               reduce using rule 48 (_7_NEWLINE_optional -> .)
    CASE            reduce using rule 48 (_7_NEWLINE_optional -> .)
    IF              reduce using rule 48 (_7_NEWLINE_optional -> .)
    STRING          reduce using rule 48 (_7_NEWLINE_optional -> .)
    NUMBER          reduce using rule 48 (_7_NEWLINE_optional -> .)
    DO              reduce using rule 48 (_7_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 48 (_7_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 48 (_7_NEWLINE_optional -> .)
    END             reduce using rule 48 (_7_NEWLINE_optional -> .)

    block_statement                shift and go to state 206
    _7_NEWLINE_optional            shift and go to state 148

state 182

    (46) block_statement -> _7_NEWLINE_optional _8_stmts_optional .
    ELIF            reduce using rule 46 (block_statement -> _7_NEWLINE_optional _8_stmts_optional .)
    ELSE            reduce using rule 46 (block_statement -> _7_NEWLINE_optional _8_stmts_optional .)
    END             reduce using rule 46 (block_statement -> _7_NEWLINE_optional _8_stmts_optional .)


state 183

    (49) _8_stmts_optional -> stmts .
    ELIF            reduce using rule 49 (_8_stmts_optional -> stmts .)
    ELSE            reduce using rule 49 (_8_stmts_optional -> stmts .)
    END             reduce using rule 49 (_8_stmts_optional -> stmts .)


state 184

    (114) _28_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 114 (_28_0x3a_type_optional -> : type .)
    ,               reduce using rule 114 (_28_0x3a_type_optional -> : type .)
    )               reduce using rule 114 (_28_0x3a_type_optional -> : type .)


state 185

    (51) def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional . do
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    DO              shift and go to state 32

    do                             shift and go to state 207

state 186

    (56) _11_0x3a_type_optional -> : . type
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 208
    type_identifier                shift and go to state 83

state 187

    (73) params -> params , _17_NEWLINE_optional . param _18_NEWLINE_optional
    (113) param -> . identifier _28_0x3a_type_optional
    (176) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 26

    param                          shift and go to state 209
    identifier                     shift and go to state 120

state 188

    (74) _17_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 74 (_17_NEWLINE_optional -> NEWLINE .)


state 189

    (58) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( . _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (64) _13_NEWLINE_optional -> . NEWLINE
    (65) _13_NEWLINE_optional -> .
    NEWLINE         shift and go to state 211
    IDENTIFIER      reduce using rule 65 (_13_NEWLINE_optional -> .)
    )               reduce using rule 65 (_13_NEWLINE_optional -> .)

    _13_NEWLINE_optional           shift and go to state 210

state 190

    (78) type -> type_identifier < type _19_0x2c_type_repeat > .
    =               reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    NEWLINE         reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    DEF             reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    ENUM            reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    -               reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    (               reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    IDENTIFIER      reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    [               reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    CASE            reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    IF              reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    STRING          reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    NUMBER          reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    DO              reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    EXTERNAL        reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    TYPE_IDENTIFIER reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    END             reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    ,               reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    >               reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    ELIF            reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    ELSE            reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    )               reduce using rule 78 (type -> type_identifier < type _19_0x2c_type_repeat > .)


state 191

    (81) _19_0x2c_type_items -> _19_0x2c_type_items _19_0x2c_type_item .
    ,               reduce using rule 81 (_19_0x2c_type_items -> _19_0x2c_type_items _19_0x2c_type_item .)
    >               reduce using rule 81 (_19_0x2c_type_items -> _19_0x2c_type_items _19_0x2c_type_item .)


state 192

    (83) _19_0x2c_type_item -> , type .
    ,               reduce using rule 83 (_19_0x2c_type_item -> , type .)
    >               reduce using rule 83 (_19_0x2c_type_item -> , type .)


state 193

    (107) variant -> type_identifier ( type . _27_0x2c_type_repeat )
    (108) _27_0x2c_type_repeat -> . _27_0x2c_type_items
    (109) _27_0x2c_type_repeat -> .
    (110) _27_0x2c_type_items -> . _27_0x2c_type_items _27_0x2c_type_item
    (111) _27_0x2c_type_items -> . _27_0x2c_type_item
    (112) _27_0x2c_type_item -> . , type
    )               reduce using rule 109 (_27_0x2c_type_repeat -> .)
    ,               shift and go to state 215

    _27_0x2c_type_repeat           shift and go to state 212
    _27_0x2c_type_items            shift and go to state 213
    _27_0x2c_type_item             shift and go to state 214

state 194

    (103) variants -> variants variant _26_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 103 (variants -> variants variant _26_NEWLINE_optional .)
    }               reduce using rule 103 (variants -> variants variant _26_NEWLINE_optional .)


state 195

    (104) _26_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 104 (_26_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 104 (_26_NEWLINE_optional -> NEWLINE .)


state 196

    (90) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { . _23_NEWLINE_optional _24_variants_optional }
    (96) _23_NEWLINE_optional -> . NEWLINE
    (97) _23_NEWLINE_optional -> .
    NEWLINE         shift and go to state 217
    TYPE_IDENTIFIER reduce using rule 97 (_23_NEWLINE_optional -> .)
    }               reduce using rule 97 (_23_NEWLINE_optional -> .)

    _23_NEWLINE_optional           shift and go to state 216

state 197

    (171) exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional .
    ,               reduce using rule 171 (exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional .)
    ]               reduce using rule 171 (exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional .)
    )               reduce using rule 171 (exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional .)


state 198

    (174) _49_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 174 (_49_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 174 (_49_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 174 (_49_NEWLINE_optional -> NEWLINE .)


state 199

    (133) cases -> cases pattern do . _35_NEWLINE_optional
    (134) _35_NEWLINE_optional -> . NEWLINE
    (135) _35_NEWLINE_optional -> .
    NEWLINE         shift and go to state 219
    TYPE_IDENTIFIER reduce using rule 135 (_35_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 135 (_35_NEWLINE_optional -> .)
    END             reduce using rule 135 (_35_NEWLINE_optional -> .)

    _35_NEWLINE_optional           shift and go to state 218

state 200

    (130) cases -> pattern do _34_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 130 (cases -> pattern do _34_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 130 (cases -> pattern do _34_NEWLINE_optional .)
    END             reduce using rule 130 (cases -> pattern do _34_NEWLINE_optional .)


state 201

    (131) _34_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 131 (_34_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 131 (_34_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 131 (_34_NEWLINE_optional -> NEWLINE .)


state 202

    (140) match_variant -> type_identifier ( _36_NEWLINE_optional . _37_patterns_optional )
    (143) _37_patterns_optional -> . patterns
    (144) _37_patterns_optional -> .
    (145) patterns -> . pattern _38_NEWLINE_optional
    (148) patterns -> . patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional
    (136) pattern -> . match_variant
    (137) pattern -> . match_as
    (139) match_variant -> . type_identifier
    (140) match_variant -> . type_identifier ( _36_NEWLINE_optional _37_patterns_optional )
    (138) match_as -> . identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    (176) identifier -> . IDENTIFIER
    )               reduce using rule 144 (_37_patterns_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 26

    type_identifier                shift and go to state 145
    _37_patterns_optional          shift and go to state 220
    patterns                       shift and go to state 221
    pattern                        shift and go to state 222
    match_variant                  shift and go to state 143
    match_as                       shift and go to state 144
    identifier                     shift and go to state 146

state 203

    (141) _36_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 141 (_36_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 141 (_36_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 141 (_36_NEWLINE_optional -> NEWLINE .)


state 204

    (116) if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .
    (               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    INT_DIV         reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    EQUAL           reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    NOT_EQUAL       reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    |               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    >               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    %               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    <               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    *               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    /               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    -               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    +               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    CONCAT          reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    NEWLINE         reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    $end            reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    )               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    OF              reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    THEN            reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    END             reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    ELIF            reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    ELSE            reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    ,               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    ]               reduce using rule 116 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)


state 205

    (121) or_else -> ELIF expr . THEN block_statement _31_or_else_optional
    (158) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (27) binary_expr -> expr . INT_DIV expr
    (28) binary_expr -> expr . EQUAL expr
    (29) binary_expr -> expr . NOT_EQUAL expr
    (30) binary_expr -> expr . | expr
    (31) binary_expr -> expr . > expr
    (32) binary_expr -> expr . % expr
    (33) binary_expr -> expr . < expr
    (34) binary_expr -> expr . * expr
    (35) binary_expr -> expr . / expr
    (36) binary_expr -> expr . - expr
    (37) binary_expr -> expr . + expr
    (38) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 223
    (               shift and go to state 37
    INT_DIV         shift and go to state 38
    EQUAL           shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    |               shift and go to state 41
    >               shift and go to state 42
    %               shift and go to state 43
    <               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    -               shift and go to state 47
    +               shift and go to state 48
    CONCAT          shift and go to state 49


state 206

    (124) or_else -> ELSE block_statement .
    END             reduce using rule 124 (or_else -> ELSE block_statement .)


state 207

    (51) def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .
    NEWLINE         reduce using rule 51 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    $end            reduce using rule 51 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    END             reduce using rule 51 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    ELIF            reduce using rule 51 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    ELSE            reduce using rule 51 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)


state 208

    (56) _11_0x3a_type_optional -> : type .
    DO              reduce using rule 56 (_11_0x3a_type_optional -> : type .)


state 209

    (73) params -> params , _17_NEWLINE_optional param . _18_NEWLINE_optional
    (76) _18_NEWLINE_optional -> . NEWLINE
    (77) _18_NEWLINE_optional -> .
    NEWLINE         shift and go to state 225
    ,               reduce using rule 77 (_18_NEWLINE_optional -> .)
    )               reduce using rule 77 (_18_NEWLINE_optional -> .)

    _18_NEWLINE_optional           shift and go to state 224

state 210

    (58) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional . _14_params_optional ) _15_0x3a_type_optional do
    (66) _14_params_optional -> . params
    (67) _14_params_optional -> .
    (70) params -> . param _16_NEWLINE_optional
    (73) params -> . params , _17_NEWLINE_optional param _18_NEWLINE_optional
    (113) param -> . identifier _28_0x3a_type_optional
    (176) identifier -> . IDENTIFIER
    )               reduce using rule 67 (_14_params_optional -> .)
    IDENTIFIER      shift and go to state 26

    identifier                     shift and go to state 120
    _14_params_optional            shift and go to state 226
    params                         shift and go to state 227
    param                          shift and go to state 123

state 211

    (64) _13_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 64 (_13_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 64 (_13_NEWLINE_optional -> NEWLINE .)


state 212

    (107) variant -> type_identifier ( type _27_0x2c_type_repeat . )
    )               shift and go to state 228


state 213

    (108) _27_0x2c_type_repeat -> _27_0x2c_type_items .
    (110) _27_0x2c_type_items -> _27_0x2c_type_items . _27_0x2c_type_item
    (112) _27_0x2c_type_item -> . , type
    )               reduce using rule 108 (_27_0x2c_type_repeat -> _27_0x2c_type_items .)
    ,               shift and go to state 215

    _27_0x2c_type_item             shift and go to state 229

state 214

    (111) _27_0x2c_type_items -> _27_0x2c_type_item .
    ,               reduce using rule 111 (_27_0x2c_type_items -> _27_0x2c_type_item .)
    )               reduce using rule 111 (_27_0x2c_type_items -> _27_0x2c_type_item .)


state 215

    (112) _27_0x2c_type_item -> , . type
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 230
    type_identifier                shift and go to state 83

state 216

    (90) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional . _24_variants_optional }
    (98) _24_variants_optional -> . variants
    (99) _24_variants_optional -> .
    (100) variants -> . variant _25_NEWLINE_optional
    (103) variants -> . variants variant _26_NEWLINE_optional
    (106) variant -> . type_identifier
    (107) variant -> . type_identifier ( type _27_0x2c_type_repeat )
    (177) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 99 (_24_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 130
    _24_variants_optional          shift and go to state 231
    variants                       shift and go to state 232
    variant                        shift and go to state 133

state 217

    (96) _23_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 96 (_23_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 96 (_23_NEWLINE_optional -> NEWLINE .)


state 218

    (133) cases -> cases pattern do _35_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 133 (cases -> cases pattern do _35_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 133 (cases -> cases pattern do _35_NEWLINE_optional .)
    END             reduce using rule 133 (cases -> cases pattern do _35_NEWLINE_optional .)


state 219

    (134) _35_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 134 (_35_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 134 (_35_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 134 (_35_NEWLINE_optional -> NEWLINE .)


state 220

    (140) match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional . )
    )               shift and go to state 233


state 221

    (143) _37_patterns_optional -> patterns .
    (148) patterns -> patterns . , _39_NEWLINE_optional pattern _40_NEWLINE_optional
    )               reduce using rule 143 (_37_patterns_optional -> patterns .)
    ,               shift and go to state 234


state 222

    (145) patterns -> pattern . _38_NEWLINE_optional
    (146) _38_NEWLINE_optional -> . NEWLINE
    (147) _38_NEWLINE_optional -> .
    NEWLINE         shift and go to state 236
    ,               reduce using rule 147 (_38_NEWLINE_optional -> .)
    )               reduce using rule 147 (_38_NEWLINE_optional -> .)

    _38_NEWLINE_optional           shift and go to state 235

state 223

    (121) or_else -> ELIF expr THEN . block_statement _31_or_else_optional
    (46) block_statement -> . _7_NEWLINE_optional _8_stmts_optional
    (47) _7_NEWLINE_optional -> . NEWLINE
    (48) _7_NEWLINE_optional -> .
    NEWLINE         shift and go to state 149
    DEF             reduce using rule 48 (_7_NEWLINE_optional -> .)
    ENUM            reduce using rule 48 (_7_NEWLINE_optional -> .)
    -               reduce using rule 48 (_7_NEWLINE_optional -> .)
    (               reduce using rule 48 (_7_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 48 (_7_NEWLINE_optional -> .)
    [               reduce using rule 48 (_7_NEWLINE_optional -> .)
    CASE            reduce using rule 48 (_7_NEWLINE_optional -> .)
    IF              reduce using rule 48 (_7_NEWLINE_optional -> .)
    STRING          reduce using rule 48 (_7_NEWLINE_optional -> .)
    NUMBER          reduce using rule 48 (_7_NEWLINE_optional -> .)
    DO              reduce using rule 48 (_7_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 48 (_7_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 48 (_7_NEWLINE_optional -> .)
    ELIF            reduce using rule 48 (_7_NEWLINE_optional -> .)
    ELSE            reduce using rule 48 (_7_NEWLINE_optional -> .)
    END             reduce using rule 48 (_7_NEWLINE_optional -> .)

    block_statement                shift and go to state 237
    _7_NEWLINE_optional            shift and go to state 148

state 224

    (73) params -> params , _17_NEWLINE_optional param _18_NEWLINE_optional .
    ,               reduce using rule 73 (params -> params , _17_NEWLINE_optional param _18_NEWLINE_optional .)
    )               reduce using rule 73 (params -> params , _17_NEWLINE_optional param _18_NEWLINE_optional .)


state 225

    (76) _18_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 76 (_18_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 76 (_18_NEWLINE_optional -> NEWLINE .)


state 226

    (58) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional . ) _15_0x3a_type_optional do
    )               shift and go to state 238


state 227

    (66) _14_params_optional -> params .
    (73) params -> params . , _17_NEWLINE_optional param _18_NEWLINE_optional
    )               reduce using rule 66 (_14_params_optional -> params .)
    ,               shift and go to state 155


state 228

    (107) variant -> type_identifier ( type _27_0x2c_type_repeat ) .
    NEWLINE         reduce using rule 107 (variant -> type_identifier ( type _27_0x2c_type_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 107 (variant -> type_identifier ( type _27_0x2c_type_repeat ) .)
    }               reduce using rule 107 (variant -> type_identifier ( type _27_0x2c_type_repeat ) .)


state 229

    (110) _27_0x2c_type_items -> _27_0x2c_type_items _27_0x2c_type_item .
    ,               reduce using rule 110 (_27_0x2c_type_items -> _27_0x2c_type_items _27_0x2c_type_item .)
    )               reduce using rule 110 (_27_0x2c_type_items -> _27_0x2c_type_items _27_0x2c_type_item .)


state 230

    (112) _27_0x2c_type_item -> , type .
    ,               reduce using rule 112 (_27_0x2c_type_item -> , type .)
    )               reduce using rule 112 (_27_0x2c_type_item -> , type .)


state 231

    (90) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional . }
    }               shift and go to state 239


state 232

    (98) _24_variants_optional -> variants .
    (103) variants -> variants . variant _26_NEWLINE_optional
    (106) variant -> . type_identifier
    (107) variant -> . type_identifier ( type _27_0x2c_type_repeat )
    (177) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 98 (_24_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 34

    variant                        shift and go to state 167
    type_identifier                shift and go to state 130

state 233

    (140) match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .
    DO              reduce using rule 140 (match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .)
    NEWLINE         reduce using rule 140 (match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .)
    ,               reduce using rule 140 (match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .)
    )               reduce using rule 140 (match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .)


state 234

    (148) patterns -> patterns , . _39_NEWLINE_optional pattern _40_NEWLINE_optional
    (149) _39_NEWLINE_optional -> . NEWLINE
    (150) _39_NEWLINE_optional -> .
    NEWLINE         shift and go to state 241
    TYPE_IDENTIFIER reduce using rule 150 (_39_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 150 (_39_NEWLINE_optional -> .)

    _39_NEWLINE_optional           shift and go to state 240

state 235

    (145) patterns -> pattern _38_NEWLINE_optional .
    ,               reduce using rule 145 (patterns -> pattern _38_NEWLINE_optional .)
    )               reduce using rule 145 (patterns -> pattern _38_NEWLINE_optional .)


state 236

    (146) _38_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 146 (_38_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 146 (_38_NEWLINE_optional -> NEWLINE .)


state 237

    (121) or_else -> ELIF expr THEN block_statement . _31_or_else_optional
    (122) _31_or_else_optional -> . or_else
    (123) _31_or_else_optional -> .
    (121) or_else -> . ELIF expr THEN block_statement _31_or_else_optional
    (124) or_else -> . ELSE block_statement
    END             reduce using rule 123 (_31_or_else_optional -> .)
    ELIF            shift and go to state 180
    ELSE            shift and go to state 181

    _31_or_else_optional           shift and go to state 242
    or_else                        shift and go to state 243

state 238

    (58) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) . _15_0x3a_type_optional do
    (68) _15_0x3a_type_optional -> . : type
    (69) _15_0x3a_type_optional -> .
    :               shift and go to state 245
    DO              reduce using rule 69 (_15_0x3a_type_optional -> .)

    _15_0x3a_type_optional         shift and go to state 244

state 239

    (90) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .
    NEWLINE         reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    $end            reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    END             reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    ELIF            reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    ELSE            reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)


state 240

    (148) patterns -> patterns , _39_NEWLINE_optional . pattern _40_NEWLINE_optional
    (136) pattern -> . match_variant
    (137) pattern -> . match_as
    (139) match_variant -> . type_identifier
    (140) match_variant -> . type_identifier ( _36_NEWLINE_optional _37_patterns_optional )
    (138) match_as -> . identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    (176) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 26

    pattern                        shift and go to state 246
    match_variant                  shift and go to state 143
    match_as                       shift and go to state 144
    type_identifier                shift and go to state 145
    identifier                     shift and go to state 146

state 241

    (149) _39_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 149 (_39_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 149 (_39_NEWLINE_optional -> NEWLINE .)


state 242

    (121) or_else -> ELIF expr THEN block_statement _31_or_else_optional .
    END             reduce using rule 121 (or_else -> ELIF expr THEN block_statement _31_or_else_optional .)


state 243

    (122) _31_or_else_optional -> or_else .
    END             reduce using rule 122 (_31_or_else_optional -> or_else .)


state 244

    (58) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional . do
    (39) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_stmts_optional END
    DO              shift and go to state 32

    do                             shift and go to state 247

state 245

    (68) _15_0x3a_type_optional -> : . type
    (78) type -> . type_identifier < type _19_0x2c_type_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 248
    type_identifier                shift and go to state 83

state 246

    (148) patterns -> patterns , _39_NEWLINE_optional pattern . _40_NEWLINE_optional
    (151) _40_NEWLINE_optional -> . NEWLINE
    (152) _40_NEWLINE_optional -> .
    NEWLINE         shift and go to state 250
    ,               reduce using rule 152 (_40_NEWLINE_optional -> .)
    )               reduce using rule 152 (_40_NEWLINE_optional -> .)

    _40_NEWLINE_optional           shift and go to state 249

state 247

    (58) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .
    NEWLINE         reduce using rule 58 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    $end            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    END             reduce using rule 58 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    ELIF            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    ELSE            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)


state 248

    (68) _15_0x3a_type_optional -> : type .
    DO              reduce using rule 68 (_15_0x3a_type_optional -> : type .)


state 249

    (148) patterns -> patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional .
    ,               reduce using rule 148 (patterns -> patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional .)
    )               reduce using rule 148 (patterns -> patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional .)


state 250

    (151) _40_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 151 (_40_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 151 (_40_NEWLINE_optional -> NEWLINE .)
