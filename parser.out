Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_optional _2_repeat
Rule 2     _1_optional -> stmt
Rule 3     _1_optional -> <empty>
Rule 4     _2_repeat -> _2_items
Rule 5     _2_repeat -> <empty>
Rule 6     _2_items -> _2_items _2_item
Rule 7     _2_items -> _2_item
Rule 8     _2_item -> NEWLINE stmt
Rule 9     stmt -> enum
Rule 10    stmt -> struct
Rule 11    stmt -> expr
Rule 12    expr -> ( expr )
Rule 13    expr -> - expr  [precedence=right, level=6]
Rule 14    expr -> tuple
Rule 15    expr -> array
Rule 16    expr -> binary_expr
Rule 17    expr -> identifier
Rule 18    expr -> variable_declaration
Rule 19    expr -> case_of
Rule 20    expr -> call
Rule 21    expr -> if_expr
Rule 22    expr -> def_expr
Rule 23    expr -> literal
Rule 24    expr -> do
Rule 25    binary_expr -> expr INT_DIV expr  [precedence=left, level=4]
Rule 26    binary_expr -> expr > expr  [precedence=left, level=5]
Rule 27    binary_expr -> expr < expr  [precedence=left, level=5]
Rule 28    binary_expr -> expr * expr  [precedence=left, level=4]
Rule 29    binary_expr -> expr / expr  [precedence=left, level=4]
Rule 30    binary_expr -> expr - expr  [precedence=left, level=3]
Rule 31    binary_expr -> expr + expr  [precedence=left, level=3]
Rule 32    binary_expr -> expr CONCAT expr  [precedence=left, level=2]
Rule 33    do -> DO _3_optional _4_optional _5_repeat END
Rule 34    _3_optional -> : type
Rule 35    _3_optional -> <empty>
Rule 36    _4_optional -> expr
Rule 37    _4_optional -> <empty>
Rule 38    _5_repeat -> _5_items
Rule 39    _5_repeat -> <empty>
Rule 40    _5_items -> _5_items _5_item
Rule 41    _5_items -> _5_item
Rule 42    _5_item -> NEWLINE expr
Rule 43    block_statement -> _6_optional _7_repeat
Rule 44    _6_optional -> expr
Rule 45    _6_optional -> <empty>
Rule 46    _7_repeat -> _7_items
Rule 47    _7_repeat -> <empty>
Rule 48    _7_items -> _7_items _7_item
Rule 49    _7_items -> _7_item
Rule 50    _7_item -> NEWLINE expr
Rule 51    def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do
Rule 52    _8_optional -> param
Rule 53    _8_optional -> <empty>
Rule 54    _9_repeat -> _9_items
Rule 55    _9_repeat -> <empty>
Rule 56    _9_items -> _9_items _9_item
Rule 57    _9_items -> _9_item
Rule 58    _9_item -> , param
Rule 59    _10_optional -> : type
Rule 60    _10_optional -> <empty>
Rule 61    type -> identifier _11_optional
Rule 62    _11_optional -> < type _12_repeat >  [precedence=left, level=5]
Rule 63    _12_repeat -> _12_items
Rule 64    _12_repeat -> <empty>
Rule 65    _12_items -> _12_items _12_item
Rule 66    _12_items -> _12_item
Rule 67    _12_item -> , type
Rule 68    _11_optional -> <empty>
Rule 69    struct -> STRUCT identifier _13_optional { _15_repeat }
Rule 70    _13_optional -> < identifier _14_repeat >  [precedence=left, level=5]
Rule 71    _14_repeat -> _14_items
Rule 72    _14_repeat -> <empty>
Rule 73    _14_items -> _14_items _14_item
Rule 74    _14_items -> _14_item
Rule 75    _14_item -> , identifier
Rule 76    _13_optional -> <empty>
Rule 77    _15_repeat -> _15_items
Rule 78    _15_repeat -> <empty>
Rule 79    _15_items -> _15_items _15_item
Rule 80    _15_items -> _15_item
Rule 81    _15_item -> identifier : type
Rule 82    enum -> ENUM identifier _16_optional { _18_repeat }
Rule 83    _16_optional -> < identifier _17_repeat >  [precedence=left, level=5]
Rule 84    _17_repeat -> _17_items
Rule 85    _17_repeat -> <empty>
Rule 86    _17_items -> _17_items _17_item
Rule 87    _17_items -> _17_item
Rule 88    _17_item -> , identifier
Rule 89    _16_optional -> <empty>
Rule 90    _18_repeat -> _18_items
Rule 91    _18_repeat -> <empty>
Rule 92    _18_items -> _18_items _18_item
Rule 93    _18_items -> _18_item
Rule 94    _18_item -> enum_key
Rule 95    enum_key -> identifier _19_optional
Rule 96    _19_optional -> ( identifier _20_repeat )
Rule 97    _20_repeat -> _20_items
Rule 98    _20_repeat -> <empty>
Rule 99    _20_items -> _20_items _20_item
Rule 100   _20_items -> _20_item
Rule 101   _20_item -> , identifier
Rule 102   _19_optional -> <empty>
Rule 103   param -> identifier _21_optional
Rule 104   _21_optional -> : type
Rule 105   _21_optional -> <empty>
Rule 106   if_expr -> IF expr THEN _22_optional block_statement _23_optional END
Rule 107   _22_optional -> : type
Rule 108   _22_optional -> <empty>
Rule 109   _23_optional -> or_else
Rule 110   _23_optional -> <empty>
Rule 111   or_else -> ELIF expr THEN block_statement _24_optional
Rule 112   _24_optional -> or_else
Rule 113   _24_optional -> <empty>
Rule 114   or_else -> ELSE block_statement
Rule 115   case_of -> CASE expr OF case _25_repeat END
Rule 116   _25_repeat -> _25_items
Rule 117   _25_repeat -> <empty>
Rule 118   _25_items -> _25_items _25_item
Rule 119   _25_items -> _25_item
Rule 120   _25_item -> case
Rule 121   case -> pattern do
Rule 122   pattern -> enum_pattern
Rule 123   enum_pattern -> identifier _26_optional
Rule 124   _26_optional -> ( pattern _27_repeat )
Rule 125   _27_repeat -> _27_items
Rule 126   _27_repeat -> <empty>
Rule 127   _27_items -> _27_items _27_item
Rule 128   _27_items -> _27_item
Rule 129   _27_item -> , pattern
Rule 130   _26_optional -> <empty>
Rule 131   array -> [ _28_optional _29_repeat ]
Rule 132   _28_optional -> expr
Rule 133   _28_optional -> <empty>
Rule 134   _29_repeat -> _29_items
Rule 135   _29_repeat -> <empty>
Rule 136   _29_items -> _29_items _29_item
Rule 137   _29_items -> _29_item
Rule 138   _29_item -> , expr
Rule 139   tuple -> { _30_optional _31_repeat }
Rule 140   _30_optional -> expr
Rule 141   _30_optional -> <empty>
Rule 142   _31_repeat -> _31_items
Rule 143   _31_repeat -> <empty>
Rule 144   _31_items -> _31_items _31_item
Rule 145   _31_items -> _31_item
Rule 146   _31_item -> , expr
Rule 147   call -> callee ( _32_optional _33_repeat )
Rule 148   _32_optional -> expr
Rule 149   _32_optional -> <empty>
Rule 150   _33_repeat -> _33_items
Rule 151   _33_repeat -> <empty>
Rule 152   _33_items -> _33_items _33_item
Rule 153   _33_items -> _33_item
Rule 154   _33_item -> , expr
Rule 155   callee -> identifier
Rule 156   identifier -> IDENTIFIER
Rule 157   variable_declaration -> identifier _34_optional = expr  [precedence=left, level=1]
Rule 158   _34_optional -> : type
Rule 159   _34_optional -> <empty>
Rule 160   literal -> STRING
Rule 161   literal -> NUMBER

Unused terminals:

    SPREAD

Terminals, with rules where they appear:

(                    : 12 51 96 124 147
)                    : 12 51 96 124 147
*                    : 28
+                    : 31
,                    : 58 67 75 88 101 129 138 146 154
-                    : 13 30
/                    : 29
:                    : 34 59 81 104 107 158
<                    : 27 62 70 83
=                    : 157
>                    : 26 62 70 83
CASE                 : 115
CONCAT               : 32
DEF                  : 51
DO                   : 33
ELIF                 : 111
ELSE                 : 114
END                  : 33 106 115
ENUM                 : 82
IDENTIFIER           : 156
IF                   : 106
INT_DIV              : 25
NEWLINE              : 8 42 50
NUMBER               : 161
OF                   : 115
SPREAD               : 
STRING               : 160
STRUCT               : 69
THEN                 : 106 111
[                    : 131
]                    : 131
error                : 
{                    : 69 82 139
}                    : 69 82 139

Nonterminals, with rules where they appear:

_10_optional         : 51
_11_optional         : 61
_12_item             : 65 66
_12_items            : 63 65
_12_repeat           : 62
_13_optional         : 69
_14_item             : 73 74
_14_items            : 71 73
_14_repeat           : 70
_15_item             : 79 80
_15_items            : 77 79
_15_repeat           : 69
_16_optional         : 82
_17_item             : 86 87
_17_items            : 84 86
_17_repeat           : 83
_18_item             : 92 93
_18_items            : 90 92
_18_repeat           : 82
_19_optional         : 95
_1_optional          : 1
_20_item             : 99 100
_20_items            : 97 99
_20_repeat           : 96
_21_optional         : 103
_22_optional         : 106
_23_optional         : 106
_24_optional         : 111
_25_item             : 118 119
_25_items            : 116 118
_25_repeat           : 115
_26_optional         : 123
_27_item             : 127 128
_27_items            : 125 127
_27_repeat           : 124
_28_optional         : 131
_29_item             : 136 137
_29_items            : 134 136
_29_repeat           : 131
_2_item              : 6 7
_2_items             : 4 6
_2_repeat            : 1
_30_optional         : 139
_31_item             : 144 145
_31_items            : 142 144
_31_repeat           : 139
_32_optional         : 147
_33_item             : 152 153
_33_items            : 150 152
_33_repeat           : 147
_34_optional         : 157
_3_optional          : 33
_4_optional          : 33
_5_item              : 40 41
_5_items             : 38 40
_5_repeat            : 33
_6_optional          : 43
_7_item              : 48 49
_7_items             : 46 48
_7_repeat            : 43
_8_optional          : 51
_9_item              : 56 57
_9_items             : 54 56
_9_repeat            : 51
array                : 15
binary_expr          : 16
block_statement      : 106 111 114
call                 : 20
callee               : 147
case                 : 115 120
case_of              : 19
def_expr             : 22
do                   : 24 51 121
enum                 : 9
enum_key             : 94
enum_pattern         : 122
expr                 : 11 12 13 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 36 42 44 50 106 111 115 132 138 140 146 148 154 157
identifier           : 17 51 61 69 70 75 81 82 83 88 95 96 101 103 123 155 157
if_expr              : 21
literal              : 23
or_else              : 109 112
param                : 52 58
pattern              : 121 124 129
program              : 0
stmt                 : 2 8
struct               : 10
tuple                : 14
type                 : 34 59 62 67 81 104 107 158
variable_declaration : 18


state 0

    (0) S' -> . program
    (1) program -> . _1_optional _2_repeat
    (2) _1_optional -> . stmt
    (3) _1_optional -> .
    (9) stmt -> . enum
    (10) stmt -> . struct
    (11) stmt -> . expr
    (82) enum -> . ENUM identifier _16_optional { _18_repeat }
    (69) struct -> . STRUCT identifier _13_optional { _15_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    NEWLINE         reduce using rule 3 (_1_optional -> .)
    $end            reduce using rule 3 (_1_optional -> .)
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    program                        shift and go to state 1
    _1_optional                    shift and go to state 2
    stmt                           shift and go to state 3
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    identifier                     shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_optional . _2_repeat
    (4) _2_repeat -> . _2_items
    (5) _2_repeat -> .
    (6) _2_items -> . _2_items _2_item
    (7) _2_items -> . _2_item
    (8) _2_item -> . NEWLINE stmt
    $end            reduce using rule 5 (_2_repeat -> .)
    NEWLINE         shift and go to state 35

    _2_repeat                      shift and go to state 32
    _2_items                       shift and go to state 33
    _2_item                        shift and go to state 34

state 3

    (2) _1_optional -> stmt .
    NEWLINE         reduce using rule 2 (_1_optional -> stmt .)
    $end            reduce using rule 2 (_1_optional -> stmt .)


state 4

    (9) stmt -> enum .
    NEWLINE         reduce using rule 9 (stmt -> enum .)
    $end            reduce using rule 9 (stmt -> enum .)


state 5

    (10) stmt -> struct .
    NEWLINE         reduce using rule 10 (stmt -> struct .)
    $end            reduce using rule 10 (stmt -> struct .)


state 6

    (11) stmt -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 11 (stmt -> expr .)
    $end            reduce using rule 11 (stmt -> expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 7

    (82) enum -> ENUM . identifier _16_optional { _18_repeat }
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 44

state 8

    (17) expr -> identifier .
    (157) variable_declaration -> identifier . _34_optional = expr
    (155) callee -> identifier .
    (158) _34_optional -> . : type
    (159) _34_optional -> .
    INT_DIV         reduce using rule 17 (expr -> identifier .)
    >               reduce using rule 17 (expr -> identifier .)
    <               reduce using rule 17 (expr -> identifier .)
    *               reduce using rule 17 (expr -> identifier .)
    /               reduce using rule 17 (expr -> identifier .)
    -               reduce using rule 17 (expr -> identifier .)
    +               reduce using rule 17 (expr -> identifier .)
    CONCAT          reduce using rule 17 (expr -> identifier .)
    NEWLINE         reduce using rule 17 (expr -> identifier .)
    $end            reduce using rule 17 (expr -> identifier .)
    ,               reduce using rule 17 (expr -> identifier .)
    }               reduce using rule 17 (expr -> identifier .)
    )               reduce using rule 17 (expr -> identifier .)
    ]               reduce using rule 17 (expr -> identifier .)
    OF              reduce using rule 17 (expr -> identifier .)
    THEN            reduce using rule 17 (expr -> identifier .)
    END             reduce using rule 17 (expr -> identifier .)
    ELIF            reduce using rule 17 (expr -> identifier .)
    ELSE            reduce using rule 17 (expr -> identifier .)
    (               reduce using rule 155 (callee -> identifier .)
    :               shift and go to state 46
    =               reduce using rule 159 (_34_optional -> .)

    _34_optional                   shift and go to state 45

state 9

    (139) tuple -> { . _30_optional _31_repeat }
    (140) _30_optional -> . expr
    (141) _30_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    ,               reduce using rule 141 (_30_optional -> .)
    }               reduce using rule 141 (_30_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    _30_optional                   shift and go to state 47
    expr                           shift and go to state 48
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 10

    (69) struct -> STRUCT . identifier _13_optional { _15_repeat }
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 49

state 11

    (12) expr -> ( . expr )
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 50
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 12

    (13) expr -> - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 51
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 13

    (14) expr -> tuple .
    INT_DIV         reduce using rule 14 (expr -> tuple .)
    >               reduce using rule 14 (expr -> tuple .)
    <               reduce using rule 14 (expr -> tuple .)
    *               reduce using rule 14 (expr -> tuple .)
    /               reduce using rule 14 (expr -> tuple .)
    -               reduce using rule 14 (expr -> tuple .)
    +               reduce using rule 14 (expr -> tuple .)
    CONCAT          reduce using rule 14 (expr -> tuple .)
    NEWLINE         reduce using rule 14 (expr -> tuple .)
    $end            reduce using rule 14 (expr -> tuple .)
    ,               reduce using rule 14 (expr -> tuple .)
    }               reduce using rule 14 (expr -> tuple .)
    )               reduce using rule 14 (expr -> tuple .)
    ]               reduce using rule 14 (expr -> tuple .)
    OF              reduce using rule 14 (expr -> tuple .)
    THEN            reduce using rule 14 (expr -> tuple .)
    END             reduce using rule 14 (expr -> tuple .)
    ELIF            reduce using rule 14 (expr -> tuple .)
    ELSE            reduce using rule 14 (expr -> tuple .)


state 14

    (15) expr -> array .
    INT_DIV         reduce using rule 15 (expr -> array .)
    >               reduce using rule 15 (expr -> array .)
    <               reduce using rule 15 (expr -> array .)
    *               reduce using rule 15 (expr -> array .)
    /               reduce using rule 15 (expr -> array .)
    -               reduce using rule 15 (expr -> array .)
    +               reduce using rule 15 (expr -> array .)
    CONCAT          reduce using rule 15 (expr -> array .)
    NEWLINE         reduce using rule 15 (expr -> array .)
    $end            reduce using rule 15 (expr -> array .)
    ,               reduce using rule 15 (expr -> array .)
    }               reduce using rule 15 (expr -> array .)
    )               reduce using rule 15 (expr -> array .)
    ]               reduce using rule 15 (expr -> array .)
    OF              reduce using rule 15 (expr -> array .)
    THEN            reduce using rule 15 (expr -> array .)
    END             reduce using rule 15 (expr -> array .)
    ELIF            reduce using rule 15 (expr -> array .)
    ELSE            reduce using rule 15 (expr -> array .)


state 15

    (16) expr -> binary_expr .
    INT_DIV         reduce using rule 16 (expr -> binary_expr .)
    >               reduce using rule 16 (expr -> binary_expr .)
    <               reduce using rule 16 (expr -> binary_expr .)
    *               reduce using rule 16 (expr -> binary_expr .)
    /               reduce using rule 16 (expr -> binary_expr .)
    -               reduce using rule 16 (expr -> binary_expr .)
    +               reduce using rule 16 (expr -> binary_expr .)
    CONCAT          reduce using rule 16 (expr -> binary_expr .)
    NEWLINE         reduce using rule 16 (expr -> binary_expr .)
    $end            reduce using rule 16 (expr -> binary_expr .)
    ,               reduce using rule 16 (expr -> binary_expr .)
    }               reduce using rule 16 (expr -> binary_expr .)
    )               reduce using rule 16 (expr -> binary_expr .)
    ]               reduce using rule 16 (expr -> binary_expr .)
    OF              reduce using rule 16 (expr -> binary_expr .)
    THEN            reduce using rule 16 (expr -> binary_expr .)
    END             reduce using rule 16 (expr -> binary_expr .)
    ELIF            reduce using rule 16 (expr -> binary_expr .)
    ELSE            reduce using rule 16 (expr -> binary_expr .)


state 16

    (18) expr -> variable_declaration .
    INT_DIV         reduce using rule 18 (expr -> variable_declaration .)
    >               reduce using rule 18 (expr -> variable_declaration .)
    <               reduce using rule 18 (expr -> variable_declaration .)
    *               reduce using rule 18 (expr -> variable_declaration .)
    /               reduce using rule 18 (expr -> variable_declaration .)
    -               reduce using rule 18 (expr -> variable_declaration .)
    +               reduce using rule 18 (expr -> variable_declaration .)
    CONCAT          reduce using rule 18 (expr -> variable_declaration .)
    NEWLINE         reduce using rule 18 (expr -> variable_declaration .)
    $end            reduce using rule 18 (expr -> variable_declaration .)
    ,               reduce using rule 18 (expr -> variable_declaration .)
    }               reduce using rule 18 (expr -> variable_declaration .)
    )               reduce using rule 18 (expr -> variable_declaration .)
    ]               reduce using rule 18 (expr -> variable_declaration .)
    OF              reduce using rule 18 (expr -> variable_declaration .)
    THEN            reduce using rule 18 (expr -> variable_declaration .)
    END             reduce using rule 18 (expr -> variable_declaration .)
    ELIF            reduce using rule 18 (expr -> variable_declaration .)
    ELSE            reduce using rule 18 (expr -> variable_declaration .)


state 17

    (19) expr -> case_of .
    INT_DIV         reduce using rule 19 (expr -> case_of .)
    >               reduce using rule 19 (expr -> case_of .)
    <               reduce using rule 19 (expr -> case_of .)
    *               reduce using rule 19 (expr -> case_of .)
    /               reduce using rule 19 (expr -> case_of .)
    -               reduce using rule 19 (expr -> case_of .)
    +               reduce using rule 19 (expr -> case_of .)
    CONCAT          reduce using rule 19 (expr -> case_of .)
    NEWLINE         reduce using rule 19 (expr -> case_of .)
    $end            reduce using rule 19 (expr -> case_of .)
    ,               reduce using rule 19 (expr -> case_of .)
    }               reduce using rule 19 (expr -> case_of .)
    )               reduce using rule 19 (expr -> case_of .)
    ]               reduce using rule 19 (expr -> case_of .)
    OF              reduce using rule 19 (expr -> case_of .)
    THEN            reduce using rule 19 (expr -> case_of .)
    END             reduce using rule 19 (expr -> case_of .)
    ELIF            reduce using rule 19 (expr -> case_of .)
    ELSE            reduce using rule 19 (expr -> case_of .)


state 18

    (20) expr -> call .
    INT_DIV         reduce using rule 20 (expr -> call .)
    >               reduce using rule 20 (expr -> call .)
    <               reduce using rule 20 (expr -> call .)
    *               reduce using rule 20 (expr -> call .)
    /               reduce using rule 20 (expr -> call .)
    -               reduce using rule 20 (expr -> call .)
    +               reduce using rule 20 (expr -> call .)
    CONCAT          reduce using rule 20 (expr -> call .)
    NEWLINE         reduce using rule 20 (expr -> call .)
    $end            reduce using rule 20 (expr -> call .)
    ,               reduce using rule 20 (expr -> call .)
    }               reduce using rule 20 (expr -> call .)
    )               reduce using rule 20 (expr -> call .)
    ]               reduce using rule 20 (expr -> call .)
    OF              reduce using rule 20 (expr -> call .)
    THEN            reduce using rule 20 (expr -> call .)
    END             reduce using rule 20 (expr -> call .)
    ELIF            reduce using rule 20 (expr -> call .)
    ELSE            reduce using rule 20 (expr -> call .)


state 19

    (21) expr -> if_expr .
    INT_DIV         reduce using rule 21 (expr -> if_expr .)
    >               reduce using rule 21 (expr -> if_expr .)
    <               reduce using rule 21 (expr -> if_expr .)
    *               reduce using rule 21 (expr -> if_expr .)
    /               reduce using rule 21 (expr -> if_expr .)
    -               reduce using rule 21 (expr -> if_expr .)
    +               reduce using rule 21 (expr -> if_expr .)
    CONCAT          reduce using rule 21 (expr -> if_expr .)
    NEWLINE         reduce using rule 21 (expr -> if_expr .)
    $end            reduce using rule 21 (expr -> if_expr .)
    ,               reduce using rule 21 (expr -> if_expr .)
    }               reduce using rule 21 (expr -> if_expr .)
    )               reduce using rule 21 (expr -> if_expr .)
    ]               reduce using rule 21 (expr -> if_expr .)
    OF              reduce using rule 21 (expr -> if_expr .)
    THEN            reduce using rule 21 (expr -> if_expr .)
    END             reduce using rule 21 (expr -> if_expr .)
    ELIF            reduce using rule 21 (expr -> if_expr .)
    ELSE            reduce using rule 21 (expr -> if_expr .)


state 20

    (22) expr -> def_expr .
    INT_DIV         reduce using rule 22 (expr -> def_expr .)
    >               reduce using rule 22 (expr -> def_expr .)
    <               reduce using rule 22 (expr -> def_expr .)
    *               reduce using rule 22 (expr -> def_expr .)
    /               reduce using rule 22 (expr -> def_expr .)
    -               reduce using rule 22 (expr -> def_expr .)
    +               reduce using rule 22 (expr -> def_expr .)
    CONCAT          reduce using rule 22 (expr -> def_expr .)
    NEWLINE         reduce using rule 22 (expr -> def_expr .)
    $end            reduce using rule 22 (expr -> def_expr .)
    ,               reduce using rule 22 (expr -> def_expr .)
    }               reduce using rule 22 (expr -> def_expr .)
    )               reduce using rule 22 (expr -> def_expr .)
    ]               reduce using rule 22 (expr -> def_expr .)
    OF              reduce using rule 22 (expr -> def_expr .)
    THEN            reduce using rule 22 (expr -> def_expr .)
    END             reduce using rule 22 (expr -> def_expr .)
    ELIF            reduce using rule 22 (expr -> def_expr .)
    ELSE            reduce using rule 22 (expr -> def_expr .)


state 21

    (23) expr -> literal .
    INT_DIV         reduce using rule 23 (expr -> literal .)
    >               reduce using rule 23 (expr -> literal .)
    <               reduce using rule 23 (expr -> literal .)
    *               reduce using rule 23 (expr -> literal .)
    /               reduce using rule 23 (expr -> literal .)
    -               reduce using rule 23 (expr -> literal .)
    +               reduce using rule 23 (expr -> literal .)
    CONCAT          reduce using rule 23 (expr -> literal .)
    NEWLINE         reduce using rule 23 (expr -> literal .)
    $end            reduce using rule 23 (expr -> literal .)
    ,               reduce using rule 23 (expr -> literal .)
    }               reduce using rule 23 (expr -> literal .)
    )               reduce using rule 23 (expr -> literal .)
    ]               reduce using rule 23 (expr -> literal .)
    OF              reduce using rule 23 (expr -> literal .)
    THEN            reduce using rule 23 (expr -> literal .)
    END             reduce using rule 23 (expr -> literal .)
    ELIF            reduce using rule 23 (expr -> literal .)
    ELSE            reduce using rule 23 (expr -> literal .)


state 22

    (24) expr -> do .
    INT_DIV         reduce using rule 24 (expr -> do .)
    >               reduce using rule 24 (expr -> do .)
    <               reduce using rule 24 (expr -> do .)
    *               reduce using rule 24 (expr -> do .)
    /               reduce using rule 24 (expr -> do .)
    -               reduce using rule 24 (expr -> do .)
    +               reduce using rule 24 (expr -> do .)
    CONCAT          reduce using rule 24 (expr -> do .)
    NEWLINE         reduce using rule 24 (expr -> do .)
    $end            reduce using rule 24 (expr -> do .)
    ,               reduce using rule 24 (expr -> do .)
    }               reduce using rule 24 (expr -> do .)
    )               reduce using rule 24 (expr -> do .)
    ]               reduce using rule 24 (expr -> do .)
    OF              reduce using rule 24 (expr -> do .)
    THEN            reduce using rule 24 (expr -> do .)
    END             reduce using rule 24 (expr -> do .)
    ELIF            reduce using rule 24 (expr -> do .)
    ELSE            reduce using rule 24 (expr -> do .)


state 23

    (131) array -> [ . _28_optional _29_repeat ]
    (132) _28_optional -> . expr
    (133) _28_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    ,               reduce using rule 133 (_28_optional -> .)
    ]               reduce using rule 133 (_28_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    _28_optional                   shift and go to state 52
    expr                           shift and go to state 53
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 24

    (156) identifier -> IDENTIFIER .
    :               reduce using rule 156 (identifier -> IDENTIFIER .)
    =               reduce using rule 156 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 156 (identifier -> IDENTIFIER .)
    >               reduce using rule 156 (identifier -> IDENTIFIER .)
    <               reduce using rule 156 (identifier -> IDENTIFIER .)
    *               reduce using rule 156 (identifier -> IDENTIFIER .)
    /               reduce using rule 156 (identifier -> IDENTIFIER .)
    -               reduce using rule 156 (identifier -> IDENTIFIER .)
    +               reduce using rule 156 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 156 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 156 (identifier -> IDENTIFIER .)
    $end            reduce using rule 156 (identifier -> IDENTIFIER .)
    (               reduce using rule 156 (identifier -> IDENTIFIER .)
    {               reduce using rule 156 (identifier -> IDENTIFIER .)
    ,               reduce using rule 156 (identifier -> IDENTIFIER .)
    }               reduce using rule 156 (identifier -> IDENTIFIER .)
    )               reduce using rule 156 (identifier -> IDENTIFIER .)
    ]               reduce using rule 156 (identifier -> IDENTIFIER .)
    OF              reduce using rule 156 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 156 (identifier -> IDENTIFIER .)
    END             reduce using rule 156 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 156 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 156 (identifier -> IDENTIFIER .)
    [               reduce using rule 156 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 156 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 156 (identifier -> IDENTIFIER .)
    IF              reduce using rule 156 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 156 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 156 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 156 (identifier -> IDENTIFIER .)
    DO              reduce using rule 156 (identifier -> IDENTIFIER .)


state 25

    (115) case_of -> CASE . expr OF case _25_repeat END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 54
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 26

    (147) call -> callee . ( _32_optional _33_repeat )
    (               shift and go to state 55


state 27

    (106) if_expr -> IF . expr THEN _22_optional block_statement _23_optional END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 56
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 28

    (51) def_expr -> DEF . identifier ( _8_optional _9_repeat ) _10_optional do
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 57

state 29

    (160) literal -> STRING .
    INT_DIV         reduce using rule 160 (literal -> STRING .)
    >               reduce using rule 160 (literal -> STRING .)
    <               reduce using rule 160 (literal -> STRING .)
    *               reduce using rule 160 (literal -> STRING .)
    /               reduce using rule 160 (literal -> STRING .)
    -               reduce using rule 160 (literal -> STRING .)
    +               reduce using rule 160 (literal -> STRING .)
    CONCAT          reduce using rule 160 (literal -> STRING .)
    NEWLINE         reduce using rule 160 (literal -> STRING .)
    $end            reduce using rule 160 (literal -> STRING .)
    ,               reduce using rule 160 (literal -> STRING .)
    }               reduce using rule 160 (literal -> STRING .)
    )               reduce using rule 160 (literal -> STRING .)
    ]               reduce using rule 160 (literal -> STRING .)
    OF              reduce using rule 160 (literal -> STRING .)
    THEN            reduce using rule 160 (literal -> STRING .)
    END             reduce using rule 160 (literal -> STRING .)
    ELIF            reduce using rule 160 (literal -> STRING .)
    ELSE            reduce using rule 160 (literal -> STRING .)


state 30

    (161) literal -> NUMBER .
    INT_DIV         reduce using rule 161 (literal -> NUMBER .)
    >               reduce using rule 161 (literal -> NUMBER .)
    <               reduce using rule 161 (literal -> NUMBER .)
    *               reduce using rule 161 (literal -> NUMBER .)
    /               reduce using rule 161 (literal -> NUMBER .)
    -               reduce using rule 161 (literal -> NUMBER .)
    +               reduce using rule 161 (literal -> NUMBER .)
    CONCAT          reduce using rule 161 (literal -> NUMBER .)
    NEWLINE         reduce using rule 161 (literal -> NUMBER .)
    $end            reduce using rule 161 (literal -> NUMBER .)
    ,               reduce using rule 161 (literal -> NUMBER .)
    }               reduce using rule 161 (literal -> NUMBER .)
    )               reduce using rule 161 (literal -> NUMBER .)
    ]               reduce using rule 161 (literal -> NUMBER .)
    OF              reduce using rule 161 (literal -> NUMBER .)
    THEN            reduce using rule 161 (literal -> NUMBER .)
    END             reduce using rule 161 (literal -> NUMBER .)
    ELIF            reduce using rule 161 (literal -> NUMBER .)
    ELSE            reduce using rule 161 (literal -> NUMBER .)


state 31

    (33) do -> DO . _3_optional _4_optional _5_repeat END
    (34) _3_optional -> . : type
    (35) _3_optional -> .
    :               shift and go to state 59
    (               reduce using rule 35 (_3_optional -> .)
    -               reduce using rule 35 (_3_optional -> .)
    {               reduce using rule 35 (_3_optional -> .)
    [               reduce using rule 35 (_3_optional -> .)
    IDENTIFIER      reduce using rule 35 (_3_optional -> .)
    CASE            reduce using rule 35 (_3_optional -> .)
    IF              reduce using rule 35 (_3_optional -> .)
    DEF             reduce using rule 35 (_3_optional -> .)
    STRING          reduce using rule 35 (_3_optional -> .)
    NUMBER          reduce using rule 35 (_3_optional -> .)
    DO              reduce using rule 35 (_3_optional -> .)
    NEWLINE         reduce using rule 35 (_3_optional -> .)
    END             reduce using rule 35 (_3_optional -> .)

    _3_optional                    shift and go to state 58

state 32

    (1) program -> _1_optional _2_repeat .
    $end            reduce using rule 1 (program -> _1_optional _2_repeat .)


state 33

    (4) _2_repeat -> _2_items .
    (6) _2_items -> _2_items . _2_item
    (8) _2_item -> . NEWLINE stmt
    $end            reduce using rule 4 (_2_repeat -> _2_items .)
    NEWLINE         shift and go to state 35

    _2_item                        shift and go to state 60

state 34

    (7) _2_items -> _2_item .
    NEWLINE         reduce using rule 7 (_2_items -> _2_item .)
    $end            reduce using rule 7 (_2_items -> _2_item .)


state 35

    (8) _2_item -> NEWLINE . stmt
    (9) stmt -> . enum
    (10) stmt -> . struct
    (11) stmt -> . expr
    (82) enum -> . ENUM identifier _16_optional { _18_repeat }
    (69) struct -> . STRUCT identifier _13_optional { _15_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    stmt                           shift and go to state 61
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    identifier                     shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 36

    (25) binary_expr -> expr INT_DIV . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 62
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 37

    (26) binary_expr -> expr > . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 63
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 38

    (27) binary_expr -> expr < . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 64
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 39

    (28) binary_expr -> expr * . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 65
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 40

    (29) binary_expr -> expr / . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 66
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 41

    (30) binary_expr -> expr - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 67
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 42

    (31) binary_expr -> expr + . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 68
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 43

    (32) binary_expr -> expr CONCAT . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 69
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 44

    (82) enum -> ENUM identifier . _16_optional { _18_repeat }
    (83) _16_optional -> . < identifier _17_repeat >
    (89) _16_optional -> .
    <               shift and go to state 71
    {               reduce using rule 89 (_16_optional -> .)

    _16_optional                   shift and go to state 70

state 45

    (157) variable_declaration -> identifier _34_optional . = expr
    =               shift and go to state 72


state 46

    (158) _34_optional -> : . type
    (61) type -> . identifier _11_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    type                           shift and go to state 73
    identifier                     shift and go to state 74

state 47

    (139) tuple -> { _30_optional . _31_repeat }
    (142) _31_repeat -> . _31_items
    (143) _31_repeat -> .
    (144) _31_items -> . _31_items _31_item
    (145) _31_items -> . _31_item
    (146) _31_item -> . , expr
    }               reduce using rule 143 (_31_repeat -> .)
    ,               shift and go to state 78

    _31_repeat                     shift and go to state 75
    _31_items                      shift and go to state 76
    _31_item                       shift and go to state 77

state 48

    (140) _30_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 140 (_30_optional -> expr .)
    }               reduce using rule 140 (_30_optional -> expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 49

    (69) struct -> STRUCT identifier . _13_optional { _15_repeat }
    (70) _13_optional -> . < identifier _14_repeat >
    (76) _13_optional -> .
    <               shift and go to state 80
    {               reduce using rule 76 (_13_optional -> .)

    _13_optional                   shift and go to state 79

state 50

    (12) expr -> ( expr . )
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    )               shift and go to state 81
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 51

    (13) expr -> - expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 13 (expr -> - expr .)
    >               reduce using rule 13 (expr -> - expr .)
    <               reduce using rule 13 (expr -> - expr .)
    *               reduce using rule 13 (expr -> - expr .)
    /               reduce using rule 13 (expr -> - expr .)
    -               reduce using rule 13 (expr -> - expr .)
    +               reduce using rule 13 (expr -> - expr .)
    CONCAT          reduce using rule 13 (expr -> - expr .)
    NEWLINE         reduce using rule 13 (expr -> - expr .)
    $end            reduce using rule 13 (expr -> - expr .)
    ,               reduce using rule 13 (expr -> - expr .)
    }               reduce using rule 13 (expr -> - expr .)
    )               reduce using rule 13 (expr -> - expr .)
    ]               reduce using rule 13 (expr -> - expr .)
    OF              reduce using rule 13 (expr -> - expr .)
    THEN            reduce using rule 13 (expr -> - expr .)
    END             reduce using rule 13 (expr -> - expr .)
    ELIF            reduce using rule 13 (expr -> - expr .)
    ELSE            reduce using rule 13 (expr -> - expr .)


state 52

    (131) array -> [ _28_optional . _29_repeat ]
    (134) _29_repeat -> . _29_items
    (135) _29_repeat -> .
    (136) _29_items -> . _29_items _29_item
    (137) _29_items -> . _29_item
    (138) _29_item -> . , expr
    ]               reduce using rule 135 (_29_repeat -> .)
    ,               shift and go to state 85

    _29_repeat                     shift and go to state 82
    _29_items                      shift and go to state 83
    _29_item                       shift and go to state 84

state 53

    (132) _28_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 132 (_28_optional -> expr .)
    ]               reduce using rule 132 (_28_optional -> expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 54

    (115) case_of -> CASE expr . OF case _25_repeat END
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 86
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 55

    (147) call -> callee ( . _32_optional _33_repeat )
    (148) _32_optional -> . expr
    (149) _32_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    ,               reduce using rule 149 (_32_optional -> .)
    )               reduce using rule 149 (_32_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    callee                         shift and go to state 26
    _32_optional                   shift and go to state 87
    expr                           shift and go to state 88
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22

state 56

    (106) if_expr -> IF expr . THEN _22_optional block_statement _23_optional END
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 89
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 57

    (51) def_expr -> DEF identifier . ( _8_optional _9_repeat ) _10_optional do
    (               shift and go to state 90


state 58

    (33) do -> DO _3_optional . _4_optional _5_repeat END
    (36) _4_optional -> . expr
    (37) _4_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    NEWLINE         reduce using rule 37 (_4_optional -> .)
    END             reduce using rule 37 (_4_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    _4_optional                    shift and go to state 91
    expr                           shift and go to state 92
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 59

    (34) _3_optional -> : . type
    (61) type -> . identifier _11_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    type                           shift and go to state 93
    identifier                     shift and go to state 74

state 60

    (6) _2_items -> _2_items _2_item .
    NEWLINE         reduce using rule 6 (_2_items -> _2_items _2_item .)
    $end            reduce using rule 6 (_2_items -> _2_items _2_item .)


state 61

    (8) _2_item -> NEWLINE stmt .
    NEWLINE         reduce using rule 8 (_2_item -> NEWLINE stmt .)
    $end            reduce using rule 8 (_2_item -> NEWLINE stmt .)


state 62

    (25) binary_expr -> expr INT_DIV expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    NEWLINE         reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    }               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    >               shift and go to state 37
    <               shift and go to state 38


state 63

    (26) binary_expr -> expr > expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 26 (binary_expr -> expr > expr .)
    >               reduce using rule 26 (binary_expr -> expr > expr .)
    <               reduce using rule 26 (binary_expr -> expr > expr .)
    *               reduce using rule 26 (binary_expr -> expr > expr .)
    /               reduce using rule 26 (binary_expr -> expr > expr .)
    -               reduce using rule 26 (binary_expr -> expr > expr .)
    +               reduce using rule 26 (binary_expr -> expr > expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr > expr .)
    NEWLINE         reduce using rule 26 (binary_expr -> expr > expr .)
    $end            reduce using rule 26 (binary_expr -> expr > expr .)
    ,               reduce using rule 26 (binary_expr -> expr > expr .)
    }               reduce using rule 26 (binary_expr -> expr > expr .)
    )               reduce using rule 26 (binary_expr -> expr > expr .)
    ]               reduce using rule 26 (binary_expr -> expr > expr .)
    OF              reduce using rule 26 (binary_expr -> expr > expr .)
    THEN            reduce using rule 26 (binary_expr -> expr > expr .)
    END             reduce using rule 26 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr > expr .)


state 64

    (27) binary_expr -> expr < expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 27 (binary_expr -> expr < expr .)
    >               reduce using rule 27 (binary_expr -> expr < expr .)
    <               reduce using rule 27 (binary_expr -> expr < expr .)
    *               reduce using rule 27 (binary_expr -> expr < expr .)
    /               reduce using rule 27 (binary_expr -> expr < expr .)
    -               reduce using rule 27 (binary_expr -> expr < expr .)
    +               reduce using rule 27 (binary_expr -> expr < expr .)
    CONCAT          reduce using rule 27 (binary_expr -> expr < expr .)
    NEWLINE         reduce using rule 27 (binary_expr -> expr < expr .)
    $end            reduce using rule 27 (binary_expr -> expr < expr .)
    ,               reduce using rule 27 (binary_expr -> expr < expr .)
    }               reduce using rule 27 (binary_expr -> expr < expr .)
    )               reduce using rule 27 (binary_expr -> expr < expr .)
    ]               reduce using rule 27 (binary_expr -> expr < expr .)
    OF              reduce using rule 27 (binary_expr -> expr < expr .)
    THEN            reduce using rule 27 (binary_expr -> expr < expr .)
    END             reduce using rule 27 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr < expr .)


state 65

    (28) binary_expr -> expr * expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 28 (binary_expr -> expr * expr .)
    *               reduce using rule 28 (binary_expr -> expr * expr .)
    /               reduce using rule 28 (binary_expr -> expr * expr .)
    -               reduce using rule 28 (binary_expr -> expr * expr .)
    +               reduce using rule 28 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 28 (binary_expr -> expr * expr .)
    NEWLINE         reduce using rule 28 (binary_expr -> expr * expr .)
    $end            reduce using rule 28 (binary_expr -> expr * expr .)
    ,               reduce using rule 28 (binary_expr -> expr * expr .)
    }               reduce using rule 28 (binary_expr -> expr * expr .)
    )               reduce using rule 28 (binary_expr -> expr * expr .)
    ]               reduce using rule 28 (binary_expr -> expr * expr .)
    OF              reduce using rule 28 (binary_expr -> expr * expr .)
    THEN            reduce using rule 28 (binary_expr -> expr * expr .)
    END             reduce using rule 28 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr * expr .)
    >               shift and go to state 37
    <               shift and go to state 38


state 66

    (29) binary_expr -> expr / expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 29 (binary_expr -> expr / expr .)
    *               reduce using rule 29 (binary_expr -> expr / expr .)
    /               reduce using rule 29 (binary_expr -> expr / expr .)
    -               reduce using rule 29 (binary_expr -> expr / expr .)
    +               reduce using rule 29 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 29 (binary_expr -> expr / expr .)
    NEWLINE         reduce using rule 29 (binary_expr -> expr / expr .)
    $end            reduce using rule 29 (binary_expr -> expr / expr .)
    ,               reduce using rule 29 (binary_expr -> expr / expr .)
    }               reduce using rule 29 (binary_expr -> expr / expr .)
    )               reduce using rule 29 (binary_expr -> expr / expr .)
    ]               reduce using rule 29 (binary_expr -> expr / expr .)
    OF              reduce using rule 29 (binary_expr -> expr / expr .)
    THEN            reduce using rule 29 (binary_expr -> expr / expr .)
    END             reduce using rule 29 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr / expr .)
    >               shift and go to state 37
    <               shift and go to state 38


state 67

    (30) binary_expr -> expr - expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    -               reduce using rule 30 (binary_expr -> expr - expr .)
    +               reduce using rule 30 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 30 (binary_expr -> expr - expr .)
    NEWLINE         reduce using rule 30 (binary_expr -> expr - expr .)
    $end            reduce using rule 30 (binary_expr -> expr - expr .)
    ,               reduce using rule 30 (binary_expr -> expr - expr .)
    }               reduce using rule 30 (binary_expr -> expr - expr .)
    )               reduce using rule 30 (binary_expr -> expr - expr .)
    ]               reduce using rule 30 (binary_expr -> expr - expr .)
    OF              reduce using rule 30 (binary_expr -> expr - expr .)
    THEN            reduce using rule 30 (binary_expr -> expr - expr .)
    END             reduce using rule 30 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr - expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40


state 68

    (31) binary_expr -> expr + expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    -               reduce using rule 31 (binary_expr -> expr + expr .)
    +               reduce using rule 31 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 31 (binary_expr -> expr + expr .)
    NEWLINE         reduce using rule 31 (binary_expr -> expr + expr .)
    $end            reduce using rule 31 (binary_expr -> expr + expr .)
    ,               reduce using rule 31 (binary_expr -> expr + expr .)
    }               reduce using rule 31 (binary_expr -> expr + expr .)
    )               reduce using rule 31 (binary_expr -> expr + expr .)
    ]               reduce using rule 31 (binary_expr -> expr + expr .)
    OF              reduce using rule 31 (binary_expr -> expr + expr .)
    THEN            reduce using rule 31 (binary_expr -> expr + expr .)
    END             reduce using rule 31 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr + expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40


state 69

    (32) binary_expr -> expr CONCAT expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    CONCAT          reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    NEWLINE         reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    }               reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr CONCAT expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42


state 70

    (82) enum -> ENUM identifier _16_optional . { _18_repeat }
    {               shift and go to state 94


state 71

    (83) _16_optional -> < . identifier _17_repeat >
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 95

state 72

    (157) variable_declaration -> identifier _34_optional = . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    identifier                     shift and go to state 8
    expr                           shift and go to state 96
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 73

    (158) _34_optional -> : type .
    =               reduce using rule 158 (_34_optional -> : type .)


state 74

    (61) type -> identifier . _11_optional
    (62) _11_optional -> . < type _12_repeat >
    (68) _11_optional -> .
    <               shift and go to state 98
    =               reduce using rule 68 (_11_optional -> .)
    (               reduce using rule 68 (_11_optional -> .)
    -               reduce using rule 68 (_11_optional -> .)
    {               reduce using rule 68 (_11_optional -> .)
    [               reduce using rule 68 (_11_optional -> .)
    IDENTIFIER      reduce using rule 68 (_11_optional -> .)
    CASE            reduce using rule 68 (_11_optional -> .)
    IF              reduce using rule 68 (_11_optional -> .)
    DEF             reduce using rule 68 (_11_optional -> .)
    STRING          reduce using rule 68 (_11_optional -> .)
    NUMBER          reduce using rule 68 (_11_optional -> .)
    DO              reduce using rule 68 (_11_optional -> .)
    NEWLINE         reduce using rule 68 (_11_optional -> .)
    END             reduce using rule 68 (_11_optional -> .)
    ,               reduce using rule 68 (_11_optional -> .)
    >               reduce using rule 68 (_11_optional -> .)
    ELIF            reduce using rule 68 (_11_optional -> .)
    ELSE            reduce using rule 68 (_11_optional -> .)
    )               reduce using rule 68 (_11_optional -> .)
    }               reduce using rule 68 (_11_optional -> .)

    _11_optional                   shift and go to state 97

state 75

    (139) tuple -> { _30_optional _31_repeat . }
    }               shift and go to state 99


state 76

    (142) _31_repeat -> _31_items .
    (144) _31_items -> _31_items . _31_item
    (146) _31_item -> . , expr
    }               reduce using rule 142 (_31_repeat -> _31_items .)
    ,               shift and go to state 78

    _31_item                       shift and go to state 100

state 77

    (145) _31_items -> _31_item .
    ,               reduce using rule 145 (_31_items -> _31_item .)
    }               reduce using rule 145 (_31_items -> _31_item .)


state 78

    (146) _31_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 101
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 79

    (69) struct -> STRUCT identifier _13_optional . { _15_repeat }
    {               shift and go to state 102


state 80

    (70) _13_optional -> < . identifier _14_repeat >
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 103

state 81

    (12) expr -> ( expr ) .
    INT_DIV         reduce using rule 12 (expr -> ( expr ) .)
    >               reduce using rule 12 (expr -> ( expr ) .)
    <               reduce using rule 12 (expr -> ( expr ) .)
    *               reduce using rule 12 (expr -> ( expr ) .)
    /               reduce using rule 12 (expr -> ( expr ) .)
    -               reduce using rule 12 (expr -> ( expr ) .)
    +               reduce using rule 12 (expr -> ( expr ) .)
    CONCAT          reduce using rule 12 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 12 (expr -> ( expr ) .)
    $end            reduce using rule 12 (expr -> ( expr ) .)
    ,               reduce using rule 12 (expr -> ( expr ) .)
    }               reduce using rule 12 (expr -> ( expr ) .)
    )               reduce using rule 12 (expr -> ( expr ) .)
    ]               reduce using rule 12 (expr -> ( expr ) .)
    OF              reduce using rule 12 (expr -> ( expr ) .)
    THEN            reduce using rule 12 (expr -> ( expr ) .)
    END             reduce using rule 12 (expr -> ( expr ) .)
    ELIF            reduce using rule 12 (expr -> ( expr ) .)
    ELSE            reduce using rule 12 (expr -> ( expr ) .)


state 82

    (131) array -> [ _28_optional _29_repeat . ]
    ]               shift and go to state 104


state 83

    (134) _29_repeat -> _29_items .
    (136) _29_items -> _29_items . _29_item
    (138) _29_item -> . , expr
    ]               reduce using rule 134 (_29_repeat -> _29_items .)
    ,               shift and go to state 85

    _29_item                       shift and go to state 105

state 84

    (137) _29_items -> _29_item .
    ,               reduce using rule 137 (_29_items -> _29_item .)
    ]               reduce using rule 137 (_29_items -> _29_item .)


state 85

    (138) _29_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 106
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 86

    (115) case_of -> CASE expr OF . case _25_repeat END
    (121) case -> . pattern do
    (122) pattern -> . enum_pattern
    (123) enum_pattern -> . identifier _26_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    case                           shift and go to state 107
    pattern                        shift and go to state 108
    enum_pattern                   shift and go to state 109
    identifier                     shift and go to state 110

state 87

    (147) call -> callee ( _32_optional . _33_repeat )
    (150) _33_repeat -> . _33_items
    (151) _33_repeat -> .
    (152) _33_items -> . _33_items _33_item
    (153) _33_items -> . _33_item
    (154) _33_item -> . , expr
    )               reduce using rule 151 (_33_repeat -> .)
    ,               shift and go to state 114

    _33_repeat                     shift and go to state 111
    _33_items                      shift and go to state 112
    _33_item                       shift and go to state 113

state 88

    (148) _32_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 148 (_32_optional -> expr .)
    )               reduce using rule 148 (_32_optional -> expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 89

    (106) if_expr -> IF expr THEN . _22_optional block_statement _23_optional END
    (107) _22_optional -> . : type
    (108) _22_optional -> .
    :               shift and go to state 116
    (               reduce using rule 108 (_22_optional -> .)
    -               reduce using rule 108 (_22_optional -> .)
    {               reduce using rule 108 (_22_optional -> .)
    [               reduce using rule 108 (_22_optional -> .)
    IDENTIFIER      reduce using rule 108 (_22_optional -> .)
    CASE            reduce using rule 108 (_22_optional -> .)
    IF              reduce using rule 108 (_22_optional -> .)
    DEF             reduce using rule 108 (_22_optional -> .)
    STRING          reduce using rule 108 (_22_optional -> .)
    NUMBER          reduce using rule 108 (_22_optional -> .)
    DO              reduce using rule 108 (_22_optional -> .)
    ELIF            reduce using rule 108 (_22_optional -> .)
    ELSE            reduce using rule 108 (_22_optional -> .)
    END             reduce using rule 108 (_22_optional -> .)
    NEWLINE         reduce using rule 108 (_22_optional -> .)

    _22_optional                   shift and go to state 115

state 90

    (51) def_expr -> DEF identifier ( . _8_optional _9_repeat ) _10_optional do
    (52) _8_optional -> . param
    (53) _8_optional -> .
    (103) param -> . identifier _21_optional
    (156) identifier -> . IDENTIFIER
    ,               reduce using rule 53 (_8_optional -> .)
    )               reduce using rule 53 (_8_optional -> .)
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 117
    _8_optional                    shift and go to state 118
    param                          shift and go to state 119

state 91

    (33) do -> DO _3_optional _4_optional . _5_repeat END
    (38) _5_repeat -> . _5_items
    (39) _5_repeat -> .
    (40) _5_items -> . _5_items _5_item
    (41) _5_items -> . _5_item
    (42) _5_item -> . NEWLINE expr
    END             reduce using rule 39 (_5_repeat -> .)
    NEWLINE         shift and go to state 123

    _5_repeat                      shift and go to state 120
    _5_items                       shift and go to state 121
    _5_item                        shift and go to state 122

state 92

    (36) _4_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 36 (_4_optional -> expr .)
    END             reduce using rule 36 (_4_optional -> expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 93

    (34) _3_optional -> : type .
    (               reduce using rule 34 (_3_optional -> : type .)
    -               reduce using rule 34 (_3_optional -> : type .)
    {               reduce using rule 34 (_3_optional -> : type .)
    [               reduce using rule 34 (_3_optional -> : type .)
    IDENTIFIER      reduce using rule 34 (_3_optional -> : type .)
    CASE            reduce using rule 34 (_3_optional -> : type .)
    IF              reduce using rule 34 (_3_optional -> : type .)
    DEF             reduce using rule 34 (_3_optional -> : type .)
    STRING          reduce using rule 34 (_3_optional -> : type .)
    NUMBER          reduce using rule 34 (_3_optional -> : type .)
    DO              reduce using rule 34 (_3_optional -> : type .)
    NEWLINE         reduce using rule 34 (_3_optional -> : type .)
    END             reduce using rule 34 (_3_optional -> : type .)


state 94

    (82) enum -> ENUM identifier _16_optional { . _18_repeat }
    (90) _18_repeat -> . _18_items
    (91) _18_repeat -> .
    (92) _18_items -> . _18_items _18_item
    (93) _18_items -> . _18_item
    (94) _18_item -> . enum_key
    (95) enum_key -> . identifier _19_optional
    (156) identifier -> . IDENTIFIER
    }               reduce using rule 91 (_18_repeat -> .)
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 124
    _18_repeat                     shift and go to state 125
    _18_items                      shift and go to state 126
    _18_item                       shift and go to state 127
    enum_key                       shift and go to state 128

state 95

    (83) _16_optional -> < identifier . _17_repeat >
    (84) _17_repeat -> . _17_items
    (85) _17_repeat -> .
    (86) _17_items -> . _17_items _17_item
    (87) _17_items -> . _17_item
    (88) _17_item -> . , identifier
    >               reduce using rule 85 (_17_repeat -> .)
    ,               shift and go to state 132

    _17_repeat                     shift and go to state 129
    _17_items                      shift and go to state 130
    _17_item                       shift and go to state 131

state 96

    (157) variable_declaration -> identifier _34_optional = expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    $end            reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    ,               reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    }               reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    )               reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    ]               reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    OF              reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    THEN            reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    END             reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    ELIF            reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    ELSE            reduce using rule 157 (variable_declaration -> identifier _34_optional = expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 97

    (61) type -> identifier _11_optional .
    =               reduce using rule 61 (type -> identifier _11_optional .)
    (               reduce using rule 61 (type -> identifier _11_optional .)
    -               reduce using rule 61 (type -> identifier _11_optional .)
    {               reduce using rule 61 (type -> identifier _11_optional .)
    [               reduce using rule 61 (type -> identifier _11_optional .)
    IDENTIFIER      reduce using rule 61 (type -> identifier _11_optional .)
    CASE            reduce using rule 61 (type -> identifier _11_optional .)
    IF              reduce using rule 61 (type -> identifier _11_optional .)
    DEF             reduce using rule 61 (type -> identifier _11_optional .)
    STRING          reduce using rule 61 (type -> identifier _11_optional .)
    NUMBER          reduce using rule 61 (type -> identifier _11_optional .)
    DO              reduce using rule 61 (type -> identifier _11_optional .)
    NEWLINE         reduce using rule 61 (type -> identifier _11_optional .)
    END             reduce using rule 61 (type -> identifier _11_optional .)
    ,               reduce using rule 61 (type -> identifier _11_optional .)
    >               reduce using rule 61 (type -> identifier _11_optional .)
    ELIF            reduce using rule 61 (type -> identifier _11_optional .)
    ELSE            reduce using rule 61 (type -> identifier _11_optional .)
    )               reduce using rule 61 (type -> identifier _11_optional .)
    }               reduce using rule 61 (type -> identifier _11_optional .)


state 98

    (62) _11_optional -> < . type _12_repeat >
    (61) type -> . identifier _11_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    type                           shift and go to state 133
    identifier                     shift and go to state 74

state 99

    (139) tuple -> { _30_optional _31_repeat } .
    INT_DIV         reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    >               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    <               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    *               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    /               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    -               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    +               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    CONCAT          reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    NEWLINE         reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    $end            reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    ,               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    }               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    )               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    ]               reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    OF              reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    THEN            reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    END             reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    ELIF            reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)
    ELSE            reduce using rule 139 (tuple -> { _30_optional _31_repeat } .)


state 100

    (144) _31_items -> _31_items _31_item .
    ,               reduce using rule 144 (_31_items -> _31_items _31_item .)
    }               reduce using rule 144 (_31_items -> _31_items _31_item .)


state 101

    (146) _31_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 146 (_31_item -> , expr .)
    }               reduce using rule 146 (_31_item -> , expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 102

    (69) struct -> STRUCT identifier _13_optional { . _15_repeat }
    (77) _15_repeat -> . _15_items
    (78) _15_repeat -> .
    (79) _15_items -> . _15_items _15_item
    (80) _15_items -> . _15_item
    (81) _15_item -> . identifier : type
    (156) identifier -> . IDENTIFIER
    }               reduce using rule 78 (_15_repeat -> .)
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 134
    _15_repeat                     shift and go to state 135
    _15_items                      shift and go to state 136
    _15_item                       shift and go to state 137

state 103

    (70) _13_optional -> < identifier . _14_repeat >
    (71) _14_repeat -> . _14_items
    (72) _14_repeat -> .
    (73) _14_items -> . _14_items _14_item
    (74) _14_items -> . _14_item
    (75) _14_item -> . , identifier
    >               reduce using rule 72 (_14_repeat -> .)
    ,               shift and go to state 141

    _14_repeat                     shift and go to state 138
    _14_items                      shift and go to state 139
    _14_item                       shift and go to state 140

state 104

    (131) array -> [ _28_optional _29_repeat ] .
    INT_DIV         reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    >               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    <               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    *               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    /               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    -               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    +               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    CONCAT          reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    NEWLINE         reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    $end            reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    ,               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    }               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    )               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    ]               reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    OF              reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    THEN            reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    END             reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    ELIF            reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)
    ELSE            reduce using rule 131 (array -> [ _28_optional _29_repeat ] .)


state 105

    (136) _29_items -> _29_items _29_item .
    ,               reduce using rule 136 (_29_items -> _29_items _29_item .)
    ]               reduce using rule 136 (_29_items -> _29_items _29_item .)


state 106

    (138) _29_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 138 (_29_item -> , expr .)
    ]               reduce using rule 138 (_29_item -> , expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 107

    (115) case_of -> CASE expr OF case . _25_repeat END
    (116) _25_repeat -> . _25_items
    (117) _25_repeat -> .
    (118) _25_items -> . _25_items _25_item
    (119) _25_items -> . _25_item
    (120) _25_item -> . case
    (121) case -> . pattern do
    (122) pattern -> . enum_pattern
    (123) enum_pattern -> . identifier _26_optional
    (156) identifier -> . IDENTIFIER
    END             reduce using rule 117 (_25_repeat -> .)
    IDENTIFIER      shift and go to state 24

    case                           shift and go to state 142
    _25_repeat                     shift and go to state 143
    _25_items                      shift and go to state 144
    _25_item                       shift and go to state 145
    pattern                        shift and go to state 108
    enum_pattern                   shift and go to state 109
    identifier                     shift and go to state 110

state 108

    (121) case -> pattern . do
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    DO              shift and go to state 31

    do                             shift and go to state 146

state 109

    (122) pattern -> enum_pattern .
    DO              reduce using rule 122 (pattern -> enum_pattern .)
    ,               reduce using rule 122 (pattern -> enum_pattern .)
    )               reduce using rule 122 (pattern -> enum_pattern .)


state 110

    (123) enum_pattern -> identifier . _26_optional
    (124) _26_optional -> . ( pattern _27_repeat )
    (130) _26_optional -> .
    (               shift and go to state 148
    DO              reduce using rule 130 (_26_optional -> .)
    ,               reduce using rule 130 (_26_optional -> .)
    )               reduce using rule 130 (_26_optional -> .)

    _26_optional                   shift and go to state 147

state 111

    (147) call -> callee ( _32_optional _33_repeat . )
    )               shift and go to state 149


state 112

    (150) _33_repeat -> _33_items .
    (152) _33_items -> _33_items . _33_item
    (154) _33_item -> . , expr
    )               reduce using rule 150 (_33_repeat -> _33_items .)
    ,               shift and go to state 114

    _33_item                       shift and go to state 150

state 113

    (153) _33_items -> _33_item .
    ,               reduce using rule 153 (_33_items -> _33_item .)
    )               reduce using rule 153 (_33_items -> _33_item .)


state 114

    (154) _33_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 151
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 115

    (106) if_expr -> IF expr THEN _22_optional . block_statement _23_optional END
    (43) block_statement -> . _6_optional _7_repeat
    (44) _6_optional -> . expr
    (45) _6_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    NEWLINE         reduce using rule 45 (_6_optional -> .)
    ELIF            reduce using rule 45 (_6_optional -> .)
    ELSE            reduce using rule 45 (_6_optional -> .)
    END             reduce using rule 45 (_6_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 152
    block_statement                shift and go to state 153
    _6_optional                    shift and go to state 154
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 116

    (107) _22_optional -> : . type
    (61) type -> . identifier _11_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    type                           shift and go to state 155
    identifier                     shift and go to state 74

state 117

    (103) param -> identifier . _21_optional
    (104) _21_optional -> . : type
    (105) _21_optional -> .
    :               shift and go to state 157
    ,               reduce using rule 105 (_21_optional -> .)
    )               reduce using rule 105 (_21_optional -> .)

    _21_optional                   shift and go to state 156

state 118

    (51) def_expr -> DEF identifier ( _8_optional . _9_repeat ) _10_optional do
    (54) _9_repeat -> . _9_items
    (55) _9_repeat -> .
    (56) _9_items -> . _9_items _9_item
    (57) _9_items -> . _9_item
    (58) _9_item -> . , param
    )               reduce using rule 55 (_9_repeat -> .)
    ,               shift and go to state 161

    _9_repeat                      shift and go to state 158
    _9_items                       shift and go to state 159
    _9_item                        shift and go to state 160

state 119

    (52) _8_optional -> param .
    ,               reduce using rule 52 (_8_optional -> param .)
    )               reduce using rule 52 (_8_optional -> param .)


state 120

    (33) do -> DO _3_optional _4_optional _5_repeat . END
    END             shift and go to state 162


state 121

    (38) _5_repeat -> _5_items .
    (40) _5_items -> _5_items . _5_item
    (42) _5_item -> . NEWLINE expr
    END             reduce using rule 38 (_5_repeat -> _5_items .)
    NEWLINE         shift and go to state 123

    _5_item                        shift and go to state 163

state 122

    (41) _5_items -> _5_item .
    NEWLINE         reduce using rule 41 (_5_items -> _5_item .)
    END             reduce using rule 41 (_5_items -> _5_item .)


state 123

    (42) _5_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 164
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 124

    (95) enum_key -> identifier . _19_optional
    (96) _19_optional -> . ( identifier _20_repeat )
    (102) _19_optional -> .
    (               shift and go to state 166
    IDENTIFIER      reduce using rule 102 (_19_optional -> .)
    }               reduce using rule 102 (_19_optional -> .)

    _19_optional                   shift and go to state 165

state 125

    (82) enum -> ENUM identifier _16_optional { _18_repeat . }
    }               shift and go to state 167


state 126

    (90) _18_repeat -> _18_items .
    (92) _18_items -> _18_items . _18_item
    (94) _18_item -> . enum_key
    (95) enum_key -> . identifier _19_optional
    (156) identifier -> . IDENTIFIER
    }               reduce using rule 90 (_18_repeat -> _18_items .)
    IDENTIFIER      shift and go to state 24

    _18_item                       shift and go to state 168
    enum_key                       shift and go to state 128
    identifier                     shift and go to state 124

state 127

    (93) _18_items -> _18_item .
    IDENTIFIER      reduce using rule 93 (_18_items -> _18_item .)
    }               reduce using rule 93 (_18_items -> _18_item .)


state 128

    (94) _18_item -> enum_key .
    IDENTIFIER      reduce using rule 94 (_18_item -> enum_key .)
    }               reduce using rule 94 (_18_item -> enum_key .)


state 129

    (83) _16_optional -> < identifier _17_repeat . >
    >               shift and go to state 169


state 130

    (84) _17_repeat -> _17_items .
    (86) _17_items -> _17_items . _17_item
    (88) _17_item -> . , identifier
    >               reduce using rule 84 (_17_repeat -> _17_items .)
    ,               shift and go to state 132

    _17_item                       shift and go to state 170

state 131

    (87) _17_items -> _17_item .
    ,               reduce using rule 87 (_17_items -> _17_item .)
    >               reduce using rule 87 (_17_items -> _17_item .)


state 132

    (88) _17_item -> , . identifier
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 171

state 133

    (62) _11_optional -> < type . _12_repeat >
    (63) _12_repeat -> . _12_items
    (64) _12_repeat -> .
    (65) _12_items -> . _12_items _12_item
    (66) _12_items -> . _12_item
    (67) _12_item -> . , type
    >               reduce using rule 64 (_12_repeat -> .)
    ,               shift and go to state 175

    _12_repeat                     shift and go to state 172
    _12_items                      shift and go to state 173
    _12_item                       shift and go to state 174

state 134

    (81) _15_item -> identifier . : type
    :               shift and go to state 176


state 135

    (69) struct -> STRUCT identifier _13_optional { _15_repeat . }
    }               shift and go to state 177


state 136

    (77) _15_repeat -> _15_items .
    (79) _15_items -> _15_items . _15_item
    (81) _15_item -> . identifier : type
    (156) identifier -> . IDENTIFIER
    }               reduce using rule 77 (_15_repeat -> _15_items .)
    IDENTIFIER      shift and go to state 24

    _15_item                       shift and go to state 178
    identifier                     shift and go to state 134

state 137

    (80) _15_items -> _15_item .
    IDENTIFIER      reduce using rule 80 (_15_items -> _15_item .)
    }               reduce using rule 80 (_15_items -> _15_item .)


state 138

    (70) _13_optional -> < identifier _14_repeat . >
    >               shift and go to state 179


state 139

    (71) _14_repeat -> _14_items .
    (73) _14_items -> _14_items . _14_item
    (75) _14_item -> . , identifier
    >               reduce using rule 71 (_14_repeat -> _14_items .)
    ,               shift and go to state 141

    _14_item                       shift and go to state 180

state 140

    (74) _14_items -> _14_item .
    ,               reduce using rule 74 (_14_items -> _14_item .)
    >               reduce using rule 74 (_14_items -> _14_item .)


state 141

    (75) _14_item -> , . identifier
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 181

state 142

    (120) _25_item -> case .
    IDENTIFIER      reduce using rule 120 (_25_item -> case .)
    END             reduce using rule 120 (_25_item -> case .)


state 143

    (115) case_of -> CASE expr OF case _25_repeat . END
    END             shift and go to state 182


state 144

    (116) _25_repeat -> _25_items .
    (118) _25_items -> _25_items . _25_item
    (120) _25_item -> . case
    (121) case -> . pattern do
    (122) pattern -> . enum_pattern
    (123) enum_pattern -> . identifier _26_optional
    (156) identifier -> . IDENTIFIER
    END             reduce using rule 116 (_25_repeat -> _25_items .)
    IDENTIFIER      shift and go to state 24

    _25_item                       shift and go to state 183
    case                           shift and go to state 142
    pattern                        shift and go to state 108
    enum_pattern                   shift and go to state 109
    identifier                     shift and go to state 110

state 145

    (119) _25_items -> _25_item .
    IDENTIFIER      reduce using rule 119 (_25_items -> _25_item .)
    END             reduce using rule 119 (_25_items -> _25_item .)


state 146

    (121) case -> pattern do .
    IDENTIFIER      reduce using rule 121 (case -> pattern do .)
    END             reduce using rule 121 (case -> pattern do .)


state 147

    (123) enum_pattern -> identifier _26_optional .
    DO              reduce using rule 123 (enum_pattern -> identifier _26_optional .)
    ,               reduce using rule 123 (enum_pattern -> identifier _26_optional .)
    )               reduce using rule 123 (enum_pattern -> identifier _26_optional .)


state 148

    (124) _26_optional -> ( . pattern _27_repeat )
    (122) pattern -> . enum_pattern
    (123) enum_pattern -> . identifier _26_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    pattern                        shift and go to state 184
    enum_pattern                   shift and go to state 109
    identifier                     shift and go to state 110

state 149

    (147) call -> callee ( _32_optional _33_repeat ) .
    INT_DIV         reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    >               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    <               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    *               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    /               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    -               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    +               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    CONCAT          reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    NEWLINE         reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    $end            reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    ,               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    }               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    )               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    ]               reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    OF              reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    THEN            reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    END             reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    ELIF            reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)
    ELSE            reduce using rule 147 (call -> callee ( _32_optional _33_repeat ) .)


state 150

    (152) _33_items -> _33_items _33_item .
    ,               reduce using rule 152 (_33_items -> _33_items _33_item .)
    )               reduce using rule 152 (_33_items -> _33_items _33_item .)


state 151

    (154) _33_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 154 (_33_item -> , expr .)
    )               reduce using rule 154 (_33_item -> , expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 152

    (44) _6_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 44 (_6_optional -> expr .)
    ELIF            reduce using rule 44 (_6_optional -> expr .)
    ELSE            reduce using rule 44 (_6_optional -> expr .)
    END             reduce using rule 44 (_6_optional -> expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 153

    (106) if_expr -> IF expr THEN _22_optional block_statement . _23_optional END
    (109) _23_optional -> . or_else
    (110) _23_optional -> .
    (111) or_else -> . ELIF expr THEN block_statement _24_optional
    (114) or_else -> . ELSE block_statement
    END             reduce using rule 110 (_23_optional -> .)
    ELIF            shift and go to state 187
    ELSE            shift and go to state 188

    _23_optional                   shift and go to state 185
    or_else                        shift and go to state 186

state 154

    (43) block_statement -> _6_optional . _7_repeat
    (46) _7_repeat -> . _7_items
    (47) _7_repeat -> .
    (48) _7_items -> . _7_items _7_item
    (49) _7_items -> . _7_item
    (50) _7_item -> . NEWLINE expr
    ELIF            reduce using rule 47 (_7_repeat -> .)
    ELSE            reduce using rule 47 (_7_repeat -> .)
    END             reduce using rule 47 (_7_repeat -> .)
    NEWLINE         shift and go to state 192

    _7_repeat                      shift and go to state 189
    _7_items                       shift and go to state 190
    _7_item                        shift and go to state 191

state 155

    (107) _22_optional -> : type .
    (               reduce using rule 107 (_22_optional -> : type .)
    -               reduce using rule 107 (_22_optional -> : type .)
    {               reduce using rule 107 (_22_optional -> : type .)
    [               reduce using rule 107 (_22_optional -> : type .)
    IDENTIFIER      reduce using rule 107 (_22_optional -> : type .)
    CASE            reduce using rule 107 (_22_optional -> : type .)
    IF              reduce using rule 107 (_22_optional -> : type .)
    DEF             reduce using rule 107 (_22_optional -> : type .)
    STRING          reduce using rule 107 (_22_optional -> : type .)
    NUMBER          reduce using rule 107 (_22_optional -> : type .)
    DO              reduce using rule 107 (_22_optional -> : type .)
    ELIF            reduce using rule 107 (_22_optional -> : type .)
    ELSE            reduce using rule 107 (_22_optional -> : type .)
    END             reduce using rule 107 (_22_optional -> : type .)
    NEWLINE         reduce using rule 107 (_22_optional -> : type .)


state 156

    (103) param -> identifier _21_optional .
    ,               reduce using rule 103 (param -> identifier _21_optional .)
    )               reduce using rule 103 (param -> identifier _21_optional .)


state 157

    (104) _21_optional -> : . type
    (61) type -> . identifier _11_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    type                           shift and go to state 193
    identifier                     shift and go to state 74

state 158

    (51) def_expr -> DEF identifier ( _8_optional _9_repeat . ) _10_optional do
    )               shift and go to state 194


state 159

    (54) _9_repeat -> _9_items .
    (56) _9_items -> _9_items . _9_item
    (58) _9_item -> . , param
    )               reduce using rule 54 (_9_repeat -> _9_items .)
    ,               shift and go to state 161

    _9_item                        shift and go to state 195

state 160

    (57) _9_items -> _9_item .
    ,               reduce using rule 57 (_9_items -> _9_item .)
    )               reduce using rule 57 (_9_items -> _9_item .)


state 161

    (58) _9_item -> , . param
    (103) param -> . identifier _21_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    param                          shift and go to state 196
    identifier                     shift and go to state 117

state 162

    (33) do -> DO _3_optional _4_optional _5_repeat END .
    INT_DIV         reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    >               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    <               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    *               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    /               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    -               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    +               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    CONCAT          reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    NEWLINE         reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    $end            reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    ,               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    }               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    )               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    ]               reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    OF              reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    THEN            reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    END             reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    ELIF            reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    ELSE            reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)
    IDENTIFIER      reduce using rule 33 (do -> DO _3_optional _4_optional _5_repeat END .)


state 163

    (40) _5_items -> _5_items _5_item .
    NEWLINE         reduce using rule 40 (_5_items -> _5_items _5_item .)
    END             reduce using rule 40 (_5_items -> _5_items _5_item .)


state 164

    (42) _5_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 42 (_5_item -> NEWLINE expr .)
    END             reduce using rule 42 (_5_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 165

    (95) enum_key -> identifier _19_optional .
    IDENTIFIER      reduce using rule 95 (enum_key -> identifier _19_optional .)
    }               reduce using rule 95 (enum_key -> identifier _19_optional .)


state 166

    (96) _19_optional -> ( . identifier _20_repeat )
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 197

state 167

    (82) enum -> ENUM identifier _16_optional { _18_repeat } .
    NEWLINE         reduce using rule 82 (enum -> ENUM identifier _16_optional { _18_repeat } .)
    $end            reduce using rule 82 (enum -> ENUM identifier _16_optional { _18_repeat } .)


state 168

    (92) _18_items -> _18_items _18_item .
    IDENTIFIER      reduce using rule 92 (_18_items -> _18_items _18_item .)
    }               reduce using rule 92 (_18_items -> _18_items _18_item .)


state 169

    (83) _16_optional -> < identifier _17_repeat > .
    {               reduce using rule 83 (_16_optional -> < identifier _17_repeat > .)


state 170

    (86) _17_items -> _17_items _17_item .
    ,               reduce using rule 86 (_17_items -> _17_items _17_item .)
    >               reduce using rule 86 (_17_items -> _17_items _17_item .)


state 171

    (88) _17_item -> , identifier .
    ,               reduce using rule 88 (_17_item -> , identifier .)
    >               reduce using rule 88 (_17_item -> , identifier .)


state 172

    (62) _11_optional -> < type _12_repeat . >
    >               shift and go to state 198


state 173

    (63) _12_repeat -> _12_items .
    (65) _12_items -> _12_items . _12_item
    (67) _12_item -> . , type
    >               reduce using rule 63 (_12_repeat -> _12_items .)
    ,               shift and go to state 175

    _12_item                       shift and go to state 199

state 174

    (66) _12_items -> _12_item .
    ,               reduce using rule 66 (_12_items -> _12_item .)
    >               reduce using rule 66 (_12_items -> _12_item .)


state 175

    (67) _12_item -> , . type
    (61) type -> . identifier _11_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    type                           shift and go to state 200
    identifier                     shift and go to state 74

state 176

    (81) _15_item -> identifier : . type
    (61) type -> . identifier _11_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 74
    type                           shift and go to state 201

state 177

    (69) struct -> STRUCT identifier _13_optional { _15_repeat } .
    NEWLINE         reduce using rule 69 (struct -> STRUCT identifier _13_optional { _15_repeat } .)
    $end            reduce using rule 69 (struct -> STRUCT identifier _13_optional { _15_repeat } .)


state 178

    (79) _15_items -> _15_items _15_item .
    IDENTIFIER      reduce using rule 79 (_15_items -> _15_items _15_item .)
    }               reduce using rule 79 (_15_items -> _15_items _15_item .)


state 179

    (70) _13_optional -> < identifier _14_repeat > .
    {               reduce using rule 70 (_13_optional -> < identifier _14_repeat > .)


state 180

    (73) _14_items -> _14_items _14_item .
    ,               reduce using rule 73 (_14_items -> _14_items _14_item .)
    >               reduce using rule 73 (_14_items -> _14_items _14_item .)


state 181

    (75) _14_item -> , identifier .
    ,               reduce using rule 75 (_14_item -> , identifier .)
    >               reduce using rule 75 (_14_item -> , identifier .)


state 182

    (115) case_of -> CASE expr OF case _25_repeat END .
    INT_DIV         reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    >               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    <               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    *               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    /               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    -               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    +               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    CONCAT          reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    NEWLINE         reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    $end            reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    ,               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    }               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    )               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    ]               reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    OF              reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    THEN            reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    END             reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    ELIF            reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)
    ELSE            reduce using rule 115 (case_of -> CASE expr OF case _25_repeat END .)


state 183

    (118) _25_items -> _25_items _25_item .
    IDENTIFIER      reduce using rule 118 (_25_items -> _25_items _25_item .)
    END             reduce using rule 118 (_25_items -> _25_items _25_item .)


state 184

    (124) _26_optional -> ( pattern . _27_repeat )
    (125) _27_repeat -> . _27_items
    (126) _27_repeat -> .
    (127) _27_items -> . _27_items _27_item
    (128) _27_items -> . _27_item
    (129) _27_item -> . , pattern
    )               reduce using rule 126 (_27_repeat -> .)
    ,               shift and go to state 205

    _27_repeat                     shift and go to state 202
    _27_items                      shift and go to state 203
    _27_item                       shift and go to state 204

state 185

    (106) if_expr -> IF expr THEN _22_optional block_statement _23_optional . END
    END             shift and go to state 206


state 186

    (109) _23_optional -> or_else .
    END             reduce using rule 109 (_23_optional -> or_else .)


state 187

    (111) or_else -> ELIF . expr THEN block_statement _24_optional
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 207
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 188

    (114) or_else -> ELSE . block_statement
    (43) block_statement -> . _6_optional _7_repeat
    (44) _6_optional -> . expr
    (45) _6_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    NEWLINE         reduce using rule 45 (_6_optional -> .)
    END             reduce using rule 45 (_6_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    block_statement                shift and go to state 208
    _6_optional                    shift and go to state 154
    expr                           shift and go to state 152
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 189

    (43) block_statement -> _6_optional _7_repeat .
    ELIF            reduce using rule 43 (block_statement -> _6_optional _7_repeat .)
    ELSE            reduce using rule 43 (block_statement -> _6_optional _7_repeat .)
    END             reduce using rule 43 (block_statement -> _6_optional _7_repeat .)


state 190

    (46) _7_repeat -> _7_items .
    (48) _7_items -> _7_items . _7_item
    (50) _7_item -> . NEWLINE expr
    ELIF            reduce using rule 46 (_7_repeat -> _7_items .)
    ELSE            reduce using rule 46 (_7_repeat -> _7_items .)
    END             reduce using rule 46 (_7_repeat -> _7_items .)
    NEWLINE         shift and go to state 192

    _7_item                        shift and go to state 209

state 191

    (49) _7_items -> _7_item .
    NEWLINE         reduce using rule 49 (_7_items -> _7_item .)
    ELIF            reduce using rule 49 (_7_items -> _7_item .)
    ELSE            reduce using rule 49 (_7_items -> _7_item .)
    END             reduce using rule 49 (_7_items -> _7_item .)


state 192

    (50) _7_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 210
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 193

    (104) _21_optional -> : type .
    ,               reduce using rule 104 (_21_optional -> : type .)
    )               reduce using rule 104 (_21_optional -> : type .)


state 194

    (51) def_expr -> DEF identifier ( _8_optional _9_repeat ) . _10_optional do
    (59) _10_optional -> . : type
    (60) _10_optional -> .
    :               shift and go to state 212
    DO              reduce using rule 60 (_10_optional -> .)

    _10_optional                   shift and go to state 211

state 195

    (56) _9_items -> _9_items _9_item .
    ,               reduce using rule 56 (_9_items -> _9_items _9_item .)
    )               reduce using rule 56 (_9_items -> _9_items _9_item .)


state 196

    (58) _9_item -> , param .
    ,               reduce using rule 58 (_9_item -> , param .)
    )               reduce using rule 58 (_9_item -> , param .)


state 197

    (96) _19_optional -> ( identifier . _20_repeat )
    (97) _20_repeat -> . _20_items
    (98) _20_repeat -> .
    (99) _20_items -> . _20_items _20_item
    (100) _20_items -> . _20_item
    (101) _20_item -> . , identifier
    )               reduce using rule 98 (_20_repeat -> .)
    ,               shift and go to state 216

    _20_repeat                     shift and go to state 213
    _20_items                      shift and go to state 214
    _20_item                       shift and go to state 215

state 198

    (62) _11_optional -> < type _12_repeat > .
    =               reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    (               reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    -               reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    {               reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    [               reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    IDENTIFIER      reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    CASE            reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    IF              reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    DEF             reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    STRING          reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    NUMBER          reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    DO              reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    NEWLINE         reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    END             reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    ,               reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    >               reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    ELIF            reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    ELSE            reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    )               reduce using rule 62 (_11_optional -> < type _12_repeat > .)
    }               reduce using rule 62 (_11_optional -> < type _12_repeat > .)


state 199

    (65) _12_items -> _12_items _12_item .
    ,               reduce using rule 65 (_12_items -> _12_items _12_item .)
    >               reduce using rule 65 (_12_items -> _12_items _12_item .)


state 200

    (67) _12_item -> , type .
    ,               reduce using rule 67 (_12_item -> , type .)
    >               reduce using rule 67 (_12_item -> , type .)


state 201

    (81) _15_item -> identifier : type .
    IDENTIFIER      reduce using rule 81 (_15_item -> identifier : type .)
    }               reduce using rule 81 (_15_item -> identifier : type .)


state 202

    (124) _26_optional -> ( pattern _27_repeat . )
    )               shift and go to state 217


state 203

    (125) _27_repeat -> _27_items .
    (127) _27_items -> _27_items . _27_item
    (129) _27_item -> . , pattern
    )               reduce using rule 125 (_27_repeat -> _27_items .)
    ,               shift and go to state 205

    _27_item                       shift and go to state 218

state 204

    (128) _27_items -> _27_item .
    ,               reduce using rule 128 (_27_items -> _27_item .)
    )               reduce using rule 128 (_27_items -> _27_item .)


state 205

    (129) _27_item -> , . pattern
    (122) pattern -> . enum_pattern
    (123) enum_pattern -> . identifier _26_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    pattern                        shift and go to state 219
    enum_pattern                   shift and go to state 109
    identifier                     shift and go to state 110

state 206

    (106) if_expr -> IF expr THEN _22_optional block_statement _23_optional END .
    INT_DIV         reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    >               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    <               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    *               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    /               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    -               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    +               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    CONCAT          reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    NEWLINE         reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    $end            reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    ,               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    }               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    )               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    ]               reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    OF              reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    THEN            reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    END             reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    ELIF            reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)
    ELSE            reduce using rule 106 (if_expr -> IF expr THEN _22_optional block_statement _23_optional END .)


state 207

    (111) or_else -> ELIF expr . THEN block_statement _24_optional
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 220
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 208

    (114) or_else -> ELSE block_statement .
    END             reduce using rule 114 (or_else -> ELSE block_statement .)


state 209

    (48) _7_items -> _7_items _7_item .
    NEWLINE         reduce using rule 48 (_7_items -> _7_items _7_item .)
    ELIF            reduce using rule 48 (_7_items -> _7_items _7_item .)
    ELSE            reduce using rule 48 (_7_items -> _7_items _7_item .)
    END             reduce using rule 48 (_7_items -> _7_items _7_item .)


state 210

    (50) _7_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . < expr
    (28) binary_expr -> expr . * expr
    (29) binary_expr -> expr . / expr
    (30) binary_expr -> expr . - expr
    (31) binary_expr -> expr . + expr
    (32) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 50 (_7_item -> NEWLINE expr .)
    ELIF            reduce using rule 50 (_7_item -> NEWLINE expr .)
    ELSE            reduce using rule 50 (_7_item -> NEWLINE expr .)
    END             reduce using rule 50 (_7_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    >               shift and go to state 37
    <               shift and go to state 38
    *               shift and go to state 39
    /               shift and go to state 40
    -               shift and go to state 41
    +               shift and go to state 42
    CONCAT          shift and go to state 43


state 211

    (51) def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional . do
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    DO              shift and go to state 31

    do                             shift and go to state 221

state 212

    (59) _10_optional -> : . type
    (61) type -> . identifier _11_optional
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    type                           shift and go to state 222
    identifier                     shift and go to state 74

state 213

    (96) _19_optional -> ( identifier _20_repeat . )
    )               shift and go to state 223


state 214

    (97) _20_repeat -> _20_items .
    (99) _20_items -> _20_items . _20_item
    (101) _20_item -> . , identifier
    )               reduce using rule 97 (_20_repeat -> _20_items .)
    ,               shift and go to state 216

    _20_item                       shift and go to state 224

state 215

    (100) _20_items -> _20_item .
    ,               reduce using rule 100 (_20_items -> _20_item .)
    )               reduce using rule 100 (_20_items -> _20_item .)


state 216

    (101) _20_item -> , . identifier
    (156) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 225

state 217

    (124) _26_optional -> ( pattern _27_repeat ) .
    DO              reduce using rule 124 (_26_optional -> ( pattern _27_repeat ) .)
    ,               reduce using rule 124 (_26_optional -> ( pattern _27_repeat ) .)
    )               reduce using rule 124 (_26_optional -> ( pattern _27_repeat ) .)


state 218

    (127) _27_items -> _27_items _27_item .
    ,               reduce using rule 127 (_27_items -> _27_items _27_item .)
    )               reduce using rule 127 (_27_items -> _27_items _27_item .)


state 219

    (129) _27_item -> , pattern .
    ,               reduce using rule 129 (_27_item -> , pattern .)
    )               reduce using rule 129 (_27_item -> , pattern .)


state 220

    (111) or_else -> ELIF expr THEN . block_statement _24_optional
    (43) block_statement -> . _6_optional _7_repeat
    (44) _6_optional -> . expr
    (45) _6_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . identifier
    (18) expr -> . variable_declaration
    (19) expr -> . case_of
    (20) expr -> . call
    (21) expr -> . if_expr
    (22) expr -> . def_expr
    (23) expr -> . literal
    (24) expr -> . do
    (139) tuple -> . { _30_optional _31_repeat }
    (131) array -> . [ _28_optional _29_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr < expr
    (28) binary_expr -> . expr * expr
    (29) binary_expr -> . expr / expr
    (30) binary_expr -> . expr - expr
    (31) binary_expr -> . expr + expr
    (32) binary_expr -> . expr CONCAT expr
    (156) identifier -> . IDENTIFIER
    (157) variable_declaration -> . identifier _34_optional = expr
    (115) case_of -> . CASE expr OF case _25_repeat END
    (147) call -> . callee ( _32_optional _33_repeat )
    (106) if_expr -> . IF expr THEN _22_optional block_statement _23_optional END
    (51) def_expr -> . DEF identifier ( _8_optional _9_repeat ) _10_optional do
    (160) literal -> . STRING
    (161) literal -> . NUMBER
    (33) do -> . DO _3_optional _4_optional _5_repeat END
    (155) callee -> . identifier
    NEWLINE         reduce using rule 45 (_6_optional -> .)
    ELIF            reduce using rule 45 (_6_optional -> .)
    ELSE            reduce using rule 45 (_6_optional -> .)
    END             reduce using rule 45 (_6_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 27
    DEF             shift and go to state 28
    STRING          shift and go to state 29
    NUMBER          shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 152
    block_statement                shift and go to state 226
    _6_optional                    shift and go to state 154
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    identifier                     shift and go to state 8
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 26

state 221

    (51) def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .
    INT_DIV         reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    >               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    <               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    *               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    /               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    -               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    +               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    CONCAT          reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    NEWLINE         reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    $end            reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    ,               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    }               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    )               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    ]               reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    OF              reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    THEN            reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    END             reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    ELIF            reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)
    ELSE            reduce using rule 51 (def_expr -> DEF identifier ( _8_optional _9_repeat ) _10_optional do .)


state 222

    (59) _10_optional -> : type .
    DO              reduce using rule 59 (_10_optional -> : type .)


state 223

    (96) _19_optional -> ( identifier _20_repeat ) .
    IDENTIFIER      reduce using rule 96 (_19_optional -> ( identifier _20_repeat ) .)
    }               reduce using rule 96 (_19_optional -> ( identifier _20_repeat ) .)


state 224

    (99) _20_items -> _20_items _20_item .
    ,               reduce using rule 99 (_20_items -> _20_items _20_item .)
    )               reduce using rule 99 (_20_items -> _20_items _20_item .)


state 225

    (101) _20_item -> , identifier .
    ,               reduce using rule 101 (_20_item -> , identifier .)
    )               reduce using rule 101 (_20_item -> , identifier .)


state 226

    (111) or_else -> ELIF expr THEN block_statement . _24_optional
    (112) _24_optional -> . or_else
    (113) _24_optional -> .
    (111) or_else -> . ELIF expr THEN block_statement _24_optional
    (114) or_else -> . ELSE block_statement
    END             reduce using rule 113 (_24_optional -> .)
    ELIF            shift and go to state 187
    ELSE            shift and go to state 188

    _24_optional                   shift and go to state 227
    or_else                        shift and go to state 228

state 227

    (111) or_else -> ELIF expr THEN block_statement _24_optional .
    END             reduce using rule 111 (or_else -> ELIF expr THEN block_statement _24_optional .)


state 228

    (112) _24_optional -> or_else .
    END             reduce using rule 112 (_24_optional -> or_else .)
