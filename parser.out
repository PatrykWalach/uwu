Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_NEWLINE_optional _2_do_exprs_optional
Rule 2     _1_NEWLINE_optional -> NEWLINE
Rule 3     _1_NEWLINE_optional -> <empty>
Rule 4     _2_do_exprs_optional -> do_exprs
Rule 5     _2_do_exprs_optional -> <empty>
Rule 6     do_exprs -> expr _3_NEWLINE_optional
Rule 7     _3_NEWLINE_optional -> NEWLINE
Rule 8     _3_NEWLINE_optional -> <empty>
Rule 9     do_exprs -> expr NEWLINE do_exprs
Rule 10    expr -> ( expr )  [precedence=left, level=12]
Rule 11    expr -> binary_op_def
Rule 12    expr -> unary_expr
Rule 13    expr -> str_literal
Rule 14    expr -> float_literal
Rule 15    expr -> int_literal
Rule 16    expr -> array
Rule 17    expr -> variant_call
Rule 18    expr -> identifier
Rule 19    expr -> let
Rule 20    expr -> call
Rule 21    expr -> case_of
Rule 22    expr -> binary_expr
Rule 23    expr -> if_expr
Rule 24    expr -> def_expr
Rule 25    expr -> do
Rule 26    expr -> external
Rule 27    expr -> enum
Rule 28    unary_expr -> + expr  [precedence=right, level=11]
Rule 29    unary_expr -> ! expr  [precedence=right, level=11]
Rule 30    unary_expr -> STRICT_NOT expr  [precedence=right, level=11]
Rule 31    unary_expr -> - expr  [precedence=right, level=11]
Rule 32    external -> EXTERNAL
Rule 33    binary_expr -> expr FLOAT_MORE expr  [precedence=left, level=5]
Rule 34    binary_expr -> expr FLOAT_MORE_OR_EQ expr  [precedence=left, level=5]
Rule 35    binary_expr -> expr FLOAT_LESS expr  [precedence=left, level=5]
Rule 36    binary_expr -> expr FLOAT_LESS_OR_EQ expr  [precedence=left, level=5]
Rule 37    binary_expr -> expr SOME_SUB expr  [precedence=right, level=7]
Rule 38    binary_expr -> expr SOME_CONCAT expr  [precedence=right, level=7]
Rule 39    binary_expr -> expr ARROW_BOTH expr  [precedence=left, level=6]
Rule 40    binary_expr -> expr ARROW_RIGHT expr  [precedence=left, level=6]
Rule 41    binary_expr -> expr ARROW_LEFT expr  [precedence=left, level=6]
Rule 42    binary_expr -> expr DOUBLE_ARROW_RIGHT expr  [precedence=left, level=6]
Rule 43    binary_expr -> expr DOUBLE_ARROW_LEFT expr  [precedence=left, level=6]
Rule 44    binary_expr -> expr BIT_SHIFT_LEFT expr  [precedence=left, level=6]
Rule 45    binary_expr -> expr BIT_AND expr  [precedence=left, level=3]
Rule 46    binary_expr -> expr BIT_OR expr  [precedence=left, level=2]
Rule 47    binary_expr -> expr FLOAT_POW expr  [precedence=left, level=10]
Rule 48    binary_expr -> expr POW expr  [precedence=left, level=10]
Rule 49    binary_expr -> expr ARRAY_SUB expr  [precedence=right, level=7]
Rule 50    binary_expr -> expr ARRAY_CONCAT expr  [precedence=right, level=7]
Rule 51    binary_expr -> expr MORE_OR_EQ expr  [precedence=left, level=5]
Rule 52    binary_expr -> expr LESS_OR_EQ expr  [precedence=left, level=5]
Rule 53    binary_expr -> expr TEXT_MATCH expr  [precedence=left, level=4]
Rule 54    binary_expr -> expr STRICT_AND expr  [precedence=left, level=3]
Rule 55    binary_expr -> expr AND expr  [precedence=left, level=3]
Rule 56    binary_expr -> expr STRICT_OR expr  [precedence=left, level=2]
Rule 57    binary_expr -> expr OR expr  [precedence=left, level=2]
Rule 58    binary_expr -> expr EQUAL expr  [precedence=left, level=4]
Rule 59    binary_expr -> expr NOT_EQUAL expr  [precedence=left, level=4]
Rule 60    binary_expr -> expr > expr  [precedence=left, level=5]
Rule 61    binary_expr -> expr FLOAT_MUL expr  [precedence=left, level=9]
Rule 62    binary_expr -> expr FLOAT_DIV expr  [precedence=left, level=9]
Rule 63    binary_expr -> expr FLOAT_SUB expr  [precedence=left, level=8]
Rule 64    binary_expr -> expr FLOAT_SUM expr  [precedence=left, level=8]
Rule 65    binary_expr -> expr < expr  [precedence=left, level=5]
Rule 66    binary_expr -> expr * expr  [precedence=left, level=9]
Rule 67    binary_expr -> expr / expr  [precedence=left, level=9]
Rule 68    binary_expr -> expr - expr  [precedence=left, level=8]
Rule 69    binary_expr -> expr + expr  [precedence=left, level=8]
Rule 70    binary_expr -> expr CONCAT expr  [precedence=right, level=7]
Rule 71    binary_op -> FLOAT_MORE  [precedence=left, level=5]
Rule 72    binary_op -> FLOAT_MORE_OR_EQ  [precedence=left, level=5]
Rule 73    binary_op -> FLOAT_LESS  [precedence=left, level=5]
Rule 74    binary_op -> FLOAT_LESS_OR_EQ  [precedence=left, level=5]
Rule 75    binary_op -> SOME_SUB  [precedence=right, level=7]
Rule 76    binary_op -> SOME_CONCAT  [precedence=right, level=7]
Rule 77    binary_op -> ARROW_BOTH  [precedence=left, level=6]
Rule 78    binary_op -> ARROW_RIGHT  [precedence=left, level=6]
Rule 79    binary_op -> ARROW_LEFT  [precedence=left, level=6]
Rule 80    binary_op -> DOUBLE_ARROW_RIGHT  [precedence=left, level=6]
Rule 81    binary_op -> DOUBLE_ARROW_LEFT  [precedence=left, level=6]
Rule 82    binary_op -> BIT_SHIFT_LEFT  [precedence=left, level=6]
Rule 83    binary_op -> BIT_AND  [precedence=left, level=3]
Rule 84    binary_op -> BIT_OR  [precedence=left, level=2]
Rule 85    binary_op -> FLOAT_POW  [precedence=left, level=10]
Rule 86    binary_op -> POW  [precedence=left, level=10]
Rule 87    binary_op -> ARRAY_SUB  [precedence=right, level=7]
Rule 88    binary_op -> ARRAY_CONCAT  [precedence=right, level=7]
Rule 89    binary_op -> MORE_OR_EQ  [precedence=left, level=5]
Rule 90    binary_op -> LESS_OR_EQ  [precedence=left, level=5]
Rule 91    binary_op -> TEXT_MATCH  [precedence=left, level=4]
Rule 92    binary_op -> STRICT_AND  [precedence=left, level=3]
Rule 93    binary_op -> AND  [precedence=left, level=3]
Rule 94    binary_op -> STRICT_OR  [precedence=left, level=2]
Rule 95    binary_op -> OR  [precedence=left, level=2]
Rule 96    binary_op -> EQUAL  [precedence=left, level=4]
Rule 97    binary_op -> NOT_EQUAL  [precedence=left, level=4]
Rule 98    binary_op -> >  [precedence=left, level=5]
Rule 99    binary_op -> FLOAT_MUL  [precedence=left, level=9]
Rule 100   binary_op -> FLOAT_DIV  [precedence=left, level=9]
Rule 101   binary_op -> FLOAT_SUB  [precedence=left, level=8]
Rule 102   binary_op -> FLOAT_SUM  [precedence=left, level=8]
Rule 103   binary_op -> <  [precedence=left, level=5]
Rule 104   binary_op -> *  [precedence=left, level=9]
Rule 105   binary_op -> /  [precedence=left, level=9]
Rule 106   binary_op -> -  [precedence=left, level=8]
Rule 107   binary_op -> +  [precedence=left, level=8]
Rule 108   binary_op -> CONCAT  [precedence=right, level=7]
Rule 109   binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do  [precedence=left, level=12]
Rule 110   _4_NEWLINE_optional -> NEWLINE
Rule 111   _4_NEWLINE_optional -> <empty>
Rule 112   _5_NEWLINE_optional -> NEWLINE
Rule 113   _5_NEWLINE_optional -> <empty>
Rule 114   _6_NEWLINE_optional -> NEWLINE
Rule 115   _6_NEWLINE_optional -> <empty>
Rule 116   _7_0x3a_type_optional -> : type
Rule 117   _7_0x3a_type_optional -> <empty>
Rule 118   binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do  [precedence=left, level=12]
Rule 119   _8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items
Rule 120   _8_0x2c_type_identifier_repeat -> <empty>
Rule 121   _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item
Rule 122   _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item
Rule 123   _8_0x2c_type_identifier_item -> , type_identifier
Rule 124   _9_NEWLINE_optional -> NEWLINE
Rule 125   _9_NEWLINE_optional -> <empty>
Rule 126   _10_NEWLINE_optional -> NEWLINE
Rule 127   _10_NEWLINE_optional -> <empty>
Rule 128   _11_NEWLINE_optional -> NEWLINE
Rule 129   _11_NEWLINE_optional -> <empty>
Rule 130   _12_0x3a_type_optional -> : type
Rule 131   _12_0x3a_type_optional -> <empty>
Rule 132   do -> DO _13_0x3a_type_optional block_statement END
Rule 133   _13_0x3a_type_optional -> : type
Rule 134   _13_0x3a_type_optional -> <empty>
Rule 135   block_statement -> _14_NEWLINE_optional _15_do_exprs_optional
Rule 136   _14_NEWLINE_optional -> NEWLINE
Rule 137   _14_NEWLINE_optional -> <empty>
Rule 138   _15_do_exprs_optional -> do_exprs
Rule 139   _15_do_exprs_optional -> <empty>
Rule 140   def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do  [precedence=left, level=12]
Rule 141   _16_NEWLINE_optional -> NEWLINE
Rule 142   _16_NEWLINE_optional -> <empty>
Rule 143   _17_params_optional -> params
Rule 144   _17_params_optional -> <empty>
Rule 145   _18_0x3a_type_optional -> : type
Rule 146   _18_0x3a_type_optional -> <empty>
Rule 147   def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do  [precedence=left, level=12]
Rule 148   _19_0x2c_type_identifier_repeat -> _19_0x2c_type_identifier_items
Rule 149   _19_0x2c_type_identifier_repeat -> <empty>
Rule 150   _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item
Rule 151   _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_item
Rule 152   _19_0x2c_type_identifier_item -> , type_identifier
Rule 153   _20_NEWLINE_optional -> NEWLINE
Rule 154   _20_NEWLINE_optional -> <empty>
Rule 155   _21_params_optional -> params
Rule 156   _21_params_optional -> <empty>
Rule 157   _22_0x3a_type_optional -> : type
Rule 158   _22_0x3a_type_optional -> <empty>
Rule 159   params -> param _23_NEWLINE_optional
Rule 160   _23_NEWLINE_optional -> NEWLINE
Rule 161   _23_NEWLINE_optional -> <empty>
Rule 162   params -> params , _24_NEWLINE_optional param _25_NEWLINE_optional
Rule 163   _24_NEWLINE_optional -> NEWLINE
Rule 164   _24_NEWLINE_optional -> <empty>
Rule 165   _25_NEWLINE_optional -> NEWLINE
Rule 166   _25_NEWLINE_optional -> <empty>
Rule 167   type -> type_identifier < type _26_0x2c_type_repeat >  [precedence=left, level=5]
Rule 168   _26_0x2c_type_repeat -> _26_0x2c_type_items
Rule 169   _26_0x2c_type_repeat -> <empty>
Rule 170   _26_0x2c_type_items -> _26_0x2c_type_items _26_0x2c_type_item
Rule 171   _26_0x2c_type_items -> _26_0x2c_type_item
Rule 172   _26_0x2c_type_item -> , type
Rule 173   type -> type_identifier
Rule 174   enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
Rule 175   _27_NEWLINE_optional -> NEWLINE
Rule 176   _27_NEWLINE_optional -> <empty>
Rule 177   _28_variants_optional -> variants
Rule 178   _28_variants_optional -> <empty>
Rule 179   enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
Rule 180   _29_0x2c_type_identifier_repeat -> _29_0x2c_type_identifier_items
Rule 181   _29_0x2c_type_identifier_repeat -> <empty>
Rule 182   _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item
Rule 183   _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_item
Rule 184   _29_0x2c_type_identifier_item -> , type_identifier
Rule 185   _30_NEWLINE_optional -> NEWLINE
Rule 186   _30_NEWLINE_optional -> <empty>
Rule 187   _31_variants_optional -> variants
Rule 188   _31_variants_optional -> <empty>
Rule 189   variants -> variant _32_NEWLINE_optional
Rule 190   _32_NEWLINE_optional -> NEWLINE
Rule 191   _32_NEWLINE_optional -> <empty>
Rule 192   variants -> variants variant _33_NEWLINE_optional
Rule 193   _33_NEWLINE_optional -> NEWLINE
Rule 194   _33_NEWLINE_optional -> <empty>
Rule 195   variant -> TYPE_IDENTIFIER
Rule 196   variant -> TYPE_IDENTIFIER ( type _34_0x2c_type_repeat )  [precedence=left, level=12]
Rule 197   _34_0x2c_type_repeat -> _34_0x2c_type_items
Rule 198   _34_0x2c_type_repeat -> <empty>
Rule 199   _34_0x2c_type_items -> _34_0x2c_type_items _34_0x2c_type_item
Rule 200   _34_0x2c_type_items -> _34_0x2c_type_item
Rule 201   _34_0x2c_type_item -> , type
Rule 202   param -> identifier _35_0x3a_type_optional
Rule 203   _35_0x3a_type_optional -> : type
Rule 204   _35_0x3a_type_optional -> <empty>
Rule 205   if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
Rule 206   _36_0x3a_type_optional -> : type
Rule 207   _36_0x3a_type_optional -> <empty>
Rule 208   _37_or_else_optional -> or_else
Rule 209   _37_or_else_optional -> <empty>
Rule 210   or_else -> ELIF expr THEN block_statement _38_or_else_optional
Rule 211   _38_or_else_optional -> or_else
Rule 212   _38_or_else_optional -> <empty>
Rule 213   or_else -> ELSE block_statement
Rule 214   case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END
Rule 215   _39_NEWLINE_optional -> NEWLINE
Rule 216   _39_NEWLINE_optional -> <empty>
Rule 217   _40_cases_optional -> cases
Rule 218   _40_cases_optional -> <empty>
Rule 219   cases -> pattern do _41_NEWLINE_optional
Rule 220   _41_NEWLINE_optional -> NEWLINE
Rule 221   _41_NEWLINE_optional -> <empty>
Rule 222   cases -> cases pattern do _42_NEWLINE_optional
Rule 223   _42_NEWLINE_optional -> NEWLINE
Rule 224   _42_NEWLINE_optional -> <empty>
Rule 225   pattern -> match_variant
Rule 226   pattern -> match_as
Rule 227   match_as -> identifier
Rule 228   match_variant -> TYPE_IDENTIFIER
Rule 229   match_variant -> TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional )  [precedence=left, level=12]
Rule 230   _43_NEWLINE_optional -> NEWLINE
Rule 231   _43_NEWLINE_optional -> <empty>
Rule 232   _44_patterns_optional -> patterns
Rule 233   _44_patterns_optional -> <empty>
Rule 234   patterns -> pattern _45_NEWLINE_optional
Rule 235   _45_NEWLINE_optional -> NEWLINE
Rule 236   _45_NEWLINE_optional -> <empty>
Rule 237   patterns -> patterns , _46_NEWLINE_optional pattern _47_NEWLINE_optional
Rule 238   _46_NEWLINE_optional -> NEWLINE
Rule 239   _46_NEWLINE_optional -> <empty>
Rule 240   _47_NEWLINE_optional -> NEWLINE
Rule 241   _47_NEWLINE_optional -> <empty>
Rule 242   array -> [ _48_NEWLINE_optional _49_exprs_optional ]
Rule 243   _48_NEWLINE_optional -> NEWLINE
Rule 244   _48_NEWLINE_optional -> <empty>
Rule 245   _49_exprs_optional -> exprs
Rule 246   _49_exprs_optional -> <empty>
Rule 247   call -> expr ( _50_NEWLINE_optional _51_exprs_optional )  [precedence=left, level=12]
Rule 248   _50_NEWLINE_optional -> NEWLINE
Rule 249   _50_NEWLINE_optional -> <empty>
Rule 250   _51_exprs_optional -> exprs
Rule 251   _51_exprs_optional -> <empty>
Rule 252   variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )  [precedence=left, level=12]
Rule 253   _52_NEWLINE_optional -> NEWLINE
Rule 254   _52_NEWLINE_optional -> <empty>
Rule 255   _53_exprs_optional -> exprs
Rule 256   _53_exprs_optional -> <empty>
Rule 257   exprs -> expr _54_NEWLINE_optional
Rule 258   _54_NEWLINE_optional -> NEWLINE
Rule 259   _54_NEWLINE_optional -> <empty>
Rule 260   exprs -> exprs , _55_NEWLINE_optional expr _56_NEWLINE_optional
Rule 261   _55_NEWLINE_optional -> NEWLINE
Rule 262   _55_NEWLINE_optional -> <empty>
Rule 263   _56_NEWLINE_optional -> NEWLINE
Rule 264   _56_NEWLINE_optional -> <empty>
Rule 265   identifier -> IDENTIFIER
Rule 266   type_identifier -> IDENTIFIER
Rule 267   type_identifier -> TYPE_IDENTIFIER
Rule 268   let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr  [precedence=left, level=5]
Rule 269   _57_0x2c_type_repeat -> _57_0x2c_type_items
Rule 270   _57_0x2c_type_repeat -> <empty>
Rule 271   _57_0x2c_type_items -> _57_0x2c_type_items _57_0x2c_type_item
Rule 272   _57_0x2c_type_items -> _57_0x2c_type_item
Rule 273   _57_0x2c_type_item -> , type
Rule 274   let -> identifier _58_0x3a_type_optional = expr  [precedence=right, level=1]
Rule 275   _58_0x3a_type_optional -> : type
Rule 276   _58_0x3a_type_optional -> <empty>
Rule 277   int_literal -> INT
Rule 278   float_literal -> FLOAT
Rule 279   str_literal -> STRING

Terminals, with rules where they appear:

!                    : 29
(                    : 10 109 118 140 147 196 229 247 252
)                    : 10 109 118 140 147 196 229 247 252
*                    : 66 104
+                    : 28 69 107
,                    : 109 118 123 152 162 172 184 201 237 260 273
-                    : 31 68 106
/                    : 67 105
:                    : 116 130 133 145 157 203 206 268 275
<                    : 65 103 118 147 167 179 268
=                    : 274
>                    : 60 98 118 147 167 179
AND                  : 55 93
ARRAY_CONCAT         : 50 88
ARRAY_SUB            : 49 87
ARROW_BOTH           : 39 77
ARROW_LEFT           : 41 79
ARROW_RIGHT          : 40 78
BIT_AND              : 45 83
BIT_OR               : 46 84
BIT_SHIFT_LEFT       : 44 82
CASE                 : 214
CONCAT               : 70 108
DEF                  : 109 118 140 147
DO                   : 132
DOUBLE_ARROW_LEFT    : 43 81
DOUBLE_ARROW_RIGHT   : 42 80
ELIF                 : 210
ELSE                 : 213
END                  : 132 205 214
ENUM                 : 174 179
EQUAL                : 58 96
EXTERNAL             : 32
FLOAT                : 278
FLOAT_DIV            : 62 100
FLOAT_LESS           : 35 73
FLOAT_LESS_OR_EQ     : 36 74
FLOAT_MORE           : 33 71
FLOAT_MORE_OR_EQ     : 34 72
FLOAT_MUL            : 61 99
FLOAT_POW            : 47 85
FLOAT_SUB            : 63 101
FLOAT_SUM            : 64 102
IDENTIFIER           : 265 266
IF                   : 205
INT                  : 277
LESS_OR_EQ           : 52 90
MORE_OR_EQ           : 51 89 268
NEWLINE              : 2 7 9 110 112 114 124 126 128 136 141 153 160 163 165 175 185 190 193 215 220 223 230 235 238 240 243 248 253 258 261 263
NOT_EQUAL            : 59 97
OF                   : 214
OR                   : 57 95
POW                  : 48 86
SOME_CONCAT          : 38 76
SOME_SUB             : 37 75
STRICT_AND           : 54 92
STRICT_NOT           : 30
STRICT_OR            : 56 94
STRING               : 279
TEXT_MATCH           : 53 91
THEN                 : 205 210
TYPE_IDENTIFIER      : 195 196 228 229 252 267
[                    : 242
]                    : 242
error                : 
{                    : 174 179
}                    : 174 179

Nonterminals, with rules where they appear:

_10_NEWLINE_optional : 118
_11_NEWLINE_optional : 118
_12_0x3a_type_optional : 118
_13_0x3a_type_optional : 132
_14_NEWLINE_optional : 135
_15_do_exprs_optional : 135
_16_NEWLINE_optional : 140
_17_params_optional  : 140
_18_0x3a_type_optional : 140
_19_0x2c_type_identifier_item : 150 151
_19_0x2c_type_identifier_items : 148 150
_19_0x2c_type_identifier_repeat : 147
_1_NEWLINE_optional  : 1
_20_NEWLINE_optional : 147
_21_params_optional  : 147
_22_0x3a_type_optional : 147
_23_NEWLINE_optional : 159
_24_NEWLINE_optional : 162
_25_NEWLINE_optional : 162
_26_0x2c_type_item   : 170 171
_26_0x2c_type_items  : 168 170
_26_0x2c_type_repeat : 167
_27_NEWLINE_optional : 174
_28_variants_optional : 174
_29_0x2c_type_identifier_item : 182 183
_29_0x2c_type_identifier_items : 180 182
_29_0x2c_type_identifier_repeat : 179
_2_do_exprs_optional : 1
_30_NEWLINE_optional : 179
_31_variants_optional : 179
_32_NEWLINE_optional : 189
_33_NEWLINE_optional : 192
_34_0x2c_type_item   : 199 200
_34_0x2c_type_items  : 197 199
_34_0x2c_type_repeat : 196
_35_0x3a_type_optional : 202
_36_0x3a_type_optional : 205
_37_or_else_optional : 205
_38_or_else_optional : 210
_39_NEWLINE_optional : 214
_3_NEWLINE_optional  : 6
_40_cases_optional   : 214
_41_NEWLINE_optional : 219
_42_NEWLINE_optional : 222
_43_NEWLINE_optional : 229
_44_patterns_optional : 229
_45_NEWLINE_optional : 234
_46_NEWLINE_optional : 237
_47_NEWLINE_optional : 237
_48_NEWLINE_optional : 242
_49_exprs_optional   : 242
_4_NEWLINE_optional  : 109
_50_NEWLINE_optional : 247
_51_exprs_optional   : 247
_52_NEWLINE_optional : 252
_53_exprs_optional   : 252
_54_NEWLINE_optional : 257
_55_NEWLINE_optional : 260
_56_NEWLINE_optional : 260
_57_0x2c_type_item   : 271 272
_57_0x2c_type_items  : 269 271
_57_0x2c_type_repeat : 268
_58_0x3a_type_optional : 274
_5_NEWLINE_optional  : 109
_6_NEWLINE_optional  : 109
_7_0x3a_type_optional : 109
_8_0x2c_type_identifier_item : 121 122
_8_0x2c_type_identifier_items : 119 121
_8_0x2c_type_identifier_repeat : 118
_9_NEWLINE_optional  : 118
array                : 16
binary_expr          : 22
binary_op            : 109 118
binary_op_def        : 11
block_statement      : 132 205 210 213
call                 : 20
case_of              : 21
cases                : 217 222
def_expr             : 24
do                   : 25 109 118 140 147 219 222
do_exprs             : 4 9 138
enum                 : 27
expr                 : 6 9 10 28 29 30 31 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 205 210 214 247 257 260 268 274
exprs                : 245 250 255 260
external             : 26
float_literal        : 14
identifier           : 18 140 147 202 227 268 274
if_expr              : 23
int_literal          : 15
let                  : 19
match_as             : 226
match_variant        : 225
or_else              : 208 211
param                : 109 109 118 118 159 162
params               : 143 155 162
pattern              : 219 222 234 237
patterns             : 232 237
program              : 0
str_literal          : 13
type                 : 116 130 133 145 157 167 172 196 201 203 206 268 273 275
type_identifier      : 118 123 147 152 167 173 174 179 179 184 268
unary_expr           : 12
variant              : 189 192
variant_call         : 17
variants             : 177 187 192


state 0

    (0) S' -> . program
    (1) program -> . _1_NEWLINE_optional _2_do_exprs_optional
    (2) _1_NEWLINE_optional -> . NEWLINE
    (3) _1_NEWLINE_optional -> .
    NEWLINE         shift and go to state 3
    (               reduce using rule 3 (_1_NEWLINE_optional -> .)
    DEF             reduce using rule 3 (_1_NEWLINE_optional -> .)
    +               reduce using rule 3 (_1_NEWLINE_optional -> .)
    !               reduce using rule 3 (_1_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 3 (_1_NEWLINE_optional -> .)
    -               reduce using rule 3 (_1_NEWLINE_optional -> .)
    STRING          reduce using rule 3 (_1_NEWLINE_optional -> .)
    FLOAT           reduce using rule 3 (_1_NEWLINE_optional -> .)
    INT             reduce using rule 3 (_1_NEWLINE_optional -> .)
    [               reduce using rule 3 (_1_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 3 (_1_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 3 (_1_NEWLINE_optional -> .)
    CASE            reduce using rule 3 (_1_NEWLINE_optional -> .)
    IF              reduce using rule 3 (_1_NEWLINE_optional -> .)
    DO              reduce using rule 3 (_1_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 3 (_1_NEWLINE_optional -> .)
    ENUM            reduce using rule 3 (_1_NEWLINE_optional -> .)
    $end            reduce using rule 3 (_1_NEWLINE_optional -> .)

    program                        shift and go to state 1
    _1_NEWLINE_optional            shift and go to state 2

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_NEWLINE_optional . _2_do_exprs_optional
    (4) _2_do_exprs_optional -> . do_exprs
    (5) _2_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    $end            reduce using rule 5 (_2_do_exprs_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    _2_do_exprs_optional           shift and go to state 4
    do_exprs                       shift and go to state 5
    expr                           shift and go to state 6
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 3

    (2) _1_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    $end            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)


state 4

    (1) program -> _1_NEWLINE_optional _2_do_exprs_optional .
    $end            reduce using rule 1 (program -> _1_NEWLINE_optional _2_do_exprs_optional .)


state 5

    (4) _2_do_exprs_optional -> do_exprs .
    $end            reduce using rule 4 (_2_do_exprs_optional -> do_exprs .)


state 6

    (6) do_exprs -> expr . _3_NEWLINE_optional
    (9) do_exprs -> expr . NEWLINE do_exprs
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    (7) _3_NEWLINE_optional -> . NEWLINE
    (8) _3_NEWLINE_optional -> .
    NEWLINE         shift and go to state 42
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    BIT_OR          shift and go to state 57
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    STRICT_OR       shift and go to state 67
    OR              shift and go to state 68
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81
    $end            reduce using rule 8 (_3_NEWLINE_optional -> .)
    END             reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELIF            reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELSE            reduce using rule 8 (_3_NEWLINE_optional -> .)

    _3_NEWLINE_optional            shift and go to state 41

state 7

    (10) expr -> ( . expr )
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 82
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 8

    (11) expr -> binary_op_def .
    NEWLINE         reduce using rule 11 (expr -> binary_op_def .)
    (               reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_MORE      reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_MORE_OR_EQ reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_LESS      reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_LESS_OR_EQ reduce using rule 11 (expr -> binary_op_def .)
    SOME_SUB        reduce using rule 11 (expr -> binary_op_def .)
    SOME_CONCAT     reduce using rule 11 (expr -> binary_op_def .)
    ARROW_BOTH      reduce using rule 11 (expr -> binary_op_def .)
    ARROW_RIGHT     reduce using rule 11 (expr -> binary_op_def .)
    ARROW_LEFT      reduce using rule 11 (expr -> binary_op_def .)
    DOUBLE_ARROW_RIGHT reduce using rule 11 (expr -> binary_op_def .)
    DOUBLE_ARROW_LEFT reduce using rule 11 (expr -> binary_op_def .)
    BIT_SHIFT_LEFT  reduce using rule 11 (expr -> binary_op_def .)
    BIT_AND         reduce using rule 11 (expr -> binary_op_def .)
    BIT_OR          reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_POW       reduce using rule 11 (expr -> binary_op_def .)
    POW             reduce using rule 11 (expr -> binary_op_def .)
    ARRAY_SUB       reduce using rule 11 (expr -> binary_op_def .)
    ARRAY_CONCAT    reduce using rule 11 (expr -> binary_op_def .)
    MORE_OR_EQ      reduce using rule 11 (expr -> binary_op_def .)
    LESS_OR_EQ      reduce using rule 11 (expr -> binary_op_def .)
    TEXT_MATCH      reduce using rule 11 (expr -> binary_op_def .)
    STRICT_AND      reduce using rule 11 (expr -> binary_op_def .)
    AND             reduce using rule 11 (expr -> binary_op_def .)
    STRICT_OR       reduce using rule 11 (expr -> binary_op_def .)
    OR              reduce using rule 11 (expr -> binary_op_def .)
    EQUAL           reduce using rule 11 (expr -> binary_op_def .)
    NOT_EQUAL       reduce using rule 11 (expr -> binary_op_def .)
    >               reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_MUL       reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_DIV       reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_SUB       reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_SUM       reduce using rule 11 (expr -> binary_op_def .)
    <               reduce using rule 11 (expr -> binary_op_def .)
    *               reduce using rule 11 (expr -> binary_op_def .)
    /               reduce using rule 11 (expr -> binary_op_def .)
    -               reduce using rule 11 (expr -> binary_op_def .)
    +               reduce using rule 11 (expr -> binary_op_def .)
    CONCAT          reduce using rule 11 (expr -> binary_op_def .)
    $end            reduce using rule 11 (expr -> binary_op_def .)
    )               reduce using rule 11 (expr -> binary_op_def .)
    OF              reduce using rule 11 (expr -> binary_op_def .)
    THEN            reduce using rule 11 (expr -> binary_op_def .)
    END             reduce using rule 11 (expr -> binary_op_def .)
    ELIF            reduce using rule 11 (expr -> binary_op_def .)
    ELSE            reduce using rule 11 (expr -> binary_op_def .)
    ,               reduce using rule 11 (expr -> binary_op_def .)
    ]               reduce using rule 11 (expr -> binary_op_def .)


state 9

    (12) expr -> unary_expr .
    NEWLINE         reduce using rule 12 (expr -> unary_expr .)
    (               reduce using rule 12 (expr -> unary_expr .)
    FLOAT_MORE      reduce using rule 12 (expr -> unary_expr .)
    FLOAT_MORE_OR_EQ reduce using rule 12 (expr -> unary_expr .)
    FLOAT_LESS      reduce using rule 12 (expr -> unary_expr .)
    FLOAT_LESS_OR_EQ reduce using rule 12 (expr -> unary_expr .)
    SOME_SUB        reduce using rule 12 (expr -> unary_expr .)
    SOME_CONCAT     reduce using rule 12 (expr -> unary_expr .)
    ARROW_BOTH      reduce using rule 12 (expr -> unary_expr .)
    ARROW_RIGHT     reduce using rule 12 (expr -> unary_expr .)
    ARROW_LEFT      reduce using rule 12 (expr -> unary_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 12 (expr -> unary_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 12 (expr -> unary_expr .)
    BIT_SHIFT_LEFT  reduce using rule 12 (expr -> unary_expr .)
    BIT_AND         reduce using rule 12 (expr -> unary_expr .)
    BIT_OR          reduce using rule 12 (expr -> unary_expr .)
    FLOAT_POW       reduce using rule 12 (expr -> unary_expr .)
    POW             reduce using rule 12 (expr -> unary_expr .)
    ARRAY_SUB       reduce using rule 12 (expr -> unary_expr .)
    ARRAY_CONCAT    reduce using rule 12 (expr -> unary_expr .)
    MORE_OR_EQ      reduce using rule 12 (expr -> unary_expr .)
    LESS_OR_EQ      reduce using rule 12 (expr -> unary_expr .)
    TEXT_MATCH      reduce using rule 12 (expr -> unary_expr .)
    STRICT_AND      reduce using rule 12 (expr -> unary_expr .)
    AND             reduce using rule 12 (expr -> unary_expr .)
    STRICT_OR       reduce using rule 12 (expr -> unary_expr .)
    OR              reduce using rule 12 (expr -> unary_expr .)
    EQUAL           reduce using rule 12 (expr -> unary_expr .)
    NOT_EQUAL       reduce using rule 12 (expr -> unary_expr .)
    >               reduce using rule 12 (expr -> unary_expr .)
    FLOAT_MUL       reduce using rule 12 (expr -> unary_expr .)
    FLOAT_DIV       reduce using rule 12 (expr -> unary_expr .)
    FLOAT_SUB       reduce using rule 12 (expr -> unary_expr .)
    FLOAT_SUM       reduce using rule 12 (expr -> unary_expr .)
    <               reduce using rule 12 (expr -> unary_expr .)
    *               reduce using rule 12 (expr -> unary_expr .)
    /               reduce using rule 12 (expr -> unary_expr .)
    -               reduce using rule 12 (expr -> unary_expr .)
    +               reduce using rule 12 (expr -> unary_expr .)
    CONCAT          reduce using rule 12 (expr -> unary_expr .)
    $end            reduce using rule 12 (expr -> unary_expr .)
    )               reduce using rule 12 (expr -> unary_expr .)
    OF              reduce using rule 12 (expr -> unary_expr .)
    THEN            reduce using rule 12 (expr -> unary_expr .)
    END             reduce using rule 12 (expr -> unary_expr .)
    ELIF            reduce using rule 12 (expr -> unary_expr .)
    ELSE            reduce using rule 12 (expr -> unary_expr .)
    ,               reduce using rule 12 (expr -> unary_expr .)
    ]               reduce using rule 12 (expr -> unary_expr .)


state 10

    (13) expr -> str_literal .
    NEWLINE         reduce using rule 13 (expr -> str_literal .)
    (               reduce using rule 13 (expr -> str_literal .)
    FLOAT_MORE      reduce using rule 13 (expr -> str_literal .)
    FLOAT_MORE_OR_EQ reduce using rule 13 (expr -> str_literal .)
    FLOAT_LESS      reduce using rule 13 (expr -> str_literal .)
    FLOAT_LESS_OR_EQ reduce using rule 13 (expr -> str_literal .)
    SOME_SUB        reduce using rule 13 (expr -> str_literal .)
    SOME_CONCAT     reduce using rule 13 (expr -> str_literal .)
    ARROW_BOTH      reduce using rule 13 (expr -> str_literal .)
    ARROW_RIGHT     reduce using rule 13 (expr -> str_literal .)
    ARROW_LEFT      reduce using rule 13 (expr -> str_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 13 (expr -> str_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 13 (expr -> str_literal .)
    BIT_SHIFT_LEFT  reduce using rule 13 (expr -> str_literal .)
    BIT_AND         reduce using rule 13 (expr -> str_literal .)
    BIT_OR          reduce using rule 13 (expr -> str_literal .)
    FLOAT_POW       reduce using rule 13 (expr -> str_literal .)
    POW             reduce using rule 13 (expr -> str_literal .)
    ARRAY_SUB       reduce using rule 13 (expr -> str_literal .)
    ARRAY_CONCAT    reduce using rule 13 (expr -> str_literal .)
    MORE_OR_EQ      reduce using rule 13 (expr -> str_literal .)
    LESS_OR_EQ      reduce using rule 13 (expr -> str_literal .)
    TEXT_MATCH      reduce using rule 13 (expr -> str_literal .)
    STRICT_AND      reduce using rule 13 (expr -> str_literal .)
    AND             reduce using rule 13 (expr -> str_literal .)
    STRICT_OR       reduce using rule 13 (expr -> str_literal .)
    OR              reduce using rule 13 (expr -> str_literal .)
    EQUAL           reduce using rule 13 (expr -> str_literal .)
    NOT_EQUAL       reduce using rule 13 (expr -> str_literal .)
    >               reduce using rule 13 (expr -> str_literal .)
    FLOAT_MUL       reduce using rule 13 (expr -> str_literal .)
    FLOAT_DIV       reduce using rule 13 (expr -> str_literal .)
    FLOAT_SUB       reduce using rule 13 (expr -> str_literal .)
    FLOAT_SUM       reduce using rule 13 (expr -> str_literal .)
    <               reduce using rule 13 (expr -> str_literal .)
    *               reduce using rule 13 (expr -> str_literal .)
    /               reduce using rule 13 (expr -> str_literal .)
    -               reduce using rule 13 (expr -> str_literal .)
    +               reduce using rule 13 (expr -> str_literal .)
    CONCAT          reduce using rule 13 (expr -> str_literal .)
    $end            reduce using rule 13 (expr -> str_literal .)
    )               reduce using rule 13 (expr -> str_literal .)
    OF              reduce using rule 13 (expr -> str_literal .)
    THEN            reduce using rule 13 (expr -> str_literal .)
    END             reduce using rule 13 (expr -> str_literal .)
    ELIF            reduce using rule 13 (expr -> str_literal .)
    ELSE            reduce using rule 13 (expr -> str_literal .)
    ,               reduce using rule 13 (expr -> str_literal .)
    ]               reduce using rule 13 (expr -> str_literal .)


state 11

    (14) expr -> float_literal .
    NEWLINE         reduce using rule 14 (expr -> float_literal .)
    (               reduce using rule 14 (expr -> float_literal .)
    FLOAT_MORE      reduce using rule 14 (expr -> float_literal .)
    FLOAT_MORE_OR_EQ reduce using rule 14 (expr -> float_literal .)
    FLOAT_LESS      reduce using rule 14 (expr -> float_literal .)
    FLOAT_LESS_OR_EQ reduce using rule 14 (expr -> float_literal .)
    SOME_SUB        reduce using rule 14 (expr -> float_literal .)
    SOME_CONCAT     reduce using rule 14 (expr -> float_literal .)
    ARROW_BOTH      reduce using rule 14 (expr -> float_literal .)
    ARROW_RIGHT     reduce using rule 14 (expr -> float_literal .)
    ARROW_LEFT      reduce using rule 14 (expr -> float_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 14 (expr -> float_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 14 (expr -> float_literal .)
    BIT_SHIFT_LEFT  reduce using rule 14 (expr -> float_literal .)
    BIT_AND         reduce using rule 14 (expr -> float_literal .)
    BIT_OR          reduce using rule 14 (expr -> float_literal .)
    FLOAT_POW       reduce using rule 14 (expr -> float_literal .)
    POW             reduce using rule 14 (expr -> float_literal .)
    ARRAY_SUB       reduce using rule 14 (expr -> float_literal .)
    ARRAY_CONCAT    reduce using rule 14 (expr -> float_literal .)
    MORE_OR_EQ      reduce using rule 14 (expr -> float_literal .)
    LESS_OR_EQ      reduce using rule 14 (expr -> float_literal .)
    TEXT_MATCH      reduce using rule 14 (expr -> float_literal .)
    STRICT_AND      reduce using rule 14 (expr -> float_literal .)
    AND             reduce using rule 14 (expr -> float_literal .)
    STRICT_OR       reduce using rule 14 (expr -> float_literal .)
    OR              reduce using rule 14 (expr -> float_literal .)
    EQUAL           reduce using rule 14 (expr -> float_literal .)
    NOT_EQUAL       reduce using rule 14 (expr -> float_literal .)
    >               reduce using rule 14 (expr -> float_literal .)
    FLOAT_MUL       reduce using rule 14 (expr -> float_literal .)
    FLOAT_DIV       reduce using rule 14 (expr -> float_literal .)
    FLOAT_SUB       reduce using rule 14 (expr -> float_literal .)
    FLOAT_SUM       reduce using rule 14 (expr -> float_literal .)
    <               reduce using rule 14 (expr -> float_literal .)
    *               reduce using rule 14 (expr -> float_literal .)
    /               reduce using rule 14 (expr -> float_literal .)
    -               reduce using rule 14 (expr -> float_literal .)
    +               reduce using rule 14 (expr -> float_literal .)
    CONCAT          reduce using rule 14 (expr -> float_literal .)
    $end            reduce using rule 14 (expr -> float_literal .)
    )               reduce using rule 14 (expr -> float_literal .)
    OF              reduce using rule 14 (expr -> float_literal .)
    THEN            reduce using rule 14 (expr -> float_literal .)
    END             reduce using rule 14 (expr -> float_literal .)
    ELIF            reduce using rule 14 (expr -> float_literal .)
    ELSE            reduce using rule 14 (expr -> float_literal .)
    ,               reduce using rule 14 (expr -> float_literal .)
    ]               reduce using rule 14 (expr -> float_literal .)


state 12

    (15) expr -> int_literal .
    NEWLINE         reduce using rule 15 (expr -> int_literal .)
    (               reduce using rule 15 (expr -> int_literal .)
    FLOAT_MORE      reduce using rule 15 (expr -> int_literal .)
    FLOAT_MORE_OR_EQ reduce using rule 15 (expr -> int_literal .)
    FLOAT_LESS      reduce using rule 15 (expr -> int_literal .)
    FLOAT_LESS_OR_EQ reduce using rule 15 (expr -> int_literal .)
    SOME_SUB        reduce using rule 15 (expr -> int_literal .)
    SOME_CONCAT     reduce using rule 15 (expr -> int_literal .)
    ARROW_BOTH      reduce using rule 15 (expr -> int_literal .)
    ARROW_RIGHT     reduce using rule 15 (expr -> int_literal .)
    ARROW_LEFT      reduce using rule 15 (expr -> int_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 15 (expr -> int_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 15 (expr -> int_literal .)
    BIT_SHIFT_LEFT  reduce using rule 15 (expr -> int_literal .)
    BIT_AND         reduce using rule 15 (expr -> int_literal .)
    BIT_OR          reduce using rule 15 (expr -> int_literal .)
    FLOAT_POW       reduce using rule 15 (expr -> int_literal .)
    POW             reduce using rule 15 (expr -> int_literal .)
    ARRAY_SUB       reduce using rule 15 (expr -> int_literal .)
    ARRAY_CONCAT    reduce using rule 15 (expr -> int_literal .)
    MORE_OR_EQ      reduce using rule 15 (expr -> int_literal .)
    LESS_OR_EQ      reduce using rule 15 (expr -> int_literal .)
    TEXT_MATCH      reduce using rule 15 (expr -> int_literal .)
    STRICT_AND      reduce using rule 15 (expr -> int_literal .)
    AND             reduce using rule 15 (expr -> int_literal .)
    STRICT_OR       reduce using rule 15 (expr -> int_literal .)
    OR              reduce using rule 15 (expr -> int_literal .)
    EQUAL           reduce using rule 15 (expr -> int_literal .)
    NOT_EQUAL       reduce using rule 15 (expr -> int_literal .)
    >               reduce using rule 15 (expr -> int_literal .)
    FLOAT_MUL       reduce using rule 15 (expr -> int_literal .)
    FLOAT_DIV       reduce using rule 15 (expr -> int_literal .)
    FLOAT_SUB       reduce using rule 15 (expr -> int_literal .)
    FLOAT_SUM       reduce using rule 15 (expr -> int_literal .)
    <               reduce using rule 15 (expr -> int_literal .)
    *               reduce using rule 15 (expr -> int_literal .)
    /               reduce using rule 15 (expr -> int_literal .)
    -               reduce using rule 15 (expr -> int_literal .)
    +               reduce using rule 15 (expr -> int_literal .)
    CONCAT          reduce using rule 15 (expr -> int_literal .)
    $end            reduce using rule 15 (expr -> int_literal .)
    )               reduce using rule 15 (expr -> int_literal .)
    OF              reduce using rule 15 (expr -> int_literal .)
    THEN            reduce using rule 15 (expr -> int_literal .)
    END             reduce using rule 15 (expr -> int_literal .)
    ELIF            reduce using rule 15 (expr -> int_literal .)
    ELSE            reduce using rule 15 (expr -> int_literal .)
    ,               reduce using rule 15 (expr -> int_literal .)
    ]               reduce using rule 15 (expr -> int_literal .)


state 13

    (16) expr -> array .
    NEWLINE         reduce using rule 16 (expr -> array .)
    (               reduce using rule 16 (expr -> array .)
    FLOAT_MORE      reduce using rule 16 (expr -> array .)
    FLOAT_MORE_OR_EQ reduce using rule 16 (expr -> array .)
    FLOAT_LESS      reduce using rule 16 (expr -> array .)
    FLOAT_LESS_OR_EQ reduce using rule 16 (expr -> array .)
    SOME_SUB        reduce using rule 16 (expr -> array .)
    SOME_CONCAT     reduce using rule 16 (expr -> array .)
    ARROW_BOTH      reduce using rule 16 (expr -> array .)
    ARROW_RIGHT     reduce using rule 16 (expr -> array .)
    ARROW_LEFT      reduce using rule 16 (expr -> array .)
    DOUBLE_ARROW_RIGHT reduce using rule 16 (expr -> array .)
    DOUBLE_ARROW_LEFT reduce using rule 16 (expr -> array .)
    BIT_SHIFT_LEFT  reduce using rule 16 (expr -> array .)
    BIT_AND         reduce using rule 16 (expr -> array .)
    BIT_OR          reduce using rule 16 (expr -> array .)
    FLOAT_POW       reduce using rule 16 (expr -> array .)
    POW             reduce using rule 16 (expr -> array .)
    ARRAY_SUB       reduce using rule 16 (expr -> array .)
    ARRAY_CONCAT    reduce using rule 16 (expr -> array .)
    MORE_OR_EQ      reduce using rule 16 (expr -> array .)
    LESS_OR_EQ      reduce using rule 16 (expr -> array .)
    TEXT_MATCH      reduce using rule 16 (expr -> array .)
    STRICT_AND      reduce using rule 16 (expr -> array .)
    AND             reduce using rule 16 (expr -> array .)
    STRICT_OR       reduce using rule 16 (expr -> array .)
    OR              reduce using rule 16 (expr -> array .)
    EQUAL           reduce using rule 16 (expr -> array .)
    NOT_EQUAL       reduce using rule 16 (expr -> array .)
    >               reduce using rule 16 (expr -> array .)
    FLOAT_MUL       reduce using rule 16 (expr -> array .)
    FLOAT_DIV       reduce using rule 16 (expr -> array .)
    FLOAT_SUB       reduce using rule 16 (expr -> array .)
    FLOAT_SUM       reduce using rule 16 (expr -> array .)
    <               reduce using rule 16 (expr -> array .)
    *               reduce using rule 16 (expr -> array .)
    /               reduce using rule 16 (expr -> array .)
    -               reduce using rule 16 (expr -> array .)
    +               reduce using rule 16 (expr -> array .)
    CONCAT          reduce using rule 16 (expr -> array .)
    $end            reduce using rule 16 (expr -> array .)
    )               reduce using rule 16 (expr -> array .)
    OF              reduce using rule 16 (expr -> array .)
    THEN            reduce using rule 16 (expr -> array .)
    END             reduce using rule 16 (expr -> array .)
    ELIF            reduce using rule 16 (expr -> array .)
    ELSE            reduce using rule 16 (expr -> array .)
    ,               reduce using rule 16 (expr -> array .)
    ]               reduce using rule 16 (expr -> array .)


state 14

    (17) expr -> variant_call .
    NEWLINE         reduce using rule 17 (expr -> variant_call .)
    (               reduce using rule 17 (expr -> variant_call .)
    FLOAT_MORE      reduce using rule 17 (expr -> variant_call .)
    FLOAT_MORE_OR_EQ reduce using rule 17 (expr -> variant_call .)
    FLOAT_LESS      reduce using rule 17 (expr -> variant_call .)
    FLOAT_LESS_OR_EQ reduce using rule 17 (expr -> variant_call .)
    SOME_SUB        reduce using rule 17 (expr -> variant_call .)
    SOME_CONCAT     reduce using rule 17 (expr -> variant_call .)
    ARROW_BOTH      reduce using rule 17 (expr -> variant_call .)
    ARROW_RIGHT     reduce using rule 17 (expr -> variant_call .)
    ARROW_LEFT      reduce using rule 17 (expr -> variant_call .)
    DOUBLE_ARROW_RIGHT reduce using rule 17 (expr -> variant_call .)
    DOUBLE_ARROW_LEFT reduce using rule 17 (expr -> variant_call .)
    BIT_SHIFT_LEFT  reduce using rule 17 (expr -> variant_call .)
    BIT_AND         reduce using rule 17 (expr -> variant_call .)
    BIT_OR          reduce using rule 17 (expr -> variant_call .)
    FLOAT_POW       reduce using rule 17 (expr -> variant_call .)
    POW             reduce using rule 17 (expr -> variant_call .)
    ARRAY_SUB       reduce using rule 17 (expr -> variant_call .)
    ARRAY_CONCAT    reduce using rule 17 (expr -> variant_call .)
    MORE_OR_EQ      reduce using rule 17 (expr -> variant_call .)
    LESS_OR_EQ      reduce using rule 17 (expr -> variant_call .)
    TEXT_MATCH      reduce using rule 17 (expr -> variant_call .)
    STRICT_AND      reduce using rule 17 (expr -> variant_call .)
    AND             reduce using rule 17 (expr -> variant_call .)
    STRICT_OR       reduce using rule 17 (expr -> variant_call .)
    OR              reduce using rule 17 (expr -> variant_call .)
    EQUAL           reduce using rule 17 (expr -> variant_call .)
    NOT_EQUAL       reduce using rule 17 (expr -> variant_call .)
    >               reduce using rule 17 (expr -> variant_call .)
    FLOAT_MUL       reduce using rule 17 (expr -> variant_call .)
    FLOAT_DIV       reduce using rule 17 (expr -> variant_call .)
    FLOAT_SUB       reduce using rule 17 (expr -> variant_call .)
    FLOAT_SUM       reduce using rule 17 (expr -> variant_call .)
    <               reduce using rule 17 (expr -> variant_call .)
    *               reduce using rule 17 (expr -> variant_call .)
    /               reduce using rule 17 (expr -> variant_call .)
    -               reduce using rule 17 (expr -> variant_call .)
    +               reduce using rule 17 (expr -> variant_call .)
    CONCAT          reduce using rule 17 (expr -> variant_call .)
    $end            reduce using rule 17 (expr -> variant_call .)
    )               reduce using rule 17 (expr -> variant_call .)
    OF              reduce using rule 17 (expr -> variant_call .)
    THEN            reduce using rule 17 (expr -> variant_call .)
    END             reduce using rule 17 (expr -> variant_call .)
    ELIF            reduce using rule 17 (expr -> variant_call .)
    ELSE            reduce using rule 17 (expr -> variant_call .)
    ,               reduce using rule 17 (expr -> variant_call .)
    ]               reduce using rule 17 (expr -> variant_call .)


state 15

    (18) expr -> identifier .
    (268) let -> identifier . : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> identifier . _58_0x3a_type_optional = expr
    (275) _58_0x3a_type_optional -> . : type
    (276) _58_0x3a_type_optional -> .
    NEWLINE         reduce using rule 18 (expr -> identifier .)
    (               reduce using rule 18 (expr -> identifier .)
    FLOAT_MORE      reduce using rule 18 (expr -> identifier .)
    FLOAT_MORE_OR_EQ reduce using rule 18 (expr -> identifier .)
    FLOAT_LESS      reduce using rule 18 (expr -> identifier .)
    FLOAT_LESS_OR_EQ reduce using rule 18 (expr -> identifier .)
    SOME_SUB        reduce using rule 18 (expr -> identifier .)
    SOME_CONCAT     reduce using rule 18 (expr -> identifier .)
    ARROW_BOTH      reduce using rule 18 (expr -> identifier .)
    ARROW_RIGHT     reduce using rule 18 (expr -> identifier .)
    ARROW_LEFT      reduce using rule 18 (expr -> identifier .)
    DOUBLE_ARROW_RIGHT reduce using rule 18 (expr -> identifier .)
    DOUBLE_ARROW_LEFT reduce using rule 18 (expr -> identifier .)
    BIT_SHIFT_LEFT  reduce using rule 18 (expr -> identifier .)
    BIT_AND         reduce using rule 18 (expr -> identifier .)
    BIT_OR          reduce using rule 18 (expr -> identifier .)
    FLOAT_POW       reduce using rule 18 (expr -> identifier .)
    POW             reduce using rule 18 (expr -> identifier .)
    ARRAY_SUB       reduce using rule 18 (expr -> identifier .)
    ARRAY_CONCAT    reduce using rule 18 (expr -> identifier .)
    MORE_OR_EQ      reduce using rule 18 (expr -> identifier .)
    LESS_OR_EQ      reduce using rule 18 (expr -> identifier .)
    TEXT_MATCH      reduce using rule 18 (expr -> identifier .)
    STRICT_AND      reduce using rule 18 (expr -> identifier .)
    AND             reduce using rule 18 (expr -> identifier .)
    STRICT_OR       reduce using rule 18 (expr -> identifier .)
    OR              reduce using rule 18 (expr -> identifier .)
    EQUAL           reduce using rule 18 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 18 (expr -> identifier .)
    >               reduce using rule 18 (expr -> identifier .)
    FLOAT_MUL       reduce using rule 18 (expr -> identifier .)
    FLOAT_DIV       reduce using rule 18 (expr -> identifier .)
    FLOAT_SUB       reduce using rule 18 (expr -> identifier .)
    FLOAT_SUM       reduce using rule 18 (expr -> identifier .)
    <               reduce using rule 18 (expr -> identifier .)
    *               reduce using rule 18 (expr -> identifier .)
    /               reduce using rule 18 (expr -> identifier .)
    -               reduce using rule 18 (expr -> identifier .)
    +               reduce using rule 18 (expr -> identifier .)
    CONCAT          reduce using rule 18 (expr -> identifier .)
    $end            reduce using rule 18 (expr -> identifier .)
    )               reduce using rule 18 (expr -> identifier .)
    OF              reduce using rule 18 (expr -> identifier .)
    THEN            reduce using rule 18 (expr -> identifier .)
    END             reduce using rule 18 (expr -> identifier .)
    ELIF            reduce using rule 18 (expr -> identifier .)
    ELSE            reduce using rule 18 (expr -> identifier .)
    ,               reduce using rule 18 (expr -> identifier .)
    ]               reduce using rule 18 (expr -> identifier .)
    :               shift and go to state 83
    =               reduce using rule 276 (_58_0x3a_type_optional -> .)

    _58_0x3a_type_optional         shift and go to state 84

state 16

    (19) expr -> let .
    NEWLINE         reduce using rule 19 (expr -> let .)
    (               reduce using rule 19 (expr -> let .)
    FLOAT_MORE      reduce using rule 19 (expr -> let .)
    FLOAT_MORE_OR_EQ reduce using rule 19 (expr -> let .)
    FLOAT_LESS      reduce using rule 19 (expr -> let .)
    FLOAT_LESS_OR_EQ reduce using rule 19 (expr -> let .)
    SOME_SUB        reduce using rule 19 (expr -> let .)
    SOME_CONCAT     reduce using rule 19 (expr -> let .)
    ARROW_BOTH      reduce using rule 19 (expr -> let .)
    ARROW_RIGHT     reduce using rule 19 (expr -> let .)
    ARROW_LEFT      reduce using rule 19 (expr -> let .)
    DOUBLE_ARROW_RIGHT reduce using rule 19 (expr -> let .)
    DOUBLE_ARROW_LEFT reduce using rule 19 (expr -> let .)
    BIT_SHIFT_LEFT  reduce using rule 19 (expr -> let .)
    BIT_AND         reduce using rule 19 (expr -> let .)
    BIT_OR          reduce using rule 19 (expr -> let .)
    FLOAT_POW       reduce using rule 19 (expr -> let .)
    POW             reduce using rule 19 (expr -> let .)
    ARRAY_SUB       reduce using rule 19 (expr -> let .)
    ARRAY_CONCAT    reduce using rule 19 (expr -> let .)
    MORE_OR_EQ      reduce using rule 19 (expr -> let .)
    LESS_OR_EQ      reduce using rule 19 (expr -> let .)
    TEXT_MATCH      reduce using rule 19 (expr -> let .)
    STRICT_AND      reduce using rule 19 (expr -> let .)
    AND             reduce using rule 19 (expr -> let .)
    STRICT_OR       reduce using rule 19 (expr -> let .)
    OR              reduce using rule 19 (expr -> let .)
    EQUAL           reduce using rule 19 (expr -> let .)
    NOT_EQUAL       reduce using rule 19 (expr -> let .)
    >               reduce using rule 19 (expr -> let .)
    FLOAT_MUL       reduce using rule 19 (expr -> let .)
    FLOAT_DIV       reduce using rule 19 (expr -> let .)
    FLOAT_SUB       reduce using rule 19 (expr -> let .)
    FLOAT_SUM       reduce using rule 19 (expr -> let .)
    <               reduce using rule 19 (expr -> let .)
    *               reduce using rule 19 (expr -> let .)
    /               reduce using rule 19 (expr -> let .)
    -               reduce using rule 19 (expr -> let .)
    +               reduce using rule 19 (expr -> let .)
    CONCAT          reduce using rule 19 (expr -> let .)
    $end            reduce using rule 19 (expr -> let .)
    )               reduce using rule 19 (expr -> let .)
    OF              reduce using rule 19 (expr -> let .)
    THEN            reduce using rule 19 (expr -> let .)
    END             reduce using rule 19 (expr -> let .)
    ELIF            reduce using rule 19 (expr -> let .)
    ELSE            reduce using rule 19 (expr -> let .)
    ,               reduce using rule 19 (expr -> let .)
    ]               reduce using rule 19 (expr -> let .)


state 17

    (20) expr -> call .
    NEWLINE         reduce using rule 20 (expr -> call .)
    (               reduce using rule 20 (expr -> call .)
    FLOAT_MORE      reduce using rule 20 (expr -> call .)
    FLOAT_MORE_OR_EQ reduce using rule 20 (expr -> call .)
    FLOAT_LESS      reduce using rule 20 (expr -> call .)
    FLOAT_LESS_OR_EQ reduce using rule 20 (expr -> call .)
    SOME_SUB        reduce using rule 20 (expr -> call .)
    SOME_CONCAT     reduce using rule 20 (expr -> call .)
    ARROW_BOTH      reduce using rule 20 (expr -> call .)
    ARROW_RIGHT     reduce using rule 20 (expr -> call .)
    ARROW_LEFT      reduce using rule 20 (expr -> call .)
    DOUBLE_ARROW_RIGHT reduce using rule 20 (expr -> call .)
    DOUBLE_ARROW_LEFT reduce using rule 20 (expr -> call .)
    BIT_SHIFT_LEFT  reduce using rule 20 (expr -> call .)
    BIT_AND         reduce using rule 20 (expr -> call .)
    BIT_OR          reduce using rule 20 (expr -> call .)
    FLOAT_POW       reduce using rule 20 (expr -> call .)
    POW             reduce using rule 20 (expr -> call .)
    ARRAY_SUB       reduce using rule 20 (expr -> call .)
    ARRAY_CONCAT    reduce using rule 20 (expr -> call .)
    MORE_OR_EQ      reduce using rule 20 (expr -> call .)
    LESS_OR_EQ      reduce using rule 20 (expr -> call .)
    TEXT_MATCH      reduce using rule 20 (expr -> call .)
    STRICT_AND      reduce using rule 20 (expr -> call .)
    AND             reduce using rule 20 (expr -> call .)
    STRICT_OR       reduce using rule 20 (expr -> call .)
    OR              reduce using rule 20 (expr -> call .)
    EQUAL           reduce using rule 20 (expr -> call .)
    NOT_EQUAL       reduce using rule 20 (expr -> call .)
    >               reduce using rule 20 (expr -> call .)
    FLOAT_MUL       reduce using rule 20 (expr -> call .)
    FLOAT_DIV       reduce using rule 20 (expr -> call .)
    FLOAT_SUB       reduce using rule 20 (expr -> call .)
    FLOAT_SUM       reduce using rule 20 (expr -> call .)
    <               reduce using rule 20 (expr -> call .)
    *               reduce using rule 20 (expr -> call .)
    /               reduce using rule 20 (expr -> call .)
    -               reduce using rule 20 (expr -> call .)
    +               reduce using rule 20 (expr -> call .)
    CONCAT          reduce using rule 20 (expr -> call .)
    $end            reduce using rule 20 (expr -> call .)
    )               reduce using rule 20 (expr -> call .)
    OF              reduce using rule 20 (expr -> call .)
    THEN            reduce using rule 20 (expr -> call .)
    END             reduce using rule 20 (expr -> call .)
    ELIF            reduce using rule 20 (expr -> call .)
    ELSE            reduce using rule 20 (expr -> call .)
    ,               reduce using rule 20 (expr -> call .)
    ]               reduce using rule 20 (expr -> call .)


state 18

    (21) expr -> case_of .
    NEWLINE         reduce using rule 21 (expr -> case_of .)
    (               reduce using rule 21 (expr -> case_of .)
    FLOAT_MORE      reduce using rule 21 (expr -> case_of .)
    FLOAT_MORE_OR_EQ reduce using rule 21 (expr -> case_of .)
    FLOAT_LESS      reduce using rule 21 (expr -> case_of .)
    FLOAT_LESS_OR_EQ reduce using rule 21 (expr -> case_of .)
    SOME_SUB        reduce using rule 21 (expr -> case_of .)
    SOME_CONCAT     reduce using rule 21 (expr -> case_of .)
    ARROW_BOTH      reduce using rule 21 (expr -> case_of .)
    ARROW_RIGHT     reduce using rule 21 (expr -> case_of .)
    ARROW_LEFT      reduce using rule 21 (expr -> case_of .)
    DOUBLE_ARROW_RIGHT reduce using rule 21 (expr -> case_of .)
    DOUBLE_ARROW_LEFT reduce using rule 21 (expr -> case_of .)
    BIT_SHIFT_LEFT  reduce using rule 21 (expr -> case_of .)
    BIT_AND         reduce using rule 21 (expr -> case_of .)
    BIT_OR          reduce using rule 21 (expr -> case_of .)
    FLOAT_POW       reduce using rule 21 (expr -> case_of .)
    POW             reduce using rule 21 (expr -> case_of .)
    ARRAY_SUB       reduce using rule 21 (expr -> case_of .)
    ARRAY_CONCAT    reduce using rule 21 (expr -> case_of .)
    MORE_OR_EQ      reduce using rule 21 (expr -> case_of .)
    LESS_OR_EQ      reduce using rule 21 (expr -> case_of .)
    TEXT_MATCH      reduce using rule 21 (expr -> case_of .)
    STRICT_AND      reduce using rule 21 (expr -> case_of .)
    AND             reduce using rule 21 (expr -> case_of .)
    STRICT_OR       reduce using rule 21 (expr -> case_of .)
    OR              reduce using rule 21 (expr -> case_of .)
    EQUAL           reduce using rule 21 (expr -> case_of .)
    NOT_EQUAL       reduce using rule 21 (expr -> case_of .)
    >               reduce using rule 21 (expr -> case_of .)
    FLOAT_MUL       reduce using rule 21 (expr -> case_of .)
    FLOAT_DIV       reduce using rule 21 (expr -> case_of .)
    FLOAT_SUB       reduce using rule 21 (expr -> case_of .)
    FLOAT_SUM       reduce using rule 21 (expr -> case_of .)
    <               reduce using rule 21 (expr -> case_of .)
    *               reduce using rule 21 (expr -> case_of .)
    /               reduce using rule 21 (expr -> case_of .)
    -               reduce using rule 21 (expr -> case_of .)
    +               reduce using rule 21 (expr -> case_of .)
    CONCAT          reduce using rule 21 (expr -> case_of .)
    $end            reduce using rule 21 (expr -> case_of .)
    )               reduce using rule 21 (expr -> case_of .)
    OF              reduce using rule 21 (expr -> case_of .)
    THEN            reduce using rule 21 (expr -> case_of .)
    END             reduce using rule 21 (expr -> case_of .)
    ELIF            reduce using rule 21 (expr -> case_of .)
    ELSE            reduce using rule 21 (expr -> case_of .)
    ,               reduce using rule 21 (expr -> case_of .)
    ]               reduce using rule 21 (expr -> case_of .)


state 19

    (22) expr -> binary_expr .
    NEWLINE         reduce using rule 22 (expr -> binary_expr .)
    (               reduce using rule 22 (expr -> binary_expr .)
    FLOAT_MORE      reduce using rule 22 (expr -> binary_expr .)
    FLOAT_MORE_OR_EQ reduce using rule 22 (expr -> binary_expr .)
    FLOAT_LESS      reduce using rule 22 (expr -> binary_expr .)
    FLOAT_LESS_OR_EQ reduce using rule 22 (expr -> binary_expr .)
    SOME_SUB        reduce using rule 22 (expr -> binary_expr .)
    SOME_CONCAT     reduce using rule 22 (expr -> binary_expr .)
    ARROW_BOTH      reduce using rule 22 (expr -> binary_expr .)
    ARROW_RIGHT     reduce using rule 22 (expr -> binary_expr .)
    ARROW_LEFT      reduce using rule 22 (expr -> binary_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 22 (expr -> binary_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 22 (expr -> binary_expr .)
    BIT_SHIFT_LEFT  reduce using rule 22 (expr -> binary_expr .)
    BIT_AND         reduce using rule 22 (expr -> binary_expr .)
    BIT_OR          reduce using rule 22 (expr -> binary_expr .)
    FLOAT_POW       reduce using rule 22 (expr -> binary_expr .)
    POW             reduce using rule 22 (expr -> binary_expr .)
    ARRAY_SUB       reduce using rule 22 (expr -> binary_expr .)
    ARRAY_CONCAT    reduce using rule 22 (expr -> binary_expr .)
    MORE_OR_EQ      reduce using rule 22 (expr -> binary_expr .)
    LESS_OR_EQ      reduce using rule 22 (expr -> binary_expr .)
    TEXT_MATCH      reduce using rule 22 (expr -> binary_expr .)
    STRICT_AND      reduce using rule 22 (expr -> binary_expr .)
    AND             reduce using rule 22 (expr -> binary_expr .)
    STRICT_OR       reduce using rule 22 (expr -> binary_expr .)
    OR              reduce using rule 22 (expr -> binary_expr .)
    EQUAL           reduce using rule 22 (expr -> binary_expr .)
    NOT_EQUAL       reduce using rule 22 (expr -> binary_expr .)
    >               reduce using rule 22 (expr -> binary_expr .)
    FLOAT_MUL       reduce using rule 22 (expr -> binary_expr .)
    FLOAT_DIV       reduce using rule 22 (expr -> binary_expr .)
    FLOAT_SUB       reduce using rule 22 (expr -> binary_expr .)
    FLOAT_SUM       reduce using rule 22 (expr -> binary_expr .)
    <               reduce using rule 22 (expr -> binary_expr .)
    *               reduce using rule 22 (expr -> binary_expr .)
    /               reduce using rule 22 (expr -> binary_expr .)
    -               reduce using rule 22 (expr -> binary_expr .)
    +               reduce using rule 22 (expr -> binary_expr .)
    CONCAT          reduce using rule 22 (expr -> binary_expr .)
    $end            reduce using rule 22 (expr -> binary_expr .)
    )               reduce using rule 22 (expr -> binary_expr .)
    OF              reduce using rule 22 (expr -> binary_expr .)
    THEN            reduce using rule 22 (expr -> binary_expr .)
    END             reduce using rule 22 (expr -> binary_expr .)
    ELIF            reduce using rule 22 (expr -> binary_expr .)
    ELSE            reduce using rule 22 (expr -> binary_expr .)
    ,               reduce using rule 22 (expr -> binary_expr .)
    ]               reduce using rule 22 (expr -> binary_expr .)


state 20

    (23) expr -> if_expr .
    NEWLINE         reduce using rule 23 (expr -> if_expr .)
    (               reduce using rule 23 (expr -> if_expr .)
    FLOAT_MORE      reduce using rule 23 (expr -> if_expr .)
    FLOAT_MORE_OR_EQ reduce using rule 23 (expr -> if_expr .)
    FLOAT_LESS      reduce using rule 23 (expr -> if_expr .)
    FLOAT_LESS_OR_EQ reduce using rule 23 (expr -> if_expr .)
    SOME_SUB        reduce using rule 23 (expr -> if_expr .)
    SOME_CONCAT     reduce using rule 23 (expr -> if_expr .)
    ARROW_BOTH      reduce using rule 23 (expr -> if_expr .)
    ARROW_RIGHT     reduce using rule 23 (expr -> if_expr .)
    ARROW_LEFT      reduce using rule 23 (expr -> if_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 23 (expr -> if_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 23 (expr -> if_expr .)
    BIT_SHIFT_LEFT  reduce using rule 23 (expr -> if_expr .)
    BIT_AND         reduce using rule 23 (expr -> if_expr .)
    BIT_OR          reduce using rule 23 (expr -> if_expr .)
    FLOAT_POW       reduce using rule 23 (expr -> if_expr .)
    POW             reduce using rule 23 (expr -> if_expr .)
    ARRAY_SUB       reduce using rule 23 (expr -> if_expr .)
    ARRAY_CONCAT    reduce using rule 23 (expr -> if_expr .)
    MORE_OR_EQ      reduce using rule 23 (expr -> if_expr .)
    LESS_OR_EQ      reduce using rule 23 (expr -> if_expr .)
    TEXT_MATCH      reduce using rule 23 (expr -> if_expr .)
    STRICT_AND      reduce using rule 23 (expr -> if_expr .)
    AND             reduce using rule 23 (expr -> if_expr .)
    STRICT_OR       reduce using rule 23 (expr -> if_expr .)
    OR              reduce using rule 23 (expr -> if_expr .)
    EQUAL           reduce using rule 23 (expr -> if_expr .)
    NOT_EQUAL       reduce using rule 23 (expr -> if_expr .)
    >               reduce using rule 23 (expr -> if_expr .)
    FLOAT_MUL       reduce using rule 23 (expr -> if_expr .)
    FLOAT_DIV       reduce using rule 23 (expr -> if_expr .)
    FLOAT_SUB       reduce using rule 23 (expr -> if_expr .)
    FLOAT_SUM       reduce using rule 23 (expr -> if_expr .)
    <               reduce using rule 23 (expr -> if_expr .)
    *               reduce using rule 23 (expr -> if_expr .)
    /               reduce using rule 23 (expr -> if_expr .)
    -               reduce using rule 23 (expr -> if_expr .)
    +               reduce using rule 23 (expr -> if_expr .)
    CONCAT          reduce using rule 23 (expr -> if_expr .)
    $end            reduce using rule 23 (expr -> if_expr .)
    )               reduce using rule 23 (expr -> if_expr .)
    OF              reduce using rule 23 (expr -> if_expr .)
    THEN            reduce using rule 23 (expr -> if_expr .)
    END             reduce using rule 23 (expr -> if_expr .)
    ELIF            reduce using rule 23 (expr -> if_expr .)
    ELSE            reduce using rule 23 (expr -> if_expr .)
    ,               reduce using rule 23 (expr -> if_expr .)
    ]               reduce using rule 23 (expr -> if_expr .)


state 21

    (24) expr -> def_expr .
    NEWLINE         reduce using rule 24 (expr -> def_expr .)
    (               reduce using rule 24 (expr -> def_expr .)
    FLOAT_MORE      reduce using rule 24 (expr -> def_expr .)
    FLOAT_MORE_OR_EQ reduce using rule 24 (expr -> def_expr .)
    FLOAT_LESS      reduce using rule 24 (expr -> def_expr .)
    FLOAT_LESS_OR_EQ reduce using rule 24 (expr -> def_expr .)
    SOME_SUB        reduce using rule 24 (expr -> def_expr .)
    SOME_CONCAT     reduce using rule 24 (expr -> def_expr .)
    ARROW_BOTH      reduce using rule 24 (expr -> def_expr .)
    ARROW_RIGHT     reduce using rule 24 (expr -> def_expr .)
    ARROW_LEFT      reduce using rule 24 (expr -> def_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 24 (expr -> def_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 24 (expr -> def_expr .)
    BIT_SHIFT_LEFT  reduce using rule 24 (expr -> def_expr .)
    BIT_AND         reduce using rule 24 (expr -> def_expr .)
    BIT_OR          reduce using rule 24 (expr -> def_expr .)
    FLOAT_POW       reduce using rule 24 (expr -> def_expr .)
    POW             reduce using rule 24 (expr -> def_expr .)
    ARRAY_SUB       reduce using rule 24 (expr -> def_expr .)
    ARRAY_CONCAT    reduce using rule 24 (expr -> def_expr .)
    MORE_OR_EQ      reduce using rule 24 (expr -> def_expr .)
    LESS_OR_EQ      reduce using rule 24 (expr -> def_expr .)
    TEXT_MATCH      reduce using rule 24 (expr -> def_expr .)
    STRICT_AND      reduce using rule 24 (expr -> def_expr .)
    AND             reduce using rule 24 (expr -> def_expr .)
    STRICT_OR       reduce using rule 24 (expr -> def_expr .)
    OR              reduce using rule 24 (expr -> def_expr .)
    EQUAL           reduce using rule 24 (expr -> def_expr .)
    NOT_EQUAL       reduce using rule 24 (expr -> def_expr .)
    >               reduce using rule 24 (expr -> def_expr .)
    FLOAT_MUL       reduce using rule 24 (expr -> def_expr .)
    FLOAT_DIV       reduce using rule 24 (expr -> def_expr .)
    FLOAT_SUB       reduce using rule 24 (expr -> def_expr .)
    FLOAT_SUM       reduce using rule 24 (expr -> def_expr .)
    <               reduce using rule 24 (expr -> def_expr .)
    *               reduce using rule 24 (expr -> def_expr .)
    /               reduce using rule 24 (expr -> def_expr .)
    -               reduce using rule 24 (expr -> def_expr .)
    +               reduce using rule 24 (expr -> def_expr .)
    CONCAT          reduce using rule 24 (expr -> def_expr .)
    $end            reduce using rule 24 (expr -> def_expr .)
    )               reduce using rule 24 (expr -> def_expr .)
    OF              reduce using rule 24 (expr -> def_expr .)
    THEN            reduce using rule 24 (expr -> def_expr .)
    END             reduce using rule 24 (expr -> def_expr .)
    ELIF            reduce using rule 24 (expr -> def_expr .)
    ELSE            reduce using rule 24 (expr -> def_expr .)
    ,               reduce using rule 24 (expr -> def_expr .)
    ]               reduce using rule 24 (expr -> def_expr .)


state 22

    (25) expr -> do .
    NEWLINE         reduce using rule 25 (expr -> do .)
    (               reduce using rule 25 (expr -> do .)
    FLOAT_MORE      reduce using rule 25 (expr -> do .)
    FLOAT_MORE_OR_EQ reduce using rule 25 (expr -> do .)
    FLOAT_LESS      reduce using rule 25 (expr -> do .)
    FLOAT_LESS_OR_EQ reduce using rule 25 (expr -> do .)
    SOME_SUB        reduce using rule 25 (expr -> do .)
    SOME_CONCAT     reduce using rule 25 (expr -> do .)
    ARROW_BOTH      reduce using rule 25 (expr -> do .)
    ARROW_RIGHT     reduce using rule 25 (expr -> do .)
    ARROW_LEFT      reduce using rule 25 (expr -> do .)
    DOUBLE_ARROW_RIGHT reduce using rule 25 (expr -> do .)
    DOUBLE_ARROW_LEFT reduce using rule 25 (expr -> do .)
    BIT_SHIFT_LEFT  reduce using rule 25 (expr -> do .)
    BIT_AND         reduce using rule 25 (expr -> do .)
    BIT_OR          reduce using rule 25 (expr -> do .)
    FLOAT_POW       reduce using rule 25 (expr -> do .)
    POW             reduce using rule 25 (expr -> do .)
    ARRAY_SUB       reduce using rule 25 (expr -> do .)
    ARRAY_CONCAT    reduce using rule 25 (expr -> do .)
    MORE_OR_EQ      reduce using rule 25 (expr -> do .)
    LESS_OR_EQ      reduce using rule 25 (expr -> do .)
    TEXT_MATCH      reduce using rule 25 (expr -> do .)
    STRICT_AND      reduce using rule 25 (expr -> do .)
    AND             reduce using rule 25 (expr -> do .)
    STRICT_OR       reduce using rule 25 (expr -> do .)
    OR              reduce using rule 25 (expr -> do .)
    EQUAL           reduce using rule 25 (expr -> do .)
    NOT_EQUAL       reduce using rule 25 (expr -> do .)
    >               reduce using rule 25 (expr -> do .)
    FLOAT_MUL       reduce using rule 25 (expr -> do .)
    FLOAT_DIV       reduce using rule 25 (expr -> do .)
    FLOAT_SUB       reduce using rule 25 (expr -> do .)
    FLOAT_SUM       reduce using rule 25 (expr -> do .)
    <               reduce using rule 25 (expr -> do .)
    *               reduce using rule 25 (expr -> do .)
    /               reduce using rule 25 (expr -> do .)
    -               reduce using rule 25 (expr -> do .)
    +               reduce using rule 25 (expr -> do .)
    CONCAT          reduce using rule 25 (expr -> do .)
    $end            reduce using rule 25 (expr -> do .)
    )               reduce using rule 25 (expr -> do .)
    OF              reduce using rule 25 (expr -> do .)
    THEN            reduce using rule 25 (expr -> do .)
    END             reduce using rule 25 (expr -> do .)
    ELIF            reduce using rule 25 (expr -> do .)
    ELSE            reduce using rule 25 (expr -> do .)
    ,               reduce using rule 25 (expr -> do .)
    ]               reduce using rule 25 (expr -> do .)


state 23

    (26) expr -> external .
    NEWLINE         reduce using rule 26 (expr -> external .)
    (               reduce using rule 26 (expr -> external .)
    FLOAT_MORE      reduce using rule 26 (expr -> external .)
    FLOAT_MORE_OR_EQ reduce using rule 26 (expr -> external .)
    FLOAT_LESS      reduce using rule 26 (expr -> external .)
    FLOAT_LESS_OR_EQ reduce using rule 26 (expr -> external .)
    SOME_SUB        reduce using rule 26 (expr -> external .)
    SOME_CONCAT     reduce using rule 26 (expr -> external .)
    ARROW_BOTH      reduce using rule 26 (expr -> external .)
    ARROW_RIGHT     reduce using rule 26 (expr -> external .)
    ARROW_LEFT      reduce using rule 26 (expr -> external .)
    DOUBLE_ARROW_RIGHT reduce using rule 26 (expr -> external .)
    DOUBLE_ARROW_LEFT reduce using rule 26 (expr -> external .)
    BIT_SHIFT_LEFT  reduce using rule 26 (expr -> external .)
    BIT_AND         reduce using rule 26 (expr -> external .)
    BIT_OR          reduce using rule 26 (expr -> external .)
    FLOAT_POW       reduce using rule 26 (expr -> external .)
    POW             reduce using rule 26 (expr -> external .)
    ARRAY_SUB       reduce using rule 26 (expr -> external .)
    ARRAY_CONCAT    reduce using rule 26 (expr -> external .)
    MORE_OR_EQ      reduce using rule 26 (expr -> external .)
    LESS_OR_EQ      reduce using rule 26 (expr -> external .)
    TEXT_MATCH      reduce using rule 26 (expr -> external .)
    STRICT_AND      reduce using rule 26 (expr -> external .)
    AND             reduce using rule 26 (expr -> external .)
    STRICT_OR       reduce using rule 26 (expr -> external .)
    OR              reduce using rule 26 (expr -> external .)
    EQUAL           reduce using rule 26 (expr -> external .)
    NOT_EQUAL       reduce using rule 26 (expr -> external .)
    >               reduce using rule 26 (expr -> external .)
    FLOAT_MUL       reduce using rule 26 (expr -> external .)
    FLOAT_DIV       reduce using rule 26 (expr -> external .)
    FLOAT_SUB       reduce using rule 26 (expr -> external .)
    FLOAT_SUM       reduce using rule 26 (expr -> external .)
    <               reduce using rule 26 (expr -> external .)
    *               reduce using rule 26 (expr -> external .)
    /               reduce using rule 26 (expr -> external .)
    -               reduce using rule 26 (expr -> external .)
    +               reduce using rule 26 (expr -> external .)
    CONCAT          reduce using rule 26 (expr -> external .)
    $end            reduce using rule 26 (expr -> external .)
    )               reduce using rule 26 (expr -> external .)
    OF              reduce using rule 26 (expr -> external .)
    THEN            reduce using rule 26 (expr -> external .)
    END             reduce using rule 26 (expr -> external .)
    ELIF            reduce using rule 26 (expr -> external .)
    ELSE            reduce using rule 26 (expr -> external .)
    ,               reduce using rule 26 (expr -> external .)
    ]               reduce using rule 26 (expr -> external .)


state 24

    (27) expr -> enum .
    NEWLINE         reduce using rule 27 (expr -> enum .)
    (               reduce using rule 27 (expr -> enum .)
    FLOAT_MORE      reduce using rule 27 (expr -> enum .)
    FLOAT_MORE_OR_EQ reduce using rule 27 (expr -> enum .)
    FLOAT_LESS      reduce using rule 27 (expr -> enum .)
    FLOAT_LESS_OR_EQ reduce using rule 27 (expr -> enum .)
    SOME_SUB        reduce using rule 27 (expr -> enum .)
    SOME_CONCAT     reduce using rule 27 (expr -> enum .)
    ARROW_BOTH      reduce using rule 27 (expr -> enum .)
    ARROW_RIGHT     reduce using rule 27 (expr -> enum .)
    ARROW_LEFT      reduce using rule 27 (expr -> enum .)
    DOUBLE_ARROW_RIGHT reduce using rule 27 (expr -> enum .)
    DOUBLE_ARROW_LEFT reduce using rule 27 (expr -> enum .)
    BIT_SHIFT_LEFT  reduce using rule 27 (expr -> enum .)
    BIT_AND         reduce using rule 27 (expr -> enum .)
    BIT_OR          reduce using rule 27 (expr -> enum .)
    FLOAT_POW       reduce using rule 27 (expr -> enum .)
    POW             reduce using rule 27 (expr -> enum .)
    ARRAY_SUB       reduce using rule 27 (expr -> enum .)
    ARRAY_CONCAT    reduce using rule 27 (expr -> enum .)
    MORE_OR_EQ      reduce using rule 27 (expr -> enum .)
    LESS_OR_EQ      reduce using rule 27 (expr -> enum .)
    TEXT_MATCH      reduce using rule 27 (expr -> enum .)
    STRICT_AND      reduce using rule 27 (expr -> enum .)
    AND             reduce using rule 27 (expr -> enum .)
    STRICT_OR       reduce using rule 27 (expr -> enum .)
    OR              reduce using rule 27 (expr -> enum .)
    EQUAL           reduce using rule 27 (expr -> enum .)
    NOT_EQUAL       reduce using rule 27 (expr -> enum .)
    >               reduce using rule 27 (expr -> enum .)
    FLOAT_MUL       reduce using rule 27 (expr -> enum .)
    FLOAT_DIV       reduce using rule 27 (expr -> enum .)
    FLOAT_SUB       reduce using rule 27 (expr -> enum .)
    FLOAT_SUM       reduce using rule 27 (expr -> enum .)
    <               reduce using rule 27 (expr -> enum .)
    *               reduce using rule 27 (expr -> enum .)
    /               reduce using rule 27 (expr -> enum .)
    -               reduce using rule 27 (expr -> enum .)
    +               reduce using rule 27 (expr -> enum .)
    CONCAT          reduce using rule 27 (expr -> enum .)
    $end            reduce using rule 27 (expr -> enum .)
    )               reduce using rule 27 (expr -> enum .)
    OF              reduce using rule 27 (expr -> enum .)
    THEN            reduce using rule 27 (expr -> enum .)
    END             reduce using rule 27 (expr -> enum .)
    ELIF            reduce using rule 27 (expr -> enum .)
    ELSE            reduce using rule 27 (expr -> enum .)
    ,               reduce using rule 27 (expr -> enum .)
    ]               reduce using rule 27 (expr -> enum .)


state 25

    (109) binary_op_def -> DEF . binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> DEF . binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (140) def_expr -> DEF . identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> DEF . identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (71) binary_op -> . FLOAT_MORE
    (72) binary_op -> . FLOAT_MORE_OR_EQ
    (73) binary_op -> . FLOAT_LESS
    (74) binary_op -> . FLOAT_LESS_OR_EQ
    (75) binary_op -> . SOME_SUB
    (76) binary_op -> . SOME_CONCAT
    (77) binary_op -> . ARROW_BOTH
    (78) binary_op -> . ARROW_RIGHT
    (79) binary_op -> . ARROW_LEFT
    (80) binary_op -> . DOUBLE_ARROW_RIGHT
    (81) binary_op -> . DOUBLE_ARROW_LEFT
    (82) binary_op -> . BIT_SHIFT_LEFT
    (83) binary_op -> . BIT_AND
    (84) binary_op -> . BIT_OR
    (85) binary_op -> . FLOAT_POW
    (86) binary_op -> . POW
    (87) binary_op -> . ARRAY_SUB
    (88) binary_op -> . ARRAY_CONCAT
    (89) binary_op -> . MORE_OR_EQ
    (90) binary_op -> . LESS_OR_EQ
    (91) binary_op -> . TEXT_MATCH
    (92) binary_op -> . STRICT_AND
    (93) binary_op -> . AND
    (94) binary_op -> . STRICT_OR
    (95) binary_op -> . OR
    (96) binary_op -> . EQUAL
    (97) binary_op -> . NOT_EQUAL
    (98) binary_op -> . >
    (99) binary_op -> . FLOAT_MUL
    (100) binary_op -> . FLOAT_DIV
    (101) binary_op -> . FLOAT_SUB
    (102) binary_op -> . FLOAT_SUM
    (103) binary_op -> . <
    (104) binary_op -> . *
    (105) binary_op -> . /
    (106) binary_op -> . -
    (107) binary_op -> . +
    (108) binary_op -> . CONCAT
    (265) identifier -> . IDENTIFIER
    FLOAT_MORE      shift and go to state 89
    FLOAT_MORE_OR_EQ shift and go to state 90
    FLOAT_LESS      shift and go to state 91
    FLOAT_LESS_OR_EQ shift and go to state 92
    SOME_SUB        shift and go to state 93
    SOME_CONCAT     shift and go to state 94
    ARROW_BOTH      shift and go to state 95
    ARROW_RIGHT     shift and go to state 96
    ARROW_LEFT      shift and go to state 97
    DOUBLE_ARROW_RIGHT shift and go to state 98
    DOUBLE_ARROW_LEFT shift and go to state 99
    BIT_SHIFT_LEFT  shift and go to state 100
    BIT_AND         shift and go to state 101
    BIT_OR          shift and go to state 102
    FLOAT_POW       shift and go to state 103
    POW             shift and go to state 104
    ARRAY_SUB       shift and go to state 105
    ARRAY_CONCAT    shift and go to state 106
    MORE_OR_EQ      shift and go to state 107
    LESS_OR_EQ      shift and go to state 108
    TEXT_MATCH      shift and go to state 109
    STRICT_AND      shift and go to state 110
    AND             shift and go to state 111
    STRICT_OR       shift and go to state 112
    OR              shift and go to state 113
    EQUAL           shift and go to state 114
    NOT_EQUAL       shift and go to state 115
    >               shift and go to state 87
    FLOAT_MUL       shift and go to state 116
    FLOAT_DIV       shift and go to state 117
    FLOAT_SUB       shift and go to state 118
    FLOAT_SUM       shift and go to state 119
    <               shift and go to state 86
    *               shift and go to state 120
    /               shift and go to state 121
    -               shift and go to state 122
    +               shift and go to state 123
    CONCAT          shift and go to state 124
    IDENTIFIER      shift and go to state 35

    binary_op                      shift and go to state 85
    identifier                     shift and go to state 88

state 26

    (28) unary_expr -> + . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 125
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 27

    (29) unary_expr -> ! . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 126
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 28

    (30) unary_expr -> STRICT_NOT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 127
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 29

    (31) unary_expr -> - . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 128
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 30

    (279) str_literal -> STRING .
    NEWLINE         reduce using rule 279 (str_literal -> STRING .)
    (               reduce using rule 279 (str_literal -> STRING .)
    FLOAT_MORE      reduce using rule 279 (str_literal -> STRING .)
    FLOAT_MORE_OR_EQ reduce using rule 279 (str_literal -> STRING .)
    FLOAT_LESS      reduce using rule 279 (str_literal -> STRING .)
    FLOAT_LESS_OR_EQ reduce using rule 279 (str_literal -> STRING .)
    SOME_SUB        reduce using rule 279 (str_literal -> STRING .)
    SOME_CONCAT     reduce using rule 279 (str_literal -> STRING .)
    ARROW_BOTH      reduce using rule 279 (str_literal -> STRING .)
    ARROW_RIGHT     reduce using rule 279 (str_literal -> STRING .)
    ARROW_LEFT      reduce using rule 279 (str_literal -> STRING .)
    DOUBLE_ARROW_RIGHT reduce using rule 279 (str_literal -> STRING .)
    DOUBLE_ARROW_LEFT reduce using rule 279 (str_literal -> STRING .)
    BIT_SHIFT_LEFT  reduce using rule 279 (str_literal -> STRING .)
    BIT_AND         reduce using rule 279 (str_literal -> STRING .)
    BIT_OR          reduce using rule 279 (str_literal -> STRING .)
    FLOAT_POW       reduce using rule 279 (str_literal -> STRING .)
    POW             reduce using rule 279 (str_literal -> STRING .)
    ARRAY_SUB       reduce using rule 279 (str_literal -> STRING .)
    ARRAY_CONCAT    reduce using rule 279 (str_literal -> STRING .)
    MORE_OR_EQ      reduce using rule 279 (str_literal -> STRING .)
    LESS_OR_EQ      reduce using rule 279 (str_literal -> STRING .)
    TEXT_MATCH      reduce using rule 279 (str_literal -> STRING .)
    STRICT_AND      reduce using rule 279 (str_literal -> STRING .)
    AND             reduce using rule 279 (str_literal -> STRING .)
    STRICT_OR       reduce using rule 279 (str_literal -> STRING .)
    OR              reduce using rule 279 (str_literal -> STRING .)
    EQUAL           reduce using rule 279 (str_literal -> STRING .)
    NOT_EQUAL       reduce using rule 279 (str_literal -> STRING .)
    >               reduce using rule 279 (str_literal -> STRING .)
    FLOAT_MUL       reduce using rule 279 (str_literal -> STRING .)
    FLOAT_DIV       reduce using rule 279 (str_literal -> STRING .)
    FLOAT_SUB       reduce using rule 279 (str_literal -> STRING .)
    FLOAT_SUM       reduce using rule 279 (str_literal -> STRING .)
    <               reduce using rule 279 (str_literal -> STRING .)
    *               reduce using rule 279 (str_literal -> STRING .)
    /               reduce using rule 279 (str_literal -> STRING .)
    -               reduce using rule 279 (str_literal -> STRING .)
    +               reduce using rule 279 (str_literal -> STRING .)
    CONCAT          reduce using rule 279 (str_literal -> STRING .)
    $end            reduce using rule 279 (str_literal -> STRING .)
    )               reduce using rule 279 (str_literal -> STRING .)
    OF              reduce using rule 279 (str_literal -> STRING .)
    THEN            reduce using rule 279 (str_literal -> STRING .)
    END             reduce using rule 279 (str_literal -> STRING .)
    ELIF            reduce using rule 279 (str_literal -> STRING .)
    ELSE            reduce using rule 279 (str_literal -> STRING .)
    ,               reduce using rule 279 (str_literal -> STRING .)
    ]               reduce using rule 279 (str_literal -> STRING .)


state 31

    (278) float_literal -> FLOAT .
    NEWLINE         reduce using rule 278 (float_literal -> FLOAT .)
    (               reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_MORE      reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_MORE_OR_EQ reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_LESS      reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_LESS_OR_EQ reduce using rule 278 (float_literal -> FLOAT .)
    SOME_SUB        reduce using rule 278 (float_literal -> FLOAT .)
    SOME_CONCAT     reduce using rule 278 (float_literal -> FLOAT .)
    ARROW_BOTH      reduce using rule 278 (float_literal -> FLOAT .)
    ARROW_RIGHT     reduce using rule 278 (float_literal -> FLOAT .)
    ARROW_LEFT      reduce using rule 278 (float_literal -> FLOAT .)
    DOUBLE_ARROW_RIGHT reduce using rule 278 (float_literal -> FLOAT .)
    DOUBLE_ARROW_LEFT reduce using rule 278 (float_literal -> FLOAT .)
    BIT_SHIFT_LEFT  reduce using rule 278 (float_literal -> FLOAT .)
    BIT_AND         reduce using rule 278 (float_literal -> FLOAT .)
    BIT_OR          reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_POW       reduce using rule 278 (float_literal -> FLOAT .)
    POW             reduce using rule 278 (float_literal -> FLOAT .)
    ARRAY_SUB       reduce using rule 278 (float_literal -> FLOAT .)
    ARRAY_CONCAT    reduce using rule 278 (float_literal -> FLOAT .)
    MORE_OR_EQ      reduce using rule 278 (float_literal -> FLOAT .)
    LESS_OR_EQ      reduce using rule 278 (float_literal -> FLOAT .)
    TEXT_MATCH      reduce using rule 278 (float_literal -> FLOAT .)
    STRICT_AND      reduce using rule 278 (float_literal -> FLOAT .)
    AND             reduce using rule 278 (float_literal -> FLOAT .)
    STRICT_OR       reduce using rule 278 (float_literal -> FLOAT .)
    OR              reduce using rule 278 (float_literal -> FLOAT .)
    EQUAL           reduce using rule 278 (float_literal -> FLOAT .)
    NOT_EQUAL       reduce using rule 278 (float_literal -> FLOAT .)
    >               reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_MUL       reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_DIV       reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_SUB       reduce using rule 278 (float_literal -> FLOAT .)
    FLOAT_SUM       reduce using rule 278 (float_literal -> FLOAT .)
    <               reduce using rule 278 (float_literal -> FLOAT .)
    *               reduce using rule 278 (float_literal -> FLOAT .)
    /               reduce using rule 278 (float_literal -> FLOAT .)
    -               reduce using rule 278 (float_literal -> FLOAT .)
    +               reduce using rule 278 (float_literal -> FLOAT .)
    CONCAT          reduce using rule 278 (float_literal -> FLOAT .)
    $end            reduce using rule 278 (float_literal -> FLOAT .)
    )               reduce using rule 278 (float_literal -> FLOAT .)
    OF              reduce using rule 278 (float_literal -> FLOAT .)
    THEN            reduce using rule 278 (float_literal -> FLOAT .)
    END             reduce using rule 278 (float_literal -> FLOAT .)
    ELIF            reduce using rule 278 (float_literal -> FLOAT .)
    ELSE            reduce using rule 278 (float_literal -> FLOAT .)
    ,               reduce using rule 278 (float_literal -> FLOAT .)
    ]               reduce using rule 278 (float_literal -> FLOAT .)


state 32

    (277) int_literal -> INT .
    NEWLINE         reduce using rule 277 (int_literal -> INT .)
    (               reduce using rule 277 (int_literal -> INT .)
    FLOAT_MORE      reduce using rule 277 (int_literal -> INT .)
    FLOAT_MORE_OR_EQ reduce using rule 277 (int_literal -> INT .)
    FLOAT_LESS      reduce using rule 277 (int_literal -> INT .)
    FLOAT_LESS_OR_EQ reduce using rule 277 (int_literal -> INT .)
    SOME_SUB        reduce using rule 277 (int_literal -> INT .)
    SOME_CONCAT     reduce using rule 277 (int_literal -> INT .)
    ARROW_BOTH      reduce using rule 277 (int_literal -> INT .)
    ARROW_RIGHT     reduce using rule 277 (int_literal -> INT .)
    ARROW_LEFT      reduce using rule 277 (int_literal -> INT .)
    DOUBLE_ARROW_RIGHT reduce using rule 277 (int_literal -> INT .)
    DOUBLE_ARROW_LEFT reduce using rule 277 (int_literal -> INT .)
    BIT_SHIFT_LEFT  reduce using rule 277 (int_literal -> INT .)
    BIT_AND         reduce using rule 277 (int_literal -> INT .)
    BIT_OR          reduce using rule 277 (int_literal -> INT .)
    FLOAT_POW       reduce using rule 277 (int_literal -> INT .)
    POW             reduce using rule 277 (int_literal -> INT .)
    ARRAY_SUB       reduce using rule 277 (int_literal -> INT .)
    ARRAY_CONCAT    reduce using rule 277 (int_literal -> INT .)
    MORE_OR_EQ      reduce using rule 277 (int_literal -> INT .)
    LESS_OR_EQ      reduce using rule 277 (int_literal -> INT .)
    TEXT_MATCH      reduce using rule 277 (int_literal -> INT .)
    STRICT_AND      reduce using rule 277 (int_literal -> INT .)
    AND             reduce using rule 277 (int_literal -> INT .)
    STRICT_OR       reduce using rule 277 (int_literal -> INT .)
    OR              reduce using rule 277 (int_literal -> INT .)
    EQUAL           reduce using rule 277 (int_literal -> INT .)
    NOT_EQUAL       reduce using rule 277 (int_literal -> INT .)
    >               reduce using rule 277 (int_literal -> INT .)
    FLOAT_MUL       reduce using rule 277 (int_literal -> INT .)
    FLOAT_DIV       reduce using rule 277 (int_literal -> INT .)
    FLOAT_SUB       reduce using rule 277 (int_literal -> INT .)
    FLOAT_SUM       reduce using rule 277 (int_literal -> INT .)
    <               reduce using rule 277 (int_literal -> INT .)
    *               reduce using rule 277 (int_literal -> INT .)
    /               reduce using rule 277 (int_literal -> INT .)
    -               reduce using rule 277 (int_literal -> INT .)
    +               reduce using rule 277 (int_literal -> INT .)
    CONCAT          reduce using rule 277 (int_literal -> INT .)
    $end            reduce using rule 277 (int_literal -> INT .)
    )               reduce using rule 277 (int_literal -> INT .)
    OF              reduce using rule 277 (int_literal -> INT .)
    THEN            reduce using rule 277 (int_literal -> INT .)
    END             reduce using rule 277 (int_literal -> INT .)
    ELIF            reduce using rule 277 (int_literal -> INT .)
    ELSE            reduce using rule 277 (int_literal -> INT .)
    ,               reduce using rule 277 (int_literal -> INT .)
    ]               reduce using rule 277 (int_literal -> INT .)


state 33

    (242) array -> [ . _48_NEWLINE_optional _49_exprs_optional ]
    (243) _48_NEWLINE_optional -> . NEWLINE
    (244) _48_NEWLINE_optional -> .
    NEWLINE         shift and go to state 130
    (               reduce using rule 244 (_48_NEWLINE_optional -> .)
    DEF             reduce using rule 244 (_48_NEWLINE_optional -> .)
    +               reduce using rule 244 (_48_NEWLINE_optional -> .)
    !               reduce using rule 244 (_48_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 244 (_48_NEWLINE_optional -> .)
    -               reduce using rule 244 (_48_NEWLINE_optional -> .)
    STRING          reduce using rule 244 (_48_NEWLINE_optional -> .)
    FLOAT           reduce using rule 244 (_48_NEWLINE_optional -> .)
    INT             reduce using rule 244 (_48_NEWLINE_optional -> .)
    [               reduce using rule 244 (_48_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 244 (_48_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 244 (_48_NEWLINE_optional -> .)
    CASE            reduce using rule 244 (_48_NEWLINE_optional -> .)
    IF              reduce using rule 244 (_48_NEWLINE_optional -> .)
    DO              reduce using rule 244 (_48_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 244 (_48_NEWLINE_optional -> .)
    ENUM            reduce using rule 244 (_48_NEWLINE_optional -> .)
    ]               reduce using rule 244 (_48_NEWLINE_optional -> .)

    _48_NEWLINE_optional           shift and go to state 129

state 34

    (252) variant_call -> TYPE_IDENTIFIER . ( _52_NEWLINE_optional _53_exprs_optional )
    (               shift and go to state 131


state 35

    (265) identifier -> IDENTIFIER .
    :               reduce using rule 265 (identifier -> IDENTIFIER .)
    =               reduce using rule 265 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 265 (identifier -> IDENTIFIER .)
    (               reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_MORE      reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_MORE_OR_EQ reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_LESS      reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_LESS_OR_EQ reduce using rule 265 (identifier -> IDENTIFIER .)
    SOME_SUB        reduce using rule 265 (identifier -> IDENTIFIER .)
    SOME_CONCAT     reduce using rule 265 (identifier -> IDENTIFIER .)
    ARROW_BOTH      reduce using rule 265 (identifier -> IDENTIFIER .)
    ARROW_RIGHT     reduce using rule 265 (identifier -> IDENTIFIER .)
    ARROW_LEFT      reduce using rule 265 (identifier -> IDENTIFIER .)
    DOUBLE_ARROW_RIGHT reduce using rule 265 (identifier -> IDENTIFIER .)
    DOUBLE_ARROW_LEFT reduce using rule 265 (identifier -> IDENTIFIER .)
    BIT_SHIFT_LEFT  reduce using rule 265 (identifier -> IDENTIFIER .)
    BIT_AND         reduce using rule 265 (identifier -> IDENTIFIER .)
    BIT_OR          reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_POW       reduce using rule 265 (identifier -> IDENTIFIER .)
    POW             reduce using rule 265 (identifier -> IDENTIFIER .)
    ARRAY_SUB       reduce using rule 265 (identifier -> IDENTIFIER .)
    ARRAY_CONCAT    reduce using rule 265 (identifier -> IDENTIFIER .)
    MORE_OR_EQ      reduce using rule 265 (identifier -> IDENTIFIER .)
    LESS_OR_EQ      reduce using rule 265 (identifier -> IDENTIFIER .)
    TEXT_MATCH      reduce using rule 265 (identifier -> IDENTIFIER .)
    STRICT_AND      reduce using rule 265 (identifier -> IDENTIFIER .)
    AND             reduce using rule 265 (identifier -> IDENTIFIER .)
    STRICT_OR       reduce using rule 265 (identifier -> IDENTIFIER .)
    OR              reduce using rule 265 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 265 (identifier -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 265 (identifier -> IDENTIFIER .)
    >               reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_MUL       reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_DIV       reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_SUB       reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_SUM       reduce using rule 265 (identifier -> IDENTIFIER .)
    <               reduce using rule 265 (identifier -> IDENTIFIER .)
    *               reduce using rule 265 (identifier -> IDENTIFIER .)
    /               reduce using rule 265 (identifier -> IDENTIFIER .)
    -               reduce using rule 265 (identifier -> IDENTIFIER .)
    +               reduce using rule 265 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 265 (identifier -> IDENTIFIER .)
    $end            reduce using rule 265 (identifier -> IDENTIFIER .)
    )               reduce using rule 265 (identifier -> IDENTIFIER .)
    OF              reduce using rule 265 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 265 (identifier -> IDENTIFIER .)
    END             reduce using rule 265 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 265 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 265 (identifier -> IDENTIFIER .)
    ,               reduce using rule 265 (identifier -> IDENTIFIER .)
    ]               reduce using rule 265 (identifier -> IDENTIFIER .)
    DO              reduce using rule 265 (identifier -> IDENTIFIER .)


state 36

    (214) case_of -> CASE . expr OF _39_NEWLINE_optional _40_cases_optional END
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 132
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 37

    (205) if_expr -> IF . expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 133
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 38

    (132) do -> DO . _13_0x3a_type_optional block_statement END
    (133) _13_0x3a_type_optional -> . : type
    (134) _13_0x3a_type_optional -> .
    :               shift and go to state 135
    NEWLINE         reduce using rule 134 (_13_0x3a_type_optional -> .)
    END             reduce using rule 134 (_13_0x3a_type_optional -> .)
    (               reduce using rule 134 (_13_0x3a_type_optional -> .)
    DEF             reduce using rule 134 (_13_0x3a_type_optional -> .)
    +               reduce using rule 134 (_13_0x3a_type_optional -> .)
    !               reduce using rule 134 (_13_0x3a_type_optional -> .)
    STRICT_NOT      reduce using rule 134 (_13_0x3a_type_optional -> .)
    -               reduce using rule 134 (_13_0x3a_type_optional -> .)
    STRING          reduce using rule 134 (_13_0x3a_type_optional -> .)
    FLOAT           reduce using rule 134 (_13_0x3a_type_optional -> .)
    INT             reduce using rule 134 (_13_0x3a_type_optional -> .)
    [               reduce using rule 134 (_13_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 134 (_13_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 134 (_13_0x3a_type_optional -> .)
    CASE            reduce using rule 134 (_13_0x3a_type_optional -> .)
    IF              reduce using rule 134 (_13_0x3a_type_optional -> .)
    DO              reduce using rule 134 (_13_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 134 (_13_0x3a_type_optional -> .)
    ENUM            reduce using rule 134 (_13_0x3a_type_optional -> .)

    _13_0x3a_type_optional         shift and go to state 134

state 39

    (32) external -> EXTERNAL .
    NEWLINE         reduce using rule 32 (external -> EXTERNAL .)
    (               reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_MORE      reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_MORE_OR_EQ reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_LESS      reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_LESS_OR_EQ reduce using rule 32 (external -> EXTERNAL .)
    SOME_SUB        reduce using rule 32 (external -> EXTERNAL .)
    SOME_CONCAT     reduce using rule 32 (external -> EXTERNAL .)
    ARROW_BOTH      reduce using rule 32 (external -> EXTERNAL .)
    ARROW_RIGHT     reduce using rule 32 (external -> EXTERNAL .)
    ARROW_LEFT      reduce using rule 32 (external -> EXTERNAL .)
    DOUBLE_ARROW_RIGHT reduce using rule 32 (external -> EXTERNAL .)
    DOUBLE_ARROW_LEFT reduce using rule 32 (external -> EXTERNAL .)
    BIT_SHIFT_LEFT  reduce using rule 32 (external -> EXTERNAL .)
    BIT_AND         reduce using rule 32 (external -> EXTERNAL .)
    BIT_OR          reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_POW       reduce using rule 32 (external -> EXTERNAL .)
    POW             reduce using rule 32 (external -> EXTERNAL .)
    ARRAY_SUB       reduce using rule 32 (external -> EXTERNAL .)
    ARRAY_CONCAT    reduce using rule 32 (external -> EXTERNAL .)
    MORE_OR_EQ      reduce using rule 32 (external -> EXTERNAL .)
    LESS_OR_EQ      reduce using rule 32 (external -> EXTERNAL .)
    TEXT_MATCH      reduce using rule 32 (external -> EXTERNAL .)
    STRICT_AND      reduce using rule 32 (external -> EXTERNAL .)
    AND             reduce using rule 32 (external -> EXTERNAL .)
    STRICT_OR       reduce using rule 32 (external -> EXTERNAL .)
    OR              reduce using rule 32 (external -> EXTERNAL .)
    EQUAL           reduce using rule 32 (external -> EXTERNAL .)
    NOT_EQUAL       reduce using rule 32 (external -> EXTERNAL .)
    >               reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_MUL       reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_DIV       reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_SUB       reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_SUM       reduce using rule 32 (external -> EXTERNAL .)
    <               reduce using rule 32 (external -> EXTERNAL .)
    *               reduce using rule 32 (external -> EXTERNAL .)
    /               reduce using rule 32 (external -> EXTERNAL .)
    -               reduce using rule 32 (external -> EXTERNAL .)
    +               reduce using rule 32 (external -> EXTERNAL .)
    CONCAT          reduce using rule 32 (external -> EXTERNAL .)
    $end            reduce using rule 32 (external -> EXTERNAL .)
    )               reduce using rule 32 (external -> EXTERNAL .)
    OF              reduce using rule 32 (external -> EXTERNAL .)
    THEN            reduce using rule 32 (external -> EXTERNAL .)
    END             reduce using rule 32 (external -> EXTERNAL .)
    ELIF            reduce using rule 32 (external -> EXTERNAL .)
    ELSE            reduce using rule 32 (external -> EXTERNAL .)
    ,               reduce using rule 32 (external -> EXTERNAL .)
    ]               reduce using rule 32 (external -> EXTERNAL .)


state 40

    (174) enum -> ENUM . type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> ENUM . type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 136

state 41

    (6) do_exprs -> expr _3_NEWLINE_optional .
    $end            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    END             reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    ELIF            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    ELSE            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)


state 42

    (9) do_exprs -> expr NEWLINE . do_exprs
    (7) _3_NEWLINE_optional -> NEWLINE .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    $end            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 6
    do_exprs                       shift and go to state 139
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 43

    (247) call -> expr ( . _50_NEWLINE_optional _51_exprs_optional )
    (248) _50_NEWLINE_optional -> . NEWLINE
    (249) _50_NEWLINE_optional -> .
    NEWLINE         shift and go to state 141
    (               reduce using rule 249 (_50_NEWLINE_optional -> .)
    DEF             reduce using rule 249 (_50_NEWLINE_optional -> .)
    +               reduce using rule 249 (_50_NEWLINE_optional -> .)
    !               reduce using rule 249 (_50_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 249 (_50_NEWLINE_optional -> .)
    -               reduce using rule 249 (_50_NEWLINE_optional -> .)
    STRING          reduce using rule 249 (_50_NEWLINE_optional -> .)
    FLOAT           reduce using rule 249 (_50_NEWLINE_optional -> .)
    INT             reduce using rule 249 (_50_NEWLINE_optional -> .)
    [               reduce using rule 249 (_50_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 249 (_50_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 249 (_50_NEWLINE_optional -> .)
    CASE            reduce using rule 249 (_50_NEWLINE_optional -> .)
    IF              reduce using rule 249 (_50_NEWLINE_optional -> .)
    DO              reduce using rule 249 (_50_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 249 (_50_NEWLINE_optional -> .)
    ENUM            reduce using rule 249 (_50_NEWLINE_optional -> .)
    )               reduce using rule 249 (_50_NEWLINE_optional -> .)

    _50_NEWLINE_optional           shift and go to state 140

state 44

    (33) binary_expr -> expr FLOAT_MORE . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 142
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 45

    (34) binary_expr -> expr FLOAT_MORE_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 143
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 46

    (35) binary_expr -> expr FLOAT_LESS . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 144
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 47

    (36) binary_expr -> expr FLOAT_LESS_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 145
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 48

    (37) binary_expr -> expr SOME_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 146
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 49

    (38) binary_expr -> expr SOME_CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 147
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 50

    (39) binary_expr -> expr ARROW_BOTH . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 148
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 51

    (40) binary_expr -> expr ARROW_RIGHT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 149
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 52

    (41) binary_expr -> expr ARROW_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 150
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 53

    (42) binary_expr -> expr DOUBLE_ARROW_RIGHT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 151
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 54

    (43) binary_expr -> expr DOUBLE_ARROW_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 152
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 55

    (44) binary_expr -> expr BIT_SHIFT_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 153
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 56

    (45) binary_expr -> expr BIT_AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 154
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 57

    (46) binary_expr -> expr BIT_OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 155
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 58

    (47) binary_expr -> expr FLOAT_POW . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 156
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 59

    (48) binary_expr -> expr POW . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 157
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 60

    (49) binary_expr -> expr ARRAY_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 158
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 61

    (50) binary_expr -> expr ARRAY_CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 159
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 62

    (51) binary_expr -> expr MORE_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 160
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 63

    (52) binary_expr -> expr LESS_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 161
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 64

    (53) binary_expr -> expr TEXT_MATCH . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 162
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 65

    (54) binary_expr -> expr STRICT_AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 163
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 66

    (55) binary_expr -> expr AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 164
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 67

    (56) binary_expr -> expr STRICT_OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 165
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 68

    (57) binary_expr -> expr OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 166
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 69

    (58) binary_expr -> expr EQUAL . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 167
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 70

    (59) binary_expr -> expr NOT_EQUAL . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 168
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 71

    (60) binary_expr -> expr > . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 169
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 72

    (61) binary_expr -> expr FLOAT_MUL . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 170
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 73

    (62) binary_expr -> expr FLOAT_DIV . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 171
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 74

    (63) binary_expr -> expr FLOAT_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 172
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 75

    (64) binary_expr -> expr FLOAT_SUM . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 173
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 76

    (65) binary_expr -> expr < . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 174
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 77

    (66) binary_expr -> expr * . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 175
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 78

    (67) binary_expr -> expr / . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 176
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 79

    (68) binary_expr -> expr - . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 177
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 80

    (69) binary_expr -> expr + . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 178
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 81

    (70) binary_expr -> expr CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 179
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 82

    (10) expr -> ( expr . )
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    )               shift and go to state 180
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    BIT_OR          shift and go to state 57
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    STRICT_OR       shift and go to state 67
    OR              shift and go to state 68
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 83

    (268) let -> identifier : . type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (275) _58_0x3a_type_optional -> : . type
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 181
    type                           shift and go to state 182

state 84

    (274) let -> identifier _58_0x3a_type_optional . = expr
    =               shift and go to state 183


state 85

    (109) binary_op_def -> DEF binary_op . ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> DEF binary_op . < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (               shift and go to state 184
    <               shift and go to state 185


state 86

    (103) binary_op -> < .
    (               reduce using rule 103 (binary_op -> < .)
    <               reduce using rule 103 (binary_op -> < .)


state 87

    (98) binary_op -> > .
    (               reduce using rule 98 (binary_op -> > .)
    <               reduce using rule 98 (binary_op -> > .)


state 88

    (140) def_expr -> DEF identifier . ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> DEF identifier . < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (               shift and go to state 186
    <               shift and go to state 187


state 89

    (71) binary_op -> FLOAT_MORE .
    (               reduce using rule 71 (binary_op -> FLOAT_MORE .)
    <               reduce using rule 71 (binary_op -> FLOAT_MORE .)


state 90

    (72) binary_op -> FLOAT_MORE_OR_EQ .
    (               reduce using rule 72 (binary_op -> FLOAT_MORE_OR_EQ .)
    <               reduce using rule 72 (binary_op -> FLOAT_MORE_OR_EQ .)


state 91

    (73) binary_op -> FLOAT_LESS .
    (               reduce using rule 73 (binary_op -> FLOAT_LESS .)
    <               reduce using rule 73 (binary_op -> FLOAT_LESS .)


state 92

    (74) binary_op -> FLOAT_LESS_OR_EQ .
    (               reduce using rule 74 (binary_op -> FLOAT_LESS_OR_EQ .)
    <               reduce using rule 74 (binary_op -> FLOAT_LESS_OR_EQ .)


state 93

    (75) binary_op -> SOME_SUB .
    (               reduce using rule 75 (binary_op -> SOME_SUB .)
    <               reduce using rule 75 (binary_op -> SOME_SUB .)


state 94

    (76) binary_op -> SOME_CONCAT .
    (               reduce using rule 76 (binary_op -> SOME_CONCAT .)
    <               reduce using rule 76 (binary_op -> SOME_CONCAT .)


state 95

    (77) binary_op -> ARROW_BOTH .
    (               reduce using rule 77 (binary_op -> ARROW_BOTH .)
    <               reduce using rule 77 (binary_op -> ARROW_BOTH .)


state 96

    (78) binary_op -> ARROW_RIGHT .
    (               reduce using rule 78 (binary_op -> ARROW_RIGHT .)
    <               reduce using rule 78 (binary_op -> ARROW_RIGHT .)


state 97

    (79) binary_op -> ARROW_LEFT .
    (               reduce using rule 79 (binary_op -> ARROW_LEFT .)
    <               reduce using rule 79 (binary_op -> ARROW_LEFT .)


state 98

    (80) binary_op -> DOUBLE_ARROW_RIGHT .
    (               reduce using rule 80 (binary_op -> DOUBLE_ARROW_RIGHT .)
    <               reduce using rule 80 (binary_op -> DOUBLE_ARROW_RIGHT .)


state 99

    (81) binary_op -> DOUBLE_ARROW_LEFT .
    (               reduce using rule 81 (binary_op -> DOUBLE_ARROW_LEFT .)
    <               reduce using rule 81 (binary_op -> DOUBLE_ARROW_LEFT .)


state 100

    (82) binary_op -> BIT_SHIFT_LEFT .
    (               reduce using rule 82 (binary_op -> BIT_SHIFT_LEFT .)
    <               reduce using rule 82 (binary_op -> BIT_SHIFT_LEFT .)


state 101

    (83) binary_op -> BIT_AND .
    (               reduce using rule 83 (binary_op -> BIT_AND .)
    <               reduce using rule 83 (binary_op -> BIT_AND .)


state 102

    (84) binary_op -> BIT_OR .
    (               reduce using rule 84 (binary_op -> BIT_OR .)
    <               reduce using rule 84 (binary_op -> BIT_OR .)


state 103

    (85) binary_op -> FLOAT_POW .
    (               reduce using rule 85 (binary_op -> FLOAT_POW .)
    <               reduce using rule 85 (binary_op -> FLOAT_POW .)


state 104

    (86) binary_op -> POW .
    (               reduce using rule 86 (binary_op -> POW .)
    <               reduce using rule 86 (binary_op -> POW .)


state 105

    (87) binary_op -> ARRAY_SUB .
    (               reduce using rule 87 (binary_op -> ARRAY_SUB .)
    <               reduce using rule 87 (binary_op -> ARRAY_SUB .)


state 106

    (88) binary_op -> ARRAY_CONCAT .
    (               reduce using rule 88 (binary_op -> ARRAY_CONCAT .)
    <               reduce using rule 88 (binary_op -> ARRAY_CONCAT .)


state 107

    (89) binary_op -> MORE_OR_EQ .
    (               reduce using rule 89 (binary_op -> MORE_OR_EQ .)
    <               reduce using rule 89 (binary_op -> MORE_OR_EQ .)


state 108

    (90) binary_op -> LESS_OR_EQ .
    (               reduce using rule 90 (binary_op -> LESS_OR_EQ .)
    <               reduce using rule 90 (binary_op -> LESS_OR_EQ .)


state 109

    (91) binary_op -> TEXT_MATCH .
    (               reduce using rule 91 (binary_op -> TEXT_MATCH .)
    <               reduce using rule 91 (binary_op -> TEXT_MATCH .)


state 110

    (92) binary_op -> STRICT_AND .
    (               reduce using rule 92 (binary_op -> STRICT_AND .)
    <               reduce using rule 92 (binary_op -> STRICT_AND .)


state 111

    (93) binary_op -> AND .
    (               reduce using rule 93 (binary_op -> AND .)
    <               reduce using rule 93 (binary_op -> AND .)


state 112

    (94) binary_op -> STRICT_OR .
    (               reduce using rule 94 (binary_op -> STRICT_OR .)
    <               reduce using rule 94 (binary_op -> STRICT_OR .)


state 113

    (95) binary_op -> OR .
    (               reduce using rule 95 (binary_op -> OR .)
    <               reduce using rule 95 (binary_op -> OR .)


state 114

    (96) binary_op -> EQUAL .
    (               reduce using rule 96 (binary_op -> EQUAL .)
    <               reduce using rule 96 (binary_op -> EQUAL .)


state 115

    (97) binary_op -> NOT_EQUAL .
    (               reduce using rule 97 (binary_op -> NOT_EQUAL .)
    <               reduce using rule 97 (binary_op -> NOT_EQUAL .)


state 116

    (99) binary_op -> FLOAT_MUL .
    (               reduce using rule 99 (binary_op -> FLOAT_MUL .)
    <               reduce using rule 99 (binary_op -> FLOAT_MUL .)


state 117

    (100) binary_op -> FLOAT_DIV .
    (               reduce using rule 100 (binary_op -> FLOAT_DIV .)
    <               reduce using rule 100 (binary_op -> FLOAT_DIV .)


state 118

    (101) binary_op -> FLOAT_SUB .
    (               reduce using rule 101 (binary_op -> FLOAT_SUB .)
    <               reduce using rule 101 (binary_op -> FLOAT_SUB .)


state 119

    (102) binary_op -> FLOAT_SUM .
    (               reduce using rule 102 (binary_op -> FLOAT_SUM .)
    <               reduce using rule 102 (binary_op -> FLOAT_SUM .)


state 120

    (104) binary_op -> * .
    (               reduce using rule 104 (binary_op -> * .)
    <               reduce using rule 104 (binary_op -> * .)


state 121

    (105) binary_op -> / .
    (               reduce using rule 105 (binary_op -> / .)
    <               reduce using rule 105 (binary_op -> / .)


state 122

    (106) binary_op -> - .
    (               reduce using rule 106 (binary_op -> - .)
    <               reduce using rule 106 (binary_op -> - .)


state 123

    (107) binary_op -> + .
    (               reduce using rule 107 (binary_op -> + .)
    <               reduce using rule 107 (binary_op -> + .)


state 124

    (108) binary_op -> CONCAT .
    (               reduce using rule 108 (binary_op -> CONCAT .)
    <               reduce using rule 108 (binary_op -> CONCAT .)


state 125

    (28) unary_expr -> + expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_MORE      reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_MORE_OR_EQ reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_LESS      reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_LESS_OR_EQ reduce using rule 28 (unary_expr -> + expr .)
    SOME_SUB        reduce using rule 28 (unary_expr -> + expr .)
    SOME_CONCAT     reduce using rule 28 (unary_expr -> + expr .)
    ARROW_BOTH      reduce using rule 28 (unary_expr -> + expr .)
    ARROW_RIGHT     reduce using rule 28 (unary_expr -> + expr .)
    ARROW_LEFT      reduce using rule 28 (unary_expr -> + expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 28 (unary_expr -> + expr .)
    DOUBLE_ARROW_LEFT reduce using rule 28 (unary_expr -> + expr .)
    BIT_SHIFT_LEFT  reduce using rule 28 (unary_expr -> + expr .)
    BIT_AND         reduce using rule 28 (unary_expr -> + expr .)
    BIT_OR          reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_POW       reduce using rule 28 (unary_expr -> + expr .)
    POW             reduce using rule 28 (unary_expr -> + expr .)
    ARRAY_SUB       reduce using rule 28 (unary_expr -> + expr .)
    ARRAY_CONCAT    reduce using rule 28 (unary_expr -> + expr .)
    MORE_OR_EQ      reduce using rule 28 (unary_expr -> + expr .)
    LESS_OR_EQ      reduce using rule 28 (unary_expr -> + expr .)
    TEXT_MATCH      reduce using rule 28 (unary_expr -> + expr .)
    STRICT_AND      reduce using rule 28 (unary_expr -> + expr .)
    AND             reduce using rule 28 (unary_expr -> + expr .)
    STRICT_OR       reduce using rule 28 (unary_expr -> + expr .)
    OR              reduce using rule 28 (unary_expr -> + expr .)
    EQUAL           reduce using rule 28 (unary_expr -> + expr .)
    NOT_EQUAL       reduce using rule 28 (unary_expr -> + expr .)
    >               reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_MUL       reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_DIV       reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_SUB       reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_SUM       reduce using rule 28 (unary_expr -> + expr .)
    <               reduce using rule 28 (unary_expr -> + expr .)
    *               reduce using rule 28 (unary_expr -> + expr .)
    /               reduce using rule 28 (unary_expr -> + expr .)
    -               reduce using rule 28 (unary_expr -> + expr .)
    +               reduce using rule 28 (unary_expr -> + expr .)
    CONCAT          reduce using rule 28 (unary_expr -> + expr .)
    $end            reduce using rule 28 (unary_expr -> + expr .)
    )               reduce using rule 28 (unary_expr -> + expr .)
    OF              reduce using rule 28 (unary_expr -> + expr .)
    THEN            reduce using rule 28 (unary_expr -> + expr .)
    END             reduce using rule 28 (unary_expr -> + expr .)
    ELIF            reduce using rule 28 (unary_expr -> + expr .)
    ELSE            reduce using rule 28 (unary_expr -> + expr .)
    ,               reduce using rule 28 (unary_expr -> + expr .)
    ]               reduce using rule 28 (unary_expr -> + expr .)
    (               shift and go to state 43


state 126

    (29) unary_expr -> ! expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_MORE      reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_MORE_OR_EQ reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_LESS      reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_LESS_OR_EQ reduce using rule 29 (unary_expr -> ! expr .)
    SOME_SUB        reduce using rule 29 (unary_expr -> ! expr .)
    SOME_CONCAT     reduce using rule 29 (unary_expr -> ! expr .)
    ARROW_BOTH      reduce using rule 29 (unary_expr -> ! expr .)
    ARROW_RIGHT     reduce using rule 29 (unary_expr -> ! expr .)
    ARROW_LEFT      reduce using rule 29 (unary_expr -> ! expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 29 (unary_expr -> ! expr .)
    DOUBLE_ARROW_LEFT reduce using rule 29 (unary_expr -> ! expr .)
    BIT_SHIFT_LEFT  reduce using rule 29 (unary_expr -> ! expr .)
    BIT_AND         reduce using rule 29 (unary_expr -> ! expr .)
    BIT_OR          reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_POW       reduce using rule 29 (unary_expr -> ! expr .)
    POW             reduce using rule 29 (unary_expr -> ! expr .)
    ARRAY_SUB       reduce using rule 29 (unary_expr -> ! expr .)
    ARRAY_CONCAT    reduce using rule 29 (unary_expr -> ! expr .)
    MORE_OR_EQ      reduce using rule 29 (unary_expr -> ! expr .)
    LESS_OR_EQ      reduce using rule 29 (unary_expr -> ! expr .)
    TEXT_MATCH      reduce using rule 29 (unary_expr -> ! expr .)
    STRICT_AND      reduce using rule 29 (unary_expr -> ! expr .)
    AND             reduce using rule 29 (unary_expr -> ! expr .)
    STRICT_OR       reduce using rule 29 (unary_expr -> ! expr .)
    OR              reduce using rule 29 (unary_expr -> ! expr .)
    EQUAL           reduce using rule 29 (unary_expr -> ! expr .)
    NOT_EQUAL       reduce using rule 29 (unary_expr -> ! expr .)
    >               reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_MUL       reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_DIV       reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_SUB       reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_SUM       reduce using rule 29 (unary_expr -> ! expr .)
    <               reduce using rule 29 (unary_expr -> ! expr .)
    *               reduce using rule 29 (unary_expr -> ! expr .)
    /               reduce using rule 29 (unary_expr -> ! expr .)
    -               reduce using rule 29 (unary_expr -> ! expr .)
    +               reduce using rule 29 (unary_expr -> ! expr .)
    CONCAT          reduce using rule 29 (unary_expr -> ! expr .)
    $end            reduce using rule 29 (unary_expr -> ! expr .)
    )               reduce using rule 29 (unary_expr -> ! expr .)
    OF              reduce using rule 29 (unary_expr -> ! expr .)
    THEN            reduce using rule 29 (unary_expr -> ! expr .)
    END             reduce using rule 29 (unary_expr -> ! expr .)
    ELIF            reduce using rule 29 (unary_expr -> ! expr .)
    ELSE            reduce using rule 29 (unary_expr -> ! expr .)
    ,               reduce using rule 29 (unary_expr -> ! expr .)
    ]               reduce using rule 29 (unary_expr -> ! expr .)
    (               shift and go to state 43


state 127

    (30) unary_expr -> STRICT_NOT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_MORE      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_LESS      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    SOME_SUB        reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    SOME_CONCAT     reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARROW_BOTH      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARROW_RIGHT     reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARROW_LEFT      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    BIT_SHIFT_LEFT  reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    BIT_AND         reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    BIT_OR          reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_POW       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    POW             reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARRAY_SUB       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARRAY_CONCAT    reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    MORE_OR_EQ      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    LESS_OR_EQ      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    TEXT_MATCH      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    STRICT_AND      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    AND             reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    STRICT_OR       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    OR              reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    EQUAL           reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    NOT_EQUAL       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    >               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_MUL       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_DIV       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_SUB       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_SUM       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    <               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    *               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    /               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    -               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    +               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    CONCAT          reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    $end            reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    )               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    OF              reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    THEN            reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    END             reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ELIF            reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ELSE            reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ,               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ]               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    (               shift and go to state 43


state 128

    (31) unary_expr -> - expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_MORE      reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_MORE_OR_EQ reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_LESS      reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_LESS_OR_EQ reduce using rule 31 (unary_expr -> - expr .)
    SOME_SUB        reduce using rule 31 (unary_expr -> - expr .)
    SOME_CONCAT     reduce using rule 31 (unary_expr -> - expr .)
    ARROW_BOTH      reduce using rule 31 (unary_expr -> - expr .)
    ARROW_RIGHT     reduce using rule 31 (unary_expr -> - expr .)
    ARROW_LEFT      reduce using rule 31 (unary_expr -> - expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 31 (unary_expr -> - expr .)
    DOUBLE_ARROW_LEFT reduce using rule 31 (unary_expr -> - expr .)
    BIT_SHIFT_LEFT  reduce using rule 31 (unary_expr -> - expr .)
    BIT_AND         reduce using rule 31 (unary_expr -> - expr .)
    BIT_OR          reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_POW       reduce using rule 31 (unary_expr -> - expr .)
    POW             reduce using rule 31 (unary_expr -> - expr .)
    ARRAY_SUB       reduce using rule 31 (unary_expr -> - expr .)
    ARRAY_CONCAT    reduce using rule 31 (unary_expr -> - expr .)
    MORE_OR_EQ      reduce using rule 31 (unary_expr -> - expr .)
    LESS_OR_EQ      reduce using rule 31 (unary_expr -> - expr .)
    TEXT_MATCH      reduce using rule 31 (unary_expr -> - expr .)
    STRICT_AND      reduce using rule 31 (unary_expr -> - expr .)
    AND             reduce using rule 31 (unary_expr -> - expr .)
    STRICT_OR       reduce using rule 31 (unary_expr -> - expr .)
    OR              reduce using rule 31 (unary_expr -> - expr .)
    EQUAL           reduce using rule 31 (unary_expr -> - expr .)
    NOT_EQUAL       reduce using rule 31 (unary_expr -> - expr .)
    >               reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_MUL       reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_DIV       reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_SUB       reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_SUM       reduce using rule 31 (unary_expr -> - expr .)
    <               reduce using rule 31 (unary_expr -> - expr .)
    *               reduce using rule 31 (unary_expr -> - expr .)
    /               reduce using rule 31 (unary_expr -> - expr .)
    -               reduce using rule 31 (unary_expr -> - expr .)
    +               reduce using rule 31 (unary_expr -> - expr .)
    CONCAT          reduce using rule 31 (unary_expr -> - expr .)
    $end            reduce using rule 31 (unary_expr -> - expr .)
    )               reduce using rule 31 (unary_expr -> - expr .)
    OF              reduce using rule 31 (unary_expr -> - expr .)
    THEN            reduce using rule 31 (unary_expr -> - expr .)
    END             reduce using rule 31 (unary_expr -> - expr .)
    ELIF            reduce using rule 31 (unary_expr -> - expr .)
    ELSE            reduce using rule 31 (unary_expr -> - expr .)
    ,               reduce using rule 31 (unary_expr -> - expr .)
    ]               reduce using rule 31 (unary_expr -> - expr .)
    (               shift and go to state 43


state 129

    (242) array -> [ _48_NEWLINE_optional . _49_exprs_optional ]
    (245) _49_exprs_optional -> . exprs
    (246) _49_exprs_optional -> .
    (257) exprs -> . expr _54_NEWLINE_optional
    (260) exprs -> . exprs , _55_NEWLINE_optional expr _56_NEWLINE_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    ]               reduce using rule 246 (_49_exprs_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    _49_exprs_optional             shift and go to state 188
    exprs                          shift and go to state 189
    expr                           shift and go to state 190
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 130

    (243) _48_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 243 (_48_NEWLINE_optional -> NEWLINE .)


state 131

    (252) variant_call -> TYPE_IDENTIFIER ( . _52_NEWLINE_optional _53_exprs_optional )
    (253) _52_NEWLINE_optional -> . NEWLINE
    (254) _52_NEWLINE_optional -> .
    NEWLINE         shift and go to state 192
    (               reduce using rule 254 (_52_NEWLINE_optional -> .)
    DEF             reduce using rule 254 (_52_NEWLINE_optional -> .)
    +               reduce using rule 254 (_52_NEWLINE_optional -> .)
    !               reduce using rule 254 (_52_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 254 (_52_NEWLINE_optional -> .)
    -               reduce using rule 254 (_52_NEWLINE_optional -> .)
    STRING          reduce using rule 254 (_52_NEWLINE_optional -> .)
    FLOAT           reduce using rule 254 (_52_NEWLINE_optional -> .)
    INT             reduce using rule 254 (_52_NEWLINE_optional -> .)
    [               reduce using rule 254 (_52_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 254 (_52_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 254 (_52_NEWLINE_optional -> .)
    CASE            reduce using rule 254 (_52_NEWLINE_optional -> .)
    IF              reduce using rule 254 (_52_NEWLINE_optional -> .)
    DO              reduce using rule 254 (_52_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 254 (_52_NEWLINE_optional -> .)
    ENUM            reduce using rule 254 (_52_NEWLINE_optional -> .)
    )               reduce using rule 254 (_52_NEWLINE_optional -> .)

    _52_NEWLINE_optional           shift and go to state 191

state 132

    (214) case_of -> CASE expr . OF _39_NEWLINE_optional _40_cases_optional END
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 193
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    BIT_OR          shift and go to state 57
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    STRICT_OR       shift and go to state 67
    OR              shift and go to state 68
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 133

    (205) if_expr -> IF expr . THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 194
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    BIT_OR          shift and go to state 57
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    STRICT_OR       shift and go to state 67
    OR              shift and go to state 68
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 134

    (132) do -> DO _13_0x3a_type_optional . block_statement END
    (135) block_statement -> . _14_NEWLINE_optional _15_do_exprs_optional
    (136) _14_NEWLINE_optional -> . NEWLINE
    (137) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 197
    (               reduce using rule 137 (_14_NEWLINE_optional -> .)
    DEF             reduce using rule 137 (_14_NEWLINE_optional -> .)
    +               reduce using rule 137 (_14_NEWLINE_optional -> .)
    !               reduce using rule 137 (_14_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 137 (_14_NEWLINE_optional -> .)
    -               reduce using rule 137 (_14_NEWLINE_optional -> .)
    STRING          reduce using rule 137 (_14_NEWLINE_optional -> .)
    FLOAT           reduce using rule 137 (_14_NEWLINE_optional -> .)
    INT             reduce using rule 137 (_14_NEWLINE_optional -> .)
    [               reduce using rule 137 (_14_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 137 (_14_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 137 (_14_NEWLINE_optional -> .)
    CASE            reduce using rule 137 (_14_NEWLINE_optional -> .)
    IF              reduce using rule 137 (_14_NEWLINE_optional -> .)
    DO              reduce using rule 137 (_14_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 137 (_14_NEWLINE_optional -> .)
    ENUM            reduce using rule 137 (_14_NEWLINE_optional -> .)
    END             reduce using rule 137 (_14_NEWLINE_optional -> .)

    block_statement                shift and go to state 195
    _14_NEWLINE_optional           shift and go to state 196

state 135

    (133) _13_0x3a_type_optional -> : . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 198
    type_identifier                shift and go to state 199

state 136

    (174) enum -> ENUM type_identifier . { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> ENUM type_identifier . < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    {               shift and go to state 200
    <               shift and go to state 201


state 137

    (266) type_identifier -> IDENTIFIER .
    {               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    <               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    =               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 266 (type_identifier -> IDENTIFIER .)
    END             reduce using rule 266 (type_identifier -> IDENTIFIER .)
    (               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    DEF             reduce using rule 266 (type_identifier -> IDENTIFIER .)
    +               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    !               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    STRICT_NOT      reduce using rule 266 (type_identifier -> IDENTIFIER .)
    -               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    STRING          reduce using rule 266 (type_identifier -> IDENTIFIER .)
    FLOAT           reduce using rule 266 (type_identifier -> IDENTIFIER .)
    INT             reduce using rule 266 (type_identifier -> IDENTIFIER .)
    [               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 266 (type_identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 266 (type_identifier -> IDENTIFIER .)
    CASE            reduce using rule 266 (type_identifier -> IDENTIFIER .)
    IF              reduce using rule 266 (type_identifier -> IDENTIFIER .)
    DO              reduce using rule 266 (type_identifier -> IDENTIFIER .)
    EXTERNAL        reduce using rule 266 (type_identifier -> IDENTIFIER .)
    ENUM            reduce using rule 266 (type_identifier -> IDENTIFIER .)
    ,               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    >               reduce using rule 266 (type_identifier -> IDENTIFIER .)
    MORE_OR_EQ      reduce using rule 266 (type_identifier -> IDENTIFIER .)
    ELIF            reduce using rule 266 (type_identifier -> IDENTIFIER .)
    ELSE            reduce using rule 266 (type_identifier -> IDENTIFIER .)
    )               reduce using rule 266 (type_identifier -> IDENTIFIER .)


state 138

    (267) type_identifier -> TYPE_IDENTIFIER .
    {               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    (               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    +               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    !               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    STRICT_NOT      reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT           reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    INT             reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    MORE_OR_EQ      reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 267 (type_identifier -> TYPE_IDENTIFIER .)


state 139

    (9) do_exprs -> expr NEWLINE do_exprs .
    $end            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    END             reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELIF            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELSE            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)


state 140

    (247) call -> expr ( _50_NEWLINE_optional . _51_exprs_optional )
    (250) _51_exprs_optional -> . exprs
    (251) _51_exprs_optional -> .
    (257) exprs -> . expr _54_NEWLINE_optional
    (260) exprs -> . exprs , _55_NEWLINE_optional expr _56_NEWLINE_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    )               reduce using rule 251 (_51_exprs_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 190
    _51_exprs_optional             shift and go to state 202
    exprs                          shift and go to state 203
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 141

    (248) _50_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 248 (_50_NEWLINE_optional -> NEWLINE .)


state 142

    (33) binary_expr -> expr FLOAT_MORE expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    FLOAT_MORE      reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    FLOAT_MORE_OR_EQ reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    FLOAT_LESS      reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    FLOAT_LESS_OR_EQ reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    BIT_AND         reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    BIT_OR          reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    MORE_OR_EQ      reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    LESS_OR_EQ      reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    TEXT_MATCH      reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    STRICT_AND      reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    AND             reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    STRICT_OR       reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    OR              reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    EQUAL           reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    NOT_EQUAL       reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    >               reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    <               reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    $end            reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    )               reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    OF              reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    THEN            reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    END             reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    ,               reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    ]               reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 143

    (34) binary_expr -> expr FLOAT_MORE_OR_EQ expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    FLOAT_MORE      reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    FLOAT_MORE_OR_EQ reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    FLOAT_LESS      reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    FLOAT_LESS_OR_EQ reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    BIT_AND         reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    BIT_OR          reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    STRICT_AND      reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    AND             reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    STRICT_OR       reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    OR              reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    EQUAL           reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    >               reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    <               reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    $end            reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    )               reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    OF              reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    THEN            reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    END             reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    ,               reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    ]               reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 144

    (35) binary_expr -> expr FLOAT_LESS expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    FLOAT_MORE      reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    FLOAT_MORE_OR_EQ reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    FLOAT_LESS      reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    FLOAT_LESS_OR_EQ reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    BIT_AND         reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    BIT_OR          reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    MORE_OR_EQ      reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    LESS_OR_EQ      reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    TEXT_MATCH      reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    STRICT_AND      reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    AND             reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    STRICT_OR       reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    OR              reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    EQUAL           reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    NOT_EQUAL       reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    >               reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    <               reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    $end            reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    )               reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    OF              reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    THEN            reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    END             reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    ,               reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    ]               reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 145

    (36) binary_expr -> expr FLOAT_LESS_OR_EQ expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    FLOAT_MORE      reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    FLOAT_MORE_OR_EQ reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    FLOAT_LESS      reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    FLOAT_LESS_OR_EQ reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    BIT_AND         reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    BIT_OR          reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    STRICT_AND      reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    AND             reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    STRICT_OR       reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    OR              reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    EQUAL           reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    >               reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    <               reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    $end            reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    )               reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    OF              reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    THEN            reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    END             reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    ELIF            reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    ELSE            reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    ,               reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    ]               reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 146

    (37) binary_expr -> expr SOME_SUB expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    FLOAT_MORE      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    FLOAT_MORE_OR_EQ reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    FLOAT_LESS      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    FLOAT_LESS_OR_EQ reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ARROW_BOTH      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ARROW_RIGHT     reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ARROW_LEFT      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    BIT_AND         reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    BIT_OR          reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    MORE_OR_EQ      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    LESS_OR_EQ      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    TEXT_MATCH      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    STRICT_AND      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    AND             reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    STRICT_OR       reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    OR              reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    EQUAL           reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    NOT_EQUAL       reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    >               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    <               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    $end            reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    )               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    OF              reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    THEN            reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    END             reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ELIF            reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ELSE            reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ,               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ]               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 147

    (38) binary_expr -> expr SOME_CONCAT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    FLOAT_MORE      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    FLOAT_LESS      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_BOTH      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_RIGHT     reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_LEFT      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_AND         reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_OR          reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    MORE_OR_EQ      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    LESS_OR_EQ      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    TEXT_MATCH      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    STRICT_AND      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    AND             reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    STRICT_OR       reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    OR              reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    EQUAL           reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    NOT_EQUAL       reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    >               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    <               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    $end            reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    )               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    OF              reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    THEN            reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    END             reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ELIF            reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ELSE            reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ,               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ]               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 148

    (39) binary_expr -> expr ARROW_BOTH expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    FLOAT_MORE      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    FLOAT_MORE_OR_EQ reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    FLOAT_LESS      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    FLOAT_LESS_OR_EQ reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_BOTH      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_RIGHT     reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_LEFT      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    DOUBLE_ARROW_LEFT reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_SHIFT_LEFT  reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_AND         reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_OR          reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    MORE_OR_EQ      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    LESS_OR_EQ      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    TEXT_MATCH      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    STRICT_AND      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    AND             reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    STRICT_OR       reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    OR              reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    EQUAL           reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    NOT_EQUAL       reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    >               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    <               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    $end            reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    )               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    OF              reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    THEN            reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    END             reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ELIF            reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ELSE            reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ,               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ]               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 149

    (40) binary_expr -> expr ARROW_RIGHT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    FLOAT_MORE      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    FLOAT_LESS      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_BOTH      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_RIGHT     reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_LEFT      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_SHIFT_LEFT  reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_AND         reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_OR          reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    MORE_OR_EQ      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    LESS_OR_EQ      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    TEXT_MATCH      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    STRICT_AND      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    AND             reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    STRICT_OR       reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    OR              reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    EQUAL           reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    NOT_EQUAL       reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    >               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    <               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    $end            reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    )               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    OF              reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    THEN            reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    END             reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ELIF            reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ELSE            reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ,               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ]               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 150

    (41) binary_expr -> expr ARROW_LEFT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    FLOAT_MORE      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    FLOAT_LESS      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_BOTH      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_RIGHT     reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_LEFT      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_AND         reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_OR          reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    MORE_OR_EQ      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    LESS_OR_EQ      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    TEXT_MATCH      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    STRICT_AND      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    AND             reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    STRICT_OR       reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    OR              reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    EQUAL           reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    NOT_EQUAL       reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    >               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    <               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    $end            reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    )               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    OF              reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    THEN            reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    END             reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ELIF            reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ELSE            reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ,               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ]               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 151

    (42) binary_expr -> expr DOUBLE_ARROW_RIGHT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    FLOAT_MORE      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    FLOAT_LESS      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_BOTH      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_RIGHT     reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_LEFT      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_SHIFT_LEFT  reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_AND         reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_OR          reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    MORE_OR_EQ      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    LESS_OR_EQ      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    TEXT_MATCH      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    STRICT_AND      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    AND             reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    STRICT_OR       reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    OR              reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    EQUAL           reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    NOT_EQUAL       reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    >               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    <               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    $end            reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    )               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    OF              reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    THEN            reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    END             reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ELIF            reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ELSE            reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ,               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ]               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 152

    (43) binary_expr -> expr DOUBLE_ARROW_LEFT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    FLOAT_MORE      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    FLOAT_LESS      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_BOTH      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_RIGHT     reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_LEFT      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_AND         reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_OR          reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    MORE_OR_EQ      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    LESS_OR_EQ      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    TEXT_MATCH      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    STRICT_AND      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    AND             reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    STRICT_OR       reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    OR              reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    EQUAL           reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    NOT_EQUAL       reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    >               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    <               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    $end            reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    )               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    OF              reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    THEN            reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    END             reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ELIF            reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ELSE            reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ,               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ]               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 153

    (44) binary_expr -> expr BIT_SHIFT_LEFT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    FLOAT_MORE      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    FLOAT_LESS      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_BOTH      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_RIGHT     reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_LEFT      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_AND         reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_OR          reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    MORE_OR_EQ      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    LESS_OR_EQ      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    TEXT_MATCH      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    STRICT_AND      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    AND             reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    STRICT_OR       reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    OR              reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    EQUAL           reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    NOT_EQUAL       reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    >               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    <               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    $end            reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    )               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    OF              reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    THEN            reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    END             reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ELIF            reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ELSE            reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ,               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ]               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 154

    (45) binary_expr -> expr BIT_AND expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    BIT_AND         reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    BIT_OR          reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    STRICT_AND      reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    AND             reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    STRICT_OR       reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    OR              reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    $end            reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    )               reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    OF              reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    THEN            reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    END             reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    ELIF            reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    ELSE            reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    ,               reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    ]               reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 155

    (46) binary_expr -> expr BIT_OR expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    BIT_OR          reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    STRICT_OR       reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    OR              reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    $end            reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    )               reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    OF              reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    THEN            reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    END             reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    ELIF            reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    ELSE            reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    ,               reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    ]               reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 156

    (47) binary_expr -> expr FLOAT_POW expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_MORE      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_MORE_OR_EQ reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_LESS      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_LESS_OR_EQ reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    SOME_SUB        reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    SOME_CONCAT     reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_BOTH      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_RIGHT     reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_LEFT      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    DOUBLE_ARROW_LEFT reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    BIT_SHIFT_LEFT  reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    BIT_AND         reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    BIT_OR          reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_POW       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    POW             reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARRAY_SUB       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARRAY_CONCAT    reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    MORE_OR_EQ      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    LESS_OR_EQ      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    TEXT_MATCH      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    STRICT_AND      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    AND             reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    STRICT_OR       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    OR              reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    EQUAL           reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    NOT_EQUAL       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    >               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_MUL       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_DIV       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_SUB       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_SUM       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    <               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    *               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    /               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    -               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    +               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    CONCAT          reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    $end            reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    )               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    OF              reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    THEN            reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    END             reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ELIF            reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ELSE            reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ,               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ]               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    (               shift and go to state 43


state 157

    (48) binary_expr -> expr POW expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_MORE      reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_MORE_OR_EQ reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_LESS      reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_LESS_OR_EQ reduce using rule 48 (binary_expr -> expr POW expr .)
    SOME_SUB        reduce using rule 48 (binary_expr -> expr POW expr .)
    SOME_CONCAT     reduce using rule 48 (binary_expr -> expr POW expr .)
    ARROW_BOTH      reduce using rule 48 (binary_expr -> expr POW expr .)
    ARROW_RIGHT     reduce using rule 48 (binary_expr -> expr POW expr .)
    ARROW_LEFT      reduce using rule 48 (binary_expr -> expr POW expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 48 (binary_expr -> expr POW expr .)
    DOUBLE_ARROW_LEFT reduce using rule 48 (binary_expr -> expr POW expr .)
    BIT_SHIFT_LEFT  reduce using rule 48 (binary_expr -> expr POW expr .)
    BIT_AND         reduce using rule 48 (binary_expr -> expr POW expr .)
    BIT_OR          reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_POW       reduce using rule 48 (binary_expr -> expr POW expr .)
    POW             reduce using rule 48 (binary_expr -> expr POW expr .)
    ARRAY_SUB       reduce using rule 48 (binary_expr -> expr POW expr .)
    ARRAY_CONCAT    reduce using rule 48 (binary_expr -> expr POW expr .)
    MORE_OR_EQ      reduce using rule 48 (binary_expr -> expr POW expr .)
    LESS_OR_EQ      reduce using rule 48 (binary_expr -> expr POW expr .)
    TEXT_MATCH      reduce using rule 48 (binary_expr -> expr POW expr .)
    STRICT_AND      reduce using rule 48 (binary_expr -> expr POW expr .)
    AND             reduce using rule 48 (binary_expr -> expr POW expr .)
    STRICT_OR       reduce using rule 48 (binary_expr -> expr POW expr .)
    OR              reduce using rule 48 (binary_expr -> expr POW expr .)
    EQUAL           reduce using rule 48 (binary_expr -> expr POW expr .)
    NOT_EQUAL       reduce using rule 48 (binary_expr -> expr POW expr .)
    >               reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_MUL       reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_DIV       reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_SUB       reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_SUM       reduce using rule 48 (binary_expr -> expr POW expr .)
    <               reduce using rule 48 (binary_expr -> expr POW expr .)
    *               reduce using rule 48 (binary_expr -> expr POW expr .)
    /               reduce using rule 48 (binary_expr -> expr POW expr .)
    -               reduce using rule 48 (binary_expr -> expr POW expr .)
    +               reduce using rule 48 (binary_expr -> expr POW expr .)
    CONCAT          reduce using rule 48 (binary_expr -> expr POW expr .)
    $end            reduce using rule 48 (binary_expr -> expr POW expr .)
    )               reduce using rule 48 (binary_expr -> expr POW expr .)
    OF              reduce using rule 48 (binary_expr -> expr POW expr .)
    THEN            reduce using rule 48 (binary_expr -> expr POW expr .)
    END             reduce using rule 48 (binary_expr -> expr POW expr .)
    ELIF            reduce using rule 48 (binary_expr -> expr POW expr .)
    ELSE            reduce using rule 48 (binary_expr -> expr POW expr .)
    ,               reduce using rule 48 (binary_expr -> expr POW expr .)
    ]               reduce using rule 48 (binary_expr -> expr POW expr .)
    (               shift and go to state 43


state 158

    (49) binary_expr -> expr ARRAY_SUB expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    FLOAT_MORE      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    FLOAT_MORE_OR_EQ reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    FLOAT_LESS      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    FLOAT_LESS_OR_EQ reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_BOTH      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_RIGHT     reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_LEFT      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_AND         reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_OR          reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    MORE_OR_EQ      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    LESS_OR_EQ      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    TEXT_MATCH      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    STRICT_AND      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    AND             reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    STRICT_OR       reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    OR              reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    EQUAL           reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    NOT_EQUAL       reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    >               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    <               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    $end            reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    )               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    OF              reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    THEN            reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    END             reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ELIF            reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ELSE            reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ,               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ]               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 159

    (50) binary_expr -> expr ARRAY_CONCAT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    FLOAT_MORE      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    FLOAT_LESS      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_BOTH      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_RIGHT     reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_LEFT      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_AND         reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_OR          reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    MORE_OR_EQ      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    LESS_OR_EQ      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    TEXT_MATCH      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    STRICT_AND      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    AND             reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    STRICT_OR       reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    OR              reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    EQUAL           reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    NOT_EQUAL       reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    >               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    <               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    $end            reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    )               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    OF              reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    THEN            reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    END             reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ELIF            reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ELSE            reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ,               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ]               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 160

    (51) binary_expr -> expr MORE_OR_EQ expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    FLOAT_MORE      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    FLOAT_MORE_OR_EQ reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    FLOAT_LESS      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    FLOAT_LESS_OR_EQ reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    BIT_AND         reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    BIT_OR          reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    STRICT_AND      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    AND             reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    STRICT_OR       reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    OR              reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    EQUAL           reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    >               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    <               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    $end            reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    )               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    OF              reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    THEN            reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    END             reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    ELIF            reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    ELSE            reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    ,               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    ]               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 161

    (52) binary_expr -> expr LESS_OR_EQ expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    FLOAT_MORE      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    FLOAT_MORE_OR_EQ reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    FLOAT_LESS      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    FLOAT_LESS_OR_EQ reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    BIT_AND         reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    BIT_OR          reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    STRICT_AND      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    AND             reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    STRICT_OR       reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    OR              reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    EQUAL           reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    >               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    <               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    $end            reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    )               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    OF              reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    THEN            reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    END             reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    ELIF            reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    ELSE            reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    ,               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    ]               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 162

    (53) binary_expr -> expr TEXT_MATCH expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    BIT_AND         reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    BIT_OR          reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    TEXT_MATCH      reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    STRICT_AND      reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    AND             reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    STRICT_OR       reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    OR              reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    EQUAL           reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    NOT_EQUAL       reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    $end            reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    )               reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    OF              reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    THEN            reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    END             reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    ELIF            reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    ELSE            reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    ,               reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    ]               reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 163

    (54) binary_expr -> expr STRICT_AND expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    BIT_AND         reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    BIT_OR          reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    STRICT_AND      reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    AND             reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    STRICT_OR       reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    OR              reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    $end            reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    )               reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    OF              reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    THEN            reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    END             reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    ELIF            reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    ELSE            reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    ,               reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    ]               reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 164

    (55) binary_expr -> expr AND expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 55 (binary_expr -> expr AND expr .)
    BIT_AND         reduce using rule 55 (binary_expr -> expr AND expr .)
    BIT_OR          reduce using rule 55 (binary_expr -> expr AND expr .)
    STRICT_AND      reduce using rule 55 (binary_expr -> expr AND expr .)
    AND             reduce using rule 55 (binary_expr -> expr AND expr .)
    STRICT_OR       reduce using rule 55 (binary_expr -> expr AND expr .)
    OR              reduce using rule 55 (binary_expr -> expr AND expr .)
    $end            reduce using rule 55 (binary_expr -> expr AND expr .)
    )               reduce using rule 55 (binary_expr -> expr AND expr .)
    OF              reduce using rule 55 (binary_expr -> expr AND expr .)
    THEN            reduce using rule 55 (binary_expr -> expr AND expr .)
    END             reduce using rule 55 (binary_expr -> expr AND expr .)
    ELIF            reduce using rule 55 (binary_expr -> expr AND expr .)
    ELSE            reduce using rule 55 (binary_expr -> expr AND expr .)
    ,               reduce using rule 55 (binary_expr -> expr AND expr .)
    ]               reduce using rule 55 (binary_expr -> expr AND expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 165

    (56) binary_expr -> expr STRICT_OR expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    BIT_OR          reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    STRICT_OR       reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    OR              reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    $end            reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    )               reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    OF              reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    THEN            reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    END             reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    ELIF            reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    ELSE            reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    ,               reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    ]               reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 166

    (57) binary_expr -> expr OR expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 57 (binary_expr -> expr OR expr .)
    BIT_OR          reduce using rule 57 (binary_expr -> expr OR expr .)
    STRICT_OR       reduce using rule 57 (binary_expr -> expr OR expr .)
    OR              reduce using rule 57 (binary_expr -> expr OR expr .)
    $end            reduce using rule 57 (binary_expr -> expr OR expr .)
    )               reduce using rule 57 (binary_expr -> expr OR expr .)
    OF              reduce using rule 57 (binary_expr -> expr OR expr .)
    THEN            reduce using rule 57 (binary_expr -> expr OR expr .)
    END             reduce using rule 57 (binary_expr -> expr OR expr .)
    ELIF            reduce using rule 57 (binary_expr -> expr OR expr .)
    ELSE            reduce using rule 57 (binary_expr -> expr OR expr .)
    ,               reduce using rule 57 (binary_expr -> expr OR expr .)
    ]               reduce using rule 57 (binary_expr -> expr OR expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 167

    (58) binary_expr -> expr EQUAL expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    BIT_AND         reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    BIT_OR          reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    TEXT_MATCH      reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    STRICT_AND      reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    AND             reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    STRICT_OR       reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    OR              reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    $end            reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    )               reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    OF              reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    THEN            reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    END             reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    ELIF            reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    ELSE            reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    ,               reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    ]               reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 168

    (59) binary_expr -> expr NOT_EQUAL expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    BIT_AND         reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    BIT_OR          reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    TEXT_MATCH      reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    STRICT_AND      reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    AND             reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    STRICT_OR       reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    OR              reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    END             reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    ELIF            reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    ]               reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 169

    (60) binary_expr -> expr > expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 60 (binary_expr -> expr > expr .)
    FLOAT_MORE      reduce using rule 60 (binary_expr -> expr > expr .)
    FLOAT_MORE_OR_EQ reduce using rule 60 (binary_expr -> expr > expr .)
    FLOAT_LESS      reduce using rule 60 (binary_expr -> expr > expr .)
    FLOAT_LESS_OR_EQ reduce using rule 60 (binary_expr -> expr > expr .)
    BIT_AND         reduce using rule 60 (binary_expr -> expr > expr .)
    BIT_OR          reduce using rule 60 (binary_expr -> expr > expr .)
    MORE_OR_EQ      reduce using rule 60 (binary_expr -> expr > expr .)
    LESS_OR_EQ      reduce using rule 60 (binary_expr -> expr > expr .)
    TEXT_MATCH      reduce using rule 60 (binary_expr -> expr > expr .)
    STRICT_AND      reduce using rule 60 (binary_expr -> expr > expr .)
    AND             reduce using rule 60 (binary_expr -> expr > expr .)
    STRICT_OR       reduce using rule 60 (binary_expr -> expr > expr .)
    OR              reduce using rule 60 (binary_expr -> expr > expr .)
    EQUAL           reduce using rule 60 (binary_expr -> expr > expr .)
    NOT_EQUAL       reduce using rule 60 (binary_expr -> expr > expr .)
    >               reduce using rule 60 (binary_expr -> expr > expr .)
    <               reduce using rule 60 (binary_expr -> expr > expr .)
    $end            reduce using rule 60 (binary_expr -> expr > expr .)
    )               reduce using rule 60 (binary_expr -> expr > expr .)
    OF              reduce using rule 60 (binary_expr -> expr > expr .)
    THEN            reduce using rule 60 (binary_expr -> expr > expr .)
    END             reduce using rule 60 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 60 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 60 (binary_expr -> expr > expr .)
    ,               reduce using rule 60 (binary_expr -> expr > expr .)
    ]               reduce using rule 60 (binary_expr -> expr > expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 170

    (61) binary_expr -> expr FLOAT_MUL expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_MORE      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_MORE_OR_EQ reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_LESS      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_LESS_OR_EQ reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    SOME_SUB        reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    SOME_CONCAT     reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_BOTH      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_RIGHT     reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_LEFT      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    DOUBLE_ARROW_LEFT reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_SHIFT_LEFT  reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_AND         reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_OR          reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARRAY_SUB       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARRAY_CONCAT    reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    MORE_OR_EQ      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    LESS_OR_EQ      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    TEXT_MATCH      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    STRICT_AND      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    AND             reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    STRICT_OR       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    OR              reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    EQUAL           reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    NOT_EQUAL       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    >               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_MUL       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_DIV       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_SUB       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_SUM       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    <               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    *               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    /               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    -               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    +               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    CONCAT          reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    $end            reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    )               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    OF              reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    THEN            reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    END             reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ELIF            reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ELSE            reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ,               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ]               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    (               shift and go to state 43
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59


state 171

    (62) binary_expr -> expr FLOAT_DIV expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_MORE      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_MORE_OR_EQ reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_LESS      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_LESS_OR_EQ reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    SOME_SUB        reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    SOME_CONCAT     reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_BOTH      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_RIGHT     reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_LEFT      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    DOUBLE_ARROW_LEFT reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_SHIFT_LEFT  reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_AND         reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_OR          reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARRAY_SUB       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARRAY_CONCAT    reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    MORE_OR_EQ      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    LESS_OR_EQ      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    TEXT_MATCH      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    STRICT_AND      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    AND             reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    STRICT_OR       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    OR              reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    EQUAL           reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    NOT_EQUAL       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    >               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_MUL       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_DIV       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_SUB       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_SUM       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    <               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    *               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    /               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    -               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    +               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    CONCAT          reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    $end            reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    )               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    OF              reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    THEN            reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    END             reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ELIF            reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ELSE            reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ,               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ]               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    (               shift and go to state 43
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59


state 172

    (63) binary_expr -> expr FLOAT_SUB expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_MORE      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_MORE_OR_EQ reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_LESS      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_LESS_OR_EQ reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    SOME_SUB        reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    SOME_CONCAT     reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_BOTH      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_RIGHT     reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_LEFT      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_AND         reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_OR          reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARRAY_SUB       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARRAY_CONCAT    reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    MORE_OR_EQ      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    LESS_OR_EQ      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    TEXT_MATCH      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    STRICT_AND      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    AND             reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    STRICT_OR       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    OR              reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    EQUAL           reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    NOT_EQUAL       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    >               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_SUB       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_SUM       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    <               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    -               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    +               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    CONCAT          reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    $end            reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    )               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    OF              reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    THEN            reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    END             reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ELIF            reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ELSE            reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ,               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ]               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    (               shift and go to state 43
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    *               shift and go to state 77
    /               shift and go to state 78


state 173

    (64) binary_expr -> expr FLOAT_SUM expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_MORE      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_MORE_OR_EQ reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_LESS      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_LESS_OR_EQ reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    SOME_SUB        reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    SOME_CONCAT     reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_BOTH      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_RIGHT     reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_LEFT      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    DOUBLE_ARROW_LEFT reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_SHIFT_LEFT  reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_AND         reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_OR          reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARRAY_SUB       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARRAY_CONCAT    reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    MORE_OR_EQ      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    LESS_OR_EQ      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    TEXT_MATCH      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    STRICT_AND      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    AND             reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    STRICT_OR       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    OR              reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    EQUAL           reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    NOT_EQUAL       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    >               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_SUB       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_SUM       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    <               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    -               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    +               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    CONCAT          reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    $end            reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    )               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    OF              reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    THEN            reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    END             reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ELIF            reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ELSE            reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ,               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ]               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    (               shift and go to state 43
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    *               shift and go to state 77
    /               shift and go to state 78


state 174

    (65) binary_expr -> expr < expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 65 (binary_expr -> expr < expr .)
    FLOAT_MORE      reduce using rule 65 (binary_expr -> expr < expr .)
    FLOAT_MORE_OR_EQ reduce using rule 65 (binary_expr -> expr < expr .)
    FLOAT_LESS      reduce using rule 65 (binary_expr -> expr < expr .)
    FLOAT_LESS_OR_EQ reduce using rule 65 (binary_expr -> expr < expr .)
    BIT_AND         reduce using rule 65 (binary_expr -> expr < expr .)
    BIT_OR          reduce using rule 65 (binary_expr -> expr < expr .)
    MORE_OR_EQ      reduce using rule 65 (binary_expr -> expr < expr .)
    LESS_OR_EQ      reduce using rule 65 (binary_expr -> expr < expr .)
    TEXT_MATCH      reduce using rule 65 (binary_expr -> expr < expr .)
    STRICT_AND      reduce using rule 65 (binary_expr -> expr < expr .)
    AND             reduce using rule 65 (binary_expr -> expr < expr .)
    STRICT_OR       reduce using rule 65 (binary_expr -> expr < expr .)
    OR              reduce using rule 65 (binary_expr -> expr < expr .)
    EQUAL           reduce using rule 65 (binary_expr -> expr < expr .)
    NOT_EQUAL       reduce using rule 65 (binary_expr -> expr < expr .)
    >               reduce using rule 65 (binary_expr -> expr < expr .)
    <               reduce using rule 65 (binary_expr -> expr < expr .)
    $end            reduce using rule 65 (binary_expr -> expr < expr .)
    )               reduce using rule 65 (binary_expr -> expr < expr .)
    OF              reduce using rule 65 (binary_expr -> expr < expr .)
    THEN            reduce using rule 65 (binary_expr -> expr < expr .)
    END             reduce using rule 65 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 65 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 65 (binary_expr -> expr < expr .)
    ,               reduce using rule 65 (binary_expr -> expr < expr .)
    ]               reduce using rule 65 (binary_expr -> expr < expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 175

    (66) binary_expr -> expr * expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_MORE      reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_MORE_OR_EQ reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_LESS      reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_LESS_OR_EQ reduce using rule 66 (binary_expr -> expr * expr .)
    SOME_SUB        reduce using rule 66 (binary_expr -> expr * expr .)
    SOME_CONCAT     reduce using rule 66 (binary_expr -> expr * expr .)
    ARROW_BOTH      reduce using rule 66 (binary_expr -> expr * expr .)
    ARROW_RIGHT     reduce using rule 66 (binary_expr -> expr * expr .)
    ARROW_LEFT      reduce using rule 66 (binary_expr -> expr * expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 66 (binary_expr -> expr * expr .)
    DOUBLE_ARROW_LEFT reduce using rule 66 (binary_expr -> expr * expr .)
    BIT_SHIFT_LEFT  reduce using rule 66 (binary_expr -> expr * expr .)
    BIT_AND         reduce using rule 66 (binary_expr -> expr * expr .)
    BIT_OR          reduce using rule 66 (binary_expr -> expr * expr .)
    ARRAY_SUB       reduce using rule 66 (binary_expr -> expr * expr .)
    ARRAY_CONCAT    reduce using rule 66 (binary_expr -> expr * expr .)
    MORE_OR_EQ      reduce using rule 66 (binary_expr -> expr * expr .)
    LESS_OR_EQ      reduce using rule 66 (binary_expr -> expr * expr .)
    TEXT_MATCH      reduce using rule 66 (binary_expr -> expr * expr .)
    STRICT_AND      reduce using rule 66 (binary_expr -> expr * expr .)
    AND             reduce using rule 66 (binary_expr -> expr * expr .)
    STRICT_OR       reduce using rule 66 (binary_expr -> expr * expr .)
    OR              reduce using rule 66 (binary_expr -> expr * expr .)
    EQUAL           reduce using rule 66 (binary_expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 66 (binary_expr -> expr * expr .)
    >               reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_MUL       reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_DIV       reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_SUB       reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_SUM       reduce using rule 66 (binary_expr -> expr * expr .)
    <               reduce using rule 66 (binary_expr -> expr * expr .)
    *               reduce using rule 66 (binary_expr -> expr * expr .)
    /               reduce using rule 66 (binary_expr -> expr * expr .)
    -               reduce using rule 66 (binary_expr -> expr * expr .)
    +               reduce using rule 66 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 66 (binary_expr -> expr * expr .)
    $end            reduce using rule 66 (binary_expr -> expr * expr .)
    )               reduce using rule 66 (binary_expr -> expr * expr .)
    OF              reduce using rule 66 (binary_expr -> expr * expr .)
    THEN            reduce using rule 66 (binary_expr -> expr * expr .)
    END             reduce using rule 66 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 66 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 66 (binary_expr -> expr * expr .)
    ,               reduce using rule 66 (binary_expr -> expr * expr .)
    ]               reduce using rule 66 (binary_expr -> expr * expr .)
    (               shift and go to state 43
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59


state 176

    (67) binary_expr -> expr / expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_MORE      reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_MORE_OR_EQ reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_LESS      reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_LESS_OR_EQ reduce using rule 67 (binary_expr -> expr / expr .)
    SOME_SUB        reduce using rule 67 (binary_expr -> expr / expr .)
    SOME_CONCAT     reduce using rule 67 (binary_expr -> expr / expr .)
    ARROW_BOTH      reduce using rule 67 (binary_expr -> expr / expr .)
    ARROW_RIGHT     reduce using rule 67 (binary_expr -> expr / expr .)
    ARROW_LEFT      reduce using rule 67 (binary_expr -> expr / expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 67 (binary_expr -> expr / expr .)
    DOUBLE_ARROW_LEFT reduce using rule 67 (binary_expr -> expr / expr .)
    BIT_SHIFT_LEFT  reduce using rule 67 (binary_expr -> expr / expr .)
    BIT_AND         reduce using rule 67 (binary_expr -> expr / expr .)
    BIT_OR          reduce using rule 67 (binary_expr -> expr / expr .)
    ARRAY_SUB       reduce using rule 67 (binary_expr -> expr / expr .)
    ARRAY_CONCAT    reduce using rule 67 (binary_expr -> expr / expr .)
    MORE_OR_EQ      reduce using rule 67 (binary_expr -> expr / expr .)
    LESS_OR_EQ      reduce using rule 67 (binary_expr -> expr / expr .)
    TEXT_MATCH      reduce using rule 67 (binary_expr -> expr / expr .)
    STRICT_AND      reduce using rule 67 (binary_expr -> expr / expr .)
    AND             reduce using rule 67 (binary_expr -> expr / expr .)
    STRICT_OR       reduce using rule 67 (binary_expr -> expr / expr .)
    OR              reduce using rule 67 (binary_expr -> expr / expr .)
    EQUAL           reduce using rule 67 (binary_expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 67 (binary_expr -> expr / expr .)
    >               reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_MUL       reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_DIV       reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_SUB       reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_SUM       reduce using rule 67 (binary_expr -> expr / expr .)
    <               reduce using rule 67 (binary_expr -> expr / expr .)
    *               reduce using rule 67 (binary_expr -> expr / expr .)
    /               reduce using rule 67 (binary_expr -> expr / expr .)
    -               reduce using rule 67 (binary_expr -> expr / expr .)
    +               reduce using rule 67 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 67 (binary_expr -> expr / expr .)
    $end            reduce using rule 67 (binary_expr -> expr / expr .)
    )               reduce using rule 67 (binary_expr -> expr / expr .)
    OF              reduce using rule 67 (binary_expr -> expr / expr .)
    THEN            reduce using rule 67 (binary_expr -> expr / expr .)
    END             reduce using rule 67 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 67 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 67 (binary_expr -> expr / expr .)
    ,               reduce using rule 67 (binary_expr -> expr / expr .)
    ]               reduce using rule 67 (binary_expr -> expr / expr .)
    (               shift and go to state 43
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59


state 177

    (68) binary_expr -> expr - expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_MORE      reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_MORE_OR_EQ reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_LESS      reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_LESS_OR_EQ reduce using rule 68 (binary_expr -> expr - expr .)
    SOME_SUB        reduce using rule 68 (binary_expr -> expr - expr .)
    SOME_CONCAT     reduce using rule 68 (binary_expr -> expr - expr .)
    ARROW_BOTH      reduce using rule 68 (binary_expr -> expr - expr .)
    ARROW_RIGHT     reduce using rule 68 (binary_expr -> expr - expr .)
    ARROW_LEFT      reduce using rule 68 (binary_expr -> expr - expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 68 (binary_expr -> expr - expr .)
    DOUBLE_ARROW_LEFT reduce using rule 68 (binary_expr -> expr - expr .)
    BIT_SHIFT_LEFT  reduce using rule 68 (binary_expr -> expr - expr .)
    BIT_AND         reduce using rule 68 (binary_expr -> expr - expr .)
    BIT_OR          reduce using rule 68 (binary_expr -> expr - expr .)
    ARRAY_SUB       reduce using rule 68 (binary_expr -> expr - expr .)
    ARRAY_CONCAT    reduce using rule 68 (binary_expr -> expr - expr .)
    MORE_OR_EQ      reduce using rule 68 (binary_expr -> expr - expr .)
    LESS_OR_EQ      reduce using rule 68 (binary_expr -> expr - expr .)
    TEXT_MATCH      reduce using rule 68 (binary_expr -> expr - expr .)
    STRICT_AND      reduce using rule 68 (binary_expr -> expr - expr .)
    AND             reduce using rule 68 (binary_expr -> expr - expr .)
    STRICT_OR       reduce using rule 68 (binary_expr -> expr - expr .)
    OR              reduce using rule 68 (binary_expr -> expr - expr .)
    EQUAL           reduce using rule 68 (binary_expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 68 (binary_expr -> expr - expr .)
    >               reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_SUB       reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_SUM       reduce using rule 68 (binary_expr -> expr - expr .)
    <               reduce using rule 68 (binary_expr -> expr - expr .)
    -               reduce using rule 68 (binary_expr -> expr - expr .)
    +               reduce using rule 68 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 68 (binary_expr -> expr - expr .)
    $end            reduce using rule 68 (binary_expr -> expr - expr .)
    )               reduce using rule 68 (binary_expr -> expr - expr .)
    OF              reduce using rule 68 (binary_expr -> expr - expr .)
    THEN            reduce using rule 68 (binary_expr -> expr - expr .)
    END             reduce using rule 68 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 68 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 68 (binary_expr -> expr - expr .)
    ,               reduce using rule 68 (binary_expr -> expr - expr .)
    ]               reduce using rule 68 (binary_expr -> expr - expr .)
    (               shift and go to state 43
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    *               shift and go to state 77
    /               shift and go to state 78


state 178

    (69) binary_expr -> expr + expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_MORE      reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_MORE_OR_EQ reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_LESS      reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_LESS_OR_EQ reduce using rule 69 (binary_expr -> expr + expr .)
    SOME_SUB        reduce using rule 69 (binary_expr -> expr + expr .)
    SOME_CONCAT     reduce using rule 69 (binary_expr -> expr + expr .)
    ARROW_BOTH      reduce using rule 69 (binary_expr -> expr + expr .)
    ARROW_RIGHT     reduce using rule 69 (binary_expr -> expr + expr .)
    ARROW_LEFT      reduce using rule 69 (binary_expr -> expr + expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 69 (binary_expr -> expr + expr .)
    DOUBLE_ARROW_LEFT reduce using rule 69 (binary_expr -> expr + expr .)
    BIT_SHIFT_LEFT  reduce using rule 69 (binary_expr -> expr + expr .)
    BIT_AND         reduce using rule 69 (binary_expr -> expr + expr .)
    BIT_OR          reduce using rule 69 (binary_expr -> expr + expr .)
    ARRAY_SUB       reduce using rule 69 (binary_expr -> expr + expr .)
    ARRAY_CONCAT    reduce using rule 69 (binary_expr -> expr + expr .)
    MORE_OR_EQ      reduce using rule 69 (binary_expr -> expr + expr .)
    LESS_OR_EQ      reduce using rule 69 (binary_expr -> expr + expr .)
    TEXT_MATCH      reduce using rule 69 (binary_expr -> expr + expr .)
    STRICT_AND      reduce using rule 69 (binary_expr -> expr + expr .)
    AND             reduce using rule 69 (binary_expr -> expr + expr .)
    STRICT_OR       reduce using rule 69 (binary_expr -> expr + expr .)
    OR              reduce using rule 69 (binary_expr -> expr + expr .)
    EQUAL           reduce using rule 69 (binary_expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 69 (binary_expr -> expr + expr .)
    >               reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_SUB       reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_SUM       reduce using rule 69 (binary_expr -> expr + expr .)
    <               reduce using rule 69 (binary_expr -> expr + expr .)
    -               reduce using rule 69 (binary_expr -> expr + expr .)
    +               reduce using rule 69 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 69 (binary_expr -> expr + expr .)
    $end            reduce using rule 69 (binary_expr -> expr + expr .)
    )               reduce using rule 69 (binary_expr -> expr + expr .)
    OF              reduce using rule 69 (binary_expr -> expr + expr .)
    THEN            reduce using rule 69 (binary_expr -> expr + expr .)
    END             reduce using rule 69 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 69 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 69 (binary_expr -> expr + expr .)
    ,               reduce using rule 69 (binary_expr -> expr + expr .)
    ]               reduce using rule 69 (binary_expr -> expr + expr .)
    (               shift and go to state 43
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    *               shift and go to state 77
    /               shift and go to state 78


state 179

    (70) binary_expr -> expr CONCAT expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    FLOAT_MORE      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    FLOAT_LESS      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ARROW_BOTH      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ARROW_RIGHT     reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ARROW_LEFT      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    BIT_AND         reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    BIT_OR          reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    MORE_OR_EQ      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    LESS_OR_EQ      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    TEXT_MATCH      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    STRICT_AND      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    AND             reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    STRICT_OR       reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    OR              reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    EQUAL           reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    NOT_EQUAL       reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 180

    (10) expr -> ( expr ) .
    NEWLINE         reduce using rule 10 (expr -> ( expr ) .)
    (               reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_MORE      reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_MORE_OR_EQ reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_LESS      reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_LESS_OR_EQ reduce using rule 10 (expr -> ( expr ) .)
    SOME_SUB        reduce using rule 10 (expr -> ( expr ) .)
    SOME_CONCAT     reduce using rule 10 (expr -> ( expr ) .)
    ARROW_BOTH      reduce using rule 10 (expr -> ( expr ) .)
    ARROW_RIGHT     reduce using rule 10 (expr -> ( expr ) .)
    ARROW_LEFT      reduce using rule 10 (expr -> ( expr ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 10 (expr -> ( expr ) .)
    DOUBLE_ARROW_LEFT reduce using rule 10 (expr -> ( expr ) .)
    BIT_SHIFT_LEFT  reduce using rule 10 (expr -> ( expr ) .)
    BIT_AND         reduce using rule 10 (expr -> ( expr ) .)
    BIT_OR          reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_POW       reduce using rule 10 (expr -> ( expr ) .)
    POW             reduce using rule 10 (expr -> ( expr ) .)
    ARRAY_SUB       reduce using rule 10 (expr -> ( expr ) .)
    ARRAY_CONCAT    reduce using rule 10 (expr -> ( expr ) .)
    MORE_OR_EQ      reduce using rule 10 (expr -> ( expr ) .)
    LESS_OR_EQ      reduce using rule 10 (expr -> ( expr ) .)
    TEXT_MATCH      reduce using rule 10 (expr -> ( expr ) .)
    STRICT_AND      reduce using rule 10 (expr -> ( expr ) .)
    AND             reduce using rule 10 (expr -> ( expr ) .)
    STRICT_OR       reduce using rule 10 (expr -> ( expr ) .)
    OR              reduce using rule 10 (expr -> ( expr ) .)
    EQUAL           reduce using rule 10 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 10 (expr -> ( expr ) .)
    >               reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_MUL       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_DIV       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_SUB       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_SUM       reduce using rule 10 (expr -> ( expr ) .)
    <               reduce using rule 10 (expr -> ( expr ) .)
    *               reduce using rule 10 (expr -> ( expr ) .)
    /               reduce using rule 10 (expr -> ( expr ) .)
    -               reduce using rule 10 (expr -> ( expr ) .)
    +               reduce using rule 10 (expr -> ( expr ) .)
    CONCAT          reduce using rule 10 (expr -> ( expr ) .)
    $end            reduce using rule 10 (expr -> ( expr ) .)
    )               reduce using rule 10 (expr -> ( expr ) .)
    OF              reduce using rule 10 (expr -> ( expr ) .)
    THEN            reduce using rule 10 (expr -> ( expr ) .)
    END             reduce using rule 10 (expr -> ( expr ) .)
    ELIF            reduce using rule 10 (expr -> ( expr ) .)
    ELSE            reduce using rule 10 (expr -> ( expr ) .)
    ,               reduce using rule 10 (expr -> ( expr ) .)
    ]               reduce using rule 10 (expr -> ( expr ) .)


state 181

    (268) let -> identifier : type_identifier . < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (167) type -> type_identifier . < type _26_0x2c_type_repeat >
    (173) type -> type_identifier .
    <               shift and go to state 204
    =               reduce using rule 173 (type -> type_identifier .)


state 182

    (275) _58_0x3a_type_optional -> : type .
    =               reduce using rule 275 (_58_0x3a_type_optional -> : type .)


state 183

    (274) let -> identifier _58_0x3a_type_optional = . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    identifier                     shift and go to state 15
    expr                           shift and go to state 205
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 184

    (109) binary_op_def -> DEF binary_op ( . _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (110) _4_NEWLINE_optional -> . NEWLINE
    (111) _4_NEWLINE_optional -> .
    NEWLINE         shift and go to state 207
    IDENTIFIER      reduce using rule 111 (_4_NEWLINE_optional -> .)

    _4_NEWLINE_optional            shift and go to state 206

state 185

    (118) binary_op_def -> DEF binary_op < . type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 208

state 186

    (140) def_expr -> DEF identifier ( . _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (141) _16_NEWLINE_optional -> . NEWLINE
    (142) _16_NEWLINE_optional -> .
    NEWLINE         shift and go to state 210
    IDENTIFIER      reduce using rule 142 (_16_NEWLINE_optional -> .)
    )               reduce using rule 142 (_16_NEWLINE_optional -> .)

    _16_NEWLINE_optional           shift and go to state 209

state 187

    (147) def_expr -> DEF identifier < . type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 211

state 188

    (242) array -> [ _48_NEWLINE_optional _49_exprs_optional . ]
    ]               shift and go to state 212


state 189

    (245) _49_exprs_optional -> exprs .
    (260) exprs -> exprs . , _55_NEWLINE_optional expr _56_NEWLINE_optional
    ]               reduce using rule 245 (_49_exprs_optional -> exprs .)
    ,               shift and go to state 213


state 190

    (257) exprs -> expr . _54_NEWLINE_optional
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    (258) _54_NEWLINE_optional -> . NEWLINE
    (259) _54_NEWLINE_optional -> .
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    BIT_OR          shift and go to state 57
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    STRICT_OR       shift and go to state 67
    OR              shift and go to state 68
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81
    NEWLINE         shift and go to state 215
    ,               reduce using rule 259 (_54_NEWLINE_optional -> .)
    ]               reduce using rule 259 (_54_NEWLINE_optional -> .)
    )               reduce using rule 259 (_54_NEWLINE_optional -> .)

    _54_NEWLINE_optional           shift and go to state 214

state 191

    (252) variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional . _53_exprs_optional )
    (255) _53_exprs_optional -> . exprs
    (256) _53_exprs_optional -> .
    (257) exprs -> . expr _54_NEWLINE_optional
    (260) exprs -> . exprs , _55_NEWLINE_optional expr _56_NEWLINE_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    )               reduce using rule 256 (_53_exprs_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    _53_exprs_optional             shift and go to state 216
    exprs                          shift and go to state 217
    expr                           shift and go to state 190
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 192

    (253) _52_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 253 (_52_NEWLINE_optional -> NEWLINE .)


state 193

    (214) case_of -> CASE expr OF . _39_NEWLINE_optional _40_cases_optional END
    (215) _39_NEWLINE_optional -> . NEWLINE
    (216) _39_NEWLINE_optional -> .
    NEWLINE         shift and go to state 219
    TYPE_IDENTIFIER reduce using rule 216 (_39_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 216 (_39_NEWLINE_optional -> .)
    END             reduce using rule 216 (_39_NEWLINE_optional -> .)

    _39_NEWLINE_optional           shift and go to state 218

state 194

    (205) if_expr -> IF expr THEN . _36_0x3a_type_optional block_statement _37_or_else_optional END
    (206) _36_0x3a_type_optional -> . : type
    (207) _36_0x3a_type_optional -> .
    :               shift and go to state 221
    NEWLINE         reduce using rule 207 (_36_0x3a_type_optional -> .)
    ELIF            reduce using rule 207 (_36_0x3a_type_optional -> .)
    ELSE            reduce using rule 207 (_36_0x3a_type_optional -> .)
    END             reduce using rule 207 (_36_0x3a_type_optional -> .)
    (               reduce using rule 207 (_36_0x3a_type_optional -> .)
    DEF             reduce using rule 207 (_36_0x3a_type_optional -> .)
    +               reduce using rule 207 (_36_0x3a_type_optional -> .)
    !               reduce using rule 207 (_36_0x3a_type_optional -> .)
    STRICT_NOT      reduce using rule 207 (_36_0x3a_type_optional -> .)
    -               reduce using rule 207 (_36_0x3a_type_optional -> .)
    STRING          reduce using rule 207 (_36_0x3a_type_optional -> .)
    FLOAT           reduce using rule 207 (_36_0x3a_type_optional -> .)
    INT             reduce using rule 207 (_36_0x3a_type_optional -> .)
    [               reduce using rule 207 (_36_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 207 (_36_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 207 (_36_0x3a_type_optional -> .)
    CASE            reduce using rule 207 (_36_0x3a_type_optional -> .)
    IF              reduce using rule 207 (_36_0x3a_type_optional -> .)
    DO              reduce using rule 207 (_36_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 207 (_36_0x3a_type_optional -> .)
    ENUM            reduce using rule 207 (_36_0x3a_type_optional -> .)

    _36_0x3a_type_optional         shift and go to state 220

state 195

    (132) do -> DO _13_0x3a_type_optional block_statement . END
    END             shift and go to state 222


state 196

    (135) block_statement -> _14_NEWLINE_optional . _15_do_exprs_optional
    (138) _15_do_exprs_optional -> . do_exprs
    (139) _15_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    END             reduce using rule 139 (_15_do_exprs_optional -> .)
    ELIF            reduce using rule 139 (_15_do_exprs_optional -> .)
    ELSE            reduce using rule 139 (_15_do_exprs_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    _15_do_exprs_optional          shift and go to state 223
    do_exprs                       shift and go to state 224
    expr                           shift and go to state 6
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 197

    (136) _14_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 136 (_14_NEWLINE_optional -> NEWLINE .)


state 198

    (133) _13_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    END             reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    (               reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    DEF             reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    +               reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    !               reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    STRICT_NOT      reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    -               reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    STRING          reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    FLOAT           reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    INT             reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    [               reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    CASE            reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    IF              reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    DO              reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 133 (_13_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 133 (_13_0x3a_type_optional -> : type .)


state 199

    (167) type -> type_identifier . < type _26_0x2c_type_repeat >
    (173) type -> type_identifier .
    <               shift and go to state 225
    NEWLINE         reduce using rule 173 (type -> type_identifier .)
    END             reduce using rule 173 (type -> type_identifier .)
    (               reduce using rule 173 (type -> type_identifier .)
    DEF             reduce using rule 173 (type -> type_identifier .)
    +               reduce using rule 173 (type -> type_identifier .)
    !               reduce using rule 173 (type -> type_identifier .)
    STRICT_NOT      reduce using rule 173 (type -> type_identifier .)
    -               reduce using rule 173 (type -> type_identifier .)
    STRING          reduce using rule 173 (type -> type_identifier .)
    FLOAT           reduce using rule 173 (type -> type_identifier .)
    INT             reduce using rule 173 (type -> type_identifier .)
    [               reduce using rule 173 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 173 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 173 (type -> type_identifier .)
    CASE            reduce using rule 173 (type -> type_identifier .)
    IF              reduce using rule 173 (type -> type_identifier .)
    DO              reduce using rule 173 (type -> type_identifier .)
    EXTERNAL        reduce using rule 173 (type -> type_identifier .)
    ENUM            reduce using rule 173 (type -> type_identifier .)
    ,               reduce using rule 173 (type -> type_identifier .)
    MORE_OR_EQ      reduce using rule 173 (type -> type_identifier .)
    >               reduce using rule 173 (type -> type_identifier .)
    ELIF            reduce using rule 173 (type -> type_identifier .)
    ELSE            reduce using rule 173 (type -> type_identifier .)
    )               reduce using rule 173 (type -> type_identifier .)


state 200

    (174) enum -> ENUM type_identifier { . _27_NEWLINE_optional _28_variants_optional }
    (175) _27_NEWLINE_optional -> . NEWLINE
    (176) _27_NEWLINE_optional -> .
    NEWLINE         shift and go to state 227
    TYPE_IDENTIFIER reduce using rule 176 (_27_NEWLINE_optional -> .)
    }               reduce using rule 176 (_27_NEWLINE_optional -> .)

    _27_NEWLINE_optional           shift and go to state 226

state 201

    (179) enum -> ENUM type_identifier < . type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 228

state 202

    (247) call -> expr ( _50_NEWLINE_optional _51_exprs_optional . )
    )               shift and go to state 229


state 203

    (250) _51_exprs_optional -> exprs .
    (260) exprs -> exprs . , _55_NEWLINE_optional expr _56_NEWLINE_optional
    )               reduce using rule 250 (_51_exprs_optional -> exprs .)
    ,               shift and go to state 213


state 204

    (268) let -> identifier : type_identifier < . type _57_0x2c_type_repeat MORE_OR_EQ expr
    (167) type -> type_identifier < . type _26_0x2c_type_repeat >
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 199
    type                           shift and go to state 230

state 205

    (274) let -> identifier _58_0x3a_type_optional = expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    $end            reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    )               reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    OF              reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    THEN            reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    END             reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    ELIF            reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    ELSE            reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    ,               reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    ]               reduce using rule 274 (let -> identifier _58_0x3a_type_optional = expr .)
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    BIT_OR          shift and go to state 57
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    STRICT_OR       shift and go to state 67
    OR              shift and go to state 68
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 206

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional . param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (202) param -> . identifier _35_0x3a_type_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 231
    identifier                     shift and go to state 232

state 207

    (110) _4_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 110 (_4_NEWLINE_optional -> NEWLINE .)


state 208

    (118) binary_op_def -> DEF binary_op < type_identifier . _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (119) _8_0x2c_type_identifier_repeat -> . _8_0x2c_type_identifier_items
    (120) _8_0x2c_type_identifier_repeat -> .
    (121) _8_0x2c_type_identifier_items -> . _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item
    (122) _8_0x2c_type_identifier_items -> . _8_0x2c_type_identifier_item
    (123) _8_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 120 (_8_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 234

    _8_0x2c_type_identifier_repeat shift and go to state 233
    _8_0x2c_type_identifier_items  shift and go to state 235
    _8_0x2c_type_identifier_item   shift and go to state 236

state 209

    (140) def_expr -> DEF identifier ( _16_NEWLINE_optional . _17_params_optional ) _18_0x3a_type_optional do
    (143) _17_params_optional -> . params
    (144) _17_params_optional -> .
    (159) params -> . param _23_NEWLINE_optional
    (162) params -> . params , _24_NEWLINE_optional param _25_NEWLINE_optional
    (202) param -> . identifier _35_0x3a_type_optional
    (265) identifier -> . IDENTIFIER
    )               reduce using rule 144 (_17_params_optional -> .)
    IDENTIFIER      shift and go to state 35

    identifier                     shift and go to state 232
    _17_params_optional            shift and go to state 237
    params                         shift and go to state 238
    param                          shift and go to state 239

state 210

    (141) _16_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 141 (_16_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 141 (_16_NEWLINE_optional -> NEWLINE .)


state 211

    (147) def_expr -> DEF identifier < type_identifier . _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (148) _19_0x2c_type_identifier_repeat -> . _19_0x2c_type_identifier_items
    (149) _19_0x2c_type_identifier_repeat -> .
    (150) _19_0x2c_type_identifier_items -> . _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item
    (151) _19_0x2c_type_identifier_items -> . _19_0x2c_type_identifier_item
    (152) _19_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 149 (_19_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 243

    _19_0x2c_type_identifier_repeat shift and go to state 240
    _19_0x2c_type_identifier_items shift and go to state 241
    _19_0x2c_type_identifier_item  shift and go to state 242

state 212

    (242) array -> [ _48_NEWLINE_optional _49_exprs_optional ] .
    NEWLINE         reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    (               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_MORE      reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_MORE_OR_EQ reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_LESS      reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_LESS_OR_EQ reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    SOME_SUB        reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    SOME_CONCAT     reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ARROW_BOTH      reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ARROW_RIGHT     reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ARROW_LEFT      reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    DOUBLE_ARROW_RIGHT reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    DOUBLE_ARROW_LEFT reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    BIT_SHIFT_LEFT  reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    BIT_AND         reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    BIT_OR          reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_POW       reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    POW             reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ARRAY_SUB       reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ARRAY_CONCAT    reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    MORE_OR_EQ      reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    LESS_OR_EQ      reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    TEXT_MATCH      reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    STRICT_AND      reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    AND             reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    STRICT_OR       reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    OR              reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    EQUAL           reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    NOT_EQUAL       reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    >               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_MUL       reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_DIV       reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_SUB       reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    FLOAT_SUM       reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    <               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    *               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    /               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    -               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    +               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    CONCAT          reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    $end            reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    )               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    OF              reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    THEN            reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    END             reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ELIF            reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ELSE            reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ,               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)
    ]               reduce using rule 242 (array -> [ _48_NEWLINE_optional _49_exprs_optional ] .)


state 213

    (260) exprs -> exprs , . _55_NEWLINE_optional expr _56_NEWLINE_optional
    (261) _55_NEWLINE_optional -> . NEWLINE
    (262) _55_NEWLINE_optional -> .
    NEWLINE         shift and go to state 245
    (               reduce using rule 262 (_55_NEWLINE_optional -> .)
    DEF             reduce using rule 262 (_55_NEWLINE_optional -> .)
    +               reduce using rule 262 (_55_NEWLINE_optional -> .)
    !               reduce using rule 262 (_55_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 262 (_55_NEWLINE_optional -> .)
    -               reduce using rule 262 (_55_NEWLINE_optional -> .)
    STRING          reduce using rule 262 (_55_NEWLINE_optional -> .)
    FLOAT           reduce using rule 262 (_55_NEWLINE_optional -> .)
    INT             reduce using rule 262 (_55_NEWLINE_optional -> .)
    [               reduce using rule 262 (_55_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 262 (_55_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 262 (_55_NEWLINE_optional -> .)
    CASE            reduce using rule 262 (_55_NEWLINE_optional -> .)
    IF              reduce using rule 262 (_55_NEWLINE_optional -> .)
    DO              reduce using rule 262 (_55_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 262 (_55_NEWLINE_optional -> .)
    ENUM            reduce using rule 262 (_55_NEWLINE_optional -> .)

    _55_NEWLINE_optional           shift and go to state 244

state 214

    (257) exprs -> expr _54_NEWLINE_optional .
    ,               reduce using rule 257 (exprs -> expr _54_NEWLINE_optional .)
    ]               reduce using rule 257 (exprs -> expr _54_NEWLINE_optional .)
    )               reduce using rule 257 (exprs -> expr _54_NEWLINE_optional .)


state 215

    (258) _54_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 258 (_54_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 258 (_54_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 258 (_54_NEWLINE_optional -> NEWLINE .)


state 216

    (252) variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional . )
    )               shift and go to state 246


state 217

    (255) _53_exprs_optional -> exprs .
    (260) exprs -> exprs . , _55_NEWLINE_optional expr _56_NEWLINE_optional
    )               reduce using rule 255 (_53_exprs_optional -> exprs .)
    ,               shift and go to state 213


state 218

    (214) case_of -> CASE expr OF _39_NEWLINE_optional . _40_cases_optional END
    (217) _40_cases_optional -> . cases
    (218) _40_cases_optional -> .
    (219) cases -> . pattern do _41_NEWLINE_optional
    (222) cases -> . cases pattern do _42_NEWLINE_optional
    (225) pattern -> . match_variant
    (226) pattern -> . match_as
    (228) match_variant -> . TYPE_IDENTIFIER
    (229) match_variant -> . TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional )
    (227) match_as -> . identifier
    (265) identifier -> . IDENTIFIER
    END             reduce using rule 218 (_40_cases_optional -> .)
    TYPE_IDENTIFIER shift and go to state 252
    IDENTIFIER      shift and go to state 35

    _40_cases_optional             shift and go to state 247
    cases                          shift and go to state 248
    pattern                        shift and go to state 249
    match_variant                  shift and go to state 250
    match_as                       shift and go to state 251
    identifier                     shift and go to state 253

state 219

    (215) _39_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 215 (_39_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 215 (_39_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 215 (_39_NEWLINE_optional -> NEWLINE .)


state 220

    (205) if_expr -> IF expr THEN _36_0x3a_type_optional . block_statement _37_or_else_optional END
    (135) block_statement -> . _14_NEWLINE_optional _15_do_exprs_optional
    (136) _14_NEWLINE_optional -> . NEWLINE
    (137) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 197
    (               reduce using rule 137 (_14_NEWLINE_optional -> .)
    DEF             reduce using rule 137 (_14_NEWLINE_optional -> .)
    +               reduce using rule 137 (_14_NEWLINE_optional -> .)
    !               reduce using rule 137 (_14_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 137 (_14_NEWLINE_optional -> .)
    -               reduce using rule 137 (_14_NEWLINE_optional -> .)
    STRING          reduce using rule 137 (_14_NEWLINE_optional -> .)
    FLOAT           reduce using rule 137 (_14_NEWLINE_optional -> .)
    INT             reduce using rule 137 (_14_NEWLINE_optional -> .)
    [               reduce using rule 137 (_14_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 137 (_14_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 137 (_14_NEWLINE_optional -> .)
    CASE            reduce using rule 137 (_14_NEWLINE_optional -> .)
    IF              reduce using rule 137 (_14_NEWLINE_optional -> .)
    DO              reduce using rule 137 (_14_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 137 (_14_NEWLINE_optional -> .)
    ENUM            reduce using rule 137 (_14_NEWLINE_optional -> .)
    ELIF            reduce using rule 137 (_14_NEWLINE_optional -> .)
    ELSE            reduce using rule 137 (_14_NEWLINE_optional -> .)
    END             reduce using rule 137 (_14_NEWLINE_optional -> .)

    block_statement                shift and go to state 254
    _14_NEWLINE_optional           shift and go to state 196

state 221

    (206) _36_0x3a_type_optional -> : . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 255
    type_identifier                shift and go to state 199

state 222

    (132) do -> DO _13_0x3a_type_optional block_statement END .
    NEWLINE         reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    (               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_MORE      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_MORE_OR_EQ reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_LESS      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_LESS_OR_EQ reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    SOME_SUB        reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    SOME_CONCAT     reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARROW_BOTH      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARROW_RIGHT     reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARROW_LEFT      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    DOUBLE_ARROW_RIGHT reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    DOUBLE_ARROW_LEFT reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    BIT_SHIFT_LEFT  reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    BIT_AND         reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    BIT_OR          reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_POW       reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    POW             reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARRAY_SUB       reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ARRAY_CONCAT    reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    MORE_OR_EQ      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    LESS_OR_EQ      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    TEXT_MATCH      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    STRICT_AND      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    AND             reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    STRICT_OR       reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    OR              reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    EQUAL           reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    NOT_EQUAL       reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    >               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_MUL       reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_DIV       reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_SUB       reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    FLOAT_SUM       reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    <               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    *               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    /               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    -               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    +               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    CONCAT          reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    $end            reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    )               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    OF              reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    THEN            reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    END             reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ELIF            reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ELSE            reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ,               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    ]               reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    TYPE_IDENTIFIER reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)
    IDENTIFIER      reduce using rule 132 (do -> DO _13_0x3a_type_optional block_statement END .)


state 223

    (135) block_statement -> _14_NEWLINE_optional _15_do_exprs_optional .
    END             reduce using rule 135 (block_statement -> _14_NEWLINE_optional _15_do_exprs_optional .)
    ELIF            reduce using rule 135 (block_statement -> _14_NEWLINE_optional _15_do_exprs_optional .)
    ELSE            reduce using rule 135 (block_statement -> _14_NEWLINE_optional _15_do_exprs_optional .)


state 224

    (138) _15_do_exprs_optional -> do_exprs .
    END             reduce using rule 138 (_15_do_exprs_optional -> do_exprs .)
    ELIF            reduce using rule 138 (_15_do_exprs_optional -> do_exprs .)
    ELSE            reduce using rule 138 (_15_do_exprs_optional -> do_exprs .)


state 225

    (167) type -> type_identifier < . type _26_0x2c_type_repeat >
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 199
    type                           shift and go to state 256

state 226

    (174) enum -> ENUM type_identifier { _27_NEWLINE_optional . _28_variants_optional }
    (177) _28_variants_optional -> . variants
    (178) _28_variants_optional -> .
    (189) variants -> . variant _32_NEWLINE_optional
    (192) variants -> . variants variant _33_NEWLINE_optional
    (195) variant -> . TYPE_IDENTIFIER
    (196) variant -> . TYPE_IDENTIFIER ( type _34_0x2c_type_repeat )
    }               reduce using rule 178 (_28_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 260

    _28_variants_optional          shift and go to state 257
    variants                       shift and go to state 258
    variant                        shift and go to state 259

state 227

    (175) _27_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 175 (_27_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 175 (_27_NEWLINE_optional -> NEWLINE .)


state 228

    (179) enum -> ENUM type_identifier < type_identifier . _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (180) _29_0x2c_type_identifier_repeat -> . _29_0x2c_type_identifier_items
    (181) _29_0x2c_type_identifier_repeat -> .
    (182) _29_0x2c_type_identifier_items -> . _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item
    (183) _29_0x2c_type_identifier_items -> . _29_0x2c_type_identifier_item
    (184) _29_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 181 (_29_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 264

    _29_0x2c_type_identifier_repeat shift and go to state 261
    _29_0x2c_type_identifier_items shift and go to state 262
    _29_0x2c_type_identifier_item  shift and go to state 263

state 229

    (247) call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .
    NEWLINE         reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    (               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_MORE      reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_MORE_OR_EQ reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_LESS      reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_LESS_OR_EQ reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    SOME_SUB        reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    SOME_CONCAT     reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ARROW_BOTH      reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ARROW_RIGHT     reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ARROW_LEFT      reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    DOUBLE_ARROW_LEFT reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    BIT_SHIFT_LEFT  reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    BIT_AND         reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    BIT_OR          reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_POW       reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    POW             reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ARRAY_SUB       reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ARRAY_CONCAT    reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    MORE_OR_EQ      reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    LESS_OR_EQ      reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    TEXT_MATCH      reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    STRICT_AND      reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    AND             reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    STRICT_OR       reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    OR              reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    EQUAL           reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    >               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_MUL       reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_DIV       reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_SUB       reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    FLOAT_SUM       reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    <               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    *               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    /               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    -               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    +               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    CONCAT          reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    $end            reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    )               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    OF              reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    THEN            reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    END             reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ELIF            reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ELSE            reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ,               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)
    ]               reduce using rule 247 (call -> expr ( _50_NEWLINE_optional _51_exprs_optional ) .)


state 230

    (268) let -> identifier : type_identifier < type . _57_0x2c_type_repeat MORE_OR_EQ expr
    (167) type -> type_identifier < type . _26_0x2c_type_repeat >
    (269) _57_0x2c_type_repeat -> . _57_0x2c_type_items
    (270) _57_0x2c_type_repeat -> .
    (168) _26_0x2c_type_repeat -> . _26_0x2c_type_items
    (169) _26_0x2c_type_repeat -> .
    (271) _57_0x2c_type_items -> . _57_0x2c_type_items _57_0x2c_type_item
    (272) _57_0x2c_type_items -> . _57_0x2c_type_item
    (170) _26_0x2c_type_items -> . _26_0x2c_type_items _26_0x2c_type_item
    (171) _26_0x2c_type_items -> . _26_0x2c_type_item
    (273) _57_0x2c_type_item -> . , type
    (172) _26_0x2c_type_item -> . , type
    MORE_OR_EQ      reduce using rule 270 (_57_0x2c_type_repeat -> .)
    >               reduce using rule 169 (_26_0x2c_type_repeat -> .)
    ,               shift and go to state 271

    _57_0x2c_type_repeat           shift and go to state 265
    _26_0x2c_type_repeat           shift and go to state 266
    _57_0x2c_type_items            shift and go to state 267
    _26_0x2c_type_items            shift and go to state 268
    _57_0x2c_type_item             shift and go to state 269
    _26_0x2c_type_item             shift and go to state 270

state 231

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param . , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    ,               shift and go to state 272


state 232

    (202) param -> identifier . _35_0x3a_type_optional
    (203) _35_0x3a_type_optional -> . : type
    (204) _35_0x3a_type_optional -> .
    :               shift and go to state 274
    ,               reduce using rule 204 (_35_0x3a_type_optional -> .)
    NEWLINE         reduce using rule 204 (_35_0x3a_type_optional -> .)
    )               reduce using rule 204 (_35_0x3a_type_optional -> .)

    _35_0x3a_type_optional         shift and go to state 273

state 233

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat . > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    >               shift and go to state 275


state 234

    (123) _8_0x2c_type_identifier_item -> , . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 276

state 235

    (119) _8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items .
    (121) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items . _8_0x2c_type_identifier_item
    (123) _8_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 119 (_8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items .)
    ,               shift and go to state 234

    _8_0x2c_type_identifier_item   shift and go to state 277

state 236

    (122) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .
    ,               reduce using rule 122 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .)
    >               reduce using rule 122 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .)


state 237

    (140) def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional . ) _18_0x3a_type_optional do
    )               shift and go to state 278


state 238

    (143) _17_params_optional -> params .
    (162) params -> params . , _24_NEWLINE_optional param _25_NEWLINE_optional
    )               reduce using rule 143 (_17_params_optional -> params .)
    ,               shift and go to state 279


state 239

    (159) params -> param . _23_NEWLINE_optional
    (160) _23_NEWLINE_optional -> . NEWLINE
    (161) _23_NEWLINE_optional -> .
    NEWLINE         shift and go to state 281
    ,               reduce using rule 161 (_23_NEWLINE_optional -> .)
    )               reduce using rule 161 (_23_NEWLINE_optional -> .)

    _23_NEWLINE_optional           shift and go to state 280

state 240

    (147) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat . > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    >               shift and go to state 282


state 241

    (148) _19_0x2c_type_identifier_repeat -> _19_0x2c_type_identifier_items .
    (150) _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items . _19_0x2c_type_identifier_item
    (152) _19_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 148 (_19_0x2c_type_identifier_repeat -> _19_0x2c_type_identifier_items .)
    ,               shift and go to state 243

    _19_0x2c_type_identifier_item  shift and go to state 283

state 242

    (151) _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_item .
    ,               reduce using rule 151 (_19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_item .)
    >               reduce using rule 151 (_19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_item .)


state 243

    (152) _19_0x2c_type_identifier_item -> , . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 284

state 244

    (260) exprs -> exprs , _55_NEWLINE_optional . expr _56_NEWLINE_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 285
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 245

    (261) _55_NEWLINE_optional -> NEWLINE .
    (               reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    +               reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    !               reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    -               reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    FLOAT           reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    INT             reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 261 (_55_NEWLINE_optional -> NEWLINE .)


state 246

    (252) variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .
    NEWLINE         reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    (               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_MORE      reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_MORE_OR_EQ reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_LESS      reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_LESS_OR_EQ reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    SOME_SUB        reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    SOME_CONCAT     reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ARROW_BOTH      reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ARROW_RIGHT     reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ARROW_LEFT      reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    DOUBLE_ARROW_LEFT reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    BIT_SHIFT_LEFT  reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    BIT_AND         reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    BIT_OR          reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_POW       reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    POW             reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ARRAY_SUB       reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ARRAY_CONCAT    reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    MORE_OR_EQ      reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    LESS_OR_EQ      reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    TEXT_MATCH      reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    STRICT_AND      reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    AND             reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    STRICT_OR       reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    OR              reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    EQUAL           reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    >               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_MUL       reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_DIV       reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_SUB       reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    FLOAT_SUM       reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    <               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    *               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    /               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    -               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    +               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    CONCAT          reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    $end            reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    )               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    OF              reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    THEN            reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    END             reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ELIF            reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ELSE            reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ,               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)
    ]               reduce using rule 252 (variant_call -> TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional ) .)


state 247

    (214) case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional . END
    END             shift and go to state 286


state 248

    (217) _40_cases_optional -> cases .
    (222) cases -> cases . pattern do _42_NEWLINE_optional
    (225) pattern -> . match_variant
    (226) pattern -> . match_as
    (228) match_variant -> . TYPE_IDENTIFIER
    (229) match_variant -> . TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional )
    (227) match_as -> . identifier
    (265) identifier -> . IDENTIFIER
    END             reduce using rule 217 (_40_cases_optional -> cases .)
    TYPE_IDENTIFIER shift and go to state 252
    IDENTIFIER      shift and go to state 35

    pattern                        shift and go to state 287
    match_variant                  shift and go to state 250
    match_as                       shift and go to state 251
    identifier                     shift and go to state 253

state 249

    (219) cases -> pattern . do _41_NEWLINE_optional
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 288

state 250

    (225) pattern -> match_variant .
    DO              reduce using rule 225 (pattern -> match_variant .)
    NEWLINE         reduce using rule 225 (pattern -> match_variant .)
    ,               reduce using rule 225 (pattern -> match_variant .)
    )               reduce using rule 225 (pattern -> match_variant .)


state 251

    (226) pattern -> match_as .
    DO              reduce using rule 226 (pattern -> match_as .)
    NEWLINE         reduce using rule 226 (pattern -> match_as .)
    ,               reduce using rule 226 (pattern -> match_as .)
    )               reduce using rule 226 (pattern -> match_as .)


state 252

    (228) match_variant -> TYPE_IDENTIFIER .
    (229) match_variant -> TYPE_IDENTIFIER . ( _43_NEWLINE_optional _44_patterns_optional )
    DO              reduce using rule 228 (match_variant -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 228 (match_variant -> TYPE_IDENTIFIER .)
    ,               reduce using rule 228 (match_variant -> TYPE_IDENTIFIER .)
    )               reduce using rule 228 (match_variant -> TYPE_IDENTIFIER .)
    (               shift and go to state 289


state 253

    (227) match_as -> identifier .
    DO              reduce using rule 227 (match_as -> identifier .)
    NEWLINE         reduce using rule 227 (match_as -> identifier .)
    ,               reduce using rule 227 (match_as -> identifier .)
    )               reduce using rule 227 (match_as -> identifier .)


state 254

    (205) if_expr -> IF expr THEN _36_0x3a_type_optional block_statement . _37_or_else_optional END
    (208) _37_or_else_optional -> . or_else
    (209) _37_or_else_optional -> .
    (210) or_else -> . ELIF expr THEN block_statement _38_or_else_optional
    (213) or_else -> . ELSE block_statement
    END             reduce using rule 209 (_37_or_else_optional -> .)
    ELIF            shift and go to state 292
    ELSE            shift and go to state 293

    _37_or_else_optional           shift and go to state 290
    or_else                        shift and go to state 291

state 255

    (206) _36_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    ELIF            reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    ELSE            reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    END             reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    (               reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    DEF             reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    +               reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    !               reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    STRICT_NOT      reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    -               reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    STRING          reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    FLOAT           reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    INT             reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    [               reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    CASE            reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    IF              reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    DO              reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 206 (_36_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 206 (_36_0x3a_type_optional -> : type .)


state 256

    (167) type -> type_identifier < type . _26_0x2c_type_repeat >
    (168) _26_0x2c_type_repeat -> . _26_0x2c_type_items
    (169) _26_0x2c_type_repeat -> .
    (170) _26_0x2c_type_items -> . _26_0x2c_type_items _26_0x2c_type_item
    (171) _26_0x2c_type_items -> . _26_0x2c_type_item
    (172) _26_0x2c_type_item -> . , type
    >               reduce using rule 169 (_26_0x2c_type_repeat -> .)
    ,               shift and go to state 294

    _26_0x2c_type_repeat           shift and go to state 266
    _26_0x2c_type_items            shift and go to state 268
    _26_0x2c_type_item             shift and go to state 270

state 257

    (174) enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional . }
    }               shift and go to state 295


state 258

    (177) _28_variants_optional -> variants .
    (192) variants -> variants . variant _33_NEWLINE_optional
    (195) variant -> . TYPE_IDENTIFIER
    (196) variant -> . TYPE_IDENTIFIER ( type _34_0x2c_type_repeat )
    }               reduce using rule 177 (_28_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 260

    variant                        shift and go to state 296

state 259

    (189) variants -> variant . _32_NEWLINE_optional
    (190) _32_NEWLINE_optional -> . NEWLINE
    (191) _32_NEWLINE_optional -> .
    NEWLINE         shift and go to state 298
    TYPE_IDENTIFIER reduce using rule 191 (_32_NEWLINE_optional -> .)
    }               reduce using rule 191 (_32_NEWLINE_optional -> .)

    _32_NEWLINE_optional           shift and go to state 297

state 260

    (195) variant -> TYPE_IDENTIFIER .
    (196) variant -> TYPE_IDENTIFIER . ( type _34_0x2c_type_repeat )
    NEWLINE         reduce using rule 195 (variant -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 195 (variant -> TYPE_IDENTIFIER .)
    }               reduce using rule 195 (variant -> TYPE_IDENTIFIER .)
    (               shift and go to state 299


state 261

    (179) enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat . > { _30_NEWLINE_optional _31_variants_optional }
    >               shift and go to state 300


state 262

    (180) _29_0x2c_type_identifier_repeat -> _29_0x2c_type_identifier_items .
    (182) _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items . _29_0x2c_type_identifier_item
    (184) _29_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 180 (_29_0x2c_type_identifier_repeat -> _29_0x2c_type_identifier_items .)
    ,               shift and go to state 264

    _29_0x2c_type_identifier_item  shift and go to state 301

state 263

    (183) _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_item .
    ,               reduce using rule 183 (_29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_item .)
    >               reduce using rule 183 (_29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_item .)


state 264

    (184) _29_0x2c_type_identifier_item -> , . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type_identifier                shift and go to state 302

state 265

    (268) let -> identifier : type_identifier < type _57_0x2c_type_repeat . MORE_OR_EQ expr
    MORE_OR_EQ      shift and go to state 303


state 266

    (167) type -> type_identifier < type _26_0x2c_type_repeat . >
    >               shift and go to state 304


state 267

    (269) _57_0x2c_type_repeat -> _57_0x2c_type_items .
    (271) _57_0x2c_type_items -> _57_0x2c_type_items . _57_0x2c_type_item
    (273) _57_0x2c_type_item -> . , type
    MORE_OR_EQ      reduce using rule 269 (_57_0x2c_type_repeat -> _57_0x2c_type_items .)
    ,               shift and go to state 306

    _57_0x2c_type_item             shift and go to state 305

state 268

    (168) _26_0x2c_type_repeat -> _26_0x2c_type_items .
    (170) _26_0x2c_type_items -> _26_0x2c_type_items . _26_0x2c_type_item
    (172) _26_0x2c_type_item -> . , type
    >               reduce using rule 168 (_26_0x2c_type_repeat -> _26_0x2c_type_items .)
    ,               shift and go to state 294

    _26_0x2c_type_item             shift and go to state 307

state 269

    (272) _57_0x2c_type_items -> _57_0x2c_type_item .
    ,               reduce using rule 272 (_57_0x2c_type_items -> _57_0x2c_type_item .)
    MORE_OR_EQ      reduce using rule 272 (_57_0x2c_type_items -> _57_0x2c_type_item .)


state 270

    (171) _26_0x2c_type_items -> _26_0x2c_type_item .
    ,               reduce using rule 171 (_26_0x2c_type_items -> _26_0x2c_type_item .)
    >               reduce using rule 171 (_26_0x2c_type_items -> _26_0x2c_type_item .)


state 271

    (273) _57_0x2c_type_item -> , . type
    (172) _26_0x2c_type_item -> , . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 308
    type_identifier                shift and go to state 199

state 272

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , . _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (112) _5_NEWLINE_optional -> . NEWLINE
    (113) _5_NEWLINE_optional -> .
    NEWLINE         shift and go to state 310
    IDENTIFIER      reduce using rule 113 (_5_NEWLINE_optional -> .)

    _5_NEWLINE_optional            shift and go to state 309

state 273

    (202) param -> identifier _35_0x3a_type_optional .
    ,               reduce using rule 202 (param -> identifier _35_0x3a_type_optional .)
    NEWLINE         reduce using rule 202 (param -> identifier _35_0x3a_type_optional .)
    )               reduce using rule 202 (param -> identifier _35_0x3a_type_optional .)


state 274

    (203) _35_0x3a_type_optional -> : . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 311
    type_identifier                shift and go to state 199

state 275

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > . ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (               shift and go to state 312


state 276

    (123) _8_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 123 (_8_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 123 (_8_0x2c_type_identifier_item -> , type_identifier .)


state 277

    (121) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .
    ,               reduce using rule 121 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .)
    >               reduce using rule 121 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .)


state 278

    (140) def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) . _18_0x3a_type_optional do
    (145) _18_0x3a_type_optional -> . : type
    (146) _18_0x3a_type_optional -> .
    :               shift and go to state 314
    DO              reduce using rule 146 (_18_0x3a_type_optional -> .)

    _18_0x3a_type_optional         shift and go to state 313

state 279

    (162) params -> params , . _24_NEWLINE_optional param _25_NEWLINE_optional
    (163) _24_NEWLINE_optional -> . NEWLINE
    (164) _24_NEWLINE_optional -> .
    NEWLINE         shift and go to state 316
    IDENTIFIER      reduce using rule 164 (_24_NEWLINE_optional -> .)

    _24_NEWLINE_optional           shift and go to state 315

state 280

    (159) params -> param _23_NEWLINE_optional .
    ,               reduce using rule 159 (params -> param _23_NEWLINE_optional .)
    )               reduce using rule 159 (params -> param _23_NEWLINE_optional .)


state 281

    (160) _23_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 160 (_23_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 160 (_23_NEWLINE_optional -> NEWLINE .)


state 282

    (147) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > . ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (               shift and go to state 317


state 283

    (150) _19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item .
    ,               reduce using rule 150 (_19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item .)
    >               reduce using rule 150 (_19_0x2c_type_identifier_items -> _19_0x2c_type_identifier_items _19_0x2c_type_identifier_item .)


state 284

    (152) _19_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 152 (_19_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 152 (_19_0x2c_type_identifier_item -> , type_identifier .)


state 285

    (260) exprs -> exprs , _55_NEWLINE_optional expr . _56_NEWLINE_optional
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    (263) _56_NEWLINE_optional -> . NEWLINE
    (264) _56_NEWLINE_optional -> .
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    BIT_OR          shift and go to state 57
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    STRICT_OR       shift and go to state 67
    OR              shift and go to state 68
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81
    NEWLINE         shift and go to state 319
    ,               reduce using rule 264 (_56_NEWLINE_optional -> .)
    ]               reduce using rule 264 (_56_NEWLINE_optional -> .)
    )               reduce using rule 264 (_56_NEWLINE_optional -> .)

    _56_NEWLINE_optional           shift and go to state 318

state 286

    (214) case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .
    NEWLINE         reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    (               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_MORE      reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_MORE_OR_EQ reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_LESS      reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_LESS_OR_EQ reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    SOME_SUB        reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    SOME_CONCAT     reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ARROW_BOTH      reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ARROW_RIGHT     reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ARROW_LEFT      reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    DOUBLE_ARROW_RIGHT reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    DOUBLE_ARROW_LEFT reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    BIT_SHIFT_LEFT  reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    BIT_AND         reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    BIT_OR          reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_POW       reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    POW             reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ARRAY_SUB       reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ARRAY_CONCAT    reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    MORE_OR_EQ      reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    LESS_OR_EQ      reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    TEXT_MATCH      reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    STRICT_AND      reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    AND             reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    STRICT_OR       reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    OR              reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    EQUAL           reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    NOT_EQUAL       reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    >               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_MUL       reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_DIV       reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_SUB       reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    FLOAT_SUM       reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    <               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    *               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    /               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    -               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    +               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    CONCAT          reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    $end            reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    )               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    OF              reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    THEN            reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    END             reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ELIF            reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ELSE            reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ,               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)
    ]               reduce using rule 214 (case_of -> CASE expr OF _39_NEWLINE_optional _40_cases_optional END .)


state 287

    (222) cases -> cases pattern . do _42_NEWLINE_optional
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 320

state 288

    (219) cases -> pattern do . _41_NEWLINE_optional
    (220) _41_NEWLINE_optional -> . NEWLINE
    (221) _41_NEWLINE_optional -> .
    NEWLINE         shift and go to state 322
    TYPE_IDENTIFIER reduce using rule 221 (_41_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 221 (_41_NEWLINE_optional -> .)
    END             reduce using rule 221 (_41_NEWLINE_optional -> .)

    _41_NEWLINE_optional           shift and go to state 321

state 289

    (229) match_variant -> TYPE_IDENTIFIER ( . _43_NEWLINE_optional _44_patterns_optional )
    (230) _43_NEWLINE_optional -> . NEWLINE
    (231) _43_NEWLINE_optional -> .
    NEWLINE         shift and go to state 324
    TYPE_IDENTIFIER reduce using rule 231 (_43_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 231 (_43_NEWLINE_optional -> .)
    )               reduce using rule 231 (_43_NEWLINE_optional -> .)

    _43_NEWLINE_optional           shift and go to state 323

state 290

    (205) if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional . END
    END             shift and go to state 325


state 291

    (208) _37_or_else_optional -> or_else .
    END             reduce using rule 208 (_37_or_else_optional -> or_else .)


state 292

    (210) or_else -> ELIF . expr THEN block_statement _38_or_else_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    expr                           shift and go to state 326
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 293

    (213) or_else -> ELSE . block_statement
    (135) block_statement -> . _14_NEWLINE_optional _15_do_exprs_optional
    (136) _14_NEWLINE_optional -> . NEWLINE
    (137) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 197
    (               reduce using rule 137 (_14_NEWLINE_optional -> .)
    DEF             reduce using rule 137 (_14_NEWLINE_optional -> .)
    +               reduce using rule 137 (_14_NEWLINE_optional -> .)
    !               reduce using rule 137 (_14_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 137 (_14_NEWLINE_optional -> .)
    -               reduce using rule 137 (_14_NEWLINE_optional -> .)
    STRING          reduce using rule 137 (_14_NEWLINE_optional -> .)
    FLOAT           reduce using rule 137 (_14_NEWLINE_optional -> .)
    INT             reduce using rule 137 (_14_NEWLINE_optional -> .)
    [               reduce using rule 137 (_14_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 137 (_14_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 137 (_14_NEWLINE_optional -> .)
    CASE            reduce using rule 137 (_14_NEWLINE_optional -> .)
    IF              reduce using rule 137 (_14_NEWLINE_optional -> .)
    DO              reduce using rule 137 (_14_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 137 (_14_NEWLINE_optional -> .)
    ENUM            reduce using rule 137 (_14_NEWLINE_optional -> .)
    END             reduce using rule 137 (_14_NEWLINE_optional -> .)

    block_statement                shift and go to state 327
    _14_NEWLINE_optional           shift and go to state 196

state 294

    (172) _26_0x2c_type_item -> , . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 328
    type_identifier                shift and go to state 199

state 295

    (174) enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .
    NEWLINE         reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    (               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_MORE      reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_MORE_OR_EQ reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_LESS      reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_LESS_OR_EQ reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    SOME_SUB        reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    SOME_CONCAT     reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ARROW_BOTH      reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ARROW_RIGHT     reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ARROW_LEFT      reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    DOUBLE_ARROW_RIGHT reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    DOUBLE_ARROW_LEFT reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    BIT_SHIFT_LEFT  reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    BIT_AND         reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    BIT_OR          reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_POW       reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    POW             reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ARRAY_SUB       reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ARRAY_CONCAT    reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    MORE_OR_EQ      reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    LESS_OR_EQ      reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    TEXT_MATCH      reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    STRICT_AND      reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    AND             reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    STRICT_OR       reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    OR              reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    EQUAL           reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    NOT_EQUAL       reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    >               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_MUL       reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_DIV       reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_SUB       reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    FLOAT_SUM       reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    <               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    *               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    /               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    -               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    +               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    CONCAT          reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    $end            reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    )               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    OF              reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    THEN            reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    END             reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ELIF            reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ELSE            reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ,               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)
    ]               reduce using rule 174 (enum -> ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional } .)


state 296

    (192) variants -> variants variant . _33_NEWLINE_optional
    (193) _33_NEWLINE_optional -> . NEWLINE
    (194) _33_NEWLINE_optional -> .
    NEWLINE         shift and go to state 330
    TYPE_IDENTIFIER reduce using rule 194 (_33_NEWLINE_optional -> .)
    }               reduce using rule 194 (_33_NEWLINE_optional -> .)

    _33_NEWLINE_optional           shift and go to state 329

state 297

    (189) variants -> variant _32_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 189 (variants -> variant _32_NEWLINE_optional .)
    }               reduce using rule 189 (variants -> variant _32_NEWLINE_optional .)


state 298

    (190) _32_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 190 (_32_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 190 (_32_NEWLINE_optional -> NEWLINE .)


state 299

    (196) variant -> TYPE_IDENTIFIER ( . type _34_0x2c_type_repeat )
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 331
    type_identifier                shift and go to state 199

state 300

    (179) enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > . { _30_NEWLINE_optional _31_variants_optional }
    {               shift and go to state 332


state 301

    (182) _29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item .
    ,               reduce using rule 182 (_29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item .)
    >               reduce using rule 182 (_29_0x2c_type_identifier_items -> _29_0x2c_type_identifier_items _29_0x2c_type_identifier_item .)


state 302

    (184) _29_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 184 (_29_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 184 (_29_0x2c_type_identifier_item -> , type_identifier .)


state 303

    (268) let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (279) str_literal -> . STRING
    (278) float_literal -> . FLOAT
    (277) int_literal -> . INT
    (242) array -> . [ _48_NEWLINE_optional _49_exprs_optional ]
    (252) variant_call -> . TYPE_IDENTIFIER ( _52_NEWLINE_optional _53_exprs_optional )
    (265) identifier -> . IDENTIFIER
    (268) let -> . identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr
    (274) let -> . identifier _58_0x3a_type_optional = expr
    (247) call -> . expr ( _50_NEWLINE_optional _51_exprs_optional )
    (214) case_of -> . CASE expr OF _39_NEWLINE_optional _40_cases_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END
    (140) def_expr -> . DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_NEWLINE_optional _28_variants_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional }
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 26
    !               shift and go to state 27
    STRICT_NOT      shift and go to state 28
    -               shift and go to state 29
    STRING          shift and go to state 30
    FLOAT           shift and go to state 31
    INT             shift and go to state 32
    [               shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40

    identifier                     shift and go to state 15
    expr                           shift and go to state 333
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 304

    (167) type -> type_identifier < type _26_0x2c_type_repeat > .
    =               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    NEWLINE         reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    END             reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    (               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    DEF             reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    +               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    !               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    STRICT_NOT      reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    -               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    STRING          reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    FLOAT           reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    INT             reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    [               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    TYPE_IDENTIFIER reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    IDENTIFIER      reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    CASE            reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    IF              reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    DO              reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    EXTERNAL        reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    ENUM            reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    ,               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    MORE_OR_EQ      reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    >               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    ELIF            reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    ELSE            reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)
    )               reduce using rule 167 (type -> type_identifier < type _26_0x2c_type_repeat > .)


state 305

    (271) _57_0x2c_type_items -> _57_0x2c_type_items _57_0x2c_type_item .
    ,               reduce using rule 271 (_57_0x2c_type_items -> _57_0x2c_type_items _57_0x2c_type_item .)
    MORE_OR_EQ      reduce using rule 271 (_57_0x2c_type_items -> _57_0x2c_type_items _57_0x2c_type_item .)


state 306

    (273) _57_0x2c_type_item -> , . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 334
    type_identifier                shift and go to state 199

state 307

    (170) _26_0x2c_type_items -> _26_0x2c_type_items _26_0x2c_type_item .
    ,               reduce using rule 170 (_26_0x2c_type_items -> _26_0x2c_type_items _26_0x2c_type_item .)
    >               reduce using rule 170 (_26_0x2c_type_items -> _26_0x2c_type_items _26_0x2c_type_item .)


state 308

    (273) _57_0x2c_type_item -> , type .
    (172) _26_0x2c_type_item -> , type .
  ! reduce/reduce conflict for , resolved using rule 273 (_57_0x2c_type_item -> , type .)
    ,               reduce using rule 273 (_57_0x2c_type_item -> , type .)
    MORE_OR_EQ      reduce using rule 273 (_57_0x2c_type_item -> , type .)
    >               reduce using rule 172 (_26_0x2c_type_item -> , type .)


state 309

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional . param _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (202) param -> . identifier _35_0x3a_type_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 335
    identifier                     shift and go to state 232

state 310

    (112) _5_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 112 (_5_NEWLINE_optional -> NEWLINE .)


state 311

    (203) _35_0x3a_type_optional -> : type .
    ,               reduce using rule 203 (_35_0x3a_type_optional -> : type .)
    NEWLINE         reduce using rule 203 (_35_0x3a_type_optional -> : type .)
    )               reduce using rule 203 (_35_0x3a_type_optional -> : type .)


state 312

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( . _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (124) _9_NEWLINE_optional -> . NEWLINE
    (125) _9_NEWLINE_optional -> .
    NEWLINE         shift and go to state 337
    IDENTIFIER      reduce using rule 125 (_9_NEWLINE_optional -> .)

    _9_NEWLINE_optional            shift and go to state 336

state 313

    (140) def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional . do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 338

state 314

    (145) _18_0x3a_type_optional -> : . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 339
    type_identifier                shift and go to state 199

state 315

    (162) params -> params , _24_NEWLINE_optional . param _25_NEWLINE_optional
    (202) param -> . identifier _35_0x3a_type_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 340
    identifier                     shift and go to state 232

state 316

    (163) _24_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 163 (_24_NEWLINE_optional -> NEWLINE .)


state 317

    (147) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( . _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do
    (153) _20_NEWLINE_optional -> . NEWLINE
    (154) _20_NEWLINE_optional -> .
    NEWLINE         shift and go to state 342
    IDENTIFIER      reduce using rule 154 (_20_NEWLINE_optional -> .)
    )               reduce using rule 154 (_20_NEWLINE_optional -> .)

    _20_NEWLINE_optional           shift and go to state 341

state 318

    (260) exprs -> exprs , _55_NEWLINE_optional expr _56_NEWLINE_optional .
    ,               reduce using rule 260 (exprs -> exprs , _55_NEWLINE_optional expr _56_NEWLINE_optional .)
    ]               reduce using rule 260 (exprs -> exprs , _55_NEWLINE_optional expr _56_NEWLINE_optional .)
    )               reduce using rule 260 (exprs -> exprs , _55_NEWLINE_optional expr _56_NEWLINE_optional .)


state 319

    (263) _56_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 263 (_56_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 263 (_56_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 263 (_56_NEWLINE_optional -> NEWLINE .)


state 320

    (222) cases -> cases pattern do . _42_NEWLINE_optional
    (223) _42_NEWLINE_optional -> . NEWLINE
    (224) _42_NEWLINE_optional -> .
    NEWLINE         shift and go to state 344
    TYPE_IDENTIFIER reduce using rule 224 (_42_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 224 (_42_NEWLINE_optional -> .)
    END             reduce using rule 224 (_42_NEWLINE_optional -> .)

    _42_NEWLINE_optional           shift and go to state 343

state 321

    (219) cases -> pattern do _41_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 219 (cases -> pattern do _41_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 219 (cases -> pattern do _41_NEWLINE_optional .)
    END             reduce using rule 219 (cases -> pattern do _41_NEWLINE_optional .)


state 322

    (220) _41_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 220 (_41_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 220 (_41_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 220 (_41_NEWLINE_optional -> NEWLINE .)


state 323

    (229) match_variant -> TYPE_IDENTIFIER ( _43_NEWLINE_optional . _44_patterns_optional )
    (232) _44_patterns_optional -> . patterns
    (233) _44_patterns_optional -> .
    (234) patterns -> . pattern _45_NEWLINE_optional
    (237) patterns -> . patterns , _46_NEWLINE_optional pattern _47_NEWLINE_optional
    (225) pattern -> . match_variant
    (226) pattern -> . match_as
    (228) match_variant -> . TYPE_IDENTIFIER
    (229) match_variant -> . TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional )
    (227) match_as -> . identifier
    (265) identifier -> . IDENTIFIER
    )               reduce using rule 233 (_44_patterns_optional -> .)
    TYPE_IDENTIFIER shift and go to state 252
    IDENTIFIER      shift and go to state 35

    _44_patterns_optional          shift and go to state 345
    patterns                       shift and go to state 346
    pattern                        shift and go to state 347
    match_variant                  shift and go to state 250
    match_as                       shift and go to state 251
    identifier                     shift and go to state 253

state 324

    (230) _43_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 230 (_43_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 230 (_43_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 230 (_43_NEWLINE_optional -> NEWLINE .)


state 325

    (205) if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .
    NEWLINE         reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    (               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_MORE      reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_MORE_OR_EQ reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_LESS      reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_LESS_OR_EQ reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    SOME_SUB        reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    SOME_CONCAT     reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ARROW_BOTH      reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ARROW_RIGHT     reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ARROW_LEFT      reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    DOUBLE_ARROW_RIGHT reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    DOUBLE_ARROW_LEFT reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    BIT_SHIFT_LEFT  reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    BIT_AND         reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    BIT_OR          reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_POW       reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    POW             reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ARRAY_SUB       reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ARRAY_CONCAT    reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    MORE_OR_EQ      reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    LESS_OR_EQ      reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    TEXT_MATCH      reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    STRICT_AND      reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    AND             reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    STRICT_OR       reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    OR              reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    EQUAL           reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    NOT_EQUAL       reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    >               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_MUL       reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_DIV       reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_SUB       reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    FLOAT_SUM       reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    <               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    *               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    /               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    -               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    +               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    CONCAT          reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    $end            reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    )               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    OF              reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    THEN            reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    END             reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ELIF            reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ELSE            reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ,               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)
    ]               reduce using rule 205 (if_expr -> IF expr THEN _36_0x3a_type_optional block_statement _37_or_else_optional END .)


state 326

    (210) or_else -> ELIF expr . THEN block_statement _38_or_else_optional
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 348
    (               shift and go to state 43
    FLOAT_MORE      shift and go to state 44
    FLOAT_MORE_OR_EQ shift and go to state 45
    FLOAT_LESS      shift and go to state 46
    FLOAT_LESS_OR_EQ shift and go to state 47
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    BIT_AND         shift and go to state 56
    BIT_OR          shift and go to state 57
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    MORE_OR_EQ      shift and go to state 62
    LESS_OR_EQ      shift and go to state 63
    TEXT_MATCH      shift and go to state 64
    STRICT_AND      shift and go to state 65
    AND             shift and go to state 66
    STRICT_OR       shift and go to state 67
    OR              shift and go to state 68
    EQUAL           shift and go to state 69
    NOT_EQUAL       shift and go to state 70
    >               shift and go to state 71
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    <               shift and go to state 76
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 327

    (213) or_else -> ELSE block_statement .
    END             reduce using rule 213 (or_else -> ELSE block_statement .)


state 328

    (172) _26_0x2c_type_item -> , type .
    ,               reduce using rule 172 (_26_0x2c_type_item -> , type .)
    >               reduce using rule 172 (_26_0x2c_type_item -> , type .)


state 329

    (192) variants -> variants variant _33_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 192 (variants -> variants variant _33_NEWLINE_optional .)
    }               reduce using rule 192 (variants -> variants variant _33_NEWLINE_optional .)


state 330

    (193) _33_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 193 (_33_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 193 (_33_NEWLINE_optional -> NEWLINE .)


state 331

    (196) variant -> TYPE_IDENTIFIER ( type . _34_0x2c_type_repeat )
    (197) _34_0x2c_type_repeat -> . _34_0x2c_type_items
    (198) _34_0x2c_type_repeat -> .
    (199) _34_0x2c_type_items -> . _34_0x2c_type_items _34_0x2c_type_item
    (200) _34_0x2c_type_items -> . _34_0x2c_type_item
    (201) _34_0x2c_type_item -> . , type
    )               reduce using rule 198 (_34_0x2c_type_repeat -> .)
    ,               shift and go to state 352

    _34_0x2c_type_repeat           shift and go to state 349
    _34_0x2c_type_items            shift and go to state 350
    _34_0x2c_type_item             shift and go to state 351

state 332

    (179) enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { . _30_NEWLINE_optional _31_variants_optional }
    (185) _30_NEWLINE_optional -> . NEWLINE
    (186) _30_NEWLINE_optional -> .
    NEWLINE         shift and go to state 354
    TYPE_IDENTIFIER reduce using rule 186 (_30_NEWLINE_optional -> .)
    }               reduce using rule 186 (_30_NEWLINE_optional -> .)

    _30_NEWLINE_optional           shift and go to state 353

state 333

    (268) let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .
    (247) call -> expr . ( _50_NEWLINE_optional _51_exprs_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    FLOAT_MORE      reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    FLOAT_MORE_OR_EQ reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    FLOAT_LESS      reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    FLOAT_LESS_OR_EQ reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    BIT_AND         reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    BIT_OR          reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    STRICT_AND      reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    AND             reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    STRICT_OR       reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    OR              reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    EQUAL           reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    >               reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    <               reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    $end            reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    )               reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    OF              reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    THEN            reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    END             reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    ELIF            reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    ELSE            reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    ,               reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    ]               reduce using rule 268 (let -> identifier : type_identifier < type _57_0x2c_type_repeat MORE_OR_EQ expr .)
    (               shift and go to state 43
    SOME_SUB        shift and go to state 48
    SOME_CONCAT     shift and go to state 49
    ARROW_BOTH      shift and go to state 50
    ARROW_RIGHT     shift and go to state 51
    ARROW_LEFT      shift and go to state 52
    DOUBLE_ARROW_RIGHT shift and go to state 53
    DOUBLE_ARROW_LEFT shift and go to state 54
    BIT_SHIFT_LEFT  shift and go to state 55
    FLOAT_POW       shift and go to state 58
    POW             shift and go to state 59
    ARRAY_SUB       shift and go to state 60
    ARRAY_CONCAT    shift and go to state 61
    FLOAT_MUL       shift and go to state 72
    FLOAT_DIV       shift and go to state 73
    FLOAT_SUB       shift and go to state 74
    FLOAT_SUM       shift and go to state 75
    *               shift and go to state 77
    /               shift and go to state 78
    -               shift and go to state 79
    +               shift and go to state 80
    CONCAT          shift and go to state 81


state 334

    (273) _57_0x2c_type_item -> , type .
    ,               reduce using rule 273 (_57_0x2c_type_item -> , type .)
    MORE_OR_EQ      reduce using rule 273 (_57_0x2c_type_item -> , type .)


state 335

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param . _6_NEWLINE_optional ) _7_0x3a_type_optional do
    (114) _6_NEWLINE_optional -> . NEWLINE
    (115) _6_NEWLINE_optional -> .
    NEWLINE         shift and go to state 356
    )               reduce using rule 115 (_6_NEWLINE_optional -> .)

    _6_NEWLINE_optional            shift and go to state 355

state 336

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional . param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (202) param -> . identifier _35_0x3a_type_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 357
    identifier                     shift and go to state 232

state 337

    (124) _9_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 124 (_9_NEWLINE_optional -> NEWLINE .)


state 338

    (140) def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .
    NEWLINE         reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    (               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_MORE      reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_MORE_OR_EQ reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_LESS      reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_LESS_OR_EQ reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    SOME_SUB        reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    SOME_CONCAT     reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARROW_BOTH      reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARROW_RIGHT     reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARROW_LEFT      reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    BIT_AND         reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    BIT_OR          reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_POW       reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    POW             reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARRAY_SUB       reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ARRAY_CONCAT    reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    MORE_OR_EQ      reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    LESS_OR_EQ      reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    TEXT_MATCH      reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    STRICT_AND      reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    AND             reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    STRICT_OR       reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    OR              reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    EQUAL           reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    >               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_MUL       reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_DIV       reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_SUB       reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    FLOAT_SUM       reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    <               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    *               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    /               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    -               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    +               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    CONCAT          reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    $end            reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    )               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    OF              reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    THEN            reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    END             reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ELIF            reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ELSE            reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ,               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)
    ]               reduce using rule 140 (def_expr -> DEF identifier ( _16_NEWLINE_optional _17_params_optional ) _18_0x3a_type_optional do .)


state 339

    (145) _18_0x3a_type_optional -> : type .
    DO              reduce using rule 145 (_18_0x3a_type_optional -> : type .)


state 340

    (162) params -> params , _24_NEWLINE_optional param . _25_NEWLINE_optional
    (165) _25_NEWLINE_optional -> . NEWLINE
    (166) _25_NEWLINE_optional -> .
    NEWLINE         shift and go to state 359
    ,               reduce using rule 166 (_25_NEWLINE_optional -> .)
    )               reduce using rule 166 (_25_NEWLINE_optional -> .)

    _25_NEWLINE_optional           shift and go to state 358

state 341

    (147) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional . _21_params_optional ) _22_0x3a_type_optional do
    (155) _21_params_optional -> . params
    (156) _21_params_optional -> .
    (159) params -> . param _23_NEWLINE_optional
    (162) params -> . params , _24_NEWLINE_optional param _25_NEWLINE_optional
    (202) param -> . identifier _35_0x3a_type_optional
    (265) identifier -> . IDENTIFIER
    )               reduce using rule 156 (_21_params_optional -> .)
    IDENTIFIER      shift and go to state 35

    identifier                     shift and go to state 232
    _21_params_optional            shift and go to state 360
    params                         shift and go to state 361
    param                          shift and go to state 239

state 342

    (153) _20_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 153 (_20_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 153 (_20_NEWLINE_optional -> NEWLINE .)


state 343

    (222) cases -> cases pattern do _42_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 222 (cases -> cases pattern do _42_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 222 (cases -> cases pattern do _42_NEWLINE_optional .)
    END             reduce using rule 222 (cases -> cases pattern do _42_NEWLINE_optional .)


state 344

    (223) _42_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 223 (_42_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 223 (_42_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 223 (_42_NEWLINE_optional -> NEWLINE .)


state 345

    (229) match_variant -> TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional . )
    )               shift and go to state 362


state 346

    (232) _44_patterns_optional -> patterns .
    (237) patterns -> patterns . , _46_NEWLINE_optional pattern _47_NEWLINE_optional
    )               reduce using rule 232 (_44_patterns_optional -> patterns .)
    ,               shift and go to state 363


state 347

    (234) patterns -> pattern . _45_NEWLINE_optional
    (235) _45_NEWLINE_optional -> . NEWLINE
    (236) _45_NEWLINE_optional -> .
    NEWLINE         shift and go to state 365
    ,               reduce using rule 236 (_45_NEWLINE_optional -> .)
    )               reduce using rule 236 (_45_NEWLINE_optional -> .)

    _45_NEWLINE_optional           shift and go to state 364

state 348

    (210) or_else -> ELIF expr THEN . block_statement _38_or_else_optional
    (135) block_statement -> . _14_NEWLINE_optional _15_do_exprs_optional
    (136) _14_NEWLINE_optional -> . NEWLINE
    (137) _14_NEWLINE_optional -> .
    NEWLINE         shift and go to state 197
    (               reduce using rule 137 (_14_NEWLINE_optional -> .)
    DEF             reduce using rule 137 (_14_NEWLINE_optional -> .)
    +               reduce using rule 137 (_14_NEWLINE_optional -> .)
    !               reduce using rule 137 (_14_NEWLINE_optional -> .)
    STRICT_NOT      reduce using rule 137 (_14_NEWLINE_optional -> .)
    -               reduce using rule 137 (_14_NEWLINE_optional -> .)
    STRING          reduce using rule 137 (_14_NEWLINE_optional -> .)
    FLOAT           reduce using rule 137 (_14_NEWLINE_optional -> .)
    INT             reduce using rule 137 (_14_NEWLINE_optional -> .)
    [               reduce using rule 137 (_14_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 137 (_14_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 137 (_14_NEWLINE_optional -> .)
    CASE            reduce using rule 137 (_14_NEWLINE_optional -> .)
    IF              reduce using rule 137 (_14_NEWLINE_optional -> .)
    DO              reduce using rule 137 (_14_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 137 (_14_NEWLINE_optional -> .)
    ENUM            reduce using rule 137 (_14_NEWLINE_optional -> .)
    ELIF            reduce using rule 137 (_14_NEWLINE_optional -> .)
    ELSE            reduce using rule 137 (_14_NEWLINE_optional -> .)
    END             reduce using rule 137 (_14_NEWLINE_optional -> .)

    block_statement                shift and go to state 366
    _14_NEWLINE_optional           shift and go to state 196

state 349

    (196) variant -> TYPE_IDENTIFIER ( type _34_0x2c_type_repeat . )
    )               shift and go to state 367


state 350

    (197) _34_0x2c_type_repeat -> _34_0x2c_type_items .
    (199) _34_0x2c_type_items -> _34_0x2c_type_items . _34_0x2c_type_item
    (201) _34_0x2c_type_item -> . , type
    )               reduce using rule 197 (_34_0x2c_type_repeat -> _34_0x2c_type_items .)
    ,               shift and go to state 352

    _34_0x2c_type_item             shift and go to state 368

state 351

    (200) _34_0x2c_type_items -> _34_0x2c_type_item .
    ,               reduce using rule 200 (_34_0x2c_type_items -> _34_0x2c_type_item .)
    )               reduce using rule 200 (_34_0x2c_type_items -> _34_0x2c_type_item .)


state 352

    (201) _34_0x2c_type_item -> , . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 369
    type_identifier                shift and go to state 199

state 353

    (179) enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional . _31_variants_optional }
    (187) _31_variants_optional -> . variants
    (188) _31_variants_optional -> .
    (189) variants -> . variant _32_NEWLINE_optional
    (192) variants -> . variants variant _33_NEWLINE_optional
    (195) variant -> . TYPE_IDENTIFIER
    (196) variant -> . TYPE_IDENTIFIER ( type _34_0x2c_type_repeat )
    }               reduce using rule 188 (_31_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 260

    _31_variants_optional          shift and go to state 370
    variants                       shift and go to state 371
    variant                        shift and go to state 259

state 354

    (185) _30_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 185 (_30_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 185 (_30_NEWLINE_optional -> NEWLINE .)


state 355

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional . ) _7_0x3a_type_optional do
    )               shift and go to state 372


state 356

    (114) _6_NEWLINE_optional -> NEWLINE .
    )               reduce using rule 114 (_6_NEWLINE_optional -> NEWLINE .)


state 357

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param . , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    ,               shift and go to state 373


state 358

    (162) params -> params , _24_NEWLINE_optional param _25_NEWLINE_optional .
    ,               reduce using rule 162 (params -> params , _24_NEWLINE_optional param _25_NEWLINE_optional .)
    )               reduce using rule 162 (params -> params , _24_NEWLINE_optional param _25_NEWLINE_optional .)


state 359

    (165) _25_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 165 (_25_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 165 (_25_NEWLINE_optional -> NEWLINE .)


state 360

    (147) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional . ) _22_0x3a_type_optional do
    )               shift and go to state 374


state 361

    (155) _21_params_optional -> params .
    (162) params -> params . , _24_NEWLINE_optional param _25_NEWLINE_optional
    )               reduce using rule 155 (_21_params_optional -> params .)
    ,               shift and go to state 279


state 362

    (229) match_variant -> TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional ) .
    DO              reduce using rule 229 (match_variant -> TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional ) .)
    NEWLINE         reduce using rule 229 (match_variant -> TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional ) .)
    ,               reduce using rule 229 (match_variant -> TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional ) .)
    )               reduce using rule 229 (match_variant -> TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional ) .)


state 363

    (237) patterns -> patterns , . _46_NEWLINE_optional pattern _47_NEWLINE_optional
    (238) _46_NEWLINE_optional -> . NEWLINE
    (239) _46_NEWLINE_optional -> .
    NEWLINE         shift and go to state 376
    TYPE_IDENTIFIER reduce using rule 239 (_46_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 239 (_46_NEWLINE_optional -> .)

    _46_NEWLINE_optional           shift and go to state 375

state 364

    (234) patterns -> pattern _45_NEWLINE_optional .
    ,               reduce using rule 234 (patterns -> pattern _45_NEWLINE_optional .)
    )               reduce using rule 234 (patterns -> pattern _45_NEWLINE_optional .)


state 365

    (235) _45_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 235 (_45_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 235 (_45_NEWLINE_optional -> NEWLINE .)


state 366

    (210) or_else -> ELIF expr THEN block_statement . _38_or_else_optional
    (211) _38_or_else_optional -> . or_else
    (212) _38_or_else_optional -> .
    (210) or_else -> . ELIF expr THEN block_statement _38_or_else_optional
    (213) or_else -> . ELSE block_statement
    END             reduce using rule 212 (_38_or_else_optional -> .)
    ELIF            shift and go to state 292
    ELSE            shift and go to state 293

    _38_or_else_optional           shift and go to state 377
    or_else                        shift and go to state 378

state 367

    (196) variant -> TYPE_IDENTIFIER ( type _34_0x2c_type_repeat ) .
    NEWLINE         reduce using rule 196 (variant -> TYPE_IDENTIFIER ( type _34_0x2c_type_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 196 (variant -> TYPE_IDENTIFIER ( type _34_0x2c_type_repeat ) .)
    }               reduce using rule 196 (variant -> TYPE_IDENTIFIER ( type _34_0x2c_type_repeat ) .)


state 368

    (199) _34_0x2c_type_items -> _34_0x2c_type_items _34_0x2c_type_item .
    ,               reduce using rule 199 (_34_0x2c_type_items -> _34_0x2c_type_items _34_0x2c_type_item .)
    )               reduce using rule 199 (_34_0x2c_type_items -> _34_0x2c_type_items _34_0x2c_type_item .)


state 369

    (201) _34_0x2c_type_item -> , type .
    ,               reduce using rule 201 (_34_0x2c_type_item -> , type .)
    )               reduce using rule 201 (_34_0x2c_type_item -> , type .)


state 370

    (179) enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional . }
    }               shift and go to state 379


state 371

    (187) _31_variants_optional -> variants .
    (192) variants -> variants . variant _33_NEWLINE_optional
    (195) variant -> . TYPE_IDENTIFIER
    (196) variant -> . TYPE_IDENTIFIER ( type _34_0x2c_type_repeat )
    }               reduce using rule 187 (_31_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 260

    variant                        shift and go to state 296

state 372

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) . _7_0x3a_type_optional do
    (116) _7_0x3a_type_optional -> . : type
    (117) _7_0x3a_type_optional -> .
    :               shift and go to state 381
    DO              reduce using rule 117 (_7_0x3a_type_optional -> .)

    _7_0x3a_type_optional          shift and go to state 380

state 373

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , . _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (126) _10_NEWLINE_optional -> . NEWLINE
    (127) _10_NEWLINE_optional -> .
    NEWLINE         shift and go to state 383
    IDENTIFIER      reduce using rule 127 (_10_NEWLINE_optional -> .)

    _10_NEWLINE_optional           shift and go to state 382

state 374

    (147) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) . _22_0x3a_type_optional do
    (157) _22_0x3a_type_optional -> . : type
    (158) _22_0x3a_type_optional -> .
    :               shift and go to state 385
    DO              reduce using rule 158 (_22_0x3a_type_optional -> .)

    _22_0x3a_type_optional         shift and go to state 384

state 375

    (237) patterns -> patterns , _46_NEWLINE_optional . pattern _47_NEWLINE_optional
    (225) pattern -> . match_variant
    (226) pattern -> . match_as
    (228) match_variant -> . TYPE_IDENTIFIER
    (229) match_variant -> . TYPE_IDENTIFIER ( _43_NEWLINE_optional _44_patterns_optional )
    (227) match_as -> . identifier
    (265) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 252
    IDENTIFIER      shift and go to state 35

    pattern                        shift and go to state 386
    match_variant                  shift and go to state 250
    match_as                       shift and go to state 251
    identifier                     shift and go to state 253

state 376

    (238) _46_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 238 (_46_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 238 (_46_NEWLINE_optional -> NEWLINE .)


state 377

    (210) or_else -> ELIF expr THEN block_statement _38_or_else_optional .
    END             reduce using rule 210 (or_else -> ELIF expr THEN block_statement _38_or_else_optional .)


state 378

    (211) _38_or_else_optional -> or_else .
    END             reduce using rule 211 (_38_or_else_optional -> or_else .)


state 379

    (179) enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .
    NEWLINE         reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    (               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_MORE      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_MORE_OR_EQ reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_LESS      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_LESS_OR_EQ reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    SOME_SUB        reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    SOME_CONCAT     reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ARROW_BOTH      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ARROW_RIGHT     reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ARROW_LEFT      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    DOUBLE_ARROW_RIGHT reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    DOUBLE_ARROW_LEFT reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    BIT_SHIFT_LEFT  reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    BIT_AND         reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    BIT_OR          reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_POW       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    POW             reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ARRAY_SUB       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ARRAY_CONCAT    reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    MORE_OR_EQ      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    LESS_OR_EQ      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    TEXT_MATCH      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    STRICT_AND      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    AND             reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    STRICT_OR       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    OR              reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    EQUAL           reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    NOT_EQUAL       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    >               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_MUL       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_DIV       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_SUB       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    FLOAT_SUM       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    <               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    *               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    /               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    -               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    +               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    CONCAT          reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    $end            reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    )               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    OF              reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    THEN            reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    END             reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ELIF            reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ELSE            reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ,               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)
    ]               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_0x2c_type_identifier_repeat > { _30_NEWLINE_optional _31_variants_optional } .)


state 380

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional . do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 387

state 381

    (116) _7_0x3a_type_optional -> : . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 388
    type_identifier                shift and go to state 199

state 382

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional . param _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (202) param -> . identifier _35_0x3a_type_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 389
    identifier                     shift and go to state 232

state 383

    (126) _10_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 126 (_10_NEWLINE_optional -> NEWLINE .)


state 384

    (147) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional . do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 390

state 385

    (157) _22_0x3a_type_optional -> : . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 391
    type_identifier                shift and go to state 199

state 386

    (237) patterns -> patterns , _46_NEWLINE_optional pattern . _47_NEWLINE_optional
    (240) _47_NEWLINE_optional -> . NEWLINE
    (241) _47_NEWLINE_optional -> .
    NEWLINE         shift and go to state 393
    ,               reduce using rule 241 (_47_NEWLINE_optional -> .)
    )               reduce using rule 241 (_47_NEWLINE_optional -> .)

    _47_NEWLINE_optional           shift and go to state 392

state 387

    (109) binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .
    NEWLINE         reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    (               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_MORE      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_MORE_OR_EQ reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_LESS      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_LESS_OR_EQ reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    SOME_SUB        reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    SOME_CONCAT     reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARROW_BOTH      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARROW_RIGHT     reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARROW_LEFT      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    BIT_AND         reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    BIT_OR          reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_POW       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    POW             reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARRAY_SUB       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ARRAY_CONCAT    reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    MORE_OR_EQ      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    LESS_OR_EQ      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    TEXT_MATCH      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    STRICT_AND      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    AND             reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    STRICT_OR       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    OR              reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    EQUAL           reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    >               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_MUL       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_DIV       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_SUB       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    FLOAT_SUM       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    <               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    *               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    /               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    -               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    +               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    CONCAT          reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    $end            reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    )               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    OF              reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    THEN            reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    END             reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ELIF            reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ELSE            reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ,               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)
    ]               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_NEWLINE_optional param , _5_NEWLINE_optional param _6_NEWLINE_optional ) _7_0x3a_type_optional do .)


state 388

    (116) _7_0x3a_type_optional -> : type .
    DO              reduce using rule 116 (_7_0x3a_type_optional -> : type .)


state 389

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param . _11_NEWLINE_optional ) _12_0x3a_type_optional do
    (128) _11_NEWLINE_optional -> . NEWLINE
    (129) _11_NEWLINE_optional -> .
    NEWLINE         shift and go to state 395
    )               reduce using rule 129 (_11_NEWLINE_optional -> .)

    _11_NEWLINE_optional           shift and go to state 394

state 390

    (147) def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .
    NEWLINE         reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    (               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_MORE      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_MORE_OR_EQ reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_LESS      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_LESS_OR_EQ reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    SOME_SUB        reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    SOME_CONCAT     reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARROW_BOTH      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARROW_RIGHT     reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARROW_LEFT      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    BIT_AND         reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    BIT_OR          reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_POW       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    POW             reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARRAY_SUB       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ARRAY_CONCAT    reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    MORE_OR_EQ      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    LESS_OR_EQ      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    TEXT_MATCH      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    STRICT_AND      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    AND             reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    STRICT_OR       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    OR              reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    EQUAL           reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    >               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_MUL       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_DIV       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_SUB       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    FLOAT_SUM       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    <               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    *               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    /               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    -               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    +               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    CONCAT          reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    $end            reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    )               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    OF              reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    THEN            reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    END             reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ELIF            reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ELSE            reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ,               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)
    ]               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_0x2c_type_identifier_repeat > ( _20_NEWLINE_optional _21_params_optional ) _22_0x3a_type_optional do .)


state 391

    (157) _22_0x3a_type_optional -> : type .
    DO              reduce using rule 157 (_22_0x3a_type_optional -> : type .)


state 392

    (237) patterns -> patterns , _46_NEWLINE_optional pattern _47_NEWLINE_optional .
    ,               reduce using rule 237 (patterns -> patterns , _46_NEWLINE_optional pattern _47_NEWLINE_optional .)
    )               reduce using rule 237 (patterns -> patterns , _46_NEWLINE_optional pattern _47_NEWLINE_optional .)


state 393

    (240) _47_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 240 (_47_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 240 (_47_NEWLINE_optional -> NEWLINE .)


state 394

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional . ) _12_0x3a_type_optional do
    )               shift and go to state 396


state 395

    (128) _11_NEWLINE_optional -> NEWLINE .
    )               reduce using rule 128 (_11_NEWLINE_optional -> NEWLINE .)


state 396

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) . _12_0x3a_type_optional do
    (130) _12_0x3a_type_optional -> . : type
    (131) _12_0x3a_type_optional -> .
    :               shift and go to state 398
    DO              reduce using rule 131 (_12_0x3a_type_optional -> .)

    _12_0x3a_type_optional         shift and go to state 397

state 397

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional . do
    (132) do -> . DO _13_0x3a_type_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 399

state 398

    (130) _12_0x3a_type_optional -> : . type
    (167) type -> . type_identifier < type _26_0x2c_type_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . IDENTIFIER
    (267) type_identifier -> . TYPE_IDENTIFIER
    IDENTIFIER      shift and go to state 137
    TYPE_IDENTIFIER shift and go to state 138

    type                           shift and go to state 400
    type_identifier                shift and go to state 199

state 399

    (118) binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .
    NEWLINE         reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    (               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_MORE      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_MORE_OR_EQ reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_LESS      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_LESS_OR_EQ reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    SOME_SUB        reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    SOME_CONCAT     reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARROW_BOTH      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARROW_RIGHT     reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARROW_LEFT      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    BIT_AND         reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    BIT_OR          reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_POW       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    POW             reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARRAY_SUB       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ARRAY_CONCAT    reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    MORE_OR_EQ      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    LESS_OR_EQ      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    TEXT_MATCH      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    STRICT_AND      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    AND             reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    STRICT_OR       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    OR              reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    EQUAL           reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    >               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_MUL       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_DIV       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_SUB       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    FLOAT_SUM       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    <               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    *               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    /               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    -               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    +               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    CONCAT          reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    $end            reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    )               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    OF              reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    THEN            reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    END             reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ELIF            reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ELSE            reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ,               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)
    ]               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_0x2c_type_identifier_repeat > ( _9_NEWLINE_optional param , _10_NEWLINE_optional param _11_NEWLINE_optional ) _12_0x3a_type_optional do .)


state 400

    (130) _12_0x3a_type_optional -> : type .
    DO              reduce using rule 130 (_12_0x3a_type_optional -> : type .)


Conflicts:

reduce/reduce conflict for , in state 308 resolved using rule _57_0x2c_type_item -> , type
rejected rule (_26_0x2c_type_item -> , type) in state 308
   reduce using _57_0x2c_type_item -> , type with lookahead ,
   ╭╴
   │ , type ♦              , type
   │ ╰_57_0x2c_type_item╯  ╰_57_0x2c_type_item╯
   │ ╰_57_0x2c_type_items╯
   │ ╰_57_0x2c_type_items─────────────────────╯
   ╰╴

   reduce using _26_0x2c_type_item -> , type with lookahead ,
   ╭╴
   │ , type ♦              , type
   │ ╰_26_0x2c_type_item╯  ╰_26_0x2c_type_item╯
   │ ╰_26_0x2c_type_items╯
   │ ╰_26_0x2c_type_items─────────────────────╯
   ╰╴
