Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_optional _2_optional
Rule 2     _1_optional -> NEWLINE
Rule 3     _1_optional -> <empty>
Rule 4     _2_optional -> do_exprs
Rule 5     _2_optional -> <empty>
Rule 6     do_exprs -> expr _3_optional
Rule 7     _3_optional -> NEWLINE
Rule 8     _3_optional -> <empty>
Rule 9     do_exprs -> expr NEWLINE do_exprs
Rule 10    expr -> ( expr )  [precedence=left, level=12]
Rule 11    expr -> binary_op_def
Rule 12    expr -> unary_expr
Rule 13    expr -> str_literal
Rule 14    expr -> float_literal
Rule 15    expr -> int_literal
Rule 16    expr -> array
Rule 17    expr -> variant_call
Rule 18    expr -> identifier
Rule 19    expr -> let
Rule 20    expr -> call
Rule 21    expr -> case_of
Rule 22    expr -> binary_expr
Rule 23    expr -> if_expr
Rule 24    expr -> def_expr
Rule 25    expr -> do
Rule 26    expr -> external
Rule 27    expr -> enum
Rule 28    unary_expr -> + expr  [precedence=right, level=11]
Rule 29    unary_expr -> ! expr  [precedence=right, level=11]
Rule 30    unary_expr -> STRICT_NOT expr  [precedence=right, level=11]
Rule 31    unary_expr -> - expr  [precedence=right, level=11]
Rule 32    external -> EXTERNAL
Rule 33    binary_expr -> expr FLOAT_MORE expr
Rule 34    binary_expr -> expr FLOAT_MORE_OR_EQ expr
Rule 35    binary_expr -> expr FLOAT_LESS expr
Rule 36    binary_expr -> expr FLOAT_LESS_OR_EQ expr
Rule 37    binary_expr -> expr SOME_SUB expr  [precedence=right, level=7]
Rule 38    binary_expr -> expr SOME_CONCAT expr  [precedence=right, level=7]
Rule 39    binary_expr -> expr ARROW_BOTH expr  [precedence=left, level=6]
Rule 40    binary_expr -> expr ARROW_RIGHT expr  [precedence=left, level=6]
Rule 41    binary_expr -> expr ARROW_LEFT expr  [precedence=left, level=6]
Rule 42    binary_expr -> expr DOUBLE_ARROW_RIGHT expr  [precedence=left, level=6]
Rule 43    binary_expr -> expr DOUBLE_ARROW_LEFT expr  [precedence=left, level=6]
Rule 44    binary_expr -> expr BIT_SHIFT_LEFT expr  [precedence=left, level=6]
Rule 45    binary_expr -> expr BIT_AND expr  [precedence=left, level=3]
Rule 46    binary_expr -> expr BIT_OR expr  [precedence=left, level=2]
Rule 47    binary_expr -> expr FLOAT_POW expr  [precedence=left, level=10]
Rule 48    binary_expr -> expr POW expr  [precedence=left, level=10]
Rule 49    binary_expr -> expr ARRAY_SUB expr  [precedence=right, level=7]
Rule 50    binary_expr -> expr ARRAY_CONCAT expr  [precedence=right, level=7]
Rule 51    binary_expr -> expr MORE_OR_EQ expr  [precedence=left, level=5]
Rule 52    binary_expr -> expr LESS_OR_EQ expr  [precedence=left, level=5]
Rule 53    binary_expr -> expr TEXT_MATCH expr  [precedence=left, level=4]
Rule 54    binary_expr -> expr STRICT_AND expr  [precedence=left, level=3]
Rule 55    binary_expr -> expr AND expr  [precedence=left, level=3]
Rule 56    binary_expr -> expr STRICT_OR expr  [precedence=left, level=2]
Rule 57    binary_expr -> expr OR expr  [precedence=left, level=2]
Rule 58    binary_expr -> expr EQUAL expr  [precedence=left, level=4]
Rule 59    binary_expr -> expr NOT_EQUAL expr  [precedence=left, level=4]
Rule 60    binary_expr -> expr > expr  [precedence=left, level=5]
Rule 61    binary_expr -> expr FLOAT_MUL expr  [precedence=left, level=9]
Rule 62    binary_expr -> expr FLOAT_DIV expr  [precedence=left, level=9]
Rule 63    binary_expr -> expr FLOAT_SUB expr  [precedence=left, level=8]
Rule 64    binary_expr -> expr FLOAT_SUM expr  [precedence=left, level=8]
Rule 65    binary_expr -> expr < expr  [precedence=left, level=5]
Rule 66    binary_expr -> expr * expr  [precedence=left, level=9]
Rule 67    binary_expr -> expr / expr  [precedence=left, level=9]
Rule 68    binary_expr -> expr - expr  [precedence=left, level=8]
Rule 69    binary_expr -> expr + expr  [precedence=left, level=8]
Rule 70    binary_expr -> expr CONCAT expr  [precedence=right, level=7]
Rule 71    binary_op -> FLOAT_MORE
Rule 72    binary_op -> FLOAT_MORE_OR_EQ
Rule 73    binary_op -> FLOAT_LESS
Rule 74    binary_op -> FLOAT_LESS_OR_EQ
Rule 75    binary_op -> SOME_SUB  [precedence=right, level=7]
Rule 76    binary_op -> SOME_CONCAT  [precedence=right, level=7]
Rule 77    binary_op -> ARROW_BOTH  [precedence=left, level=6]
Rule 78    binary_op -> ARROW_RIGHT  [precedence=left, level=6]
Rule 79    binary_op -> ARROW_LEFT  [precedence=left, level=6]
Rule 80    binary_op -> DOUBLE_ARROW_RIGHT  [precedence=left, level=6]
Rule 81    binary_op -> DOUBLE_ARROW_LEFT  [precedence=left, level=6]
Rule 82    binary_op -> BIT_SHIFT_LEFT  [precedence=left, level=6]
Rule 83    binary_op -> BIT_AND  [precedence=left, level=3]
Rule 84    binary_op -> BIT_OR  [precedence=left, level=2]
Rule 85    binary_op -> FLOAT_POW  [precedence=left, level=10]
Rule 86    binary_op -> POW  [precedence=left, level=10]
Rule 87    binary_op -> ARRAY_SUB  [precedence=right, level=7]
Rule 88    binary_op -> ARRAY_CONCAT  [precedence=right, level=7]
Rule 89    binary_op -> MORE_OR_EQ  [precedence=left, level=5]
Rule 90    binary_op -> LESS_OR_EQ  [precedence=left, level=5]
Rule 91    binary_op -> TEXT_MATCH  [precedence=left, level=4]
Rule 92    binary_op -> STRICT_AND  [precedence=left, level=3]
Rule 93    binary_op -> AND  [precedence=left, level=3]
Rule 94    binary_op -> STRICT_OR  [precedence=left, level=2]
Rule 95    binary_op -> OR  [precedence=left, level=2]
Rule 96    binary_op -> EQUAL  [precedence=left, level=4]
Rule 97    binary_op -> NOT_EQUAL  [precedence=left, level=4]
Rule 98    binary_op -> >  [precedence=left, level=5]
Rule 99    binary_op -> FLOAT_MUL  [precedence=left, level=9]
Rule 100   binary_op -> FLOAT_DIV  [precedence=left, level=9]
Rule 101   binary_op -> FLOAT_SUB  [precedence=left, level=8]
Rule 102   binary_op -> FLOAT_SUM  [precedence=left, level=8]
Rule 103   binary_op -> <  [precedence=left, level=5]
Rule 104   binary_op -> *  [precedence=left, level=9]
Rule 105   binary_op -> /  [precedence=left, level=9]
Rule 106   binary_op -> -  [precedence=left, level=8]
Rule 107   binary_op -> +  [precedence=left, level=8]
Rule 108   binary_op -> CONCAT  [precedence=right, level=7]
Rule 109   binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do  [precedence=left, level=12]
Rule 110   _4_optional -> NEWLINE
Rule 111   _4_optional -> <empty>
Rule 112   _5_optional -> NEWLINE
Rule 113   _5_optional -> <empty>
Rule 114   _6_optional -> NEWLINE
Rule 115   _6_optional -> <empty>
Rule 116   _7_optional -> : type
Rule 117   _7_optional -> <empty>
Rule 118   binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do  [precedence=left, level=12]
Rule 119   _8_repeat -> _8_items
Rule 120   _8_repeat -> <empty>
Rule 121   _8_items -> _8_items _8_item
Rule 122   _8_items -> _8_item
Rule 123   _8_item -> , type_identifier
Rule 124   _9_optional -> NEWLINE
Rule 125   _9_optional -> <empty>
Rule 126   _10_optional -> NEWLINE
Rule 127   _10_optional -> <empty>
Rule 128   _11_optional -> NEWLINE
Rule 129   _11_optional -> <empty>
Rule 130   _12_optional -> : type
Rule 131   _12_optional -> <empty>
Rule 132   do -> DO _13_optional block_statement END
Rule 133   _13_optional -> : type
Rule 134   _13_optional -> <empty>
Rule 135   block_statement -> _14_optional _15_optional
Rule 136   _14_optional -> NEWLINE
Rule 137   _14_optional -> <empty>
Rule 138   _15_optional -> do_exprs
Rule 139   _15_optional -> <empty>
Rule 140   def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do  [precedence=left, level=12]
Rule 141   _16_optional -> NEWLINE
Rule 142   _16_optional -> <empty>
Rule 143   _17_optional -> params
Rule 144   _17_optional -> <empty>
Rule 145   _18_optional -> : type
Rule 146   _18_optional -> <empty>
Rule 147   def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do  [precedence=left, level=12]
Rule 148   _19_repeat -> _19_items
Rule 149   _19_repeat -> <empty>
Rule 150   _19_items -> _19_items _19_item
Rule 151   _19_items -> _19_item
Rule 152   _19_item -> , type_identifier
Rule 153   _20_optional -> NEWLINE
Rule 154   _20_optional -> <empty>
Rule 155   _21_optional -> params
Rule 156   _21_optional -> <empty>
Rule 157   _22_optional -> : type
Rule 158   _22_optional -> <empty>
Rule 159   params -> param _23_optional
Rule 160   _23_optional -> NEWLINE
Rule 161   _23_optional -> <empty>
Rule 162   params -> params , _24_optional param _25_optional
Rule 163   _24_optional -> NEWLINE
Rule 164   _24_optional -> <empty>
Rule 165   _25_optional -> NEWLINE
Rule 166   _25_optional -> <empty>
Rule 167   type -> type_identifier < type _26_repeat >  [precedence=left, level=5]
Rule 168   _26_repeat -> _26_items
Rule 169   _26_repeat -> <empty>
Rule 170   _26_items -> _26_items _26_item
Rule 171   _26_items -> _26_item
Rule 172   _26_item -> , type
Rule 173   type -> type_identifier
Rule 174   enum -> ENUM type_identifier { _27_optional _28_optional }
Rule 175   _27_optional -> NEWLINE
Rule 176   _27_optional -> <empty>
Rule 177   _28_optional -> variants
Rule 178   _28_optional -> <empty>
Rule 179   enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
Rule 180   _29_repeat -> _29_items
Rule 181   _29_repeat -> <empty>
Rule 182   _29_items -> _29_items _29_item
Rule 183   _29_items -> _29_item
Rule 184   _29_item -> , type_identifier
Rule 185   _30_optional -> NEWLINE
Rule 186   _30_optional -> <empty>
Rule 187   _31_optional -> variants
Rule 188   _31_optional -> <empty>
Rule 189   variants -> variant _32_optional
Rule 190   _32_optional -> NEWLINE
Rule 191   _32_optional -> <empty>
Rule 192   variants -> variants variant _33_optional
Rule 193   _33_optional -> NEWLINE
Rule 194   _33_optional -> <empty>
Rule 195   variant -> type_identifier
Rule 196   variant -> type_identifier ( type _34_repeat )  [precedence=left, level=12]
Rule 197   _34_repeat -> _34_items
Rule 198   _34_repeat -> <empty>
Rule 199   _34_items -> _34_items _34_item
Rule 200   _34_items -> _34_item
Rule 201   _34_item -> , type
Rule 202   param -> identifier _35_optional
Rule 203   _35_optional -> : type
Rule 204   _35_optional -> <empty>
Rule 205   if_expr -> IF expr THEN _36_optional block_statement _37_optional END
Rule 206   _36_optional -> : type
Rule 207   _36_optional -> <empty>
Rule 208   _37_optional -> or_else
Rule 209   _37_optional -> <empty>
Rule 210   or_else -> ELIF expr THEN block_statement _38_optional
Rule 211   _38_optional -> or_else
Rule 212   _38_optional -> <empty>
Rule 213   or_else -> ELSE block_statement
Rule 214   case_of -> CASE expr OF _39_optional _40_optional END
Rule 215   _39_optional -> NEWLINE
Rule 216   _39_optional -> <empty>
Rule 217   _40_optional -> cases
Rule 218   _40_optional -> <empty>
Rule 219   cases -> pattern do _41_optional
Rule 220   _41_optional -> NEWLINE
Rule 221   _41_optional -> <empty>
Rule 222   cases -> cases pattern do _42_optional
Rule 223   _42_optional -> NEWLINE
Rule 224   _42_optional -> <empty>
Rule 225   pattern -> match_variant
Rule 226   pattern -> match_as
Rule 227   match_as -> identifier
Rule 228   match_variant -> type_identifier
Rule 229   match_variant -> type_identifier ( _43_optional _44_optional )  [precedence=left, level=12]
Rule 230   _43_optional -> NEWLINE
Rule 231   _43_optional -> <empty>
Rule 232   _44_optional -> patterns
Rule 233   _44_optional -> <empty>
Rule 234   patterns -> pattern _45_optional
Rule 235   _45_optional -> NEWLINE
Rule 236   _45_optional -> <empty>
Rule 237   patterns -> patterns , _46_optional pattern _47_optional
Rule 238   _46_optional -> NEWLINE
Rule 239   _46_optional -> <empty>
Rule 240   _47_optional -> NEWLINE
Rule 241   _47_optional -> <empty>
Rule 242   array -> [ _48_optional _49_optional ]
Rule 243   _48_optional -> NEWLINE
Rule 244   _48_optional -> <empty>
Rule 245   _49_optional -> exprs
Rule 246   _49_optional -> <empty>
Rule 247   call -> expr ( _50_optional _51_optional )  [precedence=left, level=12]
Rule 248   _50_optional -> NEWLINE
Rule 249   _50_optional -> <empty>
Rule 250   _51_optional -> exprs
Rule 251   _51_optional -> <empty>
Rule 252   variant_call -> type_identifier ( _52_optional _53_optional )  [precedence=left, level=12]
Rule 253   _52_optional -> NEWLINE
Rule 254   _52_optional -> <empty>
Rule 255   _53_optional -> exprs
Rule 256   _53_optional -> <empty>
Rule 257   exprs -> expr _54_optional
Rule 258   _54_optional -> NEWLINE
Rule 259   _54_optional -> <empty>
Rule 260   exprs -> exprs , _55_optional expr _56_optional
Rule 261   _55_optional -> NEWLINE
Rule 262   _55_optional -> <empty>
Rule 263   _56_optional -> NEWLINE
Rule 264   _56_optional -> <empty>
Rule 265   identifier -> IDENTIFIER
Rule 266   type_identifier -> TYPE_IDENTIFIER
Rule 267   let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr  [precedence=left, level=5]
Rule 268   _57_repeat -> _57_items
Rule 269   _57_repeat -> <empty>
Rule 270   _57_items -> _57_items _57_item
Rule 271   _57_items -> _57_item
Rule 272   _57_item -> , type
Rule 273   let -> identifier _58_optional = expr  [precedence=right, level=1]
Rule 274   _58_optional -> : type
Rule 275   _58_optional -> <empty>
Rule 276   int_literal -> INT
Rule 277   float_literal -> FLOAT
Rule 278   str_literal -> STRING

Terminals, with rules where they appear:

!                    : 29
(                    : 10 109 118 140 147 196 229 247 252
)                    : 10 109 118 140 147 196 229 247 252
*                    : 66 104
+                    : 28 69 107
,                    : 109 118 123 152 162 172 184 201 237 260 272
-                    : 31 68 106
/                    : 67 105
:                    : 116 130 133 145 157 203 206 267 274
<                    : 65 103 118 147 167 179 267
=                    : 273
>                    : 60 98 118 147 167 179
AND                  : 55 93
ARRAY_CONCAT         : 50 88
ARRAY_SUB            : 49 87
ARROW_BOTH           : 39 77
ARROW_LEFT           : 41 79
ARROW_RIGHT          : 40 78
BIT_AND              : 45 83
BIT_OR               : 46 84
BIT_SHIFT_LEFT       : 44 82
CASE                 : 214
CONCAT               : 70 108
DEF                  : 109 118 140 147
DO                   : 132
DOUBLE_ARROW_LEFT    : 43 81
DOUBLE_ARROW_RIGHT   : 42 80
ELIF                 : 210
ELSE                 : 213
END                  : 132 205 214
ENUM                 : 174 179
EQUAL                : 58 96
EXTERNAL             : 32
FLOAT                : 277
FLOAT_DIV            : 62 100
FLOAT_LESS           : 35 73
FLOAT_LESS_OR_EQ     : 36 74
FLOAT_MORE           : 33 71
FLOAT_MORE_OR_EQ     : 34 72
FLOAT_MUL            : 61 99
FLOAT_POW            : 47 85
FLOAT_SUB            : 63 101
FLOAT_SUM            : 64 102
IDENTIFIER           : 265
IF                   : 205
INT                  : 276
LESS_OR_EQ           : 52 90
MORE_OR_EQ           : 51 89 267
NEWLINE              : 2 7 9 110 112 114 124 126 128 136 141 153 160 163 165 175 185 190 193 215 220 223 230 235 238 240 243 248 253 258 261 263
NOT_EQUAL            : 59 97
OF                   : 214
OR                   : 57 95
POW                  : 48 86
SOME_CONCAT          : 38 76
SOME_SUB             : 37 75
STRICT_AND           : 54 92
STRICT_NOT           : 30
STRICT_OR            : 56 94
STRING               : 278
TEXT_MATCH           : 53 91
THEN                 : 205 210
TYPE_IDENTIFIER      : 266
[                    : 242
]                    : 242
error                : 
{                    : 174 179
}                    : 174 179

Nonterminals, with rules where they appear:

_10_optional         : 118
_11_optional         : 118
_12_optional         : 118
_13_optional         : 132
_14_optional         : 135
_15_optional         : 135
_16_optional         : 140
_17_optional         : 140
_18_optional         : 140
_19_item             : 150 151
_19_items            : 148 150
_19_repeat           : 147
_1_optional          : 1
_20_optional         : 147
_21_optional         : 147
_22_optional         : 147
_23_optional         : 159
_24_optional         : 162
_25_optional         : 162
_26_item             : 170 171
_26_items            : 168 170
_26_repeat           : 167
_27_optional         : 174
_28_optional         : 174
_29_item             : 182 183
_29_items            : 180 182
_29_repeat           : 179
_2_optional          : 1
_30_optional         : 179
_31_optional         : 179
_32_optional         : 189
_33_optional         : 192
_34_item             : 199 200
_34_items            : 197 199
_34_repeat           : 196
_35_optional         : 202
_36_optional         : 205
_37_optional         : 205
_38_optional         : 210
_39_optional         : 214
_3_optional          : 6
_40_optional         : 214
_41_optional         : 219
_42_optional         : 222
_43_optional         : 229
_44_optional         : 229
_45_optional         : 234
_46_optional         : 237
_47_optional         : 237
_48_optional         : 242
_49_optional         : 242
_4_optional          : 109
_50_optional         : 247
_51_optional         : 247
_52_optional         : 252
_53_optional         : 252
_54_optional         : 257
_55_optional         : 260
_56_optional         : 260
_57_item             : 270 271
_57_items            : 268 270
_57_repeat           : 267
_58_optional         : 273
_5_optional          : 109
_6_optional          : 109
_7_optional          : 109
_8_item              : 121 122
_8_items             : 119 121
_8_repeat            : 118
_9_optional          : 118
array                : 16
binary_expr          : 22
binary_op            : 109 118
binary_op_def        : 11
block_statement      : 132 205 210 213
call                 : 20
case_of              : 21
cases                : 217 222
def_expr             : 24
do                   : 25 109 118 140 147 219 222
do_exprs             : 4 9 138
enum                 : 27
expr                 : 6 9 10 28 29 30 31 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 205 210 214 247 257 260 267 273
exprs                : 245 250 255 260
external             : 26
float_literal        : 14
identifier           : 18 140 147 202 227 267 273
if_expr              : 23
int_literal          : 15
let                  : 19
match_as             : 226
match_variant        : 225
or_else              : 208 211
param                : 109 109 118 118 159 162
params               : 143 155 162
pattern              : 219 222 234 237
patterns             : 232 237
program              : 0
str_literal          : 13
type                 : 116 130 133 145 157 167 172 196 201 203 206 267 272 274
type_identifier      : 118 123 147 152 167 173 174 179 179 184 195 196 228 229 252 267
unary_expr           : 12
variant              : 189 192
variant_call         : 17
variants             : 177 187 192


state 0

    (0) S' -> . program
    (1) program -> . _1_optional _2_optional
    (2) _1_optional -> . NEWLINE
    (3) _1_optional -> .
    NEWLINE         shift and go to state 3
    (               reduce using rule 3 (_1_optional -> .)
    DEF             reduce using rule 3 (_1_optional -> .)
    +               reduce using rule 3 (_1_optional -> .)
    !               reduce using rule 3 (_1_optional -> .)
    STRICT_NOT      reduce using rule 3 (_1_optional -> .)
    -               reduce using rule 3 (_1_optional -> .)
    STRING          reduce using rule 3 (_1_optional -> .)
    FLOAT           reduce using rule 3 (_1_optional -> .)
    INT             reduce using rule 3 (_1_optional -> .)
    [               reduce using rule 3 (_1_optional -> .)
    IDENTIFIER      reduce using rule 3 (_1_optional -> .)
    CASE            reduce using rule 3 (_1_optional -> .)
    IF              reduce using rule 3 (_1_optional -> .)
    DO              reduce using rule 3 (_1_optional -> .)
    EXTERNAL        reduce using rule 3 (_1_optional -> .)
    ENUM            reduce using rule 3 (_1_optional -> .)
    TYPE_IDENTIFIER reduce using rule 3 (_1_optional -> .)
    $end            reduce using rule 3 (_1_optional -> .)

    program                        shift and go to state 1
    _1_optional                    shift and go to state 2

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_optional . _2_optional
    (4) _2_optional -> . do_exprs
    (5) _2_optional -> .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 5 (_2_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    _2_optional                    shift and go to state 4
    do_exprs                       shift and go to state 5
    expr                           shift and go to state 6
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 3

    (2) _1_optional -> NEWLINE .
    (               reduce using rule 2 (_1_optional -> NEWLINE .)
    DEF             reduce using rule 2 (_1_optional -> NEWLINE .)
    +               reduce using rule 2 (_1_optional -> NEWLINE .)
    !               reduce using rule 2 (_1_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 2 (_1_optional -> NEWLINE .)
    -               reduce using rule 2 (_1_optional -> NEWLINE .)
    STRING          reduce using rule 2 (_1_optional -> NEWLINE .)
    FLOAT           reduce using rule 2 (_1_optional -> NEWLINE .)
    INT             reduce using rule 2 (_1_optional -> NEWLINE .)
    [               reduce using rule 2 (_1_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 2 (_1_optional -> NEWLINE .)
    CASE            reduce using rule 2 (_1_optional -> NEWLINE .)
    IF              reduce using rule 2 (_1_optional -> NEWLINE .)
    DO              reduce using rule 2 (_1_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 2 (_1_optional -> NEWLINE .)
    ENUM            reduce using rule 2 (_1_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 2 (_1_optional -> NEWLINE .)
    $end            reduce using rule 2 (_1_optional -> NEWLINE .)


state 4

    (1) program -> _1_optional _2_optional .
    $end            reduce using rule 1 (program -> _1_optional _2_optional .)


state 5

    (4) _2_optional -> do_exprs .
    $end            reduce using rule 4 (_2_optional -> do_exprs .)


state 6

    (6) do_exprs -> expr . _3_optional
    (9) do_exprs -> expr . NEWLINE do_exprs
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    (7) _3_optional -> . NEWLINE
    (8) _3_optional -> .
    NEWLINE         shift and go to state 43
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82
    $end            reduce using rule 8 (_3_optional -> .)
    END             reduce using rule 8 (_3_optional -> .)
    ELIF            reduce using rule 8 (_3_optional -> .)
    ELSE            reduce using rule 8 (_3_optional -> .)

    _3_optional                    shift and go to state 42

state 7

    (10) expr -> ( . expr )
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 83
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 8

    (11) expr -> binary_op_def .
    NEWLINE         reduce using rule 11 (expr -> binary_op_def .)
    (               reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_MORE      reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_MORE_OR_EQ reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_LESS      reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_LESS_OR_EQ reduce using rule 11 (expr -> binary_op_def .)
    SOME_SUB        reduce using rule 11 (expr -> binary_op_def .)
    SOME_CONCAT     reduce using rule 11 (expr -> binary_op_def .)
    ARROW_BOTH      reduce using rule 11 (expr -> binary_op_def .)
    ARROW_RIGHT     reduce using rule 11 (expr -> binary_op_def .)
    ARROW_LEFT      reduce using rule 11 (expr -> binary_op_def .)
    DOUBLE_ARROW_RIGHT reduce using rule 11 (expr -> binary_op_def .)
    DOUBLE_ARROW_LEFT reduce using rule 11 (expr -> binary_op_def .)
    BIT_SHIFT_LEFT  reduce using rule 11 (expr -> binary_op_def .)
    BIT_AND         reduce using rule 11 (expr -> binary_op_def .)
    BIT_OR          reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_POW       reduce using rule 11 (expr -> binary_op_def .)
    POW             reduce using rule 11 (expr -> binary_op_def .)
    ARRAY_SUB       reduce using rule 11 (expr -> binary_op_def .)
    ARRAY_CONCAT    reduce using rule 11 (expr -> binary_op_def .)
    MORE_OR_EQ      reduce using rule 11 (expr -> binary_op_def .)
    LESS_OR_EQ      reduce using rule 11 (expr -> binary_op_def .)
    TEXT_MATCH      reduce using rule 11 (expr -> binary_op_def .)
    STRICT_AND      reduce using rule 11 (expr -> binary_op_def .)
    AND             reduce using rule 11 (expr -> binary_op_def .)
    STRICT_OR       reduce using rule 11 (expr -> binary_op_def .)
    OR              reduce using rule 11 (expr -> binary_op_def .)
    EQUAL           reduce using rule 11 (expr -> binary_op_def .)
    NOT_EQUAL       reduce using rule 11 (expr -> binary_op_def .)
    >               reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_MUL       reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_DIV       reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_SUB       reduce using rule 11 (expr -> binary_op_def .)
    FLOAT_SUM       reduce using rule 11 (expr -> binary_op_def .)
    <               reduce using rule 11 (expr -> binary_op_def .)
    *               reduce using rule 11 (expr -> binary_op_def .)
    /               reduce using rule 11 (expr -> binary_op_def .)
    -               reduce using rule 11 (expr -> binary_op_def .)
    +               reduce using rule 11 (expr -> binary_op_def .)
    CONCAT          reduce using rule 11 (expr -> binary_op_def .)
    $end            reduce using rule 11 (expr -> binary_op_def .)
    )               reduce using rule 11 (expr -> binary_op_def .)
    OF              reduce using rule 11 (expr -> binary_op_def .)
    THEN            reduce using rule 11 (expr -> binary_op_def .)
    END             reduce using rule 11 (expr -> binary_op_def .)
    ELIF            reduce using rule 11 (expr -> binary_op_def .)
    ELSE            reduce using rule 11 (expr -> binary_op_def .)
    ,               reduce using rule 11 (expr -> binary_op_def .)
    ]               reduce using rule 11 (expr -> binary_op_def .)


state 9

    (12) expr -> unary_expr .
    NEWLINE         reduce using rule 12 (expr -> unary_expr .)
    (               reduce using rule 12 (expr -> unary_expr .)
    FLOAT_MORE      reduce using rule 12 (expr -> unary_expr .)
    FLOAT_MORE_OR_EQ reduce using rule 12 (expr -> unary_expr .)
    FLOAT_LESS      reduce using rule 12 (expr -> unary_expr .)
    FLOAT_LESS_OR_EQ reduce using rule 12 (expr -> unary_expr .)
    SOME_SUB        reduce using rule 12 (expr -> unary_expr .)
    SOME_CONCAT     reduce using rule 12 (expr -> unary_expr .)
    ARROW_BOTH      reduce using rule 12 (expr -> unary_expr .)
    ARROW_RIGHT     reduce using rule 12 (expr -> unary_expr .)
    ARROW_LEFT      reduce using rule 12 (expr -> unary_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 12 (expr -> unary_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 12 (expr -> unary_expr .)
    BIT_SHIFT_LEFT  reduce using rule 12 (expr -> unary_expr .)
    BIT_AND         reduce using rule 12 (expr -> unary_expr .)
    BIT_OR          reduce using rule 12 (expr -> unary_expr .)
    FLOAT_POW       reduce using rule 12 (expr -> unary_expr .)
    POW             reduce using rule 12 (expr -> unary_expr .)
    ARRAY_SUB       reduce using rule 12 (expr -> unary_expr .)
    ARRAY_CONCAT    reduce using rule 12 (expr -> unary_expr .)
    MORE_OR_EQ      reduce using rule 12 (expr -> unary_expr .)
    LESS_OR_EQ      reduce using rule 12 (expr -> unary_expr .)
    TEXT_MATCH      reduce using rule 12 (expr -> unary_expr .)
    STRICT_AND      reduce using rule 12 (expr -> unary_expr .)
    AND             reduce using rule 12 (expr -> unary_expr .)
    STRICT_OR       reduce using rule 12 (expr -> unary_expr .)
    OR              reduce using rule 12 (expr -> unary_expr .)
    EQUAL           reduce using rule 12 (expr -> unary_expr .)
    NOT_EQUAL       reduce using rule 12 (expr -> unary_expr .)
    >               reduce using rule 12 (expr -> unary_expr .)
    FLOAT_MUL       reduce using rule 12 (expr -> unary_expr .)
    FLOAT_DIV       reduce using rule 12 (expr -> unary_expr .)
    FLOAT_SUB       reduce using rule 12 (expr -> unary_expr .)
    FLOAT_SUM       reduce using rule 12 (expr -> unary_expr .)
    <               reduce using rule 12 (expr -> unary_expr .)
    *               reduce using rule 12 (expr -> unary_expr .)
    /               reduce using rule 12 (expr -> unary_expr .)
    -               reduce using rule 12 (expr -> unary_expr .)
    +               reduce using rule 12 (expr -> unary_expr .)
    CONCAT          reduce using rule 12 (expr -> unary_expr .)
    $end            reduce using rule 12 (expr -> unary_expr .)
    )               reduce using rule 12 (expr -> unary_expr .)
    OF              reduce using rule 12 (expr -> unary_expr .)
    THEN            reduce using rule 12 (expr -> unary_expr .)
    END             reduce using rule 12 (expr -> unary_expr .)
    ELIF            reduce using rule 12 (expr -> unary_expr .)
    ELSE            reduce using rule 12 (expr -> unary_expr .)
    ,               reduce using rule 12 (expr -> unary_expr .)
    ]               reduce using rule 12 (expr -> unary_expr .)


state 10

    (13) expr -> str_literal .
    NEWLINE         reduce using rule 13 (expr -> str_literal .)
    (               reduce using rule 13 (expr -> str_literal .)
    FLOAT_MORE      reduce using rule 13 (expr -> str_literal .)
    FLOAT_MORE_OR_EQ reduce using rule 13 (expr -> str_literal .)
    FLOAT_LESS      reduce using rule 13 (expr -> str_literal .)
    FLOAT_LESS_OR_EQ reduce using rule 13 (expr -> str_literal .)
    SOME_SUB        reduce using rule 13 (expr -> str_literal .)
    SOME_CONCAT     reduce using rule 13 (expr -> str_literal .)
    ARROW_BOTH      reduce using rule 13 (expr -> str_literal .)
    ARROW_RIGHT     reduce using rule 13 (expr -> str_literal .)
    ARROW_LEFT      reduce using rule 13 (expr -> str_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 13 (expr -> str_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 13 (expr -> str_literal .)
    BIT_SHIFT_LEFT  reduce using rule 13 (expr -> str_literal .)
    BIT_AND         reduce using rule 13 (expr -> str_literal .)
    BIT_OR          reduce using rule 13 (expr -> str_literal .)
    FLOAT_POW       reduce using rule 13 (expr -> str_literal .)
    POW             reduce using rule 13 (expr -> str_literal .)
    ARRAY_SUB       reduce using rule 13 (expr -> str_literal .)
    ARRAY_CONCAT    reduce using rule 13 (expr -> str_literal .)
    MORE_OR_EQ      reduce using rule 13 (expr -> str_literal .)
    LESS_OR_EQ      reduce using rule 13 (expr -> str_literal .)
    TEXT_MATCH      reduce using rule 13 (expr -> str_literal .)
    STRICT_AND      reduce using rule 13 (expr -> str_literal .)
    AND             reduce using rule 13 (expr -> str_literal .)
    STRICT_OR       reduce using rule 13 (expr -> str_literal .)
    OR              reduce using rule 13 (expr -> str_literal .)
    EQUAL           reduce using rule 13 (expr -> str_literal .)
    NOT_EQUAL       reduce using rule 13 (expr -> str_literal .)
    >               reduce using rule 13 (expr -> str_literal .)
    FLOAT_MUL       reduce using rule 13 (expr -> str_literal .)
    FLOAT_DIV       reduce using rule 13 (expr -> str_literal .)
    FLOAT_SUB       reduce using rule 13 (expr -> str_literal .)
    FLOAT_SUM       reduce using rule 13 (expr -> str_literal .)
    <               reduce using rule 13 (expr -> str_literal .)
    *               reduce using rule 13 (expr -> str_literal .)
    /               reduce using rule 13 (expr -> str_literal .)
    -               reduce using rule 13 (expr -> str_literal .)
    +               reduce using rule 13 (expr -> str_literal .)
    CONCAT          reduce using rule 13 (expr -> str_literal .)
    $end            reduce using rule 13 (expr -> str_literal .)
    )               reduce using rule 13 (expr -> str_literal .)
    OF              reduce using rule 13 (expr -> str_literal .)
    THEN            reduce using rule 13 (expr -> str_literal .)
    END             reduce using rule 13 (expr -> str_literal .)
    ELIF            reduce using rule 13 (expr -> str_literal .)
    ELSE            reduce using rule 13 (expr -> str_literal .)
    ,               reduce using rule 13 (expr -> str_literal .)
    ]               reduce using rule 13 (expr -> str_literal .)


state 11

    (14) expr -> float_literal .
    NEWLINE         reduce using rule 14 (expr -> float_literal .)
    (               reduce using rule 14 (expr -> float_literal .)
    FLOAT_MORE      reduce using rule 14 (expr -> float_literal .)
    FLOAT_MORE_OR_EQ reduce using rule 14 (expr -> float_literal .)
    FLOAT_LESS      reduce using rule 14 (expr -> float_literal .)
    FLOAT_LESS_OR_EQ reduce using rule 14 (expr -> float_literal .)
    SOME_SUB        reduce using rule 14 (expr -> float_literal .)
    SOME_CONCAT     reduce using rule 14 (expr -> float_literal .)
    ARROW_BOTH      reduce using rule 14 (expr -> float_literal .)
    ARROW_RIGHT     reduce using rule 14 (expr -> float_literal .)
    ARROW_LEFT      reduce using rule 14 (expr -> float_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 14 (expr -> float_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 14 (expr -> float_literal .)
    BIT_SHIFT_LEFT  reduce using rule 14 (expr -> float_literal .)
    BIT_AND         reduce using rule 14 (expr -> float_literal .)
    BIT_OR          reduce using rule 14 (expr -> float_literal .)
    FLOAT_POW       reduce using rule 14 (expr -> float_literal .)
    POW             reduce using rule 14 (expr -> float_literal .)
    ARRAY_SUB       reduce using rule 14 (expr -> float_literal .)
    ARRAY_CONCAT    reduce using rule 14 (expr -> float_literal .)
    MORE_OR_EQ      reduce using rule 14 (expr -> float_literal .)
    LESS_OR_EQ      reduce using rule 14 (expr -> float_literal .)
    TEXT_MATCH      reduce using rule 14 (expr -> float_literal .)
    STRICT_AND      reduce using rule 14 (expr -> float_literal .)
    AND             reduce using rule 14 (expr -> float_literal .)
    STRICT_OR       reduce using rule 14 (expr -> float_literal .)
    OR              reduce using rule 14 (expr -> float_literal .)
    EQUAL           reduce using rule 14 (expr -> float_literal .)
    NOT_EQUAL       reduce using rule 14 (expr -> float_literal .)
    >               reduce using rule 14 (expr -> float_literal .)
    FLOAT_MUL       reduce using rule 14 (expr -> float_literal .)
    FLOAT_DIV       reduce using rule 14 (expr -> float_literal .)
    FLOAT_SUB       reduce using rule 14 (expr -> float_literal .)
    FLOAT_SUM       reduce using rule 14 (expr -> float_literal .)
    <               reduce using rule 14 (expr -> float_literal .)
    *               reduce using rule 14 (expr -> float_literal .)
    /               reduce using rule 14 (expr -> float_literal .)
    -               reduce using rule 14 (expr -> float_literal .)
    +               reduce using rule 14 (expr -> float_literal .)
    CONCAT          reduce using rule 14 (expr -> float_literal .)
    $end            reduce using rule 14 (expr -> float_literal .)
    )               reduce using rule 14 (expr -> float_literal .)
    OF              reduce using rule 14 (expr -> float_literal .)
    THEN            reduce using rule 14 (expr -> float_literal .)
    END             reduce using rule 14 (expr -> float_literal .)
    ELIF            reduce using rule 14 (expr -> float_literal .)
    ELSE            reduce using rule 14 (expr -> float_literal .)
    ,               reduce using rule 14 (expr -> float_literal .)
    ]               reduce using rule 14 (expr -> float_literal .)


state 12

    (15) expr -> int_literal .
    NEWLINE         reduce using rule 15 (expr -> int_literal .)
    (               reduce using rule 15 (expr -> int_literal .)
    FLOAT_MORE      reduce using rule 15 (expr -> int_literal .)
    FLOAT_MORE_OR_EQ reduce using rule 15 (expr -> int_literal .)
    FLOAT_LESS      reduce using rule 15 (expr -> int_literal .)
    FLOAT_LESS_OR_EQ reduce using rule 15 (expr -> int_literal .)
    SOME_SUB        reduce using rule 15 (expr -> int_literal .)
    SOME_CONCAT     reduce using rule 15 (expr -> int_literal .)
    ARROW_BOTH      reduce using rule 15 (expr -> int_literal .)
    ARROW_RIGHT     reduce using rule 15 (expr -> int_literal .)
    ARROW_LEFT      reduce using rule 15 (expr -> int_literal .)
    DOUBLE_ARROW_RIGHT reduce using rule 15 (expr -> int_literal .)
    DOUBLE_ARROW_LEFT reduce using rule 15 (expr -> int_literal .)
    BIT_SHIFT_LEFT  reduce using rule 15 (expr -> int_literal .)
    BIT_AND         reduce using rule 15 (expr -> int_literal .)
    BIT_OR          reduce using rule 15 (expr -> int_literal .)
    FLOAT_POW       reduce using rule 15 (expr -> int_literal .)
    POW             reduce using rule 15 (expr -> int_literal .)
    ARRAY_SUB       reduce using rule 15 (expr -> int_literal .)
    ARRAY_CONCAT    reduce using rule 15 (expr -> int_literal .)
    MORE_OR_EQ      reduce using rule 15 (expr -> int_literal .)
    LESS_OR_EQ      reduce using rule 15 (expr -> int_literal .)
    TEXT_MATCH      reduce using rule 15 (expr -> int_literal .)
    STRICT_AND      reduce using rule 15 (expr -> int_literal .)
    AND             reduce using rule 15 (expr -> int_literal .)
    STRICT_OR       reduce using rule 15 (expr -> int_literal .)
    OR              reduce using rule 15 (expr -> int_literal .)
    EQUAL           reduce using rule 15 (expr -> int_literal .)
    NOT_EQUAL       reduce using rule 15 (expr -> int_literal .)
    >               reduce using rule 15 (expr -> int_literal .)
    FLOAT_MUL       reduce using rule 15 (expr -> int_literal .)
    FLOAT_DIV       reduce using rule 15 (expr -> int_literal .)
    FLOAT_SUB       reduce using rule 15 (expr -> int_literal .)
    FLOAT_SUM       reduce using rule 15 (expr -> int_literal .)
    <               reduce using rule 15 (expr -> int_literal .)
    *               reduce using rule 15 (expr -> int_literal .)
    /               reduce using rule 15 (expr -> int_literal .)
    -               reduce using rule 15 (expr -> int_literal .)
    +               reduce using rule 15 (expr -> int_literal .)
    CONCAT          reduce using rule 15 (expr -> int_literal .)
    $end            reduce using rule 15 (expr -> int_literal .)
    )               reduce using rule 15 (expr -> int_literal .)
    OF              reduce using rule 15 (expr -> int_literal .)
    THEN            reduce using rule 15 (expr -> int_literal .)
    END             reduce using rule 15 (expr -> int_literal .)
    ELIF            reduce using rule 15 (expr -> int_literal .)
    ELSE            reduce using rule 15 (expr -> int_literal .)
    ,               reduce using rule 15 (expr -> int_literal .)
    ]               reduce using rule 15 (expr -> int_literal .)


state 13

    (16) expr -> array .
    NEWLINE         reduce using rule 16 (expr -> array .)
    (               reduce using rule 16 (expr -> array .)
    FLOAT_MORE      reduce using rule 16 (expr -> array .)
    FLOAT_MORE_OR_EQ reduce using rule 16 (expr -> array .)
    FLOAT_LESS      reduce using rule 16 (expr -> array .)
    FLOAT_LESS_OR_EQ reduce using rule 16 (expr -> array .)
    SOME_SUB        reduce using rule 16 (expr -> array .)
    SOME_CONCAT     reduce using rule 16 (expr -> array .)
    ARROW_BOTH      reduce using rule 16 (expr -> array .)
    ARROW_RIGHT     reduce using rule 16 (expr -> array .)
    ARROW_LEFT      reduce using rule 16 (expr -> array .)
    DOUBLE_ARROW_RIGHT reduce using rule 16 (expr -> array .)
    DOUBLE_ARROW_LEFT reduce using rule 16 (expr -> array .)
    BIT_SHIFT_LEFT  reduce using rule 16 (expr -> array .)
    BIT_AND         reduce using rule 16 (expr -> array .)
    BIT_OR          reduce using rule 16 (expr -> array .)
    FLOAT_POW       reduce using rule 16 (expr -> array .)
    POW             reduce using rule 16 (expr -> array .)
    ARRAY_SUB       reduce using rule 16 (expr -> array .)
    ARRAY_CONCAT    reduce using rule 16 (expr -> array .)
    MORE_OR_EQ      reduce using rule 16 (expr -> array .)
    LESS_OR_EQ      reduce using rule 16 (expr -> array .)
    TEXT_MATCH      reduce using rule 16 (expr -> array .)
    STRICT_AND      reduce using rule 16 (expr -> array .)
    AND             reduce using rule 16 (expr -> array .)
    STRICT_OR       reduce using rule 16 (expr -> array .)
    OR              reduce using rule 16 (expr -> array .)
    EQUAL           reduce using rule 16 (expr -> array .)
    NOT_EQUAL       reduce using rule 16 (expr -> array .)
    >               reduce using rule 16 (expr -> array .)
    FLOAT_MUL       reduce using rule 16 (expr -> array .)
    FLOAT_DIV       reduce using rule 16 (expr -> array .)
    FLOAT_SUB       reduce using rule 16 (expr -> array .)
    FLOAT_SUM       reduce using rule 16 (expr -> array .)
    <               reduce using rule 16 (expr -> array .)
    *               reduce using rule 16 (expr -> array .)
    /               reduce using rule 16 (expr -> array .)
    -               reduce using rule 16 (expr -> array .)
    +               reduce using rule 16 (expr -> array .)
    CONCAT          reduce using rule 16 (expr -> array .)
    $end            reduce using rule 16 (expr -> array .)
    )               reduce using rule 16 (expr -> array .)
    OF              reduce using rule 16 (expr -> array .)
    THEN            reduce using rule 16 (expr -> array .)
    END             reduce using rule 16 (expr -> array .)
    ELIF            reduce using rule 16 (expr -> array .)
    ELSE            reduce using rule 16 (expr -> array .)
    ,               reduce using rule 16 (expr -> array .)
    ]               reduce using rule 16 (expr -> array .)


state 14

    (17) expr -> variant_call .
    NEWLINE         reduce using rule 17 (expr -> variant_call .)
    (               reduce using rule 17 (expr -> variant_call .)
    FLOAT_MORE      reduce using rule 17 (expr -> variant_call .)
    FLOAT_MORE_OR_EQ reduce using rule 17 (expr -> variant_call .)
    FLOAT_LESS      reduce using rule 17 (expr -> variant_call .)
    FLOAT_LESS_OR_EQ reduce using rule 17 (expr -> variant_call .)
    SOME_SUB        reduce using rule 17 (expr -> variant_call .)
    SOME_CONCAT     reduce using rule 17 (expr -> variant_call .)
    ARROW_BOTH      reduce using rule 17 (expr -> variant_call .)
    ARROW_RIGHT     reduce using rule 17 (expr -> variant_call .)
    ARROW_LEFT      reduce using rule 17 (expr -> variant_call .)
    DOUBLE_ARROW_RIGHT reduce using rule 17 (expr -> variant_call .)
    DOUBLE_ARROW_LEFT reduce using rule 17 (expr -> variant_call .)
    BIT_SHIFT_LEFT  reduce using rule 17 (expr -> variant_call .)
    BIT_AND         reduce using rule 17 (expr -> variant_call .)
    BIT_OR          reduce using rule 17 (expr -> variant_call .)
    FLOAT_POW       reduce using rule 17 (expr -> variant_call .)
    POW             reduce using rule 17 (expr -> variant_call .)
    ARRAY_SUB       reduce using rule 17 (expr -> variant_call .)
    ARRAY_CONCAT    reduce using rule 17 (expr -> variant_call .)
    MORE_OR_EQ      reduce using rule 17 (expr -> variant_call .)
    LESS_OR_EQ      reduce using rule 17 (expr -> variant_call .)
    TEXT_MATCH      reduce using rule 17 (expr -> variant_call .)
    STRICT_AND      reduce using rule 17 (expr -> variant_call .)
    AND             reduce using rule 17 (expr -> variant_call .)
    STRICT_OR       reduce using rule 17 (expr -> variant_call .)
    OR              reduce using rule 17 (expr -> variant_call .)
    EQUAL           reduce using rule 17 (expr -> variant_call .)
    NOT_EQUAL       reduce using rule 17 (expr -> variant_call .)
    >               reduce using rule 17 (expr -> variant_call .)
    FLOAT_MUL       reduce using rule 17 (expr -> variant_call .)
    FLOAT_DIV       reduce using rule 17 (expr -> variant_call .)
    FLOAT_SUB       reduce using rule 17 (expr -> variant_call .)
    FLOAT_SUM       reduce using rule 17 (expr -> variant_call .)
    <               reduce using rule 17 (expr -> variant_call .)
    *               reduce using rule 17 (expr -> variant_call .)
    /               reduce using rule 17 (expr -> variant_call .)
    -               reduce using rule 17 (expr -> variant_call .)
    +               reduce using rule 17 (expr -> variant_call .)
    CONCAT          reduce using rule 17 (expr -> variant_call .)
    $end            reduce using rule 17 (expr -> variant_call .)
    )               reduce using rule 17 (expr -> variant_call .)
    OF              reduce using rule 17 (expr -> variant_call .)
    THEN            reduce using rule 17 (expr -> variant_call .)
    END             reduce using rule 17 (expr -> variant_call .)
    ELIF            reduce using rule 17 (expr -> variant_call .)
    ELSE            reduce using rule 17 (expr -> variant_call .)
    ,               reduce using rule 17 (expr -> variant_call .)
    ]               reduce using rule 17 (expr -> variant_call .)


state 15

    (18) expr -> identifier .
    (267) let -> identifier . : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> identifier . _58_optional = expr
    (274) _58_optional -> . : type
    (275) _58_optional -> .
    NEWLINE         reduce using rule 18 (expr -> identifier .)
    (               reduce using rule 18 (expr -> identifier .)
    FLOAT_MORE      reduce using rule 18 (expr -> identifier .)
    FLOAT_MORE_OR_EQ reduce using rule 18 (expr -> identifier .)
    FLOAT_LESS      reduce using rule 18 (expr -> identifier .)
    FLOAT_LESS_OR_EQ reduce using rule 18 (expr -> identifier .)
    SOME_SUB        reduce using rule 18 (expr -> identifier .)
    SOME_CONCAT     reduce using rule 18 (expr -> identifier .)
    ARROW_BOTH      reduce using rule 18 (expr -> identifier .)
    ARROW_RIGHT     reduce using rule 18 (expr -> identifier .)
    ARROW_LEFT      reduce using rule 18 (expr -> identifier .)
    DOUBLE_ARROW_RIGHT reduce using rule 18 (expr -> identifier .)
    DOUBLE_ARROW_LEFT reduce using rule 18 (expr -> identifier .)
    BIT_SHIFT_LEFT  reduce using rule 18 (expr -> identifier .)
    BIT_AND         reduce using rule 18 (expr -> identifier .)
    BIT_OR          reduce using rule 18 (expr -> identifier .)
    FLOAT_POW       reduce using rule 18 (expr -> identifier .)
    POW             reduce using rule 18 (expr -> identifier .)
    ARRAY_SUB       reduce using rule 18 (expr -> identifier .)
    ARRAY_CONCAT    reduce using rule 18 (expr -> identifier .)
    MORE_OR_EQ      reduce using rule 18 (expr -> identifier .)
    LESS_OR_EQ      reduce using rule 18 (expr -> identifier .)
    TEXT_MATCH      reduce using rule 18 (expr -> identifier .)
    STRICT_AND      reduce using rule 18 (expr -> identifier .)
    AND             reduce using rule 18 (expr -> identifier .)
    STRICT_OR       reduce using rule 18 (expr -> identifier .)
    OR              reduce using rule 18 (expr -> identifier .)
    EQUAL           reduce using rule 18 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 18 (expr -> identifier .)
    >               reduce using rule 18 (expr -> identifier .)
    FLOAT_MUL       reduce using rule 18 (expr -> identifier .)
    FLOAT_DIV       reduce using rule 18 (expr -> identifier .)
    FLOAT_SUB       reduce using rule 18 (expr -> identifier .)
    FLOAT_SUM       reduce using rule 18 (expr -> identifier .)
    <               reduce using rule 18 (expr -> identifier .)
    *               reduce using rule 18 (expr -> identifier .)
    /               reduce using rule 18 (expr -> identifier .)
    -               reduce using rule 18 (expr -> identifier .)
    +               reduce using rule 18 (expr -> identifier .)
    CONCAT          reduce using rule 18 (expr -> identifier .)
    $end            reduce using rule 18 (expr -> identifier .)
    )               reduce using rule 18 (expr -> identifier .)
    OF              reduce using rule 18 (expr -> identifier .)
    THEN            reduce using rule 18 (expr -> identifier .)
    END             reduce using rule 18 (expr -> identifier .)
    ELIF            reduce using rule 18 (expr -> identifier .)
    ELSE            reduce using rule 18 (expr -> identifier .)
    ,               reduce using rule 18 (expr -> identifier .)
    ]               reduce using rule 18 (expr -> identifier .)
    :               shift and go to state 84
    =               reduce using rule 275 (_58_optional -> .)

    _58_optional                   shift and go to state 85

state 16

    (19) expr -> let .
    NEWLINE         reduce using rule 19 (expr -> let .)
    (               reduce using rule 19 (expr -> let .)
    FLOAT_MORE      reduce using rule 19 (expr -> let .)
    FLOAT_MORE_OR_EQ reduce using rule 19 (expr -> let .)
    FLOAT_LESS      reduce using rule 19 (expr -> let .)
    FLOAT_LESS_OR_EQ reduce using rule 19 (expr -> let .)
    SOME_SUB        reduce using rule 19 (expr -> let .)
    SOME_CONCAT     reduce using rule 19 (expr -> let .)
    ARROW_BOTH      reduce using rule 19 (expr -> let .)
    ARROW_RIGHT     reduce using rule 19 (expr -> let .)
    ARROW_LEFT      reduce using rule 19 (expr -> let .)
    DOUBLE_ARROW_RIGHT reduce using rule 19 (expr -> let .)
    DOUBLE_ARROW_LEFT reduce using rule 19 (expr -> let .)
    BIT_SHIFT_LEFT  reduce using rule 19 (expr -> let .)
    BIT_AND         reduce using rule 19 (expr -> let .)
    BIT_OR          reduce using rule 19 (expr -> let .)
    FLOAT_POW       reduce using rule 19 (expr -> let .)
    POW             reduce using rule 19 (expr -> let .)
    ARRAY_SUB       reduce using rule 19 (expr -> let .)
    ARRAY_CONCAT    reduce using rule 19 (expr -> let .)
    MORE_OR_EQ      reduce using rule 19 (expr -> let .)
    LESS_OR_EQ      reduce using rule 19 (expr -> let .)
    TEXT_MATCH      reduce using rule 19 (expr -> let .)
    STRICT_AND      reduce using rule 19 (expr -> let .)
    AND             reduce using rule 19 (expr -> let .)
    STRICT_OR       reduce using rule 19 (expr -> let .)
    OR              reduce using rule 19 (expr -> let .)
    EQUAL           reduce using rule 19 (expr -> let .)
    NOT_EQUAL       reduce using rule 19 (expr -> let .)
    >               reduce using rule 19 (expr -> let .)
    FLOAT_MUL       reduce using rule 19 (expr -> let .)
    FLOAT_DIV       reduce using rule 19 (expr -> let .)
    FLOAT_SUB       reduce using rule 19 (expr -> let .)
    FLOAT_SUM       reduce using rule 19 (expr -> let .)
    <               reduce using rule 19 (expr -> let .)
    *               reduce using rule 19 (expr -> let .)
    /               reduce using rule 19 (expr -> let .)
    -               reduce using rule 19 (expr -> let .)
    +               reduce using rule 19 (expr -> let .)
    CONCAT          reduce using rule 19 (expr -> let .)
    $end            reduce using rule 19 (expr -> let .)
    )               reduce using rule 19 (expr -> let .)
    OF              reduce using rule 19 (expr -> let .)
    THEN            reduce using rule 19 (expr -> let .)
    END             reduce using rule 19 (expr -> let .)
    ELIF            reduce using rule 19 (expr -> let .)
    ELSE            reduce using rule 19 (expr -> let .)
    ,               reduce using rule 19 (expr -> let .)
    ]               reduce using rule 19 (expr -> let .)


state 17

    (20) expr -> call .
    NEWLINE         reduce using rule 20 (expr -> call .)
    (               reduce using rule 20 (expr -> call .)
    FLOAT_MORE      reduce using rule 20 (expr -> call .)
    FLOAT_MORE_OR_EQ reduce using rule 20 (expr -> call .)
    FLOAT_LESS      reduce using rule 20 (expr -> call .)
    FLOAT_LESS_OR_EQ reduce using rule 20 (expr -> call .)
    SOME_SUB        reduce using rule 20 (expr -> call .)
    SOME_CONCAT     reduce using rule 20 (expr -> call .)
    ARROW_BOTH      reduce using rule 20 (expr -> call .)
    ARROW_RIGHT     reduce using rule 20 (expr -> call .)
    ARROW_LEFT      reduce using rule 20 (expr -> call .)
    DOUBLE_ARROW_RIGHT reduce using rule 20 (expr -> call .)
    DOUBLE_ARROW_LEFT reduce using rule 20 (expr -> call .)
    BIT_SHIFT_LEFT  reduce using rule 20 (expr -> call .)
    BIT_AND         reduce using rule 20 (expr -> call .)
    BIT_OR          reduce using rule 20 (expr -> call .)
    FLOAT_POW       reduce using rule 20 (expr -> call .)
    POW             reduce using rule 20 (expr -> call .)
    ARRAY_SUB       reduce using rule 20 (expr -> call .)
    ARRAY_CONCAT    reduce using rule 20 (expr -> call .)
    MORE_OR_EQ      reduce using rule 20 (expr -> call .)
    LESS_OR_EQ      reduce using rule 20 (expr -> call .)
    TEXT_MATCH      reduce using rule 20 (expr -> call .)
    STRICT_AND      reduce using rule 20 (expr -> call .)
    AND             reduce using rule 20 (expr -> call .)
    STRICT_OR       reduce using rule 20 (expr -> call .)
    OR              reduce using rule 20 (expr -> call .)
    EQUAL           reduce using rule 20 (expr -> call .)
    NOT_EQUAL       reduce using rule 20 (expr -> call .)
    >               reduce using rule 20 (expr -> call .)
    FLOAT_MUL       reduce using rule 20 (expr -> call .)
    FLOAT_DIV       reduce using rule 20 (expr -> call .)
    FLOAT_SUB       reduce using rule 20 (expr -> call .)
    FLOAT_SUM       reduce using rule 20 (expr -> call .)
    <               reduce using rule 20 (expr -> call .)
    *               reduce using rule 20 (expr -> call .)
    /               reduce using rule 20 (expr -> call .)
    -               reduce using rule 20 (expr -> call .)
    +               reduce using rule 20 (expr -> call .)
    CONCAT          reduce using rule 20 (expr -> call .)
    $end            reduce using rule 20 (expr -> call .)
    )               reduce using rule 20 (expr -> call .)
    OF              reduce using rule 20 (expr -> call .)
    THEN            reduce using rule 20 (expr -> call .)
    END             reduce using rule 20 (expr -> call .)
    ELIF            reduce using rule 20 (expr -> call .)
    ELSE            reduce using rule 20 (expr -> call .)
    ,               reduce using rule 20 (expr -> call .)
    ]               reduce using rule 20 (expr -> call .)


state 18

    (21) expr -> case_of .
    NEWLINE         reduce using rule 21 (expr -> case_of .)
    (               reduce using rule 21 (expr -> case_of .)
    FLOAT_MORE      reduce using rule 21 (expr -> case_of .)
    FLOAT_MORE_OR_EQ reduce using rule 21 (expr -> case_of .)
    FLOAT_LESS      reduce using rule 21 (expr -> case_of .)
    FLOAT_LESS_OR_EQ reduce using rule 21 (expr -> case_of .)
    SOME_SUB        reduce using rule 21 (expr -> case_of .)
    SOME_CONCAT     reduce using rule 21 (expr -> case_of .)
    ARROW_BOTH      reduce using rule 21 (expr -> case_of .)
    ARROW_RIGHT     reduce using rule 21 (expr -> case_of .)
    ARROW_LEFT      reduce using rule 21 (expr -> case_of .)
    DOUBLE_ARROW_RIGHT reduce using rule 21 (expr -> case_of .)
    DOUBLE_ARROW_LEFT reduce using rule 21 (expr -> case_of .)
    BIT_SHIFT_LEFT  reduce using rule 21 (expr -> case_of .)
    BIT_AND         reduce using rule 21 (expr -> case_of .)
    BIT_OR          reduce using rule 21 (expr -> case_of .)
    FLOAT_POW       reduce using rule 21 (expr -> case_of .)
    POW             reduce using rule 21 (expr -> case_of .)
    ARRAY_SUB       reduce using rule 21 (expr -> case_of .)
    ARRAY_CONCAT    reduce using rule 21 (expr -> case_of .)
    MORE_OR_EQ      reduce using rule 21 (expr -> case_of .)
    LESS_OR_EQ      reduce using rule 21 (expr -> case_of .)
    TEXT_MATCH      reduce using rule 21 (expr -> case_of .)
    STRICT_AND      reduce using rule 21 (expr -> case_of .)
    AND             reduce using rule 21 (expr -> case_of .)
    STRICT_OR       reduce using rule 21 (expr -> case_of .)
    OR              reduce using rule 21 (expr -> case_of .)
    EQUAL           reduce using rule 21 (expr -> case_of .)
    NOT_EQUAL       reduce using rule 21 (expr -> case_of .)
    >               reduce using rule 21 (expr -> case_of .)
    FLOAT_MUL       reduce using rule 21 (expr -> case_of .)
    FLOAT_DIV       reduce using rule 21 (expr -> case_of .)
    FLOAT_SUB       reduce using rule 21 (expr -> case_of .)
    FLOAT_SUM       reduce using rule 21 (expr -> case_of .)
    <               reduce using rule 21 (expr -> case_of .)
    *               reduce using rule 21 (expr -> case_of .)
    /               reduce using rule 21 (expr -> case_of .)
    -               reduce using rule 21 (expr -> case_of .)
    +               reduce using rule 21 (expr -> case_of .)
    CONCAT          reduce using rule 21 (expr -> case_of .)
    $end            reduce using rule 21 (expr -> case_of .)
    )               reduce using rule 21 (expr -> case_of .)
    OF              reduce using rule 21 (expr -> case_of .)
    THEN            reduce using rule 21 (expr -> case_of .)
    END             reduce using rule 21 (expr -> case_of .)
    ELIF            reduce using rule 21 (expr -> case_of .)
    ELSE            reduce using rule 21 (expr -> case_of .)
    ,               reduce using rule 21 (expr -> case_of .)
    ]               reduce using rule 21 (expr -> case_of .)


state 19

    (22) expr -> binary_expr .
    NEWLINE         reduce using rule 22 (expr -> binary_expr .)
    (               reduce using rule 22 (expr -> binary_expr .)
    FLOAT_MORE      reduce using rule 22 (expr -> binary_expr .)
    FLOAT_MORE_OR_EQ reduce using rule 22 (expr -> binary_expr .)
    FLOAT_LESS      reduce using rule 22 (expr -> binary_expr .)
    FLOAT_LESS_OR_EQ reduce using rule 22 (expr -> binary_expr .)
    SOME_SUB        reduce using rule 22 (expr -> binary_expr .)
    SOME_CONCAT     reduce using rule 22 (expr -> binary_expr .)
    ARROW_BOTH      reduce using rule 22 (expr -> binary_expr .)
    ARROW_RIGHT     reduce using rule 22 (expr -> binary_expr .)
    ARROW_LEFT      reduce using rule 22 (expr -> binary_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 22 (expr -> binary_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 22 (expr -> binary_expr .)
    BIT_SHIFT_LEFT  reduce using rule 22 (expr -> binary_expr .)
    BIT_AND         reduce using rule 22 (expr -> binary_expr .)
    BIT_OR          reduce using rule 22 (expr -> binary_expr .)
    FLOAT_POW       reduce using rule 22 (expr -> binary_expr .)
    POW             reduce using rule 22 (expr -> binary_expr .)
    ARRAY_SUB       reduce using rule 22 (expr -> binary_expr .)
    ARRAY_CONCAT    reduce using rule 22 (expr -> binary_expr .)
    MORE_OR_EQ      reduce using rule 22 (expr -> binary_expr .)
    LESS_OR_EQ      reduce using rule 22 (expr -> binary_expr .)
    TEXT_MATCH      reduce using rule 22 (expr -> binary_expr .)
    STRICT_AND      reduce using rule 22 (expr -> binary_expr .)
    AND             reduce using rule 22 (expr -> binary_expr .)
    STRICT_OR       reduce using rule 22 (expr -> binary_expr .)
    OR              reduce using rule 22 (expr -> binary_expr .)
    EQUAL           reduce using rule 22 (expr -> binary_expr .)
    NOT_EQUAL       reduce using rule 22 (expr -> binary_expr .)
    >               reduce using rule 22 (expr -> binary_expr .)
    FLOAT_MUL       reduce using rule 22 (expr -> binary_expr .)
    FLOAT_DIV       reduce using rule 22 (expr -> binary_expr .)
    FLOAT_SUB       reduce using rule 22 (expr -> binary_expr .)
    FLOAT_SUM       reduce using rule 22 (expr -> binary_expr .)
    <               reduce using rule 22 (expr -> binary_expr .)
    *               reduce using rule 22 (expr -> binary_expr .)
    /               reduce using rule 22 (expr -> binary_expr .)
    -               reduce using rule 22 (expr -> binary_expr .)
    +               reduce using rule 22 (expr -> binary_expr .)
    CONCAT          reduce using rule 22 (expr -> binary_expr .)
    $end            reduce using rule 22 (expr -> binary_expr .)
    )               reduce using rule 22 (expr -> binary_expr .)
    OF              reduce using rule 22 (expr -> binary_expr .)
    THEN            reduce using rule 22 (expr -> binary_expr .)
    END             reduce using rule 22 (expr -> binary_expr .)
    ELIF            reduce using rule 22 (expr -> binary_expr .)
    ELSE            reduce using rule 22 (expr -> binary_expr .)
    ,               reduce using rule 22 (expr -> binary_expr .)
    ]               reduce using rule 22 (expr -> binary_expr .)


state 20

    (23) expr -> if_expr .
    NEWLINE         reduce using rule 23 (expr -> if_expr .)
    (               reduce using rule 23 (expr -> if_expr .)
    FLOAT_MORE      reduce using rule 23 (expr -> if_expr .)
    FLOAT_MORE_OR_EQ reduce using rule 23 (expr -> if_expr .)
    FLOAT_LESS      reduce using rule 23 (expr -> if_expr .)
    FLOAT_LESS_OR_EQ reduce using rule 23 (expr -> if_expr .)
    SOME_SUB        reduce using rule 23 (expr -> if_expr .)
    SOME_CONCAT     reduce using rule 23 (expr -> if_expr .)
    ARROW_BOTH      reduce using rule 23 (expr -> if_expr .)
    ARROW_RIGHT     reduce using rule 23 (expr -> if_expr .)
    ARROW_LEFT      reduce using rule 23 (expr -> if_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 23 (expr -> if_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 23 (expr -> if_expr .)
    BIT_SHIFT_LEFT  reduce using rule 23 (expr -> if_expr .)
    BIT_AND         reduce using rule 23 (expr -> if_expr .)
    BIT_OR          reduce using rule 23 (expr -> if_expr .)
    FLOAT_POW       reduce using rule 23 (expr -> if_expr .)
    POW             reduce using rule 23 (expr -> if_expr .)
    ARRAY_SUB       reduce using rule 23 (expr -> if_expr .)
    ARRAY_CONCAT    reduce using rule 23 (expr -> if_expr .)
    MORE_OR_EQ      reduce using rule 23 (expr -> if_expr .)
    LESS_OR_EQ      reduce using rule 23 (expr -> if_expr .)
    TEXT_MATCH      reduce using rule 23 (expr -> if_expr .)
    STRICT_AND      reduce using rule 23 (expr -> if_expr .)
    AND             reduce using rule 23 (expr -> if_expr .)
    STRICT_OR       reduce using rule 23 (expr -> if_expr .)
    OR              reduce using rule 23 (expr -> if_expr .)
    EQUAL           reduce using rule 23 (expr -> if_expr .)
    NOT_EQUAL       reduce using rule 23 (expr -> if_expr .)
    >               reduce using rule 23 (expr -> if_expr .)
    FLOAT_MUL       reduce using rule 23 (expr -> if_expr .)
    FLOAT_DIV       reduce using rule 23 (expr -> if_expr .)
    FLOAT_SUB       reduce using rule 23 (expr -> if_expr .)
    FLOAT_SUM       reduce using rule 23 (expr -> if_expr .)
    <               reduce using rule 23 (expr -> if_expr .)
    *               reduce using rule 23 (expr -> if_expr .)
    /               reduce using rule 23 (expr -> if_expr .)
    -               reduce using rule 23 (expr -> if_expr .)
    +               reduce using rule 23 (expr -> if_expr .)
    CONCAT          reduce using rule 23 (expr -> if_expr .)
    $end            reduce using rule 23 (expr -> if_expr .)
    )               reduce using rule 23 (expr -> if_expr .)
    OF              reduce using rule 23 (expr -> if_expr .)
    THEN            reduce using rule 23 (expr -> if_expr .)
    END             reduce using rule 23 (expr -> if_expr .)
    ELIF            reduce using rule 23 (expr -> if_expr .)
    ELSE            reduce using rule 23 (expr -> if_expr .)
    ,               reduce using rule 23 (expr -> if_expr .)
    ]               reduce using rule 23 (expr -> if_expr .)


state 21

    (24) expr -> def_expr .
    NEWLINE         reduce using rule 24 (expr -> def_expr .)
    (               reduce using rule 24 (expr -> def_expr .)
    FLOAT_MORE      reduce using rule 24 (expr -> def_expr .)
    FLOAT_MORE_OR_EQ reduce using rule 24 (expr -> def_expr .)
    FLOAT_LESS      reduce using rule 24 (expr -> def_expr .)
    FLOAT_LESS_OR_EQ reduce using rule 24 (expr -> def_expr .)
    SOME_SUB        reduce using rule 24 (expr -> def_expr .)
    SOME_CONCAT     reduce using rule 24 (expr -> def_expr .)
    ARROW_BOTH      reduce using rule 24 (expr -> def_expr .)
    ARROW_RIGHT     reduce using rule 24 (expr -> def_expr .)
    ARROW_LEFT      reduce using rule 24 (expr -> def_expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 24 (expr -> def_expr .)
    DOUBLE_ARROW_LEFT reduce using rule 24 (expr -> def_expr .)
    BIT_SHIFT_LEFT  reduce using rule 24 (expr -> def_expr .)
    BIT_AND         reduce using rule 24 (expr -> def_expr .)
    BIT_OR          reduce using rule 24 (expr -> def_expr .)
    FLOAT_POW       reduce using rule 24 (expr -> def_expr .)
    POW             reduce using rule 24 (expr -> def_expr .)
    ARRAY_SUB       reduce using rule 24 (expr -> def_expr .)
    ARRAY_CONCAT    reduce using rule 24 (expr -> def_expr .)
    MORE_OR_EQ      reduce using rule 24 (expr -> def_expr .)
    LESS_OR_EQ      reduce using rule 24 (expr -> def_expr .)
    TEXT_MATCH      reduce using rule 24 (expr -> def_expr .)
    STRICT_AND      reduce using rule 24 (expr -> def_expr .)
    AND             reduce using rule 24 (expr -> def_expr .)
    STRICT_OR       reduce using rule 24 (expr -> def_expr .)
    OR              reduce using rule 24 (expr -> def_expr .)
    EQUAL           reduce using rule 24 (expr -> def_expr .)
    NOT_EQUAL       reduce using rule 24 (expr -> def_expr .)
    >               reduce using rule 24 (expr -> def_expr .)
    FLOAT_MUL       reduce using rule 24 (expr -> def_expr .)
    FLOAT_DIV       reduce using rule 24 (expr -> def_expr .)
    FLOAT_SUB       reduce using rule 24 (expr -> def_expr .)
    FLOAT_SUM       reduce using rule 24 (expr -> def_expr .)
    <               reduce using rule 24 (expr -> def_expr .)
    *               reduce using rule 24 (expr -> def_expr .)
    /               reduce using rule 24 (expr -> def_expr .)
    -               reduce using rule 24 (expr -> def_expr .)
    +               reduce using rule 24 (expr -> def_expr .)
    CONCAT          reduce using rule 24 (expr -> def_expr .)
    $end            reduce using rule 24 (expr -> def_expr .)
    )               reduce using rule 24 (expr -> def_expr .)
    OF              reduce using rule 24 (expr -> def_expr .)
    THEN            reduce using rule 24 (expr -> def_expr .)
    END             reduce using rule 24 (expr -> def_expr .)
    ELIF            reduce using rule 24 (expr -> def_expr .)
    ELSE            reduce using rule 24 (expr -> def_expr .)
    ,               reduce using rule 24 (expr -> def_expr .)
    ]               reduce using rule 24 (expr -> def_expr .)


state 22

    (25) expr -> do .
    NEWLINE         reduce using rule 25 (expr -> do .)
    (               reduce using rule 25 (expr -> do .)
    FLOAT_MORE      reduce using rule 25 (expr -> do .)
    FLOAT_MORE_OR_EQ reduce using rule 25 (expr -> do .)
    FLOAT_LESS      reduce using rule 25 (expr -> do .)
    FLOAT_LESS_OR_EQ reduce using rule 25 (expr -> do .)
    SOME_SUB        reduce using rule 25 (expr -> do .)
    SOME_CONCAT     reduce using rule 25 (expr -> do .)
    ARROW_BOTH      reduce using rule 25 (expr -> do .)
    ARROW_RIGHT     reduce using rule 25 (expr -> do .)
    ARROW_LEFT      reduce using rule 25 (expr -> do .)
    DOUBLE_ARROW_RIGHT reduce using rule 25 (expr -> do .)
    DOUBLE_ARROW_LEFT reduce using rule 25 (expr -> do .)
    BIT_SHIFT_LEFT  reduce using rule 25 (expr -> do .)
    BIT_AND         reduce using rule 25 (expr -> do .)
    BIT_OR          reduce using rule 25 (expr -> do .)
    FLOAT_POW       reduce using rule 25 (expr -> do .)
    POW             reduce using rule 25 (expr -> do .)
    ARRAY_SUB       reduce using rule 25 (expr -> do .)
    ARRAY_CONCAT    reduce using rule 25 (expr -> do .)
    MORE_OR_EQ      reduce using rule 25 (expr -> do .)
    LESS_OR_EQ      reduce using rule 25 (expr -> do .)
    TEXT_MATCH      reduce using rule 25 (expr -> do .)
    STRICT_AND      reduce using rule 25 (expr -> do .)
    AND             reduce using rule 25 (expr -> do .)
    STRICT_OR       reduce using rule 25 (expr -> do .)
    OR              reduce using rule 25 (expr -> do .)
    EQUAL           reduce using rule 25 (expr -> do .)
    NOT_EQUAL       reduce using rule 25 (expr -> do .)
    >               reduce using rule 25 (expr -> do .)
    FLOAT_MUL       reduce using rule 25 (expr -> do .)
    FLOAT_DIV       reduce using rule 25 (expr -> do .)
    FLOAT_SUB       reduce using rule 25 (expr -> do .)
    FLOAT_SUM       reduce using rule 25 (expr -> do .)
    <               reduce using rule 25 (expr -> do .)
    *               reduce using rule 25 (expr -> do .)
    /               reduce using rule 25 (expr -> do .)
    -               reduce using rule 25 (expr -> do .)
    +               reduce using rule 25 (expr -> do .)
    CONCAT          reduce using rule 25 (expr -> do .)
    $end            reduce using rule 25 (expr -> do .)
    )               reduce using rule 25 (expr -> do .)
    OF              reduce using rule 25 (expr -> do .)
    THEN            reduce using rule 25 (expr -> do .)
    END             reduce using rule 25 (expr -> do .)
    ELIF            reduce using rule 25 (expr -> do .)
    ELSE            reduce using rule 25 (expr -> do .)
    ,               reduce using rule 25 (expr -> do .)
    ]               reduce using rule 25 (expr -> do .)


state 23

    (26) expr -> external .
    NEWLINE         reduce using rule 26 (expr -> external .)
    (               reduce using rule 26 (expr -> external .)
    FLOAT_MORE      reduce using rule 26 (expr -> external .)
    FLOAT_MORE_OR_EQ reduce using rule 26 (expr -> external .)
    FLOAT_LESS      reduce using rule 26 (expr -> external .)
    FLOAT_LESS_OR_EQ reduce using rule 26 (expr -> external .)
    SOME_SUB        reduce using rule 26 (expr -> external .)
    SOME_CONCAT     reduce using rule 26 (expr -> external .)
    ARROW_BOTH      reduce using rule 26 (expr -> external .)
    ARROW_RIGHT     reduce using rule 26 (expr -> external .)
    ARROW_LEFT      reduce using rule 26 (expr -> external .)
    DOUBLE_ARROW_RIGHT reduce using rule 26 (expr -> external .)
    DOUBLE_ARROW_LEFT reduce using rule 26 (expr -> external .)
    BIT_SHIFT_LEFT  reduce using rule 26 (expr -> external .)
    BIT_AND         reduce using rule 26 (expr -> external .)
    BIT_OR          reduce using rule 26 (expr -> external .)
    FLOAT_POW       reduce using rule 26 (expr -> external .)
    POW             reduce using rule 26 (expr -> external .)
    ARRAY_SUB       reduce using rule 26 (expr -> external .)
    ARRAY_CONCAT    reduce using rule 26 (expr -> external .)
    MORE_OR_EQ      reduce using rule 26 (expr -> external .)
    LESS_OR_EQ      reduce using rule 26 (expr -> external .)
    TEXT_MATCH      reduce using rule 26 (expr -> external .)
    STRICT_AND      reduce using rule 26 (expr -> external .)
    AND             reduce using rule 26 (expr -> external .)
    STRICT_OR       reduce using rule 26 (expr -> external .)
    OR              reduce using rule 26 (expr -> external .)
    EQUAL           reduce using rule 26 (expr -> external .)
    NOT_EQUAL       reduce using rule 26 (expr -> external .)
    >               reduce using rule 26 (expr -> external .)
    FLOAT_MUL       reduce using rule 26 (expr -> external .)
    FLOAT_DIV       reduce using rule 26 (expr -> external .)
    FLOAT_SUB       reduce using rule 26 (expr -> external .)
    FLOAT_SUM       reduce using rule 26 (expr -> external .)
    <               reduce using rule 26 (expr -> external .)
    *               reduce using rule 26 (expr -> external .)
    /               reduce using rule 26 (expr -> external .)
    -               reduce using rule 26 (expr -> external .)
    +               reduce using rule 26 (expr -> external .)
    CONCAT          reduce using rule 26 (expr -> external .)
    $end            reduce using rule 26 (expr -> external .)
    )               reduce using rule 26 (expr -> external .)
    OF              reduce using rule 26 (expr -> external .)
    THEN            reduce using rule 26 (expr -> external .)
    END             reduce using rule 26 (expr -> external .)
    ELIF            reduce using rule 26 (expr -> external .)
    ELSE            reduce using rule 26 (expr -> external .)
    ,               reduce using rule 26 (expr -> external .)
    ]               reduce using rule 26 (expr -> external .)


state 24

    (27) expr -> enum .
    NEWLINE         reduce using rule 27 (expr -> enum .)
    (               reduce using rule 27 (expr -> enum .)
    FLOAT_MORE      reduce using rule 27 (expr -> enum .)
    FLOAT_MORE_OR_EQ reduce using rule 27 (expr -> enum .)
    FLOAT_LESS      reduce using rule 27 (expr -> enum .)
    FLOAT_LESS_OR_EQ reduce using rule 27 (expr -> enum .)
    SOME_SUB        reduce using rule 27 (expr -> enum .)
    SOME_CONCAT     reduce using rule 27 (expr -> enum .)
    ARROW_BOTH      reduce using rule 27 (expr -> enum .)
    ARROW_RIGHT     reduce using rule 27 (expr -> enum .)
    ARROW_LEFT      reduce using rule 27 (expr -> enum .)
    DOUBLE_ARROW_RIGHT reduce using rule 27 (expr -> enum .)
    DOUBLE_ARROW_LEFT reduce using rule 27 (expr -> enum .)
    BIT_SHIFT_LEFT  reduce using rule 27 (expr -> enum .)
    BIT_AND         reduce using rule 27 (expr -> enum .)
    BIT_OR          reduce using rule 27 (expr -> enum .)
    FLOAT_POW       reduce using rule 27 (expr -> enum .)
    POW             reduce using rule 27 (expr -> enum .)
    ARRAY_SUB       reduce using rule 27 (expr -> enum .)
    ARRAY_CONCAT    reduce using rule 27 (expr -> enum .)
    MORE_OR_EQ      reduce using rule 27 (expr -> enum .)
    LESS_OR_EQ      reduce using rule 27 (expr -> enum .)
    TEXT_MATCH      reduce using rule 27 (expr -> enum .)
    STRICT_AND      reduce using rule 27 (expr -> enum .)
    AND             reduce using rule 27 (expr -> enum .)
    STRICT_OR       reduce using rule 27 (expr -> enum .)
    OR              reduce using rule 27 (expr -> enum .)
    EQUAL           reduce using rule 27 (expr -> enum .)
    NOT_EQUAL       reduce using rule 27 (expr -> enum .)
    >               reduce using rule 27 (expr -> enum .)
    FLOAT_MUL       reduce using rule 27 (expr -> enum .)
    FLOAT_DIV       reduce using rule 27 (expr -> enum .)
    FLOAT_SUB       reduce using rule 27 (expr -> enum .)
    FLOAT_SUM       reduce using rule 27 (expr -> enum .)
    <               reduce using rule 27 (expr -> enum .)
    *               reduce using rule 27 (expr -> enum .)
    /               reduce using rule 27 (expr -> enum .)
    -               reduce using rule 27 (expr -> enum .)
    +               reduce using rule 27 (expr -> enum .)
    CONCAT          reduce using rule 27 (expr -> enum .)
    $end            reduce using rule 27 (expr -> enum .)
    )               reduce using rule 27 (expr -> enum .)
    OF              reduce using rule 27 (expr -> enum .)
    THEN            reduce using rule 27 (expr -> enum .)
    END             reduce using rule 27 (expr -> enum .)
    ELIF            reduce using rule 27 (expr -> enum .)
    ELSE            reduce using rule 27 (expr -> enum .)
    ,               reduce using rule 27 (expr -> enum .)
    ]               reduce using rule 27 (expr -> enum .)


state 25

    (109) binary_op_def -> DEF . binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> DEF . binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (140) def_expr -> DEF . identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> DEF . identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (71) binary_op -> . FLOAT_MORE
    (72) binary_op -> . FLOAT_MORE_OR_EQ
    (73) binary_op -> . FLOAT_LESS
    (74) binary_op -> . FLOAT_LESS_OR_EQ
    (75) binary_op -> . SOME_SUB
    (76) binary_op -> . SOME_CONCAT
    (77) binary_op -> . ARROW_BOTH
    (78) binary_op -> . ARROW_RIGHT
    (79) binary_op -> . ARROW_LEFT
    (80) binary_op -> . DOUBLE_ARROW_RIGHT
    (81) binary_op -> . DOUBLE_ARROW_LEFT
    (82) binary_op -> . BIT_SHIFT_LEFT
    (83) binary_op -> . BIT_AND
    (84) binary_op -> . BIT_OR
    (85) binary_op -> . FLOAT_POW
    (86) binary_op -> . POW
    (87) binary_op -> . ARRAY_SUB
    (88) binary_op -> . ARRAY_CONCAT
    (89) binary_op -> . MORE_OR_EQ
    (90) binary_op -> . LESS_OR_EQ
    (91) binary_op -> . TEXT_MATCH
    (92) binary_op -> . STRICT_AND
    (93) binary_op -> . AND
    (94) binary_op -> . STRICT_OR
    (95) binary_op -> . OR
    (96) binary_op -> . EQUAL
    (97) binary_op -> . NOT_EQUAL
    (98) binary_op -> . >
    (99) binary_op -> . FLOAT_MUL
    (100) binary_op -> . FLOAT_DIV
    (101) binary_op -> . FLOAT_SUB
    (102) binary_op -> . FLOAT_SUM
    (103) binary_op -> . <
    (104) binary_op -> . *
    (105) binary_op -> . /
    (106) binary_op -> . -
    (107) binary_op -> . +
    (108) binary_op -> . CONCAT
    (265) identifier -> . IDENTIFIER
    FLOAT_MORE      shift and go to state 90
    FLOAT_MORE_OR_EQ shift and go to state 91
    FLOAT_LESS      shift and go to state 92
    FLOAT_LESS_OR_EQ shift and go to state 93
    SOME_SUB        shift and go to state 94
    SOME_CONCAT     shift and go to state 95
    ARROW_BOTH      shift and go to state 96
    ARROW_RIGHT     shift and go to state 97
    ARROW_LEFT      shift and go to state 98
    DOUBLE_ARROW_RIGHT shift and go to state 99
    DOUBLE_ARROW_LEFT shift and go to state 100
    BIT_SHIFT_LEFT  shift and go to state 101
    BIT_AND         shift and go to state 102
    BIT_OR          shift and go to state 103
    FLOAT_POW       shift and go to state 104
    POW             shift and go to state 105
    ARRAY_SUB       shift and go to state 106
    ARRAY_CONCAT    shift and go to state 107
    MORE_OR_EQ      shift and go to state 108
    LESS_OR_EQ      shift and go to state 109
    TEXT_MATCH      shift and go to state 110
    STRICT_AND      shift and go to state 111
    AND             shift and go to state 112
    STRICT_OR       shift and go to state 113
    OR              shift and go to state 114
    EQUAL           shift and go to state 115
    NOT_EQUAL       shift and go to state 116
    >               shift and go to state 88
    FLOAT_MUL       shift and go to state 117
    FLOAT_DIV       shift and go to state 118
    FLOAT_SUB       shift and go to state 119
    FLOAT_SUM       shift and go to state 120
    <               shift and go to state 87
    *               shift and go to state 121
    /               shift and go to state 122
    -               shift and go to state 123
    +               shift and go to state 124
    CONCAT          shift and go to state 125
    IDENTIFIER      shift and go to state 35

    binary_op                      shift and go to state 86
    identifier                     shift and go to state 89

state 26

    (252) variant_call -> type_identifier . ( _52_optional _53_optional )
    (               shift and go to state 126


state 27

    (28) unary_expr -> + . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 127
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 28

    (29) unary_expr -> ! . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 128
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 29

    (30) unary_expr -> STRICT_NOT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 129
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 30

    (31) unary_expr -> - . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 130
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 31

    (278) str_literal -> STRING .
    NEWLINE         reduce using rule 278 (str_literal -> STRING .)
    (               reduce using rule 278 (str_literal -> STRING .)
    FLOAT_MORE      reduce using rule 278 (str_literal -> STRING .)
    FLOAT_MORE_OR_EQ reduce using rule 278 (str_literal -> STRING .)
    FLOAT_LESS      reduce using rule 278 (str_literal -> STRING .)
    FLOAT_LESS_OR_EQ reduce using rule 278 (str_literal -> STRING .)
    SOME_SUB        reduce using rule 278 (str_literal -> STRING .)
    SOME_CONCAT     reduce using rule 278 (str_literal -> STRING .)
    ARROW_BOTH      reduce using rule 278 (str_literal -> STRING .)
    ARROW_RIGHT     reduce using rule 278 (str_literal -> STRING .)
    ARROW_LEFT      reduce using rule 278 (str_literal -> STRING .)
    DOUBLE_ARROW_RIGHT reduce using rule 278 (str_literal -> STRING .)
    DOUBLE_ARROW_LEFT reduce using rule 278 (str_literal -> STRING .)
    BIT_SHIFT_LEFT  reduce using rule 278 (str_literal -> STRING .)
    BIT_AND         reduce using rule 278 (str_literal -> STRING .)
    BIT_OR          reduce using rule 278 (str_literal -> STRING .)
    FLOAT_POW       reduce using rule 278 (str_literal -> STRING .)
    POW             reduce using rule 278 (str_literal -> STRING .)
    ARRAY_SUB       reduce using rule 278 (str_literal -> STRING .)
    ARRAY_CONCAT    reduce using rule 278 (str_literal -> STRING .)
    MORE_OR_EQ      reduce using rule 278 (str_literal -> STRING .)
    LESS_OR_EQ      reduce using rule 278 (str_literal -> STRING .)
    TEXT_MATCH      reduce using rule 278 (str_literal -> STRING .)
    STRICT_AND      reduce using rule 278 (str_literal -> STRING .)
    AND             reduce using rule 278 (str_literal -> STRING .)
    STRICT_OR       reduce using rule 278 (str_literal -> STRING .)
    OR              reduce using rule 278 (str_literal -> STRING .)
    EQUAL           reduce using rule 278 (str_literal -> STRING .)
    NOT_EQUAL       reduce using rule 278 (str_literal -> STRING .)
    >               reduce using rule 278 (str_literal -> STRING .)
    FLOAT_MUL       reduce using rule 278 (str_literal -> STRING .)
    FLOAT_DIV       reduce using rule 278 (str_literal -> STRING .)
    FLOAT_SUB       reduce using rule 278 (str_literal -> STRING .)
    FLOAT_SUM       reduce using rule 278 (str_literal -> STRING .)
    <               reduce using rule 278 (str_literal -> STRING .)
    *               reduce using rule 278 (str_literal -> STRING .)
    /               reduce using rule 278 (str_literal -> STRING .)
    -               reduce using rule 278 (str_literal -> STRING .)
    +               reduce using rule 278 (str_literal -> STRING .)
    CONCAT          reduce using rule 278 (str_literal -> STRING .)
    $end            reduce using rule 278 (str_literal -> STRING .)
    )               reduce using rule 278 (str_literal -> STRING .)
    OF              reduce using rule 278 (str_literal -> STRING .)
    THEN            reduce using rule 278 (str_literal -> STRING .)
    END             reduce using rule 278 (str_literal -> STRING .)
    ELIF            reduce using rule 278 (str_literal -> STRING .)
    ELSE            reduce using rule 278 (str_literal -> STRING .)
    ,               reduce using rule 278 (str_literal -> STRING .)
    ]               reduce using rule 278 (str_literal -> STRING .)


state 32

    (277) float_literal -> FLOAT .
    NEWLINE         reduce using rule 277 (float_literal -> FLOAT .)
    (               reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_MORE      reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_MORE_OR_EQ reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_LESS      reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_LESS_OR_EQ reduce using rule 277 (float_literal -> FLOAT .)
    SOME_SUB        reduce using rule 277 (float_literal -> FLOAT .)
    SOME_CONCAT     reduce using rule 277 (float_literal -> FLOAT .)
    ARROW_BOTH      reduce using rule 277 (float_literal -> FLOAT .)
    ARROW_RIGHT     reduce using rule 277 (float_literal -> FLOAT .)
    ARROW_LEFT      reduce using rule 277 (float_literal -> FLOAT .)
    DOUBLE_ARROW_RIGHT reduce using rule 277 (float_literal -> FLOAT .)
    DOUBLE_ARROW_LEFT reduce using rule 277 (float_literal -> FLOAT .)
    BIT_SHIFT_LEFT  reduce using rule 277 (float_literal -> FLOAT .)
    BIT_AND         reduce using rule 277 (float_literal -> FLOAT .)
    BIT_OR          reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_POW       reduce using rule 277 (float_literal -> FLOAT .)
    POW             reduce using rule 277 (float_literal -> FLOAT .)
    ARRAY_SUB       reduce using rule 277 (float_literal -> FLOAT .)
    ARRAY_CONCAT    reduce using rule 277 (float_literal -> FLOAT .)
    MORE_OR_EQ      reduce using rule 277 (float_literal -> FLOAT .)
    LESS_OR_EQ      reduce using rule 277 (float_literal -> FLOAT .)
    TEXT_MATCH      reduce using rule 277 (float_literal -> FLOAT .)
    STRICT_AND      reduce using rule 277 (float_literal -> FLOAT .)
    AND             reduce using rule 277 (float_literal -> FLOAT .)
    STRICT_OR       reduce using rule 277 (float_literal -> FLOAT .)
    OR              reduce using rule 277 (float_literal -> FLOAT .)
    EQUAL           reduce using rule 277 (float_literal -> FLOAT .)
    NOT_EQUAL       reduce using rule 277 (float_literal -> FLOAT .)
    >               reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_MUL       reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_DIV       reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_SUB       reduce using rule 277 (float_literal -> FLOAT .)
    FLOAT_SUM       reduce using rule 277 (float_literal -> FLOAT .)
    <               reduce using rule 277 (float_literal -> FLOAT .)
    *               reduce using rule 277 (float_literal -> FLOAT .)
    /               reduce using rule 277 (float_literal -> FLOAT .)
    -               reduce using rule 277 (float_literal -> FLOAT .)
    +               reduce using rule 277 (float_literal -> FLOAT .)
    CONCAT          reduce using rule 277 (float_literal -> FLOAT .)
    $end            reduce using rule 277 (float_literal -> FLOAT .)
    )               reduce using rule 277 (float_literal -> FLOAT .)
    OF              reduce using rule 277 (float_literal -> FLOAT .)
    THEN            reduce using rule 277 (float_literal -> FLOAT .)
    END             reduce using rule 277 (float_literal -> FLOAT .)
    ELIF            reduce using rule 277 (float_literal -> FLOAT .)
    ELSE            reduce using rule 277 (float_literal -> FLOAT .)
    ,               reduce using rule 277 (float_literal -> FLOAT .)
    ]               reduce using rule 277 (float_literal -> FLOAT .)


state 33

    (276) int_literal -> INT .
    NEWLINE         reduce using rule 276 (int_literal -> INT .)
    (               reduce using rule 276 (int_literal -> INT .)
    FLOAT_MORE      reduce using rule 276 (int_literal -> INT .)
    FLOAT_MORE_OR_EQ reduce using rule 276 (int_literal -> INT .)
    FLOAT_LESS      reduce using rule 276 (int_literal -> INT .)
    FLOAT_LESS_OR_EQ reduce using rule 276 (int_literal -> INT .)
    SOME_SUB        reduce using rule 276 (int_literal -> INT .)
    SOME_CONCAT     reduce using rule 276 (int_literal -> INT .)
    ARROW_BOTH      reduce using rule 276 (int_literal -> INT .)
    ARROW_RIGHT     reduce using rule 276 (int_literal -> INT .)
    ARROW_LEFT      reduce using rule 276 (int_literal -> INT .)
    DOUBLE_ARROW_RIGHT reduce using rule 276 (int_literal -> INT .)
    DOUBLE_ARROW_LEFT reduce using rule 276 (int_literal -> INT .)
    BIT_SHIFT_LEFT  reduce using rule 276 (int_literal -> INT .)
    BIT_AND         reduce using rule 276 (int_literal -> INT .)
    BIT_OR          reduce using rule 276 (int_literal -> INT .)
    FLOAT_POW       reduce using rule 276 (int_literal -> INT .)
    POW             reduce using rule 276 (int_literal -> INT .)
    ARRAY_SUB       reduce using rule 276 (int_literal -> INT .)
    ARRAY_CONCAT    reduce using rule 276 (int_literal -> INT .)
    MORE_OR_EQ      reduce using rule 276 (int_literal -> INT .)
    LESS_OR_EQ      reduce using rule 276 (int_literal -> INT .)
    TEXT_MATCH      reduce using rule 276 (int_literal -> INT .)
    STRICT_AND      reduce using rule 276 (int_literal -> INT .)
    AND             reduce using rule 276 (int_literal -> INT .)
    STRICT_OR       reduce using rule 276 (int_literal -> INT .)
    OR              reduce using rule 276 (int_literal -> INT .)
    EQUAL           reduce using rule 276 (int_literal -> INT .)
    NOT_EQUAL       reduce using rule 276 (int_literal -> INT .)
    >               reduce using rule 276 (int_literal -> INT .)
    FLOAT_MUL       reduce using rule 276 (int_literal -> INT .)
    FLOAT_DIV       reduce using rule 276 (int_literal -> INT .)
    FLOAT_SUB       reduce using rule 276 (int_literal -> INT .)
    FLOAT_SUM       reduce using rule 276 (int_literal -> INT .)
    <               reduce using rule 276 (int_literal -> INT .)
    *               reduce using rule 276 (int_literal -> INT .)
    /               reduce using rule 276 (int_literal -> INT .)
    -               reduce using rule 276 (int_literal -> INT .)
    +               reduce using rule 276 (int_literal -> INT .)
    CONCAT          reduce using rule 276 (int_literal -> INT .)
    $end            reduce using rule 276 (int_literal -> INT .)
    )               reduce using rule 276 (int_literal -> INT .)
    OF              reduce using rule 276 (int_literal -> INT .)
    THEN            reduce using rule 276 (int_literal -> INT .)
    END             reduce using rule 276 (int_literal -> INT .)
    ELIF            reduce using rule 276 (int_literal -> INT .)
    ELSE            reduce using rule 276 (int_literal -> INT .)
    ,               reduce using rule 276 (int_literal -> INT .)
    ]               reduce using rule 276 (int_literal -> INT .)


state 34

    (242) array -> [ . _48_optional _49_optional ]
    (243) _48_optional -> . NEWLINE
    (244) _48_optional -> .
    NEWLINE         shift and go to state 132
    (               reduce using rule 244 (_48_optional -> .)
    DEF             reduce using rule 244 (_48_optional -> .)
    +               reduce using rule 244 (_48_optional -> .)
    !               reduce using rule 244 (_48_optional -> .)
    STRICT_NOT      reduce using rule 244 (_48_optional -> .)
    -               reduce using rule 244 (_48_optional -> .)
    STRING          reduce using rule 244 (_48_optional -> .)
    FLOAT           reduce using rule 244 (_48_optional -> .)
    INT             reduce using rule 244 (_48_optional -> .)
    [               reduce using rule 244 (_48_optional -> .)
    IDENTIFIER      reduce using rule 244 (_48_optional -> .)
    CASE            reduce using rule 244 (_48_optional -> .)
    IF              reduce using rule 244 (_48_optional -> .)
    DO              reduce using rule 244 (_48_optional -> .)
    EXTERNAL        reduce using rule 244 (_48_optional -> .)
    ENUM            reduce using rule 244 (_48_optional -> .)
    TYPE_IDENTIFIER reduce using rule 244 (_48_optional -> .)
    ]               reduce using rule 244 (_48_optional -> .)

    _48_optional                   shift and go to state 131

state 35

    (265) identifier -> IDENTIFIER .
    :               reduce using rule 265 (identifier -> IDENTIFIER .)
    =               reduce using rule 265 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 265 (identifier -> IDENTIFIER .)
    (               reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_MORE      reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_MORE_OR_EQ reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_LESS      reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_LESS_OR_EQ reduce using rule 265 (identifier -> IDENTIFIER .)
    SOME_SUB        reduce using rule 265 (identifier -> IDENTIFIER .)
    SOME_CONCAT     reduce using rule 265 (identifier -> IDENTIFIER .)
    ARROW_BOTH      reduce using rule 265 (identifier -> IDENTIFIER .)
    ARROW_RIGHT     reduce using rule 265 (identifier -> IDENTIFIER .)
    ARROW_LEFT      reduce using rule 265 (identifier -> IDENTIFIER .)
    DOUBLE_ARROW_RIGHT reduce using rule 265 (identifier -> IDENTIFIER .)
    DOUBLE_ARROW_LEFT reduce using rule 265 (identifier -> IDENTIFIER .)
    BIT_SHIFT_LEFT  reduce using rule 265 (identifier -> IDENTIFIER .)
    BIT_AND         reduce using rule 265 (identifier -> IDENTIFIER .)
    BIT_OR          reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_POW       reduce using rule 265 (identifier -> IDENTIFIER .)
    POW             reduce using rule 265 (identifier -> IDENTIFIER .)
    ARRAY_SUB       reduce using rule 265 (identifier -> IDENTIFIER .)
    ARRAY_CONCAT    reduce using rule 265 (identifier -> IDENTIFIER .)
    MORE_OR_EQ      reduce using rule 265 (identifier -> IDENTIFIER .)
    LESS_OR_EQ      reduce using rule 265 (identifier -> IDENTIFIER .)
    TEXT_MATCH      reduce using rule 265 (identifier -> IDENTIFIER .)
    STRICT_AND      reduce using rule 265 (identifier -> IDENTIFIER .)
    AND             reduce using rule 265 (identifier -> IDENTIFIER .)
    STRICT_OR       reduce using rule 265 (identifier -> IDENTIFIER .)
    OR              reduce using rule 265 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 265 (identifier -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 265 (identifier -> IDENTIFIER .)
    >               reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_MUL       reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_DIV       reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_SUB       reduce using rule 265 (identifier -> IDENTIFIER .)
    FLOAT_SUM       reduce using rule 265 (identifier -> IDENTIFIER .)
    <               reduce using rule 265 (identifier -> IDENTIFIER .)
    *               reduce using rule 265 (identifier -> IDENTIFIER .)
    /               reduce using rule 265 (identifier -> IDENTIFIER .)
    -               reduce using rule 265 (identifier -> IDENTIFIER .)
    +               reduce using rule 265 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 265 (identifier -> IDENTIFIER .)
    $end            reduce using rule 265 (identifier -> IDENTIFIER .)
    )               reduce using rule 265 (identifier -> IDENTIFIER .)
    OF              reduce using rule 265 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 265 (identifier -> IDENTIFIER .)
    END             reduce using rule 265 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 265 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 265 (identifier -> IDENTIFIER .)
    ,               reduce using rule 265 (identifier -> IDENTIFIER .)
    ]               reduce using rule 265 (identifier -> IDENTIFIER .)
    DO              reduce using rule 265 (identifier -> IDENTIFIER .)


state 36

    (214) case_of -> CASE . expr OF _39_optional _40_optional END
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 133
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 37

    (205) if_expr -> IF . expr THEN _36_optional block_statement _37_optional END
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 134
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 38

    (132) do -> DO . _13_optional block_statement END
    (133) _13_optional -> . : type
    (134) _13_optional -> .
    :               shift and go to state 136
    NEWLINE         reduce using rule 134 (_13_optional -> .)
    END             reduce using rule 134 (_13_optional -> .)
    (               reduce using rule 134 (_13_optional -> .)
    DEF             reduce using rule 134 (_13_optional -> .)
    +               reduce using rule 134 (_13_optional -> .)
    !               reduce using rule 134 (_13_optional -> .)
    STRICT_NOT      reduce using rule 134 (_13_optional -> .)
    -               reduce using rule 134 (_13_optional -> .)
    STRING          reduce using rule 134 (_13_optional -> .)
    FLOAT           reduce using rule 134 (_13_optional -> .)
    INT             reduce using rule 134 (_13_optional -> .)
    [               reduce using rule 134 (_13_optional -> .)
    IDENTIFIER      reduce using rule 134 (_13_optional -> .)
    CASE            reduce using rule 134 (_13_optional -> .)
    IF              reduce using rule 134 (_13_optional -> .)
    DO              reduce using rule 134 (_13_optional -> .)
    EXTERNAL        reduce using rule 134 (_13_optional -> .)
    ENUM            reduce using rule 134 (_13_optional -> .)
    TYPE_IDENTIFIER reduce using rule 134 (_13_optional -> .)

    _13_optional                   shift and go to state 135

state 39

    (32) external -> EXTERNAL .
    NEWLINE         reduce using rule 32 (external -> EXTERNAL .)
    (               reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_MORE      reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_MORE_OR_EQ reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_LESS      reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_LESS_OR_EQ reduce using rule 32 (external -> EXTERNAL .)
    SOME_SUB        reduce using rule 32 (external -> EXTERNAL .)
    SOME_CONCAT     reduce using rule 32 (external -> EXTERNAL .)
    ARROW_BOTH      reduce using rule 32 (external -> EXTERNAL .)
    ARROW_RIGHT     reduce using rule 32 (external -> EXTERNAL .)
    ARROW_LEFT      reduce using rule 32 (external -> EXTERNAL .)
    DOUBLE_ARROW_RIGHT reduce using rule 32 (external -> EXTERNAL .)
    DOUBLE_ARROW_LEFT reduce using rule 32 (external -> EXTERNAL .)
    BIT_SHIFT_LEFT  reduce using rule 32 (external -> EXTERNAL .)
    BIT_AND         reduce using rule 32 (external -> EXTERNAL .)
    BIT_OR          reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_POW       reduce using rule 32 (external -> EXTERNAL .)
    POW             reduce using rule 32 (external -> EXTERNAL .)
    ARRAY_SUB       reduce using rule 32 (external -> EXTERNAL .)
    ARRAY_CONCAT    reduce using rule 32 (external -> EXTERNAL .)
    MORE_OR_EQ      reduce using rule 32 (external -> EXTERNAL .)
    LESS_OR_EQ      reduce using rule 32 (external -> EXTERNAL .)
    TEXT_MATCH      reduce using rule 32 (external -> EXTERNAL .)
    STRICT_AND      reduce using rule 32 (external -> EXTERNAL .)
    AND             reduce using rule 32 (external -> EXTERNAL .)
    STRICT_OR       reduce using rule 32 (external -> EXTERNAL .)
    OR              reduce using rule 32 (external -> EXTERNAL .)
    EQUAL           reduce using rule 32 (external -> EXTERNAL .)
    NOT_EQUAL       reduce using rule 32 (external -> EXTERNAL .)
    >               reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_MUL       reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_DIV       reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_SUB       reduce using rule 32 (external -> EXTERNAL .)
    FLOAT_SUM       reduce using rule 32 (external -> EXTERNAL .)
    <               reduce using rule 32 (external -> EXTERNAL .)
    *               reduce using rule 32 (external -> EXTERNAL .)
    /               reduce using rule 32 (external -> EXTERNAL .)
    -               reduce using rule 32 (external -> EXTERNAL .)
    +               reduce using rule 32 (external -> EXTERNAL .)
    CONCAT          reduce using rule 32 (external -> EXTERNAL .)
    $end            reduce using rule 32 (external -> EXTERNAL .)
    )               reduce using rule 32 (external -> EXTERNAL .)
    OF              reduce using rule 32 (external -> EXTERNAL .)
    THEN            reduce using rule 32 (external -> EXTERNAL .)
    END             reduce using rule 32 (external -> EXTERNAL .)
    ELIF            reduce using rule 32 (external -> EXTERNAL .)
    ELSE            reduce using rule 32 (external -> EXTERNAL .)
    ,               reduce using rule 32 (external -> EXTERNAL .)
    ]               reduce using rule 32 (external -> EXTERNAL .)


state 40

    (174) enum -> ENUM . type_identifier { _27_optional _28_optional }
    (179) enum -> ENUM . type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 137

state 41

    (266) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    +               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    !               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    STRICT_NOT      reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT           reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    INT             reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    MORE_OR_EQ      reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 266 (type_identifier -> TYPE_IDENTIFIER .)


state 42

    (6) do_exprs -> expr _3_optional .
    $end            reduce using rule 6 (do_exprs -> expr _3_optional .)
    END             reduce using rule 6 (do_exprs -> expr _3_optional .)
    ELIF            reduce using rule 6 (do_exprs -> expr _3_optional .)
    ELSE            reduce using rule 6 (do_exprs -> expr _3_optional .)


state 43

    (9) do_exprs -> expr NEWLINE . do_exprs
    (7) _3_optional -> NEWLINE .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 7 (_3_optional -> NEWLINE .)
    END             reduce using rule 7 (_3_optional -> NEWLINE .)
    ELIF            reduce using rule 7 (_3_optional -> NEWLINE .)
    ELSE            reduce using rule 7 (_3_optional -> NEWLINE .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 6
    do_exprs                       shift and go to state 138
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 44

    (247) call -> expr ( . _50_optional _51_optional )
    (248) _50_optional -> . NEWLINE
    (249) _50_optional -> .
    NEWLINE         shift and go to state 140
    (               reduce using rule 249 (_50_optional -> .)
    DEF             reduce using rule 249 (_50_optional -> .)
    +               reduce using rule 249 (_50_optional -> .)
    !               reduce using rule 249 (_50_optional -> .)
    STRICT_NOT      reduce using rule 249 (_50_optional -> .)
    -               reduce using rule 249 (_50_optional -> .)
    STRING          reduce using rule 249 (_50_optional -> .)
    FLOAT           reduce using rule 249 (_50_optional -> .)
    INT             reduce using rule 249 (_50_optional -> .)
    [               reduce using rule 249 (_50_optional -> .)
    IDENTIFIER      reduce using rule 249 (_50_optional -> .)
    CASE            reduce using rule 249 (_50_optional -> .)
    IF              reduce using rule 249 (_50_optional -> .)
    DO              reduce using rule 249 (_50_optional -> .)
    EXTERNAL        reduce using rule 249 (_50_optional -> .)
    ENUM            reduce using rule 249 (_50_optional -> .)
    TYPE_IDENTIFIER reduce using rule 249 (_50_optional -> .)
    )               reduce using rule 249 (_50_optional -> .)

    _50_optional                   shift and go to state 139

state 45

    (33) binary_expr -> expr FLOAT_MORE . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 141
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 46

    (34) binary_expr -> expr FLOAT_MORE_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 142
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 47

    (35) binary_expr -> expr FLOAT_LESS . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 143
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 48

    (36) binary_expr -> expr FLOAT_LESS_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 144
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 49

    (37) binary_expr -> expr SOME_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 145
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 50

    (38) binary_expr -> expr SOME_CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 146
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 51

    (39) binary_expr -> expr ARROW_BOTH . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 147
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 52

    (40) binary_expr -> expr ARROW_RIGHT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 148
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 53

    (41) binary_expr -> expr ARROW_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 149
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 54

    (42) binary_expr -> expr DOUBLE_ARROW_RIGHT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 150
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 55

    (43) binary_expr -> expr DOUBLE_ARROW_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 151
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 56

    (44) binary_expr -> expr BIT_SHIFT_LEFT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 152
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 57

    (45) binary_expr -> expr BIT_AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 153
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 58

    (46) binary_expr -> expr BIT_OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 154
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 59

    (47) binary_expr -> expr FLOAT_POW . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 155
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 60

    (48) binary_expr -> expr POW . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 156
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 61

    (49) binary_expr -> expr ARRAY_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 157
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 62

    (50) binary_expr -> expr ARRAY_CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 158
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 63

    (51) binary_expr -> expr MORE_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 159
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 64

    (52) binary_expr -> expr LESS_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 160
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 65

    (53) binary_expr -> expr TEXT_MATCH . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 161
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 66

    (54) binary_expr -> expr STRICT_AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 162
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 67

    (55) binary_expr -> expr AND . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 163
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 68

    (56) binary_expr -> expr STRICT_OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 164
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 69

    (57) binary_expr -> expr OR . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 165
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 70

    (58) binary_expr -> expr EQUAL . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 166
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 71

    (59) binary_expr -> expr NOT_EQUAL . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 167
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 72

    (60) binary_expr -> expr > . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 168
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 73

    (61) binary_expr -> expr FLOAT_MUL . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 169
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 74

    (62) binary_expr -> expr FLOAT_DIV . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 170
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 75

    (63) binary_expr -> expr FLOAT_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 171
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 76

    (64) binary_expr -> expr FLOAT_SUM . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 172
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 77

    (65) binary_expr -> expr < . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 173
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 78

    (66) binary_expr -> expr * . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 174
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 79

    (67) binary_expr -> expr / . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 175
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 80

    (68) binary_expr -> expr - . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 176
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 81

    (69) binary_expr -> expr + . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 177
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 82

    (70) binary_expr -> expr CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 178
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 83

    (10) expr -> ( expr . )
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    )               shift and go to state 179
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 84

    (267) let -> identifier : . type_identifier < type _57_repeat MORE_OR_EQ expr
    (274) _58_optional -> : . type
    (266) type_identifier -> . TYPE_IDENTIFIER
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 180
    type                           shift and go to state 181

state 85

    (273) let -> identifier _58_optional . = expr
    =               shift and go to state 182


state 86

    (109) binary_op_def -> DEF binary_op . ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> DEF binary_op . < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (               shift and go to state 183
    <               shift and go to state 184


state 87

    (103) binary_op -> < .
    (               reduce using rule 103 (binary_op -> < .)
    <               reduce using rule 103 (binary_op -> < .)


state 88

    (98) binary_op -> > .
    (               reduce using rule 98 (binary_op -> > .)
    <               reduce using rule 98 (binary_op -> > .)


state 89

    (140) def_expr -> DEF identifier . ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> DEF identifier . < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (               shift and go to state 185
    <               shift and go to state 186


state 90

    (71) binary_op -> FLOAT_MORE .
    (               reduce using rule 71 (binary_op -> FLOAT_MORE .)
    <               reduce using rule 71 (binary_op -> FLOAT_MORE .)


state 91

    (72) binary_op -> FLOAT_MORE_OR_EQ .
    (               reduce using rule 72 (binary_op -> FLOAT_MORE_OR_EQ .)
    <               reduce using rule 72 (binary_op -> FLOAT_MORE_OR_EQ .)


state 92

    (73) binary_op -> FLOAT_LESS .
    (               reduce using rule 73 (binary_op -> FLOAT_LESS .)
    <               reduce using rule 73 (binary_op -> FLOAT_LESS .)


state 93

    (74) binary_op -> FLOAT_LESS_OR_EQ .
    (               reduce using rule 74 (binary_op -> FLOAT_LESS_OR_EQ .)
    <               reduce using rule 74 (binary_op -> FLOAT_LESS_OR_EQ .)


state 94

    (75) binary_op -> SOME_SUB .
    (               reduce using rule 75 (binary_op -> SOME_SUB .)
    <               reduce using rule 75 (binary_op -> SOME_SUB .)


state 95

    (76) binary_op -> SOME_CONCAT .
    (               reduce using rule 76 (binary_op -> SOME_CONCAT .)
    <               reduce using rule 76 (binary_op -> SOME_CONCAT .)


state 96

    (77) binary_op -> ARROW_BOTH .
    (               reduce using rule 77 (binary_op -> ARROW_BOTH .)
    <               reduce using rule 77 (binary_op -> ARROW_BOTH .)


state 97

    (78) binary_op -> ARROW_RIGHT .
    (               reduce using rule 78 (binary_op -> ARROW_RIGHT .)
    <               reduce using rule 78 (binary_op -> ARROW_RIGHT .)


state 98

    (79) binary_op -> ARROW_LEFT .
    (               reduce using rule 79 (binary_op -> ARROW_LEFT .)
    <               reduce using rule 79 (binary_op -> ARROW_LEFT .)


state 99

    (80) binary_op -> DOUBLE_ARROW_RIGHT .
    (               reduce using rule 80 (binary_op -> DOUBLE_ARROW_RIGHT .)
    <               reduce using rule 80 (binary_op -> DOUBLE_ARROW_RIGHT .)


state 100

    (81) binary_op -> DOUBLE_ARROW_LEFT .
    (               reduce using rule 81 (binary_op -> DOUBLE_ARROW_LEFT .)
    <               reduce using rule 81 (binary_op -> DOUBLE_ARROW_LEFT .)


state 101

    (82) binary_op -> BIT_SHIFT_LEFT .
    (               reduce using rule 82 (binary_op -> BIT_SHIFT_LEFT .)
    <               reduce using rule 82 (binary_op -> BIT_SHIFT_LEFT .)


state 102

    (83) binary_op -> BIT_AND .
    (               reduce using rule 83 (binary_op -> BIT_AND .)
    <               reduce using rule 83 (binary_op -> BIT_AND .)


state 103

    (84) binary_op -> BIT_OR .
    (               reduce using rule 84 (binary_op -> BIT_OR .)
    <               reduce using rule 84 (binary_op -> BIT_OR .)


state 104

    (85) binary_op -> FLOAT_POW .
    (               reduce using rule 85 (binary_op -> FLOAT_POW .)
    <               reduce using rule 85 (binary_op -> FLOAT_POW .)


state 105

    (86) binary_op -> POW .
    (               reduce using rule 86 (binary_op -> POW .)
    <               reduce using rule 86 (binary_op -> POW .)


state 106

    (87) binary_op -> ARRAY_SUB .
    (               reduce using rule 87 (binary_op -> ARRAY_SUB .)
    <               reduce using rule 87 (binary_op -> ARRAY_SUB .)


state 107

    (88) binary_op -> ARRAY_CONCAT .
    (               reduce using rule 88 (binary_op -> ARRAY_CONCAT .)
    <               reduce using rule 88 (binary_op -> ARRAY_CONCAT .)


state 108

    (89) binary_op -> MORE_OR_EQ .
    (               reduce using rule 89 (binary_op -> MORE_OR_EQ .)
    <               reduce using rule 89 (binary_op -> MORE_OR_EQ .)


state 109

    (90) binary_op -> LESS_OR_EQ .
    (               reduce using rule 90 (binary_op -> LESS_OR_EQ .)
    <               reduce using rule 90 (binary_op -> LESS_OR_EQ .)


state 110

    (91) binary_op -> TEXT_MATCH .
    (               reduce using rule 91 (binary_op -> TEXT_MATCH .)
    <               reduce using rule 91 (binary_op -> TEXT_MATCH .)


state 111

    (92) binary_op -> STRICT_AND .
    (               reduce using rule 92 (binary_op -> STRICT_AND .)
    <               reduce using rule 92 (binary_op -> STRICT_AND .)


state 112

    (93) binary_op -> AND .
    (               reduce using rule 93 (binary_op -> AND .)
    <               reduce using rule 93 (binary_op -> AND .)


state 113

    (94) binary_op -> STRICT_OR .
    (               reduce using rule 94 (binary_op -> STRICT_OR .)
    <               reduce using rule 94 (binary_op -> STRICT_OR .)


state 114

    (95) binary_op -> OR .
    (               reduce using rule 95 (binary_op -> OR .)
    <               reduce using rule 95 (binary_op -> OR .)


state 115

    (96) binary_op -> EQUAL .
    (               reduce using rule 96 (binary_op -> EQUAL .)
    <               reduce using rule 96 (binary_op -> EQUAL .)


state 116

    (97) binary_op -> NOT_EQUAL .
    (               reduce using rule 97 (binary_op -> NOT_EQUAL .)
    <               reduce using rule 97 (binary_op -> NOT_EQUAL .)


state 117

    (99) binary_op -> FLOAT_MUL .
    (               reduce using rule 99 (binary_op -> FLOAT_MUL .)
    <               reduce using rule 99 (binary_op -> FLOAT_MUL .)


state 118

    (100) binary_op -> FLOAT_DIV .
    (               reduce using rule 100 (binary_op -> FLOAT_DIV .)
    <               reduce using rule 100 (binary_op -> FLOAT_DIV .)


state 119

    (101) binary_op -> FLOAT_SUB .
    (               reduce using rule 101 (binary_op -> FLOAT_SUB .)
    <               reduce using rule 101 (binary_op -> FLOAT_SUB .)


state 120

    (102) binary_op -> FLOAT_SUM .
    (               reduce using rule 102 (binary_op -> FLOAT_SUM .)
    <               reduce using rule 102 (binary_op -> FLOAT_SUM .)


state 121

    (104) binary_op -> * .
    (               reduce using rule 104 (binary_op -> * .)
    <               reduce using rule 104 (binary_op -> * .)


state 122

    (105) binary_op -> / .
    (               reduce using rule 105 (binary_op -> / .)
    <               reduce using rule 105 (binary_op -> / .)


state 123

    (106) binary_op -> - .
    (               reduce using rule 106 (binary_op -> - .)
    <               reduce using rule 106 (binary_op -> - .)


state 124

    (107) binary_op -> + .
    (               reduce using rule 107 (binary_op -> + .)
    <               reduce using rule 107 (binary_op -> + .)


state 125

    (108) binary_op -> CONCAT .
    (               reduce using rule 108 (binary_op -> CONCAT .)
    <               reduce using rule 108 (binary_op -> CONCAT .)


state 126

    (252) variant_call -> type_identifier ( . _52_optional _53_optional )
    (253) _52_optional -> . NEWLINE
    (254) _52_optional -> .
    NEWLINE         shift and go to state 188
    (               reduce using rule 254 (_52_optional -> .)
    DEF             reduce using rule 254 (_52_optional -> .)
    +               reduce using rule 254 (_52_optional -> .)
    !               reduce using rule 254 (_52_optional -> .)
    STRICT_NOT      reduce using rule 254 (_52_optional -> .)
    -               reduce using rule 254 (_52_optional -> .)
    STRING          reduce using rule 254 (_52_optional -> .)
    FLOAT           reduce using rule 254 (_52_optional -> .)
    INT             reduce using rule 254 (_52_optional -> .)
    [               reduce using rule 254 (_52_optional -> .)
    IDENTIFIER      reduce using rule 254 (_52_optional -> .)
    CASE            reduce using rule 254 (_52_optional -> .)
    IF              reduce using rule 254 (_52_optional -> .)
    DO              reduce using rule 254 (_52_optional -> .)
    EXTERNAL        reduce using rule 254 (_52_optional -> .)
    ENUM            reduce using rule 254 (_52_optional -> .)
    TYPE_IDENTIFIER reduce using rule 254 (_52_optional -> .)
    )               reduce using rule 254 (_52_optional -> .)

    _52_optional                   shift and go to state 187

state 127

    (28) unary_expr -> + expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_MORE      reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_MORE_OR_EQ reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_LESS      reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_LESS_OR_EQ reduce using rule 28 (unary_expr -> + expr .)
    SOME_SUB        reduce using rule 28 (unary_expr -> + expr .)
    SOME_CONCAT     reduce using rule 28 (unary_expr -> + expr .)
    ARROW_BOTH      reduce using rule 28 (unary_expr -> + expr .)
    ARROW_RIGHT     reduce using rule 28 (unary_expr -> + expr .)
    ARROW_LEFT      reduce using rule 28 (unary_expr -> + expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 28 (unary_expr -> + expr .)
    DOUBLE_ARROW_LEFT reduce using rule 28 (unary_expr -> + expr .)
    BIT_SHIFT_LEFT  reduce using rule 28 (unary_expr -> + expr .)
    BIT_AND         reduce using rule 28 (unary_expr -> + expr .)
    BIT_OR          reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_POW       reduce using rule 28 (unary_expr -> + expr .)
    POW             reduce using rule 28 (unary_expr -> + expr .)
    ARRAY_SUB       reduce using rule 28 (unary_expr -> + expr .)
    ARRAY_CONCAT    reduce using rule 28 (unary_expr -> + expr .)
    MORE_OR_EQ      reduce using rule 28 (unary_expr -> + expr .)
    LESS_OR_EQ      reduce using rule 28 (unary_expr -> + expr .)
    TEXT_MATCH      reduce using rule 28 (unary_expr -> + expr .)
    STRICT_AND      reduce using rule 28 (unary_expr -> + expr .)
    AND             reduce using rule 28 (unary_expr -> + expr .)
    STRICT_OR       reduce using rule 28 (unary_expr -> + expr .)
    OR              reduce using rule 28 (unary_expr -> + expr .)
    EQUAL           reduce using rule 28 (unary_expr -> + expr .)
    NOT_EQUAL       reduce using rule 28 (unary_expr -> + expr .)
    >               reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_MUL       reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_DIV       reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_SUB       reduce using rule 28 (unary_expr -> + expr .)
    FLOAT_SUM       reduce using rule 28 (unary_expr -> + expr .)
    <               reduce using rule 28 (unary_expr -> + expr .)
    *               reduce using rule 28 (unary_expr -> + expr .)
    /               reduce using rule 28 (unary_expr -> + expr .)
    -               reduce using rule 28 (unary_expr -> + expr .)
    +               reduce using rule 28 (unary_expr -> + expr .)
    CONCAT          reduce using rule 28 (unary_expr -> + expr .)
    $end            reduce using rule 28 (unary_expr -> + expr .)
    )               reduce using rule 28 (unary_expr -> + expr .)
    OF              reduce using rule 28 (unary_expr -> + expr .)
    THEN            reduce using rule 28 (unary_expr -> + expr .)
    END             reduce using rule 28 (unary_expr -> + expr .)
    ELIF            reduce using rule 28 (unary_expr -> + expr .)
    ELSE            reduce using rule 28 (unary_expr -> + expr .)
    ,               reduce using rule 28 (unary_expr -> + expr .)
    ]               reduce using rule 28 (unary_expr -> + expr .)
    (               shift and go to state 44


state 128

    (29) unary_expr -> ! expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_MORE      reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_MORE_OR_EQ reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_LESS      reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_LESS_OR_EQ reduce using rule 29 (unary_expr -> ! expr .)
    SOME_SUB        reduce using rule 29 (unary_expr -> ! expr .)
    SOME_CONCAT     reduce using rule 29 (unary_expr -> ! expr .)
    ARROW_BOTH      reduce using rule 29 (unary_expr -> ! expr .)
    ARROW_RIGHT     reduce using rule 29 (unary_expr -> ! expr .)
    ARROW_LEFT      reduce using rule 29 (unary_expr -> ! expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 29 (unary_expr -> ! expr .)
    DOUBLE_ARROW_LEFT reduce using rule 29 (unary_expr -> ! expr .)
    BIT_SHIFT_LEFT  reduce using rule 29 (unary_expr -> ! expr .)
    BIT_AND         reduce using rule 29 (unary_expr -> ! expr .)
    BIT_OR          reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_POW       reduce using rule 29 (unary_expr -> ! expr .)
    POW             reduce using rule 29 (unary_expr -> ! expr .)
    ARRAY_SUB       reduce using rule 29 (unary_expr -> ! expr .)
    ARRAY_CONCAT    reduce using rule 29 (unary_expr -> ! expr .)
    MORE_OR_EQ      reduce using rule 29 (unary_expr -> ! expr .)
    LESS_OR_EQ      reduce using rule 29 (unary_expr -> ! expr .)
    TEXT_MATCH      reduce using rule 29 (unary_expr -> ! expr .)
    STRICT_AND      reduce using rule 29 (unary_expr -> ! expr .)
    AND             reduce using rule 29 (unary_expr -> ! expr .)
    STRICT_OR       reduce using rule 29 (unary_expr -> ! expr .)
    OR              reduce using rule 29 (unary_expr -> ! expr .)
    EQUAL           reduce using rule 29 (unary_expr -> ! expr .)
    NOT_EQUAL       reduce using rule 29 (unary_expr -> ! expr .)
    >               reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_MUL       reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_DIV       reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_SUB       reduce using rule 29 (unary_expr -> ! expr .)
    FLOAT_SUM       reduce using rule 29 (unary_expr -> ! expr .)
    <               reduce using rule 29 (unary_expr -> ! expr .)
    *               reduce using rule 29 (unary_expr -> ! expr .)
    /               reduce using rule 29 (unary_expr -> ! expr .)
    -               reduce using rule 29 (unary_expr -> ! expr .)
    +               reduce using rule 29 (unary_expr -> ! expr .)
    CONCAT          reduce using rule 29 (unary_expr -> ! expr .)
    $end            reduce using rule 29 (unary_expr -> ! expr .)
    )               reduce using rule 29 (unary_expr -> ! expr .)
    OF              reduce using rule 29 (unary_expr -> ! expr .)
    THEN            reduce using rule 29 (unary_expr -> ! expr .)
    END             reduce using rule 29 (unary_expr -> ! expr .)
    ELIF            reduce using rule 29 (unary_expr -> ! expr .)
    ELSE            reduce using rule 29 (unary_expr -> ! expr .)
    ,               reduce using rule 29 (unary_expr -> ! expr .)
    ]               reduce using rule 29 (unary_expr -> ! expr .)
    (               shift and go to state 44


state 129

    (30) unary_expr -> STRICT_NOT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_MORE      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_LESS      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    SOME_SUB        reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    SOME_CONCAT     reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARROW_BOTH      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARROW_RIGHT     reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARROW_LEFT      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    BIT_SHIFT_LEFT  reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    BIT_AND         reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    BIT_OR          reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_POW       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    POW             reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARRAY_SUB       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ARRAY_CONCAT    reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    MORE_OR_EQ      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    LESS_OR_EQ      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    TEXT_MATCH      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    STRICT_AND      reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    AND             reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    STRICT_OR       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    OR              reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    EQUAL           reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    NOT_EQUAL       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    >               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_MUL       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_DIV       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_SUB       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    FLOAT_SUM       reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    <               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    *               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    /               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    -               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    +               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    CONCAT          reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    $end            reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    )               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    OF              reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    THEN            reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    END             reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ELIF            reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ELSE            reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ,               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    ]               reduce using rule 30 (unary_expr -> STRICT_NOT expr .)
    (               shift and go to state 44


state 130

    (31) unary_expr -> - expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_MORE      reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_MORE_OR_EQ reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_LESS      reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_LESS_OR_EQ reduce using rule 31 (unary_expr -> - expr .)
    SOME_SUB        reduce using rule 31 (unary_expr -> - expr .)
    SOME_CONCAT     reduce using rule 31 (unary_expr -> - expr .)
    ARROW_BOTH      reduce using rule 31 (unary_expr -> - expr .)
    ARROW_RIGHT     reduce using rule 31 (unary_expr -> - expr .)
    ARROW_LEFT      reduce using rule 31 (unary_expr -> - expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 31 (unary_expr -> - expr .)
    DOUBLE_ARROW_LEFT reduce using rule 31 (unary_expr -> - expr .)
    BIT_SHIFT_LEFT  reduce using rule 31 (unary_expr -> - expr .)
    BIT_AND         reduce using rule 31 (unary_expr -> - expr .)
    BIT_OR          reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_POW       reduce using rule 31 (unary_expr -> - expr .)
    POW             reduce using rule 31 (unary_expr -> - expr .)
    ARRAY_SUB       reduce using rule 31 (unary_expr -> - expr .)
    ARRAY_CONCAT    reduce using rule 31 (unary_expr -> - expr .)
    MORE_OR_EQ      reduce using rule 31 (unary_expr -> - expr .)
    LESS_OR_EQ      reduce using rule 31 (unary_expr -> - expr .)
    TEXT_MATCH      reduce using rule 31 (unary_expr -> - expr .)
    STRICT_AND      reduce using rule 31 (unary_expr -> - expr .)
    AND             reduce using rule 31 (unary_expr -> - expr .)
    STRICT_OR       reduce using rule 31 (unary_expr -> - expr .)
    OR              reduce using rule 31 (unary_expr -> - expr .)
    EQUAL           reduce using rule 31 (unary_expr -> - expr .)
    NOT_EQUAL       reduce using rule 31 (unary_expr -> - expr .)
    >               reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_MUL       reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_DIV       reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_SUB       reduce using rule 31 (unary_expr -> - expr .)
    FLOAT_SUM       reduce using rule 31 (unary_expr -> - expr .)
    <               reduce using rule 31 (unary_expr -> - expr .)
    *               reduce using rule 31 (unary_expr -> - expr .)
    /               reduce using rule 31 (unary_expr -> - expr .)
    -               reduce using rule 31 (unary_expr -> - expr .)
    +               reduce using rule 31 (unary_expr -> - expr .)
    CONCAT          reduce using rule 31 (unary_expr -> - expr .)
    $end            reduce using rule 31 (unary_expr -> - expr .)
    )               reduce using rule 31 (unary_expr -> - expr .)
    OF              reduce using rule 31 (unary_expr -> - expr .)
    THEN            reduce using rule 31 (unary_expr -> - expr .)
    END             reduce using rule 31 (unary_expr -> - expr .)
    ELIF            reduce using rule 31 (unary_expr -> - expr .)
    ELSE            reduce using rule 31 (unary_expr -> - expr .)
    ,               reduce using rule 31 (unary_expr -> - expr .)
    ]               reduce using rule 31 (unary_expr -> - expr .)
    (               shift and go to state 44


state 131

    (242) array -> [ _48_optional . _49_optional ]
    (245) _49_optional -> . exprs
    (246) _49_optional -> .
    (257) exprs -> . expr _54_optional
    (260) exprs -> . exprs , _55_optional expr _56_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    ]               reduce using rule 246 (_49_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    _49_optional                   shift and go to state 189
    exprs                          shift and go to state 190
    expr                           shift and go to state 191
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 132

    (243) _48_optional -> NEWLINE .
    (               reduce using rule 243 (_48_optional -> NEWLINE .)
    DEF             reduce using rule 243 (_48_optional -> NEWLINE .)
    +               reduce using rule 243 (_48_optional -> NEWLINE .)
    !               reduce using rule 243 (_48_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 243 (_48_optional -> NEWLINE .)
    -               reduce using rule 243 (_48_optional -> NEWLINE .)
    STRING          reduce using rule 243 (_48_optional -> NEWLINE .)
    FLOAT           reduce using rule 243 (_48_optional -> NEWLINE .)
    INT             reduce using rule 243 (_48_optional -> NEWLINE .)
    [               reduce using rule 243 (_48_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 243 (_48_optional -> NEWLINE .)
    CASE            reduce using rule 243 (_48_optional -> NEWLINE .)
    IF              reduce using rule 243 (_48_optional -> NEWLINE .)
    DO              reduce using rule 243 (_48_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 243 (_48_optional -> NEWLINE .)
    ENUM            reduce using rule 243 (_48_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 243 (_48_optional -> NEWLINE .)
    ]               reduce using rule 243 (_48_optional -> NEWLINE .)


state 133

    (214) case_of -> CASE expr . OF _39_optional _40_optional END
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 192
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 134

    (205) if_expr -> IF expr . THEN _36_optional block_statement _37_optional END
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 193
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 135

    (132) do -> DO _13_optional . block_statement END
    (135) block_statement -> . _14_optional _15_optional
    (136) _14_optional -> . NEWLINE
    (137) _14_optional -> .
    NEWLINE         shift and go to state 196
    (               reduce using rule 137 (_14_optional -> .)
    DEF             reduce using rule 137 (_14_optional -> .)
    +               reduce using rule 137 (_14_optional -> .)
    !               reduce using rule 137 (_14_optional -> .)
    STRICT_NOT      reduce using rule 137 (_14_optional -> .)
    -               reduce using rule 137 (_14_optional -> .)
    STRING          reduce using rule 137 (_14_optional -> .)
    FLOAT           reduce using rule 137 (_14_optional -> .)
    INT             reduce using rule 137 (_14_optional -> .)
    [               reduce using rule 137 (_14_optional -> .)
    IDENTIFIER      reduce using rule 137 (_14_optional -> .)
    CASE            reduce using rule 137 (_14_optional -> .)
    IF              reduce using rule 137 (_14_optional -> .)
    DO              reduce using rule 137 (_14_optional -> .)
    EXTERNAL        reduce using rule 137 (_14_optional -> .)
    ENUM            reduce using rule 137 (_14_optional -> .)
    TYPE_IDENTIFIER reduce using rule 137 (_14_optional -> .)
    END             reduce using rule 137 (_14_optional -> .)

    block_statement                shift and go to state 194
    _14_optional                   shift and go to state 195

state 136

    (133) _13_optional -> : . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 197
    type_identifier                shift and go to state 198

state 137

    (174) enum -> ENUM type_identifier . { _27_optional _28_optional }
    (179) enum -> ENUM type_identifier . < type_identifier _29_repeat > { _30_optional _31_optional }
    {               shift and go to state 199
    <               shift and go to state 200


state 138

    (9) do_exprs -> expr NEWLINE do_exprs .
    $end            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    END             reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELIF            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELSE            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)


state 139

    (247) call -> expr ( _50_optional . _51_optional )
    (250) _51_optional -> . exprs
    (251) _51_optional -> .
    (257) exprs -> . expr _54_optional
    (260) exprs -> . exprs , _55_optional expr _56_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 251 (_51_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 191
    _51_optional                   shift and go to state 201
    exprs                          shift and go to state 202
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 140

    (248) _50_optional -> NEWLINE .
    (               reduce using rule 248 (_50_optional -> NEWLINE .)
    DEF             reduce using rule 248 (_50_optional -> NEWLINE .)
    +               reduce using rule 248 (_50_optional -> NEWLINE .)
    !               reduce using rule 248 (_50_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 248 (_50_optional -> NEWLINE .)
    -               reduce using rule 248 (_50_optional -> NEWLINE .)
    STRING          reduce using rule 248 (_50_optional -> NEWLINE .)
    FLOAT           reduce using rule 248 (_50_optional -> NEWLINE .)
    INT             reduce using rule 248 (_50_optional -> NEWLINE .)
    [               reduce using rule 248 (_50_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 248 (_50_optional -> NEWLINE .)
    CASE            reduce using rule 248 (_50_optional -> NEWLINE .)
    IF              reduce using rule 248 (_50_optional -> NEWLINE .)
    DO              reduce using rule 248 (_50_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 248 (_50_optional -> NEWLINE .)
    ENUM            reduce using rule 248 (_50_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 248 (_50_optional -> NEWLINE .)
    )               reduce using rule 248 (_50_optional -> NEWLINE .)


state 141

    (33) binary_expr -> expr FLOAT_MORE expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for FLOAT_MORE resolved as shift
  ! shift/reduce conflict for FLOAT_MORE_OR_EQ resolved as shift
  ! shift/reduce conflict for FLOAT_LESS resolved as shift
  ! shift/reduce conflict for FLOAT_LESS_OR_EQ resolved as shift
  ! shift/reduce conflict for SOME_SUB resolved as shift
  ! shift/reduce conflict for SOME_CONCAT resolved as shift
  ! shift/reduce conflict for ARROW_BOTH resolved as shift
  ! shift/reduce conflict for ARROW_RIGHT resolved as shift
  ! shift/reduce conflict for ARROW_LEFT resolved as shift
  ! shift/reduce conflict for DOUBLE_ARROW_RIGHT resolved as shift
  ! shift/reduce conflict for DOUBLE_ARROW_LEFT resolved as shift
  ! shift/reduce conflict for BIT_SHIFT_LEFT resolved as shift
  ! shift/reduce conflict for BIT_AND resolved as shift
  ! shift/reduce conflict for BIT_OR resolved as shift
  ! shift/reduce conflict for FLOAT_POW resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for ARRAY_SUB resolved as shift
  ! shift/reduce conflict for ARRAY_CONCAT resolved as shift
  ! shift/reduce conflict for MORE_OR_EQ resolved as shift
  ! shift/reduce conflict for LESS_OR_EQ resolved as shift
  ! shift/reduce conflict for TEXT_MATCH resolved as shift
  ! shift/reduce conflict for STRICT_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for STRICT_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for FLOAT_MUL resolved as shift
  ! shift/reduce conflict for FLOAT_DIV resolved as shift
  ! shift/reduce conflict for FLOAT_SUB resolved as shift
  ! shift/reduce conflict for FLOAT_SUM resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    NEWLINE         reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    $end            reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    )               reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    OF              reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    THEN            reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    END             reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    ,               reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    ]               reduce using rule 33 (binary_expr -> expr FLOAT_MORE expr .)
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 142

    (34) binary_expr -> expr FLOAT_MORE_OR_EQ expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for FLOAT_MORE resolved as shift
  ! shift/reduce conflict for FLOAT_MORE_OR_EQ resolved as shift
  ! shift/reduce conflict for FLOAT_LESS resolved as shift
  ! shift/reduce conflict for FLOAT_LESS_OR_EQ resolved as shift
  ! shift/reduce conflict for SOME_SUB resolved as shift
  ! shift/reduce conflict for SOME_CONCAT resolved as shift
  ! shift/reduce conflict for ARROW_BOTH resolved as shift
  ! shift/reduce conflict for ARROW_RIGHT resolved as shift
  ! shift/reduce conflict for ARROW_LEFT resolved as shift
  ! shift/reduce conflict for DOUBLE_ARROW_RIGHT resolved as shift
  ! shift/reduce conflict for DOUBLE_ARROW_LEFT resolved as shift
  ! shift/reduce conflict for BIT_SHIFT_LEFT resolved as shift
  ! shift/reduce conflict for BIT_AND resolved as shift
  ! shift/reduce conflict for BIT_OR resolved as shift
  ! shift/reduce conflict for FLOAT_POW resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for ARRAY_SUB resolved as shift
  ! shift/reduce conflict for ARRAY_CONCAT resolved as shift
  ! shift/reduce conflict for MORE_OR_EQ resolved as shift
  ! shift/reduce conflict for LESS_OR_EQ resolved as shift
  ! shift/reduce conflict for TEXT_MATCH resolved as shift
  ! shift/reduce conflict for STRICT_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for STRICT_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for FLOAT_MUL resolved as shift
  ! shift/reduce conflict for FLOAT_DIV resolved as shift
  ! shift/reduce conflict for FLOAT_SUB resolved as shift
  ! shift/reduce conflict for FLOAT_SUM resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    NEWLINE         reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    $end            reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    )               reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    OF              reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    THEN            reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    END             reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    ,               reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    ]               reduce using rule 34 (binary_expr -> expr FLOAT_MORE_OR_EQ expr .)
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 143

    (35) binary_expr -> expr FLOAT_LESS expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for FLOAT_MORE resolved as shift
  ! shift/reduce conflict for FLOAT_MORE_OR_EQ resolved as shift
  ! shift/reduce conflict for FLOAT_LESS resolved as shift
  ! shift/reduce conflict for FLOAT_LESS_OR_EQ resolved as shift
  ! shift/reduce conflict for SOME_SUB resolved as shift
  ! shift/reduce conflict for SOME_CONCAT resolved as shift
  ! shift/reduce conflict for ARROW_BOTH resolved as shift
  ! shift/reduce conflict for ARROW_RIGHT resolved as shift
  ! shift/reduce conflict for ARROW_LEFT resolved as shift
  ! shift/reduce conflict for DOUBLE_ARROW_RIGHT resolved as shift
  ! shift/reduce conflict for DOUBLE_ARROW_LEFT resolved as shift
  ! shift/reduce conflict for BIT_SHIFT_LEFT resolved as shift
  ! shift/reduce conflict for BIT_AND resolved as shift
  ! shift/reduce conflict for BIT_OR resolved as shift
  ! shift/reduce conflict for FLOAT_POW resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for ARRAY_SUB resolved as shift
  ! shift/reduce conflict for ARRAY_CONCAT resolved as shift
  ! shift/reduce conflict for MORE_OR_EQ resolved as shift
  ! shift/reduce conflict for LESS_OR_EQ resolved as shift
  ! shift/reduce conflict for TEXT_MATCH resolved as shift
  ! shift/reduce conflict for STRICT_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for STRICT_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for FLOAT_MUL resolved as shift
  ! shift/reduce conflict for FLOAT_DIV resolved as shift
  ! shift/reduce conflict for FLOAT_SUB resolved as shift
  ! shift/reduce conflict for FLOAT_SUM resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    NEWLINE         reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    $end            reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    )               reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    OF              reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    THEN            reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    END             reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    ,               reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    ]               reduce using rule 35 (binary_expr -> expr FLOAT_LESS expr .)
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 144

    (36) binary_expr -> expr FLOAT_LESS_OR_EQ expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for FLOAT_MORE resolved as shift
  ! shift/reduce conflict for FLOAT_MORE_OR_EQ resolved as shift
  ! shift/reduce conflict for FLOAT_LESS resolved as shift
  ! shift/reduce conflict for FLOAT_LESS_OR_EQ resolved as shift
  ! shift/reduce conflict for SOME_SUB resolved as shift
  ! shift/reduce conflict for SOME_CONCAT resolved as shift
  ! shift/reduce conflict for ARROW_BOTH resolved as shift
  ! shift/reduce conflict for ARROW_RIGHT resolved as shift
  ! shift/reduce conflict for ARROW_LEFT resolved as shift
  ! shift/reduce conflict for DOUBLE_ARROW_RIGHT resolved as shift
  ! shift/reduce conflict for DOUBLE_ARROW_LEFT resolved as shift
  ! shift/reduce conflict for BIT_SHIFT_LEFT resolved as shift
  ! shift/reduce conflict for BIT_AND resolved as shift
  ! shift/reduce conflict for BIT_OR resolved as shift
  ! shift/reduce conflict for FLOAT_POW resolved as shift
  ! shift/reduce conflict for POW resolved as shift
  ! shift/reduce conflict for ARRAY_SUB resolved as shift
  ! shift/reduce conflict for ARRAY_CONCAT resolved as shift
  ! shift/reduce conflict for MORE_OR_EQ resolved as shift
  ! shift/reduce conflict for LESS_OR_EQ resolved as shift
  ! shift/reduce conflict for TEXT_MATCH resolved as shift
  ! shift/reduce conflict for STRICT_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for STRICT_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for FLOAT_MUL resolved as shift
  ! shift/reduce conflict for FLOAT_DIV resolved as shift
  ! shift/reduce conflict for FLOAT_SUB resolved as shift
  ! shift/reduce conflict for FLOAT_SUM resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    NEWLINE         reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    $end            reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    )               reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    OF              reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    THEN            reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    END             reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    ELIF            reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    ELSE            reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    ,               reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    ]               reduce using rule 36 (binary_expr -> expr FLOAT_LESS_OR_EQ expr .)
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 145

    (37) binary_expr -> expr SOME_SUB expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    FLOAT_MORE      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    FLOAT_MORE_OR_EQ reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    FLOAT_LESS      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    FLOAT_LESS_OR_EQ reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ARROW_BOTH      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ARROW_RIGHT     reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ARROW_LEFT      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    BIT_AND         reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    BIT_OR          reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    MORE_OR_EQ      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    LESS_OR_EQ      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    TEXT_MATCH      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    STRICT_AND      reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    AND             reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    STRICT_OR       reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    OR              reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    EQUAL           reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    NOT_EQUAL       reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    >               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    <               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    $end            reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    )               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    OF              reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    THEN            reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    END             reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ELIF            reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ELSE            reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ,               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    ]               reduce using rule 37 (binary_expr -> expr SOME_SUB expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 146

    (38) binary_expr -> expr SOME_CONCAT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    FLOAT_MORE      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    FLOAT_LESS      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_BOTH      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_RIGHT     reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ARROW_LEFT      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_AND         reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    BIT_OR          reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    MORE_OR_EQ      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    LESS_OR_EQ      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    TEXT_MATCH      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    STRICT_AND      reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    AND             reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    STRICT_OR       reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    OR              reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    EQUAL           reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    NOT_EQUAL       reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    >               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    <               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    $end            reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    )               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    OF              reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    THEN            reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    END             reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ELIF            reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ELSE            reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ,               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    ]               reduce using rule 38 (binary_expr -> expr SOME_CONCAT expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 147

    (39) binary_expr -> expr ARROW_BOTH expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    FLOAT_MORE      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    FLOAT_MORE_OR_EQ reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    FLOAT_LESS      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    FLOAT_LESS_OR_EQ reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_BOTH      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_RIGHT     reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ARROW_LEFT      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    DOUBLE_ARROW_LEFT reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_SHIFT_LEFT  reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_AND         reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    BIT_OR          reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    MORE_OR_EQ      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    LESS_OR_EQ      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    TEXT_MATCH      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    STRICT_AND      reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    AND             reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    STRICT_OR       reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    OR              reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    EQUAL           reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    NOT_EQUAL       reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    >               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    <               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    $end            reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    )               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    OF              reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    THEN            reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    END             reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ELIF            reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ELSE            reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ,               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    ]               reduce using rule 39 (binary_expr -> expr ARROW_BOTH expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 148

    (40) binary_expr -> expr ARROW_RIGHT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    FLOAT_MORE      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    FLOAT_LESS      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_BOTH      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_RIGHT     reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ARROW_LEFT      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_SHIFT_LEFT  reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_AND         reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    BIT_OR          reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    MORE_OR_EQ      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    LESS_OR_EQ      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    TEXT_MATCH      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    STRICT_AND      reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    AND             reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    STRICT_OR       reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    OR              reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    EQUAL           reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    NOT_EQUAL       reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    >               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    <               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    $end            reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    )               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    OF              reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    THEN            reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    END             reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ELIF            reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ELSE            reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ,               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    ]               reduce using rule 40 (binary_expr -> expr ARROW_RIGHT expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 149

    (41) binary_expr -> expr ARROW_LEFT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    FLOAT_MORE      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    FLOAT_LESS      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_BOTH      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_RIGHT     reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ARROW_LEFT      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_AND         reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    BIT_OR          reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    MORE_OR_EQ      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    LESS_OR_EQ      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    TEXT_MATCH      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    STRICT_AND      reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    AND             reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    STRICT_OR       reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    OR              reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    EQUAL           reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    NOT_EQUAL       reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    >               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    <               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    $end            reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    )               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    OF              reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    THEN            reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    END             reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ELIF            reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ELSE            reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ,               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    ]               reduce using rule 41 (binary_expr -> expr ARROW_LEFT expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 150

    (42) binary_expr -> expr DOUBLE_ARROW_RIGHT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    FLOAT_MORE      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    FLOAT_LESS      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_BOTH      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_RIGHT     reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ARROW_LEFT      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_SHIFT_LEFT  reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_AND         reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    BIT_OR          reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    MORE_OR_EQ      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    LESS_OR_EQ      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    TEXT_MATCH      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    STRICT_AND      reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    AND             reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    STRICT_OR       reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    OR              reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    EQUAL           reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    NOT_EQUAL       reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    >               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    <               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    $end            reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    )               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    OF              reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    THEN            reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    END             reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ELIF            reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ELSE            reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ,               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    ]               reduce using rule 42 (binary_expr -> expr DOUBLE_ARROW_RIGHT expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 151

    (43) binary_expr -> expr DOUBLE_ARROW_LEFT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    FLOAT_MORE      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    FLOAT_LESS      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_BOTH      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_RIGHT     reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ARROW_LEFT      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_AND         reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    BIT_OR          reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    MORE_OR_EQ      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    LESS_OR_EQ      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    TEXT_MATCH      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    STRICT_AND      reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    AND             reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    STRICT_OR       reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    OR              reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    EQUAL           reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    NOT_EQUAL       reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    >               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    <               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    $end            reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    )               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    OF              reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    THEN            reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    END             reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ELIF            reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ELSE            reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ,               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    ]               reduce using rule 43 (binary_expr -> expr DOUBLE_ARROW_LEFT expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 152

    (44) binary_expr -> expr BIT_SHIFT_LEFT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    FLOAT_MORE      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    FLOAT_LESS      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_BOTH      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_RIGHT     reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ARROW_LEFT      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_SHIFT_LEFT  reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_AND         reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    BIT_OR          reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    MORE_OR_EQ      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    LESS_OR_EQ      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    TEXT_MATCH      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    STRICT_AND      reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    AND             reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    STRICT_OR       reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    OR              reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    EQUAL           reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    NOT_EQUAL       reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    >               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    <               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    $end            reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    )               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    OF              reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    THEN            reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    END             reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ELIF            reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ELSE            reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ,               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    ]               reduce using rule 44 (binary_expr -> expr BIT_SHIFT_LEFT expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 153

    (45) binary_expr -> expr BIT_AND expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    FLOAT_MORE      reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    FLOAT_MORE_OR_EQ reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    FLOAT_LESS      reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    FLOAT_LESS_OR_EQ reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    BIT_AND         reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    BIT_OR          reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    STRICT_AND      reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    AND             reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    STRICT_OR       reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    OR              reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    $end            reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    )               reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    OF              reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    THEN            reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    END             reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    ELIF            reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    ELSE            reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    ,               reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    ]               reduce using rule 45 (binary_expr -> expr BIT_AND expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 154

    (46) binary_expr -> expr BIT_OR expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    FLOAT_MORE      reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    FLOAT_MORE_OR_EQ reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    FLOAT_LESS      reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    FLOAT_LESS_OR_EQ reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    BIT_OR          reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    STRICT_OR       reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    OR              reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    $end            reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    )               reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    OF              reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    THEN            reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    END             reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    ELIF            reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    ELSE            reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    ,               reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    ]               reduce using rule 46 (binary_expr -> expr BIT_OR expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 155

    (47) binary_expr -> expr FLOAT_POW expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_MORE      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_MORE_OR_EQ reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_LESS      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_LESS_OR_EQ reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    SOME_SUB        reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    SOME_CONCAT     reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_BOTH      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_RIGHT     reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARROW_LEFT      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    DOUBLE_ARROW_LEFT reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    BIT_SHIFT_LEFT  reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    BIT_AND         reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    BIT_OR          reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_POW       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    POW             reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARRAY_SUB       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ARRAY_CONCAT    reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    MORE_OR_EQ      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    LESS_OR_EQ      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    TEXT_MATCH      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    STRICT_AND      reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    AND             reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    STRICT_OR       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    OR              reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    EQUAL           reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    NOT_EQUAL       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    >               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_MUL       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_DIV       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_SUB       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    FLOAT_SUM       reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    <               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    *               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    /               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    -               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    +               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    CONCAT          reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    $end            reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    )               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    OF              reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    THEN            reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    END             reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ELIF            reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ELSE            reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ,               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    ]               reduce using rule 47 (binary_expr -> expr FLOAT_POW expr .)
    (               shift and go to state 44


state 156

    (48) binary_expr -> expr POW expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_MORE      reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_MORE_OR_EQ reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_LESS      reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_LESS_OR_EQ reduce using rule 48 (binary_expr -> expr POW expr .)
    SOME_SUB        reduce using rule 48 (binary_expr -> expr POW expr .)
    SOME_CONCAT     reduce using rule 48 (binary_expr -> expr POW expr .)
    ARROW_BOTH      reduce using rule 48 (binary_expr -> expr POW expr .)
    ARROW_RIGHT     reduce using rule 48 (binary_expr -> expr POW expr .)
    ARROW_LEFT      reduce using rule 48 (binary_expr -> expr POW expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 48 (binary_expr -> expr POW expr .)
    DOUBLE_ARROW_LEFT reduce using rule 48 (binary_expr -> expr POW expr .)
    BIT_SHIFT_LEFT  reduce using rule 48 (binary_expr -> expr POW expr .)
    BIT_AND         reduce using rule 48 (binary_expr -> expr POW expr .)
    BIT_OR          reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_POW       reduce using rule 48 (binary_expr -> expr POW expr .)
    POW             reduce using rule 48 (binary_expr -> expr POW expr .)
    ARRAY_SUB       reduce using rule 48 (binary_expr -> expr POW expr .)
    ARRAY_CONCAT    reduce using rule 48 (binary_expr -> expr POW expr .)
    MORE_OR_EQ      reduce using rule 48 (binary_expr -> expr POW expr .)
    LESS_OR_EQ      reduce using rule 48 (binary_expr -> expr POW expr .)
    TEXT_MATCH      reduce using rule 48 (binary_expr -> expr POW expr .)
    STRICT_AND      reduce using rule 48 (binary_expr -> expr POW expr .)
    AND             reduce using rule 48 (binary_expr -> expr POW expr .)
    STRICT_OR       reduce using rule 48 (binary_expr -> expr POW expr .)
    OR              reduce using rule 48 (binary_expr -> expr POW expr .)
    EQUAL           reduce using rule 48 (binary_expr -> expr POW expr .)
    NOT_EQUAL       reduce using rule 48 (binary_expr -> expr POW expr .)
    >               reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_MUL       reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_DIV       reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_SUB       reduce using rule 48 (binary_expr -> expr POW expr .)
    FLOAT_SUM       reduce using rule 48 (binary_expr -> expr POW expr .)
    <               reduce using rule 48 (binary_expr -> expr POW expr .)
    *               reduce using rule 48 (binary_expr -> expr POW expr .)
    /               reduce using rule 48 (binary_expr -> expr POW expr .)
    -               reduce using rule 48 (binary_expr -> expr POW expr .)
    +               reduce using rule 48 (binary_expr -> expr POW expr .)
    CONCAT          reduce using rule 48 (binary_expr -> expr POW expr .)
    $end            reduce using rule 48 (binary_expr -> expr POW expr .)
    )               reduce using rule 48 (binary_expr -> expr POW expr .)
    OF              reduce using rule 48 (binary_expr -> expr POW expr .)
    THEN            reduce using rule 48 (binary_expr -> expr POW expr .)
    END             reduce using rule 48 (binary_expr -> expr POW expr .)
    ELIF            reduce using rule 48 (binary_expr -> expr POW expr .)
    ELSE            reduce using rule 48 (binary_expr -> expr POW expr .)
    ,               reduce using rule 48 (binary_expr -> expr POW expr .)
    ]               reduce using rule 48 (binary_expr -> expr POW expr .)
    (               shift and go to state 44


state 157

    (49) binary_expr -> expr ARRAY_SUB expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    FLOAT_MORE      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    FLOAT_MORE_OR_EQ reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    FLOAT_LESS      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    FLOAT_LESS_OR_EQ reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_BOTH      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_RIGHT     reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ARROW_LEFT      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_AND         reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    BIT_OR          reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    MORE_OR_EQ      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    LESS_OR_EQ      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    TEXT_MATCH      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    STRICT_AND      reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    AND             reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    STRICT_OR       reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    OR              reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    EQUAL           reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    NOT_EQUAL       reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    >               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    <               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    $end            reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    )               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    OF              reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    THEN            reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    END             reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ELIF            reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ELSE            reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ,               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    ]               reduce using rule 49 (binary_expr -> expr ARRAY_SUB expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 158

    (50) binary_expr -> expr ARRAY_CONCAT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    FLOAT_MORE      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    FLOAT_LESS      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_BOTH      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_RIGHT     reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ARROW_LEFT      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_AND         reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    BIT_OR          reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    MORE_OR_EQ      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    LESS_OR_EQ      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    TEXT_MATCH      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    STRICT_AND      reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    AND             reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    STRICT_OR       reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    OR              reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    EQUAL           reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    NOT_EQUAL       reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    >               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    <               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    $end            reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    )               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    OF              reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    THEN            reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    END             reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ELIF            reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ELSE            reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ,               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    ]               reduce using rule 50 (binary_expr -> expr ARRAY_CONCAT expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 159

    (51) binary_expr -> expr MORE_OR_EQ expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    FLOAT_MORE      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    FLOAT_MORE_OR_EQ reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    FLOAT_LESS      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    FLOAT_LESS_OR_EQ reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    BIT_AND         reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    BIT_OR          reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    STRICT_AND      reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    AND             reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    STRICT_OR       reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    OR              reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    EQUAL           reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    >               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    <               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    $end            reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    )               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    OF              reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    THEN            reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    END             reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    ELIF            reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    ELSE            reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    ,               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    ]               reduce using rule 51 (binary_expr -> expr MORE_OR_EQ expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 160

    (52) binary_expr -> expr LESS_OR_EQ expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    FLOAT_MORE      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    FLOAT_MORE_OR_EQ reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    FLOAT_LESS      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    FLOAT_LESS_OR_EQ reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    BIT_AND         reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    BIT_OR          reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    STRICT_AND      reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    AND             reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    STRICT_OR       reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    OR              reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    EQUAL           reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    >               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    <               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    $end            reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    )               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    OF              reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    THEN            reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    END             reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    ELIF            reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    ELSE            reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    ,               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    ]               reduce using rule 52 (binary_expr -> expr LESS_OR_EQ expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 161

    (53) binary_expr -> expr TEXT_MATCH expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    FLOAT_MORE      reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    FLOAT_MORE_OR_EQ reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    FLOAT_LESS      reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    FLOAT_LESS_OR_EQ reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    BIT_AND         reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    BIT_OR          reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    TEXT_MATCH      reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    STRICT_AND      reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    AND             reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    STRICT_OR       reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    OR              reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    EQUAL           reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    NOT_EQUAL       reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    $end            reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    )               reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    OF              reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    THEN            reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    END             reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    ELIF            reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    ELSE            reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    ,               reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    ]               reduce using rule 53 (binary_expr -> expr TEXT_MATCH expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 162

    (54) binary_expr -> expr STRICT_AND expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    FLOAT_MORE      reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    FLOAT_MORE_OR_EQ reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    FLOAT_LESS      reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    FLOAT_LESS_OR_EQ reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    BIT_AND         reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    BIT_OR          reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    STRICT_AND      reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    AND             reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    STRICT_OR       reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    OR              reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    $end            reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    )               reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    OF              reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    THEN            reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    END             reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    ELIF            reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    ELSE            reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    ,               reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    ]               reduce using rule 54 (binary_expr -> expr STRICT_AND expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 163

    (55) binary_expr -> expr AND expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 55 (binary_expr -> expr AND expr .)
    FLOAT_MORE      reduce using rule 55 (binary_expr -> expr AND expr .)
    FLOAT_MORE_OR_EQ reduce using rule 55 (binary_expr -> expr AND expr .)
    FLOAT_LESS      reduce using rule 55 (binary_expr -> expr AND expr .)
    FLOAT_LESS_OR_EQ reduce using rule 55 (binary_expr -> expr AND expr .)
    BIT_AND         reduce using rule 55 (binary_expr -> expr AND expr .)
    BIT_OR          reduce using rule 55 (binary_expr -> expr AND expr .)
    STRICT_AND      reduce using rule 55 (binary_expr -> expr AND expr .)
    AND             reduce using rule 55 (binary_expr -> expr AND expr .)
    STRICT_OR       reduce using rule 55 (binary_expr -> expr AND expr .)
    OR              reduce using rule 55 (binary_expr -> expr AND expr .)
    $end            reduce using rule 55 (binary_expr -> expr AND expr .)
    )               reduce using rule 55 (binary_expr -> expr AND expr .)
    OF              reduce using rule 55 (binary_expr -> expr AND expr .)
    THEN            reduce using rule 55 (binary_expr -> expr AND expr .)
    END             reduce using rule 55 (binary_expr -> expr AND expr .)
    ELIF            reduce using rule 55 (binary_expr -> expr AND expr .)
    ELSE            reduce using rule 55 (binary_expr -> expr AND expr .)
    ,               reduce using rule 55 (binary_expr -> expr AND expr .)
    ]               reduce using rule 55 (binary_expr -> expr AND expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 164

    (56) binary_expr -> expr STRICT_OR expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    FLOAT_MORE      reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    FLOAT_MORE_OR_EQ reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    FLOAT_LESS      reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    FLOAT_LESS_OR_EQ reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    BIT_OR          reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    STRICT_OR       reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    OR              reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    $end            reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    )               reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    OF              reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    THEN            reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    END             reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    ELIF            reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    ELSE            reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    ,               reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    ]               reduce using rule 56 (binary_expr -> expr STRICT_OR expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 165

    (57) binary_expr -> expr OR expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 57 (binary_expr -> expr OR expr .)
    FLOAT_MORE      reduce using rule 57 (binary_expr -> expr OR expr .)
    FLOAT_MORE_OR_EQ reduce using rule 57 (binary_expr -> expr OR expr .)
    FLOAT_LESS      reduce using rule 57 (binary_expr -> expr OR expr .)
    FLOAT_LESS_OR_EQ reduce using rule 57 (binary_expr -> expr OR expr .)
    BIT_OR          reduce using rule 57 (binary_expr -> expr OR expr .)
    STRICT_OR       reduce using rule 57 (binary_expr -> expr OR expr .)
    OR              reduce using rule 57 (binary_expr -> expr OR expr .)
    $end            reduce using rule 57 (binary_expr -> expr OR expr .)
    )               reduce using rule 57 (binary_expr -> expr OR expr .)
    OF              reduce using rule 57 (binary_expr -> expr OR expr .)
    THEN            reduce using rule 57 (binary_expr -> expr OR expr .)
    END             reduce using rule 57 (binary_expr -> expr OR expr .)
    ELIF            reduce using rule 57 (binary_expr -> expr OR expr .)
    ELSE            reduce using rule 57 (binary_expr -> expr OR expr .)
    ,               reduce using rule 57 (binary_expr -> expr OR expr .)
    ]               reduce using rule 57 (binary_expr -> expr OR expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 166

    (58) binary_expr -> expr EQUAL expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    FLOAT_MORE      reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    FLOAT_MORE_OR_EQ reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    FLOAT_LESS      reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    FLOAT_LESS_OR_EQ reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    BIT_AND         reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    BIT_OR          reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    TEXT_MATCH      reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    STRICT_AND      reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    AND             reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    STRICT_OR       reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    OR              reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    $end            reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    )               reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    OF              reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    THEN            reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    END             reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    ELIF            reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    ELSE            reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    ,               reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    ]               reduce using rule 58 (binary_expr -> expr EQUAL expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 167

    (59) binary_expr -> expr NOT_EQUAL expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    FLOAT_MORE      reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    FLOAT_MORE_OR_EQ reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    FLOAT_LESS      reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    FLOAT_LESS_OR_EQ reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    BIT_AND         reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    BIT_OR          reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    TEXT_MATCH      reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    STRICT_AND      reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    AND             reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    STRICT_OR       reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    OR              reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    END             reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    ELIF            reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    ]               reduce using rule 59 (binary_expr -> expr NOT_EQUAL expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 168

    (60) binary_expr -> expr > expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 60 (binary_expr -> expr > expr .)
    FLOAT_MORE      reduce using rule 60 (binary_expr -> expr > expr .)
    FLOAT_MORE_OR_EQ reduce using rule 60 (binary_expr -> expr > expr .)
    FLOAT_LESS      reduce using rule 60 (binary_expr -> expr > expr .)
    FLOAT_LESS_OR_EQ reduce using rule 60 (binary_expr -> expr > expr .)
    BIT_AND         reduce using rule 60 (binary_expr -> expr > expr .)
    BIT_OR          reduce using rule 60 (binary_expr -> expr > expr .)
    MORE_OR_EQ      reduce using rule 60 (binary_expr -> expr > expr .)
    LESS_OR_EQ      reduce using rule 60 (binary_expr -> expr > expr .)
    TEXT_MATCH      reduce using rule 60 (binary_expr -> expr > expr .)
    STRICT_AND      reduce using rule 60 (binary_expr -> expr > expr .)
    AND             reduce using rule 60 (binary_expr -> expr > expr .)
    STRICT_OR       reduce using rule 60 (binary_expr -> expr > expr .)
    OR              reduce using rule 60 (binary_expr -> expr > expr .)
    EQUAL           reduce using rule 60 (binary_expr -> expr > expr .)
    NOT_EQUAL       reduce using rule 60 (binary_expr -> expr > expr .)
    >               reduce using rule 60 (binary_expr -> expr > expr .)
    <               reduce using rule 60 (binary_expr -> expr > expr .)
    $end            reduce using rule 60 (binary_expr -> expr > expr .)
    )               reduce using rule 60 (binary_expr -> expr > expr .)
    OF              reduce using rule 60 (binary_expr -> expr > expr .)
    THEN            reduce using rule 60 (binary_expr -> expr > expr .)
    END             reduce using rule 60 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 60 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 60 (binary_expr -> expr > expr .)
    ,               reduce using rule 60 (binary_expr -> expr > expr .)
    ]               reduce using rule 60 (binary_expr -> expr > expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 169

    (61) binary_expr -> expr FLOAT_MUL expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_MORE      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_MORE_OR_EQ reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_LESS      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_LESS_OR_EQ reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    SOME_SUB        reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    SOME_CONCAT     reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_BOTH      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_RIGHT     reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARROW_LEFT      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    DOUBLE_ARROW_LEFT reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_SHIFT_LEFT  reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_AND         reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    BIT_OR          reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARRAY_SUB       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ARRAY_CONCAT    reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    MORE_OR_EQ      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    LESS_OR_EQ      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    TEXT_MATCH      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    STRICT_AND      reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    AND             reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    STRICT_OR       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    OR              reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    EQUAL           reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    NOT_EQUAL       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    >               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_MUL       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_DIV       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_SUB       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_SUM       reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    <               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    *               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    /               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    -               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    +               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    CONCAT          reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    $end            reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    )               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    OF              reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    THEN            reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    END             reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ELIF            reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ELSE            reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ,               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    ]               reduce using rule 61 (binary_expr -> expr FLOAT_MUL expr .)
    (               shift and go to state 44
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60


state 170

    (62) binary_expr -> expr FLOAT_DIV expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_MORE      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_MORE_OR_EQ reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_LESS      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_LESS_OR_EQ reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    SOME_SUB        reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    SOME_CONCAT     reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_BOTH      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_RIGHT     reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARROW_LEFT      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    DOUBLE_ARROW_LEFT reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_SHIFT_LEFT  reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_AND         reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    BIT_OR          reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARRAY_SUB       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ARRAY_CONCAT    reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    MORE_OR_EQ      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    LESS_OR_EQ      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    TEXT_MATCH      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    STRICT_AND      reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    AND             reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    STRICT_OR       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    OR              reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    EQUAL           reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    NOT_EQUAL       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    >               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_MUL       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_DIV       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_SUB       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_SUM       reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    <               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    *               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    /               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    -               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    +               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    CONCAT          reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    $end            reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    )               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    OF              reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    THEN            reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    END             reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ELIF            reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ELSE            reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ,               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    ]               reduce using rule 62 (binary_expr -> expr FLOAT_DIV expr .)
    (               shift and go to state 44
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60


state 171

    (63) binary_expr -> expr FLOAT_SUB expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_MORE      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_MORE_OR_EQ reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_LESS      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_LESS_OR_EQ reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    SOME_SUB        reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    SOME_CONCAT     reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_BOTH      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_RIGHT     reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARROW_LEFT      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    DOUBLE_ARROW_LEFT reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_SHIFT_LEFT  reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_AND         reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    BIT_OR          reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARRAY_SUB       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ARRAY_CONCAT    reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    MORE_OR_EQ      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    LESS_OR_EQ      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    TEXT_MATCH      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    STRICT_AND      reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    AND             reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    STRICT_OR       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    OR              reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    EQUAL           reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    NOT_EQUAL       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    >               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_SUB       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_SUM       reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    <               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    -               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    +               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    CONCAT          reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    $end            reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    )               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    OF              reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    THEN            reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    END             reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ELIF            reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ELSE            reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ,               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    ]               reduce using rule 63 (binary_expr -> expr FLOAT_SUB expr .)
    (               shift and go to state 44
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    *               shift and go to state 78
    /               shift and go to state 79


state 172

    (64) binary_expr -> expr FLOAT_SUM expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_MORE      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_MORE_OR_EQ reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_LESS      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_LESS_OR_EQ reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    SOME_SUB        reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    SOME_CONCAT     reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_BOTH      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_RIGHT     reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARROW_LEFT      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    DOUBLE_ARROW_LEFT reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_SHIFT_LEFT  reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_AND         reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    BIT_OR          reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARRAY_SUB       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ARRAY_CONCAT    reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    MORE_OR_EQ      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    LESS_OR_EQ      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    TEXT_MATCH      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    STRICT_AND      reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    AND             reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    STRICT_OR       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    OR              reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    EQUAL           reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    NOT_EQUAL       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    >               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_SUB       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_SUM       reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    <               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    -               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    +               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    CONCAT          reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    $end            reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    )               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    OF              reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    THEN            reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    END             reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ELIF            reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ELSE            reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ,               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    ]               reduce using rule 64 (binary_expr -> expr FLOAT_SUM expr .)
    (               shift and go to state 44
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    *               shift and go to state 78
    /               shift and go to state 79


state 173

    (65) binary_expr -> expr < expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 65 (binary_expr -> expr < expr .)
    FLOAT_MORE      reduce using rule 65 (binary_expr -> expr < expr .)
    FLOAT_MORE_OR_EQ reduce using rule 65 (binary_expr -> expr < expr .)
    FLOAT_LESS      reduce using rule 65 (binary_expr -> expr < expr .)
    FLOAT_LESS_OR_EQ reduce using rule 65 (binary_expr -> expr < expr .)
    BIT_AND         reduce using rule 65 (binary_expr -> expr < expr .)
    BIT_OR          reduce using rule 65 (binary_expr -> expr < expr .)
    MORE_OR_EQ      reduce using rule 65 (binary_expr -> expr < expr .)
    LESS_OR_EQ      reduce using rule 65 (binary_expr -> expr < expr .)
    TEXT_MATCH      reduce using rule 65 (binary_expr -> expr < expr .)
    STRICT_AND      reduce using rule 65 (binary_expr -> expr < expr .)
    AND             reduce using rule 65 (binary_expr -> expr < expr .)
    STRICT_OR       reduce using rule 65 (binary_expr -> expr < expr .)
    OR              reduce using rule 65 (binary_expr -> expr < expr .)
    EQUAL           reduce using rule 65 (binary_expr -> expr < expr .)
    NOT_EQUAL       reduce using rule 65 (binary_expr -> expr < expr .)
    >               reduce using rule 65 (binary_expr -> expr < expr .)
    <               reduce using rule 65 (binary_expr -> expr < expr .)
    $end            reduce using rule 65 (binary_expr -> expr < expr .)
    )               reduce using rule 65 (binary_expr -> expr < expr .)
    OF              reduce using rule 65 (binary_expr -> expr < expr .)
    THEN            reduce using rule 65 (binary_expr -> expr < expr .)
    END             reduce using rule 65 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 65 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 65 (binary_expr -> expr < expr .)
    ,               reduce using rule 65 (binary_expr -> expr < expr .)
    ]               reduce using rule 65 (binary_expr -> expr < expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 174

    (66) binary_expr -> expr * expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_MORE      reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_MORE_OR_EQ reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_LESS      reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_LESS_OR_EQ reduce using rule 66 (binary_expr -> expr * expr .)
    SOME_SUB        reduce using rule 66 (binary_expr -> expr * expr .)
    SOME_CONCAT     reduce using rule 66 (binary_expr -> expr * expr .)
    ARROW_BOTH      reduce using rule 66 (binary_expr -> expr * expr .)
    ARROW_RIGHT     reduce using rule 66 (binary_expr -> expr * expr .)
    ARROW_LEFT      reduce using rule 66 (binary_expr -> expr * expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 66 (binary_expr -> expr * expr .)
    DOUBLE_ARROW_LEFT reduce using rule 66 (binary_expr -> expr * expr .)
    BIT_SHIFT_LEFT  reduce using rule 66 (binary_expr -> expr * expr .)
    BIT_AND         reduce using rule 66 (binary_expr -> expr * expr .)
    BIT_OR          reduce using rule 66 (binary_expr -> expr * expr .)
    ARRAY_SUB       reduce using rule 66 (binary_expr -> expr * expr .)
    ARRAY_CONCAT    reduce using rule 66 (binary_expr -> expr * expr .)
    MORE_OR_EQ      reduce using rule 66 (binary_expr -> expr * expr .)
    LESS_OR_EQ      reduce using rule 66 (binary_expr -> expr * expr .)
    TEXT_MATCH      reduce using rule 66 (binary_expr -> expr * expr .)
    STRICT_AND      reduce using rule 66 (binary_expr -> expr * expr .)
    AND             reduce using rule 66 (binary_expr -> expr * expr .)
    STRICT_OR       reduce using rule 66 (binary_expr -> expr * expr .)
    OR              reduce using rule 66 (binary_expr -> expr * expr .)
    EQUAL           reduce using rule 66 (binary_expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 66 (binary_expr -> expr * expr .)
    >               reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_MUL       reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_DIV       reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_SUB       reduce using rule 66 (binary_expr -> expr * expr .)
    FLOAT_SUM       reduce using rule 66 (binary_expr -> expr * expr .)
    <               reduce using rule 66 (binary_expr -> expr * expr .)
    *               reduce using rule 66 (binary_expr -> expr * expr .)
    /               reduce using rule 66 (binary_expr -> expr * expr .)
    -               reduce using rule 66 (binary_expr -> expr * expr .)
    +               reduce using rule 66 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 66 (binary_expr -> expr * expr .)
    $end            reduce using rule 66 (binary_expr -> expr * expr .)
    )               reduce using rule 66 (binary_expr -> expr * expr .)
    OF              reduce using rule 66 (binary_expr -> expr * expr .)
    THEN            reduce using rule 66 (binary_expr -> expr * expr .)
    END             reduce using rule 66 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 66 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 66 (binary_expr -> expr * expr .)
    ,               reduce using rule 66 (binary_expr -> expr * expr .)
    ]               reduce using rule 66 (binary_expr -> expr * expr .)
    (               shift and go to state 44
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60


state 175

    (67) binary_expr -> expr / expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_MORE      reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_MORE_OR_EQ reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_LESS      reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_LESS_OR_EQ reduce using rule 67 (binary_expr -> expr / expr .)
    SOME_SUB        reduce using rule 67 (binary_expr -> expr / expr .)
    SOME_CONCAT     reduce using rule 67 (binary_expr -> expr / expr .)
    ARROW_BOTH      reduce using rule 67 (binary_expr -> expr / expr .)
    ARROW_RIGHT     reduce using rule 67 (binary_expr -> expr / expr .)
    ARROW_LEFT      reduce using rule 67 (binary_expr -> expr / expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 67 (binary_expr -> expr / expr .)
    DOUBLE_ARROW_LEFT reduce using rule 67 (binary_expr -> expr / expr .)
    BIT_SHIFT_LEFT  reduce using rule 67 (binary_expr -> expr / expr .)
    BIT_AND         reduce using rule 67 (binary_expr -> expr / expr .)
    BIT_OR          reduce using rule 67 (binary_expr -> expr / expr .)
    ARRAY_SUB       reduce using rule 67 (binary_expr -> expr / expr .)
    ARRAY_CONCAT    reduce using rule 67 (binary_expr -> expr / expr .)
    MORE_OR_EQ      reduce using rule 67 (binary_expr -> expr / expr .)
    LESS_OR_EQ      reduce using rule 67 (binary_expr -> expr / expr .)
    TEXT_MATCH      reduce using rule 67 (binary_expr -> expr / expr .)
    STRICT_AND      reduce using rule 67 (binary_expr -> expr / expr .)
    AND             reduce using rule 67 (binary_expr -> expr / expr .)
    STRICT_OR       reduce using rule 67 (binary_expr -> expr / expr .)
    OR              reduce using rule 67 (binary_expr -> expr / expr .)
    EQUAL           reduce using rule 67 (binary_expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 67 (binary_expr -> expr / expr .)
    >               reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_MUL       reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_DIV       reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_SUB       reduce using rule 67 (binary_expr -> expr / expr .)
    FLOAT_SUM       reduce using rule 67 (binary_expr -> expr / expr .)
    <               reduce using rule 67 (binary_expr -> expr / expr .)
    *               reduce using rule 67 (binary_expr -> expr / expr .)
    /               reduce using rule 67 (binary_expr -> expr / expr .)
    -               reduce using rule 67 (binary_expr -> expr / expr .)
    +               reduce using rule 67 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 67 (binary_expr -> expr / expr .)
    $end            reduce using rule 67 (binary_expr -> expr / expr .)
    )               reduce using rule 67 (binary_expr -> expr / expr .)
    OF              reduce using rule 67 (binary_expr -> expr / expr .)
    THEN            reduce using rule 67 (binary_expr -> expr / expr .)
    END             reduce using rule 67 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 67 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 67 (binary_expr -> expr / expr .)
    ,               reduce using rule 67 (binary_expr -> expr / expr .)
    ]               reduce using rule 67 (binary_expr -> expr / expr .)
    (               shift and go to state 44
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60


state 176

    (68) binary_expr -> expr - expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_MORE      reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_MORE_OR_EQ reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_LESS      reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_LESS_OR_EQ reduce using rule 68 (binary_expr -> expr - expr .)
    SOME_SUB        reduce using rule 68 (binary_expr -> expr - expr .)
    SOME_CONCAT     reduce using rule 68 (binary_expr -> expr - expr .)
    ARROW_BOTH      reduce using rule 68 (binary_expr -> expr - expr .)
    ARROW_RIGHT     reduce using rule 68 (binary_expr -> expr - expr .)
    ARROW_LEFT      reduce using rule 68 (binary_expr -> expr - expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 68 (binary_expr -> expr - expr .)
    DOUBLE_ARROW_LEFT reduce using rule 68 (binary_expr -> expr - expr .)
    BIT_SHIFT_LEFT  reduce using rule 68 (binary_expr -> expr - expr .)
    BIT_AND         reduce using rule 68 (binary_expr -> expr - expr .)
    BIT_OR          reduce using rule 68 (binary_expr -> expr - expr .)
    ARRAY_SUB       reduce using rule 68 (binary_expr -> expr - expr .)
    ARRAY_CONCAT    reduce using rule 68 (binary_expr -> expr - expr .)
    MORE_OR_EQ      reduce using rule 68 (binary_expr -> expr - expr .)
    LESS_OR_EQ      reduce using rule 68 (binary_expr -> expr - expr .)
    TEXT_MATCH      reduce using rule 68 (binary_expr -> expr - expr .)
    STRICT_AND      reduce using rule 68 (binary_expr -> expr - expr .)
    AND             reduce using rule 68 (binary_expr -> expr - expr .)
    STRICT_OR       reduce using rule 68 (binary_expr -> expr - expr .)
    OR              reduce using rule 68 (binary_expr -> expr - expr .)
    EQUAL           reduce using rule 68 (binary_expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 68 (binary_expr -> expr - expr .)
    >               reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_SUB       reduce using rule 68 (binary_expr -> expr - expr .)
    FLOAT_SUM       reduce using rule 68 (binary_expr -> expr - expr .)
    <               reduce using rule 68 (binary_expr -> expr - expr .)
    -               reduce using rule 68 (binary_expr -> expr - expr .)
    +               reduce using rule 68 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 68 (binary_expr -> expr - expr .)
    $end            reduce using rule 68 (binary_expr -> expr - expr .)
    )               reduce using rule 68 (binary_expr -> expr - expr .)
    OF              reduce using rule 68 (binary_expr -> expr - expr .)
    THEN            reduce using rule 68 (binary_expr -> expr - expr .)
    END             reduce using rule 68 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 68 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 68 (binary_expr -> expr - expr .)
    ,               reduce using rule 68 (binary_expr -> expr - expr .)
    ]               reduce using rule 68 (binary_expr -> expr - expr .)
    (               shift and go to state 44
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    *               shift and go to state 78
    /               shift and go to state 79


state 177

    (69) binary_expr -> expr + expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_MORE      reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_MORE_OR_EQ reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_LESS      reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_LESS_OR_EQ reduce using rule 69 (binary_expr -> expr + expr .)
    SOME_SUB        reduce using rule 69 (binary_expr -> expr + expr .)
    SOME_CONCAT     reduce using rule 69 (binary_expr -> expr + expr .)
    ARROW_BOTH      reduce using rule 69 (binary_expr -> expr + expr .)
    ARROW_RIGHT     reduce using rule 69 (binary_expr -> expr + expr .)
    ARROW_LEFT      reduce using rule 69 (binary_expr -> expr + expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 69 (binary_expr -> expr + expr .)
    DOUBLE_ARROW_LEFT reduce using rule 69 (binary_expr -> expr + expr .)
    BIT_SHIFT_LEFT  reduce using rule 69 (binary_expr -> expr + expr .)
    BIT_AND         reduce using rule 69 (binary_expr -> expr + expr .)
    BIT_OR          reduce using rule 69 (binary_expr -> expr + expr .)
    ARRAY_SUB       reduce using rule 69 (binary_expr -> expr + expr .)
    ARRAY_CONCAT    reduce using rule 69 (binary_expr -> expr + expr .)
    MORE_OR_EQ      reduce using rule 69 (binary_expr -> expr + expr .)
    LESS_OR_EQ      reduce using rule 69 (binary_expr -> expr + expr .)
    TEXT_MATCH      reduce using rule 69 (binary_expr -> expr + expr .)
    STRICT_AND      reduce using rule 69 (binary_expr -> expr + expr .)
    AND             reduce using rule 69 (binary_expr -> expr + expr .)
    STRICT_OR       reduce using rule 69 (binary_expr -> expr + expr .)
    OR              reduce using rule 69 (binary_expr -> expr + expr .)
    EQUAL           reduce using rule 69 (binary_expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 69 (binary_expr -> expr + expr .)
    >               reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_SUB       reduce using rule 69 (binary_expr -> expr + expr .)
    FLOAT_SUM       reduce using rule 69 (binary_expr -> expr + expr .)
    <               reduce using rule 69 (binary_expr -> expr + expr .)
    -               reduce using rule 69 (binary_expr -> expr + expr .)
    +               reduce using rule 69 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 69 (binary_expr -> expr + expr .)
    $end            reduce using rule 69 (binary_expr -> expr + expr .)
    )               reduce using rule 69 (binary_expr -> expr + expr .)
    OF              reduce using rule 69 (binary_expr -> expr + expr .)
    THEN            reduce using rule 69 (binary_expr -> expr + expr .)
    END             reduce using rule 69 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 69 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 69 (binary_expr -> expr + expr .)
    ,               reduce using rule 69 (binary_expr -> expr + expr .)
    ]               reduce using rule 69 (binary_expr -> expr + expr .)
    (               shift and go to state 44
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    *               shift and go to state 78
    /               shift and go to state 79


state 178

    (70) binary_expr -> expr CONCAT expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    FLOAT_MORE      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    FLOAT_MORE_OR_EQ reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    FLOAT_LESS      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    FLOAT_LESS_OR_EQ reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ARROW_BOTH      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ARROW_RIGHT     reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ARROW_LEFT      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    DOUBLE_ARROW_RIGHT reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    DOUBLE_ARROW_LEFT reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    BIT_SHIFT_LEFT  reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    BIT_AND         reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    BIT_OR          reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    MORE_OR_EQ      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    LESS_OR_EQ      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    TEXT_MATCH      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    STRICT_AND      reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    AND             reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    STRICT_OR       reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    OR              reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    EQUAL           reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    NOT_EQUAL       reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 70 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 179

    (10) expr -> ( expr ) .
    NEWLINE         reduce using rule 10 (expr -> ( expr ) .)
    (               reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_MORE      reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_MORE_OR_EQ reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_LESS      reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_LESS_OR_EQ reduce using rule 10 (expr -> ( expr ) .)
    SOME_SUB        reduce using rule 10 (expr -> ( expr ) .)
    SOME_CONCAT     reduce using rule 10 (expr -> ( expr ) .)
    ARROW_BOTH      reduce using rule 10 (expr -> ( expr ) .)
    ARROW_RIGHT     reduce using rule 10 (expr -> ( expr ) .)
    ARROW_LEFT      reduce using rule 10 (expr -> ( expr ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 10 (expr -> ( expr ) .)
    DOUBLE_ARROW_LEFT reduce using rule 10 (expr -> ( expr ) .)
    BIT_SHIFT_LEFT  reduce using rule 10 (expr -> ( expr ) .)
    BIT_AND         reduce using rule 10 (expr -> ( expr ) .)
    BIT_OR          reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_POW       reduce using rule 10 (expr -> ( expr ) .)
    POW             reduce using rule 10 (expr -> ( expr ) .)
    ARRAY_SUB       reduce using rule 10 (expr -> ( expr ) .)
    ARRAY_CONCAT    reduce using rule 10 (expr -> ( expr ) .)
    MORE_OR_EQ      reduce using rule 10 (expr -> ( expr ) .)
    LESS_OR_EQ      reduce using rule 10 (expr -> ( expr ) .)
    TEXT_MATCH      reduce using rule 10 (expr -> ( expr ) .)
    STRICT_AND      reduce using rule 10 (expr -> ( expr ) .)
    AND             reduce using rule 10 (expr -> ( expr ) .)
    STRICT_OR       reduce using rule 10 (expr -> ( expr ) .)
    OR              reduce using rule 10 (expr -> ( expr ) .)
    EQUAL           reduce using rule 10 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 10 (expr -> ( expr ) .)
    >               reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_MUL       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_DIV       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_SUB       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_SUM       reduce using rule 10 (expr -> ( expr ) .)
    <               reduce using rule 10 (expr -> ( expr ) .)
    *               reduce using rule 10 (expr -> ( expr ) .)
    /               reduce using rule 10 (expr -> ( expr ) .)
    -               reduce using rule 10 (expr -> ( expr ) .)
    +               reduce using rule 10 (expr -> ( expr ) .)
    CONCAT          reduce using rule 10 (expr -> ( expr ) .)
    $end            reduce using rule 10 (expr -> ( expr ) .)
    )               reduce using rule 10 (expr -> ( expr ) .)
    OF              reduce using rule 10 (expr -> ( expr ) .)
    THEN            reduce using rule 10 (expr -> ( expr ) .)
    END             reduce using rule 10 (expr -> ( expr ) .)
    ELIF            reduce using rule 10 (expr -> ( expr ) .)
    ELSE            reduce using rule 10 (expr -> ( expr ) .)
    ,               reduce using rule 10 (expr -> ( expr ) .)
    ]               reduce using rule 10 (expr -> ( expr ) .)


state 180

    (267) let -> identifier : type_identifier . < type _57_repeat MORE_OR_EQ expr
    (167) type -> type_identifier . < type _26_repeat >
    (173) type -> type_identifier .
    <               shift and go to state 203
    =               reduce using rule 173 (type -> type_identifier .)


state 181

    (274) _58_optional -> : type .
    =               reduce using rule 274 (_58_optional -> : type .)


state 182

    (273) let -> identifier _58_optional = . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    identifier                     shift and go to state 15
    expr                           shift and go to state 204
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 183

    (109) binary_op_def -> DEF binary_op ( . _4_optional param , _5_optional param _6_optional ) _7_optional do
    (110) _4_optional -> . NEWLINE
    (111) _4_optional -> .
    NEWLINE         shift and go to state 206
    IDENTIFIER      reduce using rule 111 (_4_optional -> .)

    _4_optional                    shift and go to state 205

state 184

    (118) binary_op_def -> DEF binary_op < . type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 207

state 185

    (140) def_expr -> DEF identifier ( . _16_optional _17_optional ) _18_optional do
    (141) _16_optional -> . NEWLINE
    (142) _16_optional -> .
    NEWLINE         shift and go to state 209
    IDENTIFIER      reduce using rule 142 (_16_optional -> .)
    )               reduce using rule 142 (_16_optional -> .)

    _16_optional                   shift and go to state 208

state 186

    (147) def_expr -> DEF identifier < . type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 210

state 187

    (252) variant_call -> type_identifier ( _52_optional . _53_optional )
    (255) _53_optional -> . exprs
    (256) _53_optional -> .
    (257) exprs -> . expr _54_optional
    (260) exprs -> . exprs , _55_optional expr _56_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 256 (_53_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 26
    _53_optional                   shift and go to state 211
    exprs                          shift and go to state 212
    expr                           shift and go to state 191
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 188

    (253) _52_optional -> NEWLINE .
    (               reduce using rule 253 (_52_optional -> NEWLINE .)
    DEF             reduce using rule 253 (_52_optional -> NEWLINE .)
    +               reduce using rule 253 (_52_optional -> NEWLINE .)
    !               reduce using rule 253 (_52_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 253 (_52_optional -> NEWLINE .)
    -               reduce using rule 253 (_52_optional -> NEWLINE .)
    STRING          reduce using rule 253 (_52_optional -> NEWLINE .)
    FLOAT           reduce using rule 253 (_52_optional -> NEWLINE .)
    INT             reduce using rule 253 (_52_optional -> NEWLINE .)
    [               reduce using rule 253 (_52_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 253 (_52_optional -> NEWLINE .)
    CASE            reduce using rule 253 (_52_optional -> NEWLINE .)
    IF              reduce using rule 253 (_52_optional -> NEWLINE .)
    DO              reduce using rule 253 (_52_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 253 (_52_optional -> NEWLINE .)
    ENUM            reduce using rule 253 (_52_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 253 (_52_optional -> NEWLINE .)
    )               reduce using rule 253 (_52_optional -> NEWLINE .)


state 189

    (242) array -> [ _48_optional _49_optional . ]
    ]               shift and go to state 213


state 190

    (245) _49_optional -> exprs .
    (260) exprs -> exprs . , _55_optional expr _56_optional
    ]               reduce using rule 245 (_49_optional -> exprs .)
    ,               shift and go to state 214


state 191

    (257) exprs -> expr . _54_optional
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    (258) _54_optional -> . NEWLINE
    (259) _54_optional -> .
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82
    NEWLINE         shift and go to state 216
    ,               reduce using rule 259 (_54_optional -> .)
    ]               reduce using rule 259 (_54_optional -> .)
    )               reduce using rule 259 (_54_optional -> .)

    _54_optional                   shift and go to state 215

state 192

    (214) case_of -> CASE expr OF . _39_optional _40_optional END
    (215) _39_optional -> . NEWLINE
    (216) _39_optional -> .
    NEWLINE         shift and go to state 218
    TYPE_IDENTIFIER reduce using rule 216 (_39_optional -> .)
    IDENTIFIER      reduce using rule 216 (_39_optional -> .)
    END             reduce using rule 216 (_39_optional -> .)

    _39_optional                   shift and go to state 217

state 193

    (205) if_expr -> IF expr THEN . _36_optional block_statement _37_optional END
    (206) _36_optional -> . : type
    (207) _36_optional -> .
    :               shift and go to state 220
    NEWLINE         reduce using rule 207 (_36_optional -> .)
    ELIF            reduce using rule 207 (_36_optional -> .)
    ELSE            reduce using rule 207 (_36_optional -> .)
    END             reduce using rule 207 (_36_optional -> .)
    (               reduce using rule 207 (_36_optional -> .)
    DEF             reduce using rule 207 (_36_optional -> .)
    +               reduce using rule 207 (_36_optional -> .)
    !               reduce using rule 207 (_36_optional -> .)
    STRICT_NOT      reduce using rule 207 (_36_optional -> .)
    -               reduce using rule 207 (_36_optional -> .)
    STRING          reduce using rule 207 (_36_optional -> .)
    FLOAT           reduce using rule 207 (_36_optional -> .)
    INT             reduce using rule 207 (_36_optional -> .)
    [               reduce using rule 207 (_36_optional -> .)
    IDENTIFIER      reduce using rule 207 (_36_optional -> .)
    CASE            reduce using rule 207 (_36_optional -> .)
    IF              reduce using rule 207 (_36_optional -> .)
    DO              reduce using rule 207 (_36_optional -> .)
    EXTERNAL        reduce using rule 207 (_36_optional -> .)
    ENUM            reduce using rule 207 (_36_optional -> .)
    TYPE_IDENTIFIER reduce using rule 207 (_36_optional -> .)

    _36_optional                   shift and go to state 219

state 194

    (132) do -> DO _13_optional block_statement . END
    END             shift and go to state 221


state 195

    (135) block_statement -> _14_optional . _15_optional
    (138) _15_optional -> . do_exprs
    (139) _15_optional -> .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 139 (_15_optional -> .)
    ELIF            reduce using rule 139 (_15_optional -> .)
    ELSE            reduce using rule 139 (_15_optional -> .)
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    _15_optional                   shift and go to state 222
    do_exprs                       shift and go to state 223
    expr                           shift and go to state 6
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 196

    (136) _14_optional -> NEWLINE .
    (               reduce using rule 136 (_14_optional -> NEWLINE .)
    DEF             reduce using rule 136 (_14_optional -> NEWLINE .)
    +               reduce using rule 136 (_14_optional -> NEWLINE .)
    !               reduce using rule 136 (_14_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 136 (_14_optional -> NEWLINE .)
    -               reduce using rule 136 (_14_optional -> NEWLINE .)
    STRING          reduce using rule 136 (_14_optional -> NEWLINE .)
    FLOAT           reduce using rule 136 (_14_optional -> NEWLINE .)
    INT             reduce using rule 136 (_14_optional -> NEWLINE .)
    [               reduce using rule 136 (_14_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 136 (_14_optional -> NEWLINE .)
    CASE            reduce using rule 136 (_14_optional -> NEWLINE .)
    IF              reduce using rule 136 (_14_optional -> NEWLINE .)
    DO              reduce using rule 136 (_14_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 136 (_14_optional -> NEWLINE .)
    ENUM            reduce using rule 136 (_14_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 136 (_14_optional -> NEWLINE .)
    END             reduce using rule 136 (_14_optional -> NEWLINE .)
    ELIF            reduce using rule 136 (_14_optional -> NEWLINE .)
    ELSE            reduce using rule 136 (_14_optional -> NEWLINE .)


state 197

    (133) _13_optional -> : type .
    NEWLINE         reduce using rule 133 (_13_optional -> : type .)
    END             reduce using rule 133 (_13_optional -> : type .)
    (               reduce using rule 133 (_13_optional -> : type .)
    DEF             reduce using rule 133 (_13_optional -> : type .)
    +               reduce using rule 133 (_13_optional -> : type .)
    !               reduce using rule 133 (_13_optional -> : type .)
    STRICT_NOT      reduce using rule 133 (_13_optional -> : type .)
    -               reduce using rule 133 (_13_optional -> : type .)
    STRING          reduce using rule 133 (_13_optional -> : type .)
    FLOAT           reduce using rule 133 (_13_optional -> : type .)
    INT             reduce using rule 133 (_13_optional -> : type .)
    [               reduce using rule 133 (_13_optional -> : type .)
    IDENTIFIER      reduce using rule 133 (_13_optional -> : type .)
    CASE            reduce using rule 133 (_13_optional -> : type .)
    IF              reduce using rule 133 (_13_optional -> : type .)
    DO              reduce using rule 133 (_13_optional -> : type .)
    EXTERNAL        reduce using rule 133 (_13_optional -> : type .)
    ENUM            reduce using rule 133 (_13_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 133 (_13_optional -> : type .)


state 198

    (167) type -> type_identifier . < type _26_repeat >
    (173) type -> type_identifier .
    <               shift and go to state 224
    NEWLINE         reduce using rule 173 (type -> type_identifier .)
    END             reduce using rule 173 (type -> type_identifier .)
    (               reduce using rule 173 (type -> type_identifier .)
    DEF             reduce using rule 173 (type -> type_identifier .)
    +               reduce using rule 173 (type -> type_identifier .)
    !               reduce using rule 173 (type -> type_identifier .)
    STRICT_NOT      reduce using rule 173 (type -> type_identifier .)
    -               reduce using rule 173 (type -> type_identifier .)
    STRING          reduce using rule 173 (type -> type_identifier .)
    FLOAT           reduce using rule 173 (type -> type_identifier .)
    INT             reduce using rule 173 (type -> type_identifier .)
    [               reduce using rule 173 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 173 (type -> type_identifier .)
    CASE            reduce using rule 173 (type -> type_identifier .)
    IF              reduce using rule 173 (type -> type_identifier .)
    DO              reduce using rule 173 (type -> type_identifier .)
    EXTERNAL        reduce using rule 173 (type -> type_identifier .)
    ENUM            reduce using rule 173 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 173 (type -> type_identifier .)
    ,               reduce using rule 173 (type -> type_identifier .)
    MORE_OR_EQ      reduce using rule 173 (type -> type_identifier .)
    >               reduce using rule 173 (type -> type_identifier .)
    ELIF            reduce using rule 173 (type -> type_identifier .)
    ELSE            reduce using rule 173 (type -> type_identifier .)
    )               reduce using rule 173 (type -> type_identifier .)


state 199

    (174) enum -> ENUM type_identifier { . _27_optional _28_optional }
    (175) _27_optional -> . NEWLINE
    (176) _27_optional -> .
    NEWLINE         shift and go to state 226
    TYPE_IDENTIFIER reduce using rule 176 (_27_optional -> .)
    }               reduce using rule 176 (_27_optional -> .)

    _27_optional                   shift and go to state 225

state 200

    (179) enum -> ENUM type_identifier < . type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 227

state 201

    (247) call -> expr ( _50_optional _51_optional . )
    )               shift and go to state 228


state 202

    (250) _51_optional -> exprs .
    (260) exprs -> exprs . , _55_optional expr _56_optional
    )               reduce using rule 250 (_51_optional -> exprs .)
    ,               shift and go to state 214


state 203

    (267) let -> identifier : type_identifier < . type _57_repeat MORE_OR_EQ expr
    (167) type -> type_identifier < . type _26_repeat >
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 198
    type                           shift and go to state 229

state 204

    (273) let -> identifier _58_optional = expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 273 (let -> identifier _58_optional = expr .)
    FLOAT_MORE      reduce using rule 273 (let -> identifier _58_optional = expr .)
    FLOAT_MORE_OR_EQ reduce using rule 273 (let -> identifier _58_optional = expr .)
    FLOAT_LESS      reduce using rule 273 (let -> identifier _58_optional = expr .)
    FLOAT_LESS_OR_EQ reduce using rule 273 (let -> identifier _58_optional = expr .)
    $end            reduce using rule 273 (let -> identifier _58_optional = expr .)
    )               reduce using rule 273 (let -> identifier _58_optional = expr .)
    OF              reduce using rule 273 (let -> identifier _58_optional = expr .)
    THEN            reduce using rule 273 (let -> identifier _58_optional = expr .)
    END             reduce using rule 273 (let -> identifier _58_optional = expr .)
    ELIF            reduce using rule 273 (let -> identifier _58_optional = expr .)
    ELSE            reduce using rule 273 (let -> identifier _58_optional = expr .)
    ,               reduce using rule 273 (let -> identifier _58_optional = expr .)
    ]               reduce using rule 273 (let -> identifier _58_optional = expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 205

    (109) binary_op_def -> DEF binary_op ( _4_optional . param , _5_optional param _6_optional ) _7_optional do
    (202) param -> . identifier _35_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 230
    identifier                     shift and go to state 231

state 206

    (110) _4_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 110 (_4_optional -> NEWLINE .)


state 207

    (118) binary_op_def -> DEF binary_op < type_identifier . _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (119) _8_repeat -> . _8_items
    (120) _8_repeat -> .
    (121) _8_items -> . _8_items _8_item
    (122) _8_items -> . _8_item
    (123) _8_item -> . , type_identifier
    >               reduce using rule 120 (_8_repeat -> .)
    ,               shift and go to state 233

    _8_repeat                      shift and go to state 232
    _8_items                       shift and go to state 234
    _8_item                        shift and go to state 235

state 208

    (140) def_expr -> DEF identifier ( _16_optional . _17_optional ) _18_optional do
    (143) _17_optional -> . params
    (144) _17_optional -> .
    (159) params -> . param _23_optional
    (162) params -> . params , _24_optional param _25_optional
    (202) param -> . identifier _35_optional
    (265) identifier -> . IDENTIFIER
    )               reduce using rule 144 (_17_optional -> .)
    IDENTIFIER      shift and go to state 35

    identifier                     shift and go to state 231
    _17_optional                   shift and go to state 236
    params                         shift and go to state 237
    param                          shift and go to state 238

state 209

    (141) _16_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 141 (_16_optional -> NEWLINE .)
    )               reduce using rule 141 (_16_optional -> NEWLINE .)


state 210

    (147) def_expr -> DEF identifier < type_identifier . _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (148) _19_repeat -> . _19_items
    (149) _19_repeat -> .
    (150) _19_items -> . _19_items _19_item
    (151) _19_items -> . _19_item
    (152) _19_item -> . , type_identifier
    >               reduce using rule 149 (_19_repeat -> .)
    ,               shift and go to state 242

    _19_repeat                     shift and go to state 239
    _19_items                      shift and go to state 240
    _19_item                       shift and go to state 241

state 211

    (252) variant_call -> type_identifier ( _52_optional _53_optional . )
    )               shift and go to state 243


state 212

    (255) _53_optional -> exprs .
    (260) exprs -> exprs . , _55_optional expr _56_optional
    )               reduce using rule 255 (_53_optional -> exprs .)
    ,               shift and go to state 214


state 213

    (242) array -> [ _48_optional _49_optional ] .
    NEWLINE         reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    (               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_MORE      reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_MORE_OR_EQ reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_LESS      reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_LESS_OR_EQ reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    SOME_SUB        reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    SOME_CONCAT     reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ARROW_BOTH      reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ARROW_RIGHT     reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ARROW_LEFT      reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    DOUBLE_ARROW_RIGHT reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    DOUBLE_ARROW_LEFT reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    BIT_SHIFT_LEFT  reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    BIT_AND         reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    BIT_OR          reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_POW       reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    POW             reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ARRAY_SUB       reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ARRAY_CONCAT    reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    MORE_OR_EQ      reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    LESS_OR_EQ      reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    TEXT_MATCH      reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    STRICT_AND      reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    AND             reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    STRICT_OR       reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    OR              reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    EQUAL           reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    NOT_EQUAL       reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    >               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_MUL       reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_DIV       reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_SUB       reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    FLOAT_SUM       reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    <               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    *               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    /               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    -               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    +               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    CONCAT          reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    $end            reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    )               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    OF              reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    THEN            reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    END             reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ELIF            reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ELSE            reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ,               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)
    ]               reduce using rule 242 (array -> [ _48_optional _49_optional ] .)


state 214

    (260) exprs -> exprs , . _55_optional expr _56_optional
    (261) _55_optional -> . NEWLINE
    (262) _55_optional -> .
    NEWLINE         shift and go to state 245
    (               reduce using rule 262 (_55_optional -> .)
    DEF             reduce using rule 262 (_55_optional -> .)
    +               reduce using rule 262 (_55_optional -> .)
    !               reduce using rule 262 (_55_optional -> .)
    STRICT_NOT      reduce using rule 262 (_55_optional -> .)
    -               reduce using rule 262 (_55_optional -> .)
    STRING          reduce using rule 262 (_55_optional -> .)
    FLOAT           reduce using rule 262 (_55_optional -> .)
    INT             reduce using rule 262 (_55_optional -> .)
    [               reduce using rule 262 (_55_optional -> .)
    IDENTIFIER      reduce using rule 262 (_55_optional -> .)
    CASE            reduce using rule 262 (_55_optional -> .)
    IF              reduce using rule 262 (_55_optional -> .)
    DO              reduce using rule 262 (_55_optional -> .)
    EXTERNAL        reduce using rule 262 (_55_optional -> .)
    ENUM            reduce using rule 262 (_55_optional -> .)
    TYPE_IDENTIFIER reduce using rule 262 (_55_optional -> .)

    _55_optional                   shift and go to state 244

state 215

    (257) exprs -> expr _54_optional .
    ,               reduce using rule 257 (exprs -> expr _54_optional .)
    ]               reduce using rule 257 (exprs -> expr _54_optional .)
    )               reduce using rule 257 (exprs -> expr _54_optional .)


state 216

    (258) _54_optional -> NEWLINE .
    ,               reduce using rule 258 (_54_optional -> NEWLINE .)
    ]               reduce using rule 258 (_54_optional -> NEWLINE .)
    )               reduce using rule 258 (_54_optional -> NEWLINE .)


state 217

    (214) case_of -> CASE expr OF _39_optional . _40_optional END
    (217) _40_optional -> . cases
    (218) _40_optional -> .
    (219) cases -> . pattern do _41_optional
    (222) cases -> . cases pattern do _42_optional
    (225) pattern -> . match_variant
    (226) pattern -> . match_as
    (228) match_variant -> . type_identifier
    (229) match_variant -> . type_identifier ( _43_optional _44_optional )
    (227) match_as -> . identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    (265) identifier -> . IDENTIFIER
    END             reduce using rule 218 (_40_optional -> .)
    TYPE_IDENTIFIER shift and go to state 41
    IDENTIFIER      shift and go to state 35

    _40_optional                   shift and go to state 246
    cases                          shift and go to state 247
    pattern                        shift and go to state 248
    match_variant                  shift and go to state 249
    match_as                       shift and go to state 250
    type_identifier                shift and go to state 251
    identifier                     shift and go to state 252

state 218

    (215) _39_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 215 (_39_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 215 (_39_optional -> NEWLINE .)
    END             reduce using rule 215 (_39_optional -> NEWLINE .)


state 219

    (205) if_expr -> IF expr THEN _36_optional . block_statement _37_optional END
    (135) block_statement -> . _14_optional _15_optional
    (136) _14_optional -> . NEWLINE
    (137) _14_optional -> .
    NEWLINE         shift and go to state 196
    (               reduce using rule 137 (_14_optional -> .)
    DEF             reduce using rule 137 (_14_optional -> .)
    +               reduce using rule 137 (_14_optional -> .)
    !               reduce using rule 137 (_14_optional -> .)
    STRICT_NOT      reduce using rule 137 (_14_optional -> .)
    -               reduce using rule 137 (_14_optional -> .)
    STRING          reduce using rule 137 (_14_optional -> .)
    FLOAT           reduce using rule 137 (_14_optional -> .)
    INT             reduce using rule 137 (_14_optional -> .)
    [               reduce using rule 137 (_14_optional -> .)
    IDENTIFIER      reduce using rule 137 (_14_optional -> .)
    CASE            reduce using rule 137 (_14_optional -> .)
    IF              reduce using rule 137 (_14_optional -> .)
    DO              reduce using rule 137 (_14_optional -> .)
    EXTERNAL        reduce using rule 137 (_14_optional -> .)
    ENUM            reduce using rule 137 (_14_optional -> .)
    TYPE_IDENTIFIER reduce using rule 137 (_14_optional -> .)
    ELIF            reduce using rule 137 (_14_optional -> .)
    ELSE            reduce using rule 137 (_14_optional -> .)
    END             reduce using rule 137 (_14_optional -> .)

    block_statement                shift and go to state 253
    _14_optional                   shift and go to state 195

state 220

    (206) _36_optional -> : . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 254
    type_identifier                shift and go to state 198

state 221

    (132) do -> DO _13_optional block_statement END .
    NEWLINE         reduce using rule 132 (do -> DO _13_optional block_statement END .)
    (               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_MORE      reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_MORE_OR_EQ reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_LESS      reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_LESS_OR_EQ reduce using rule 132 (do -> DO _13_optional block_statement END .)
    SOME_SUB        reduce using rule 132 (do -> DO _13_optional block_statement END .)
    SOME_CONCAT     reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ARROW_BOTH      reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ARROW_RIGHT     reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ARROW_LEFT      reduce using rule 132 (do -> DO _13_optional block_statement END .)
    DOUBLE_ARROW_RIGHT reduce using rule 132 (do -> DO _13_optional block_statement END .)
    DOUBLE_ARROW_LEFT reduce using rule 132 (do -> DO _13_optional block_statement END .)
    BIT_SHIFT_LEFT  reduce using rule 132 (do -> DO _13_optional block_statement END .)
    BIT_AND         reduce using rule 132 (do -> DO _13_optional block_statement END .)
    BIT_OR          reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_POW       reduce using rule 132 (do -> DO _13_optional block_statement END .)
    POW             reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ARRAY_SUB       reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ARRAY_CONCAT    reduce using rule 132 (do -> DO _13_optional block_statement END .)
    MORE_OR_EQ      reduce using rule 132 (do -> DO _13_optional block_statement END .)
    LESS_OR_EQ      reduce using rule 132 (do -> DO _13_optional block_statement END .)
    TEXT_MATCH      reduce using rule 132 (do -> DO _13_optional block_statement END .)
    STRICT_AND      reduce using rule 132 (do -> DO _13_optional block_statement END .)
    AND             reduce using rule 132 (do -> DO _13_optional block_statement END .)
    STRICT_OR       reduce using rule 132 (do -> DO _13_optional block_statement END .)
    OR              reduce using rule 132 (do -> DO _13_optional block_statement END .)
    EQUAL           reduce using rule 132 (do -> DO _13_optional block_statement END .)
    NOT_EQUAL       reduce using rule 132 (do -> DO _13_optional block_statement END .)
    >               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_MUL       reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_DIV       reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_SUB       reduce using rule 132 (do -> DO _13_optional block_statement END .)
    FLOAT_SUM       reduce using rule 132 (do -> DO _13_optional block_statement END .)
    <               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    *               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    /               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    -               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    +               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    CONCAT          reduce using rule 132 (do -> DO _13_optional block_statement END .)
    $end            reduce using rule 132 (do -> DO _13_optional block_statement END .)
    )               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    OF              reduce using rule 132 (do -> DO _13_optional block_statement END .)
    THEN            reduce using rule 132 (do -> DO _13_optional block_statement END .)
    END             reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ELIF            reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ELSE            reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ,               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    ]               reduce using rule 132 (do -> DO _13_optional block_statement END .)
    TYPE_IDENTIFIER reduce using rule 132 (do -> DO _13_optional block_statement END .)
    IDENTIFIER      reduce using rule 132 (do -> DO _13_optional block_statement END .)


state 222

    (135) block_statement -> _14_optional _15_optional .
    END             reduce using rule 135 (block_statement -> _14_optional _15_optional .)
    ELIF            reduce using rule 135 (block_statement -> _14_optional _15_optional .)
    ELSE            reduce using rule 135 (block_statement -> _14_optional _15_optional .)


state 223

    (138) _15_optional -> do_exprs .
    END             reduce using rule 138 (_15_optional -> do_exprs .)
    ELIF            reduce using rule 138 (_15_optional -> do_exprs .)
    ELSE            reduce using rule 138 (_15_optional -> do_exprs .)


state 224

    (167) type -> type_identifier < . type _26_repeat >
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 198
    type                           shift and go to state 255

state 225

    (174) enum -> ENUM type_identifier { _27_optional . _28_optional }
    (177) _28_optional -> . variants
    (178) _28_optional -> .
    (189) variants -> . variant _32_optional
    (192) variants -> . variants variant _33_optional
    (195) variant -> . type_identifier
    (196) variant -> . type_identifier ( type _34_repeat )
    (266) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 178 (_28_optional -> .)
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 256
    _28_optional                   shift and go to state 257
    variants                       shift and go to state 258
    variant                        shift and go to state 259

state 226

    (175) _27_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 175 (_27_optional -> NEWLINE .)
    }               reduce using rule 175 (_27_optional -> NEWLINE .)


state 227

    (179) enum -> ENUM type_identifier < type_identifier . _29_repeat > { _30_optional _31_optional }
    (180) _29_repeat -> . _29_items
    (181) _29_repeat -> .
    (182) _29_items -> . _29_items _29_item
    (183) _29_items -> . _29_item
    (184) _29_item -> . , type_identifier
    >               reduce using rule 181 (_29_repeat -> .)
    ,               shift and go to state 263

    _29_repeat                     shift and go to state 260
    _29_items                      shift and go to state 261
    _29_item                       shift and go to state 262

state 228

    (247) call -> expr ( _50_optional _51_optional ) .
    NEWLINE         reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    (               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_MORE      reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_MORE_OR_EQ reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_LESS      reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_LESS_OR_EQ reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    SOME_SUB        reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    SOME_CONCAT     reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ARROW_BOTH      reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ARROW_RIGHT     reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ARROW_LEFT      reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    DOUBLE_ARROW_LEFT reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    BIT_SHIFT_LEFT  reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    BIT_AND         reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    BIT_OR          reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_POW       reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    POW             reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ARRAY_SUB       reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ARRAY_CONCAT    reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    MORE_OR_EQ      reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    LESS_OR_EQ      reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    TEXT_MATCH      reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    STRICT_AND      reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    AND             reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    STRICT_OR       reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    OR              reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    EQUAL           reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    NOT_EQUAL       reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    >               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_MUL       reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_DIV       reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_SUB       reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    FLOAT_SUM       reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    <               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    *               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    /               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    -               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    +               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    CONCAT          reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    $end            reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    )               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    OF              reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    THEN            reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    END             reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ELIF            reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ELSE            reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ,               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)
    ]               reduce using rule 247 (call -> expr ( _50_optional _51_optional ) .)


state 229

    (267) let -> identifier : type_identifier < type . _57_repeat MORE_OR_EQ expr
    (167) type -> type_identifier < type . _26_repeat >
    (268) _57_repeat -> . _57_items
    (269) _57_repeat -> .
    (168) _26_repeat -> . _26_items
    (169) _26_repeat -> .
    (270) _57_items -> . _57_items _57_item
    (271) _57_items -> . _57_item
    (170) _26_items -> . _26_items _26_item
    (171) _26_items -> . _26_item
    (272) _57_item -> . , type
    (172) _26_item -> . , type
    MORE_OR_EQ      reduce using rule 269 (_57_repeat -> .)
    >               reduce using rule 169 (_26_repeat -> .)
    ,               shift and go to state 270

    _57_repeat                     shift and go to state 264
    _26_repeat                     shift and go to state 265
    _57_items                      shift and go to state 266
    _26_items                      shift and go to state 267
    _57_item                       shift and go to state 268
    _26_item                       shift and go to state 269

state 230

    (109) binary_op_def -> DEF binary_op ( _4_optional param . , _5_optional param _6_optional ) _7_optional do
    ,               shift and go to state 271


state 231

    (202) param -> identifier . _35_optional
    (203) _35_optional -> . : type
    (204) _35_optional -> .
    :               shift and go to state 273
    ,               reduce using rule 204 (_35_optional -> .)
    NEWLINE         reduce using rule 204 (_35_optional -> .)
    )               reduce using rule 204 (_35_optional -> .)

    _35_optional                   shift and go to state 272

state 232

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat . > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    >               shift and go to state 274


state 233

    (123) _8_item -> , . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 275

state 234

    (119) _8_repeat -> _8_items .
    (121) _8_items -> _8_items . _8_item
    (123) _8_item -> . , type_identifier
    >               reduce using rule 119 (_8_repeat -> _8_items .)
    ,               shift and go to state 233

    _8_item                        shift and go to state 276

state 235

    (122) _8_items -> _8_item .
    ,               reduce using rule 122 (_8_items -> _8_item .)
    >               reduce using rule 122 (_8_items -> _8_item .)


state 236

    (140) def_expr -> DEF identifier ( _16_optional _17_optional . ) _18_optional do
    )               shift and go to state 277


state 237

    (143) _17_optional -> params .
    (162) params -> params . , _24_optional param _25_optional
    )               reduce using rule 143 (_17_optional -> params .)
    ,               shift and go to state 278


state 238

    (159) params -> param . _23_optional
    (160) _23_optional -> . NEWLINE
    (161) _23_optional -> .
    NEWLINE         shift and go to state 280
    ,               reduce using rule 161 (_23_optional -> .)
    )               reduce using rule 161 (_23_optional -> .)

    _23_optional                   shift and go to state 279

state 239

    (147) def_expr -> DEF identifier < type_identifier _19_repeat . > ( _20_optional _21_optional ) _22_optional do
    >               shift and go to state 281


state 240

    (148) _19_repeat -> _19_items .
    (150) _19_items -> _19_items . _19_item
    (152) _19_item -> . , type_identifier
    >               reduce using rule 148 (_19_repeat -> _19_items .)
    ,               shift and go to state 242

    _19_item                       shift and go to state 282

state 241

    (151) _19_items -> _19_item .
    ,               reduce using rule 151 (_19_items -> _19_item .)
    >               reduce using rule 151 (_19_items -> _19_item .)


state 242

    (152) _19_item -> , . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 283

state 243

    (252) variant_call -> type_identifier ( _52_optional _53_optional ) .
    NEWLINE         reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    (               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_MORE      reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_MORE_OR_EQ reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_LESS      reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_LESS_OR_EQ reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    SOME_SUB        reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    SOME_CONCAT     reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ARROW_BOTH      reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ARROW_RIGHT     reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ARROW_LEFT      reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    DOUBLE_ARROW_RIGHT reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    DOUBLE_ARROW_LEFT reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    BIT_SHIFT_LEFT  reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    BIT_AND         reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    BIT_OR          reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_POW       reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    POW             reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ARRAY_SUB       reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ARRAY_CONCAT    reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    MORE_OR_EQ      reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    LESS_OR_EQ      reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    TEXT_MATCH      reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    STRICT_AND      reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    AND             reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    STRICT_OR       reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    OR              reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    EQUAL           reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    NOT_EQUAL       reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    >               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_MUL       reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_DIV       reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_SUB       reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    FLOAT_SUM       reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    <               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    *               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    /               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    -               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    +               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    CONCAT          reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    $end            reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    )               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    OF              reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    THEN            reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    END             reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ELIF            reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ELSE            reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ,               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)
    ]               reduce using rule 252 (variant_call -> type_identifier ( _52_optional _53_optional ) .)


state 244

    (260) exprs -> exprs , _55_optional . expr _56_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 284
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 245

    (261) _55_optional -> NEWLINE .
    (               reduce using rule 261 (_55_optional -> NEWLINE .)
    DEF             reduce using rule 261 (_55_optional -> NEWLINE .)
    +               reduce using rule 261 (_55_optional -> NEWLINE .)
    !               reduce using rule 261 (_55_optional -> NEWLINE .)
    STRICT_NOT      reduce using rule 261 (_55_optional -> NEWLINE .)
    -               reduce using rule 261 (_55_optional -> NEWLINE .)
    STRING          reduce using rule 261 (_55_optional -> NEWLINE .)
    FLOAT           reduce using rule 261 (_55_optional -> NEWLINE .)
    INT             reduce using rule 261 (_55_optional -> NEWLINE .)
    [               reduce using rule 261 (_55_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 261 (_55_optional -> NEWLINE .)
    CASE            reduce using rule 261 (_55_optional -> NEWLINE .)
    IF              reduce using rule 261 (_55_optional -> NEWLINE .)
    DO              reduce using rule 261 (_55_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 261 (_55_optional -> NEWLINE .)
    ENUM            reduce using rule 261 (_55_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 261 (_55_optional -> NEWLINE .)


state 246

    (214) case_of -> CASE expr OF _39_optional _40_optional . END
    END             shift and go to state 285


state 247

    (217) _40_optional -> cases .
    (222) cases -> cases . pattern do _42_optional
    (225) pattern -> . match_variant
    (226) pattern -> . match_as
    (228) match_variant -> . type_identifier
    (229) match_variant -> . type_identifier ( _43_optional _44_optional )
    (227) match_as -> . identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    (265) identifier -> . IDENTIFIER
    END             reduce using rule 217 (_40_optional -> cases .)
    TYPE_IDENTIFIER shift and go to state 41
    IDENTIFIER      shift and go to state 35

    pattern                        shift and go to state 286
    match_variant                  shift and go to state 249
    match_as                       shift and go to state 250
    type_identifier                shift and go to state 251
    identifier                     shift and go to state 252

state 248

    (219) cases -> pattern . do _41_optional
    (132) do -> . DO _13_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 287

state 249

    (225) pattern -> match_variant .
    DO              reduce using rule 225 (pattern -> match_variant .)
    NEWLINE         reduce using rule 225 (pattern -> match_variant .)
    ,               reduce using rule 225 (pattern -> match_variant .)
    )               reduce using rule 225 (pattern -> match_variant .)


state 250

    (226) pattern -> match_as .
    DO              reduce using rule 226 (pattern -> match_as .)
    NEWLINE         reduce using rule 226 (pattern -> match_as .)
    ,               reduce using rule 226 (pattern -> match_as .)
    )               reduce using rule 226 (pattern -> match_as .)


state 251

    (228) match_variant -> type_identifier .
    (229) match_variant -> type_identifier . ( _43_optional _44_optional )
    DO              reduce using rule 228 (match_variant -> type_identifier .)
    NEWLINE         reduce using rule 228 (match_variant -> type_identifier .)
    ,               reduce using rule 228 (match_variant -> type_identifier .)
    )               reduce using rule 228 (match_variant -> type_identifier .)
    (               shift and go to state 288


state 252

    (227) match_as -> identifier .
    DO              reduce using rule 227 (match_as -> identifier .)
    NEWLINE         reduce using rule 227 (match_as -> identifier .)
    ,               reduce using rule 227 (match_as -> identifier .)
    )               reduce using rule 227 (match_as -> identifier .)


state 253

    (205) if_expr -> IF expr THEN _36_optional block_statement . _37_optional END
    (208) _37_optional -> . or_else
    (209) _37_optional -> .
    (210) or_else -> . ELIF expr THEN block_statement _38_optional
    (213) or_else -> . ELSE block_statement
    END             reduce using rule 209 (_37_optional -> .)
    ELIF            shift and go to state 291
    ELSE            shift and go to state 292

    _37_optional                   shift and go to state 289
    or_else                        shift and go to state 290

state 254

    (206) _36_optional -> : type .
    NEWLINE         reduce using rule 206 (_36_optional -> : type .)
    ELIF            reduce using rule 206 (_36_optional -> : type .)
    ELSE            reduce using rule 206 (_36_optional -> : type .)
    END             reduce using rule 206 (_36_optional -> : type .)
    (               reduce using rule 206 (_36_optional -> : type .)
    DEF             reduce using rule 206 (_36_optional -> : type .)
    +               reduce using rule 206 (_36_optional -> : type .)
    !               reduce using rule 206 (_36_optional -> : type .)
    STRICT_NOT      reduce using rule 206 (_36_optional -> : type .)
    -               reduce using rule 206 (_36_optional -> : type .)
    STRING          reduce using rule 206 (_36_optional -> : type .)
    FLOAT           reduce using rule 206 (_36_optional -> : type .)
    INT             reduce using rule 206 (_36_optional -> : type .)
    [               reduce using rule 206 (_36_optional -> : type .)
    IDENTIFIER      reduce using rule 206 (_36_optional -> : type .)
    CASE            reduce using rule 206 (_36_optional -> : type .)
    IF              reduce using rule 206 (_36_optional -> : type .)
    DO              reduce using rule 206 (_36_optional -> : type .)
    EXTERNAL        reduce using rule 206 (_36_optional -> : type .)
    ENUM            reduce using rule 206 (_36_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 206 (_36_optional -> : type .)


state 255

    (167) type -> type_identifier < type . _26_repeat >
    (168) _26_repeat -> . _26_items
    (169) _26_repeat -> .
    (170) _26_items -> . _26_items _26_item
    (171) _26_items -> . _26_item
    (172) _26_item -> . , type
    >               reduce using rule 169 (_26_repeat -> .)
    ,               shift and go to state 293

    _26_repeat                     shift and go to state 265
    _26_items                      shift and go to state 267
    _26_item                       shift and go to state 269

state 256

    (195) variant -> type_identifier .
    (196) variant -> type_identifier . ( type _34_repeat )
    NEWLINE         reduce using rule 195 (variant -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 195 (variant -> type_identifier .)
    }               reduce using rule 195 (variant -> type_identifier .)
    (               shift and go to state 294


state 257

    (174) enum -> ENUM type_identifier { _27_optional _28_optional . }
    }               shift and go to state 295


state 258

    (177) _28_optional -> variants .
    (192) variants -> variants . variant _33_optional
    (195) variant -> . type_identifier
    (196) variant -> . type_identifier ( type _34_repeat )
    (266) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 177 (_28_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 41

    variant                        shift and go to state 296
    type_identifier                shift and go to state 256

state 259

    (189) variants -> variant . _32_optional
    (190) _32_optional -> . NEWLINE
    (191) _32_optional -> .
    NEWLINE         shift and go to state 298
    TYPE_IDENTIFIER reduce using rule 191 (_32_optional -> .)
    }               reduce using rule 191 (_32_optional -> .)

    _32_optional                   shift and go to state 297

state 260

    (179) enum -> ENUM type_identifier < type_identifier _29_repeat . > { _30_optional _31_optional }
    >               shift and go to state 299


state 261

    (180) _29_repeat -> _29_items .
    (182) _29_items -> _29_items . _29_item
    (184) _29_item -> . , type_identifier
    >               reduce using rule 180 (_29_repeat -> _29_items .)
    ,               shift and go to state 263

    _29_item                       shift and go to state 300

state 262

    (183) _29_items -> _29_item .
    ,               reduce using rule 183 (_29_items -> _29_item .)
    >               reduce using rule 183 (_29_items -> _29_item .)


state 263

    (184) _29_item -> , . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 301

state 264

    (267) let -> identifier : type_identifier < type _57_repeat . MORE_OR_EQ expr
    MORE_OR_EQ      shift and go to state 302


state 265

    (167) type -> type_identifier < type _26_repeat . >
    >               shift and go to state 303


state 266

    (268) _57_repeat -> _57_items .
    (270) _57_items -> _57_items . _57_item
    (272) _57_item -> . , type
    MORE_OR_EQ      reduce using rule 268 (_57_repeat -> _57_items .)
    ,               shift and go to state 305

    _57_item                       shift and go to state 304

state 267

    (168) _26_repeat -> _26_items .
    (170) _26_items -> _26_items . _26_item
    (172) _26_item -> . , type
    >               reduce using rule 168 (_26_repeat -> _26_items .)
    ,               shift and go to state 293

    _26_item                       shift and go to state 306

state 268

    (271) _57_items -> _57_item .
    ,               reduce using rule 271 (_57_items -> _57_item .)
    MORE_OR_EQ      reduce using rule 271 (_57_items -> _57_item .)


state 269

    (171) _26_items -> _26_item .
    ,               reduce using rule 171 (_26_items -> _26_item .)
    >               reduce using rule 171 (_26_items -> _26_item .)


state 270

    (272) _57_item -> , . type
    (172) _26_item -> , . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 307
    type_identifier                shift and go to state 198

state 271

    (109) binary_op_def -> DEF binary_op ( _4_optional param , . _5_optional param _6_optional ) _7_optional do
    (112) _5_optional -> . NEWLINE
    (113) _5_optional -> .
    NEWLINE         shift and go to state 309
    IDENTIFIER      reduce using rule 113 (_5_optional -> .)

    _5_optional                    shift and go to state 308

state 272

    (202) param -> identifier _35_optional .
    ,               reduce using rule 202 (param -> identifier _35_optional .)
    NEWLINE         reduce using rule 202 (param -> identifier _35_optional .)
    )               reduce using rule 202 (param -> identifier _35_optional .)


state 273

    (203) _35_optional -> : . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 310
    type_identifier                shift and go to state 198

state 274

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > . ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (               shift and go to state 311


state 275

    (123) _8_item -> , type_identifier .
    ,               reduce using rule 123 (_8_item -> , type_identifier .)
    >               reduce using rule 123 (_8_item -> , type_identifier .)


state 276

    (121) _8_items -> _8_items _8_item .
    ,               reduce using rule 121 (_8_items -> _8_items _8_item .)
    >               reduce using rule 121 (_8_items -> _8_items _8_item .)


state 277

    (140) def_expr -> DEF identifier ( _16_optional _17_optional ) . _18_optional do
    (145) _18_optional -> . : type
    (146) _18_optional -> .
    :               shift and go to state 313
    DO              reduce using rule 146 (_18_optional -> .)

    _18_optional                   shift and go to state 312

state 278

    (162) params -> params , . _24_optional param _25_optional
    (163) _24_optional -> . NEWLINE
    (164) _24_optional -> .
    NEWLINE         shift and go to state 315
    IDENTIFIER      reduce using rule 164 (_24_optional -> .)

    _24_optional                   shift and go to state 314

state 279

    (159) params -> param _23_optional .
    ,               reduce using rule 159 (params -> param _23_optional .)
    )               reduce using rule 159 (params -> param _23_optional .)


state 280

    (160) _23_optional -> NEWLINE .
    ,               reduce using rule 160 (_23_optional -> NEWLINE .)
    )               reduce using rule 160 (_23_optional -> NEWLINE .)


state 281

    (147) def_expr -> DEF identifier < type_identifier _19_repeat > . ( _20_optional _21_optional ) _22_optional do
    (               shift and go to state 316


state 282

    (150) _19_items -> _19_items _19_item .
    ,               reduce using rule 150 (_19_items -> _19_items _19_item .)
    >               reduce using rule 150 (_19_items -> _19_items _19_item .)


state 283

    (152) _19_item -> , type_identifier .
    ,               reduce using rule 152 (_19_item -> , type_identifier .)
    >               reduce using rule 152 (_19_item -> , type_identifier .)


state 284

    (260) exprs -> exprs , _55_optional expr . _56_optional
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    (263) _56_optional -> . NEWLINE
    (264) _56_optional -> .
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82
    NEWLINE         shift and go to state 318
    ,               reduce using rule 264 (_56_optional -> .)
    ]               reduce using rule 264 (_56_optional -> .)
    )               reduce using rule 264 (_56_optional -> .)

    _56_optional                   shift and go to state 317

state 285

    (214) case_of -> CASE expr OF _39_optional _40_optional END .
    NEWLINE         reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    (               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_MORE      reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_MORE_OR_EQ reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_LESS      reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_LESS_OR_EQ reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    SOME_SUB        reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    SOME_CONCAT     reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ARROW_BOTH      reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ARROW_RIGHT     reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ARROW_LEFT      reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    DOUBLE_ARROW_RIGHT reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    DOUBLE_ARROW_LEFT reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    BIT_SHIFT_LEFT  reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    BIT_AND         reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    BIT_OR          reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_POW       reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    POW             reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ARRAY_SUB       reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ARRAY_CONCAT    reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    MORE_OR_EQ      reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    LESS_OR_EQ      reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    TEXT_MATCH      reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    STRICT_AND      reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    AND             reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    STRICT_OR       reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    OR              reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    EQUAL           reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    NOT_EQUAL       reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    >               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_MUL       reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_DIV       reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_SUB       reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    FLOAT_SUM       reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    <               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    *               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    /               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    -               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    +               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    CONCAT          reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    $end            reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    )               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    OF              reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    THEN            reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    END             reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ELIF            reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ELSE            reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ,               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)
    ]               reduce using rule 214 (case_of -> CASE expr OF _39_optional _40_optional END .)


state 286

    (222) cases -> cases pattern . do _42_optional
    (132) do -> . DO _13_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 319

state 287

    (219) cases -> pattern do . _41_optional
    (220) _41_optional -> . NEWLINE
    (221) _41_optional -> .
    NEWLINE         shift and go to state 321
    TYPE_IDENTIFIER reduce using rule 221 (_41_optional -> .)
    IDENTIFIER      reduce using rule 221 (_41_optional -> .)
    END             reduce using rule 221 (_41_optional -> .)

    _41_optional                   shift and go to state 320

state 288

    (229) match_variant -> type_identifier ( . _43_optional _44_optional )
    (230) _43_optional -> . NEWLINE
    (231) _43_optional -> .
    NEWLINE         shift and go to state 323
    TYPE_IDENTIFIER reduce using rule 231 (_43_optional -> .)
    IDENTIFIER      reduce using rule 231 (_43_optional -> .)
    )               reduce using rule 231 (_43_optional -> .)

    _43_optional                   shift and go to state 322

state 289

    (205) if_expr -> IF expr THEN _36_optional block_statement _37_optional . END
    END             shift and go to state 324


state 290

    (208) _37_optional -> or_else .
    END             reduce using rule 208 (_37_optional -> or_else .)


state 291

    (210) or_else -> ELIF . expr THEN block_statement _38_optional
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    expr                           shift and go to state 325
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    identifier                     shift and go to state 15
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24
    type_identifier                shift and go to state 26

state 292

    (213) or_else -> ELSE . block_statement
    (135) block_statement -> . _14_optional _15_optional
    (136) _14_optional -> . NEWLINE
    (137) _14_optional -> .
    NEWLINE         shift and go to state 196
    (               reduce using rule 137 (_14_optional -> .)
    DEF             reduce using rule 137 (_14_optional -> .)
    +               reduce using rule 137 (_14_optional -> .)
    !               reduce using rule 137 (_14_optional -> .)
    STRICT_NOT      reduce using rule 137 (_14_optional -> .)
    -               reduce using rule 137 (_14_optional -> .)
    STRING          reduce using rule 137 (_14_optional -> .)
    FLOAT           reduce using rule 137 (_14_optional -> .)
    INT             reduce using rule 137 (_14_optional -> .)
    [               reduce using rule 137 (_14_optional -> .)
    IDENTIFIER      reduce using rule 137 (_14_optional -> .)
    CASE            reduce using rule 137 (_14_optional -> .)
    IF              reduce using rule 137 (_14_optional -> .)
    DO              reduce using rule 137 (_14_optional -> .)
    EXTERNAL        reduce using rule 137 (_14_optional -> .)
    ENUM            reduce using rule 137 (_14_optional -> .)
    TYPE_IDENTIFIER reduce using rule 137 (_14_optional -> .)
    END             reduce using rule 137 (_14_optional -> .)

    block_statement                shift and go to state 326
    _14_optional                   shift and go to state 195

state 293

    (172) _26_item -> , . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 327
    type_identifier                shift and go to state 198

state 294

    (196) variant -> type_identifier ( . type _34_repeat )
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 198
    type                           shift and go to state 328

state 295

    (174) enum -> ENUM type_identifier { _27_optional _28_optional } .
    NEWLINE         reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    (               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_MORE      reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_MORE_OR_EQ reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_LESS      reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_LESS_OR_EQ reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    SOME_SUB        reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    SOME_CONCAT     reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ARROW_BOTH      reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ARROW_RIGHT     reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ARROW_LEFT      reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    DOUBLE_ARROW_RIGHT reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    DOUBLE_ARROW_LEFT reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    BIT_SHIFT_LEFT  reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    BIT_AND         reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    BIT_OR          reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_POW       reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    POW             reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ARRAY_SUB       reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ARRAY_CONCAT    reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    MORE_OR_EQ      reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    LESS_OR_EQ      reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    TEXT_MATCH      reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    STRICT_AND      reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    AND             reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    STRICT_OR       reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    OR              reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    EQUAL           reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    NOT_EQUAL       reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    >               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_MUL       reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_DIV       reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_SUB       reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    FLOAT_SUM       reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    <               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    *               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    /               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    -               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    +               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    CONCAT          reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    $end            reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    )               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    OF              reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    THEN            reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    END             reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ELIF            reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ELSE            reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ,               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)
    ]               reduce using rule 174 (enum -> ENUM type_identifier { _27_optional _28_optional } .)


state 296

    (192) variants -> variants variant . _33_optional
    (193) _33_optional -> . NEWLINE
    (194) _33_optional -> .
    NEWLINE         shift and go to state 330
    TYPE_IDENTIFIER reduce using rule 194 (_33_optional -> .)
    }               reduce using rule 194 (_33_optional -> .)

    _33_optional                   shift and go to state 329

state 297

    (189) variants -> variant _32_optional .
    TYPE_IDENTIFIER reduce using rule 189 (variants -> variant _32_optional .)
    }               reduce using rule 189 (variants -> variant _32_optional .)


state 298

    (190) _32_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 190 (_32_optional -> NEWLINE .)
    }               reduce using rule 190 (_32_optional -> NEWLINE .)


state 299

    (179) enum -> ENUM type_identifier < type_identifier _29_repeat > . { _30_optional _31_optional }
    {               shift and go to state 331


state 300

    (182) _29_items -> _29_items _29_item .
    ,               reduce using rule 182 (_29_items -> _29_items _29_item .)
    >               reduce using rule 182 (_29_items -> _29_items _29_item .)


state 301

    (184) _29_item -> , type_identifier .
    ,               reduce using rule 184 (_29_item -> , type_identifier .)
    >               reduce using rule 184 (_29_item -> , type_identifier .)


state 302

    (267) let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ . expr
    (10) expr -> . ( expr )
    (11) expr -> . binary_op_def
    (12) expr -> . unary_expr
    (13) expr -> . str_literal
    (14) expr -> . float_literal
    (15) expr -> . int_literal
    (16) expr -> . array
    (17) expr -> . variant_call
    (18) expr -> . identifier
    (19) expr -> . let
    (20) expr -> . call
    (21) expr -> . case_of
    (22) expr -> . binary_expr
    (23) expr -> . if_expr
    (24) expr -> . def_expr
    (25) expr -> . do
    (26) expr -> . external
    (27) expr -> . enum
    (109) binary_op_def -> . DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do
    (118) binary_op_def -> . DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do
    (28) unary_expr -> . + expr
    (29) unary_expr -> . ! expr
    (30) unary_expr -> . STRICT_NOT expr
    (31) unary_expr -> . - expr
    (278) str_literal -> . STRING
    (277) float_literal -> . FLOAT
    (276) int_literal -> . INT
    (242) array -> . [ _48_optional _49_optional ]
    (252) variant_call -> . type_identifier ( _52_optional _53_optional )
    (265) identifier -> . IDENTIFIER
    (267) let -> . identifier : type_identifier < type _57_repeat MORE_OR_EQ expr
    (273) let -> . identifier _58_optional = expr
    (247) call -> . expr ( _50_optional _51_optional )
    (214) case_of -> . CASE expr OF _39_optional _40_optional END
    (33) binary_expr -> . expr FLOAT_MORE expr
    (34) binary_expr -> . expr FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> . expr FLOAT_LESS expr
    (36) binary_expr -> . expr FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> . expr SOME_SUB expr
    (38) binary_expr -> . expr SOME_CONCAT expr
    (39) binary_expr -> . expr ARROW_BOTH expr
    (40) binary_expr -> . expr ARROW_RIGHT expr
    (41) binary_expr -> . expr ARROW_LEFT expr
    (42) binary_expr -> . expr DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> . expr DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> . expr BIT_SHIFT_LEFT expr
    (45) binary_expr -> . expr BIT_AND expr
    (46) binary_expr -> . expr BIT_OR expr
    (47) binary_expr -> . expr FLOAT_POW expr
    (48) binary_expr -> . expr POW expr
    (49) binary_expr -> . expr ARRAY_SUB expr
    (50) binary_expr -> . expr ARRAY_CONCAT expr
    (51) binary_expr -> . expr MORE_OR_EQ expr
    (52) binary_expr -> . expr LESS_OR_EQ expr
    (53) binary_expr -> . expr TEXT_MATCH expr
    (54) binary_expr -> . expr STRICT_AND expr
    (55) binary_expr -> . expr AND expr
    (56) binary_expr -> . expr STRICT_OR expr
    (57) binary_expr -> . expr OR expr
    (58) binary_expr -> . expr EQUAL expr
    (59) binary_expr -> . expr NOT_EQUAL expr
    (60) binary_expr -> . expr > expr
    (61) binary_expr -> . expr FLOAT_MUL expr
    (62) binary_expr -> . expr FLOAT_DIV expr
    (63) binary_expr -> . expr FLOAT_SUB expr
    (64) binary_expr -> . expr FLOAT_SUM expr
    (65) binary_expr -> . expr < expr
    (66) binary_expr -> . expr * expr
    (67) binary_expr -> . expr / expr
    (68) binary_expr -> . expr - expr
    (69) binary_expr -> . expr + expr
    (70) binary_expr -> . expr CONCAT expr
    (205) if_expr -> . IF expr THEN _36_optional block_statement _37_optional END
    (140) def_expr -> . DEF identifier ( _16_optional _17_optional ) _18_optional do
    (147) def_expr -> . DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do
    (132) do -> . DO _13_optional block_statement END
    (32) external -> . EXTERNAL
    (174) enum -> . ENUM type_identifier { _27_optional _28_optional }
    (179) enum -> . ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional }
    (266) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    DEF             shift and go to state 25
    +               shift and go to state 27
    !               shift and go to state 28
    STRICT_NOT      shift and go to state 29
    -               shift and go to state 30
    STRING          shift and go to state 31
    FLOAT           shift and go to state 32
    INT             shift and go to state 33
    [               shift and go to state 34
    IDENTIFIER      shift and go to state 35
    CASE            shift and go to state 36
    IF              shift and go to state 37
    DO              shift and go to state 38
    EXTERNAL        shift and go to state 39
    ENUM            shift and go to state 40
    TYPE_IDENTIFIER shift and go to state 41

    identifier                     shift and go to state 15
    type_identifier                shift and go to state 26
    expr                           shift and go to state 332
    binary_op_def                  shift and go to state 8
    unary_expr                     shift and go to state 9
    str_literal                    shift and go to state 10
    float_literal                  shift and go to state 11
    int_literal                    shift and go to state 12
    array                          shift and go to state 13
    variant_call                   shift and go to state 14
    let                            shift and go to state 16
    call                           shift and go to state 17
    case_of                        shift and go to state 18
    binary_expr                    shift and go to state 19
    if_expr                        shift and go to state 20
    def_expr                       shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    enum                           shift and go to state 24

state 303

    (167) type -> type_identifier < type _26_repeat > .
    =               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    NEWLINE         reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    END             reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    (               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    DEF             reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    +               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    !               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    STRICT_NOT      reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    -               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    STRING          reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    FLOAT           reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    INT             reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    [               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    IDENTIFIER      reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    CASE            reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    IF              reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    DO              reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    EXTERNAL        reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    ENUM            reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    TYPE_IDENTIFIER reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    ,               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    MORE_OR_EQ      reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    >               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    ELIF            reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    ELSE            reduce using rule 167 (type -> type_identifier < type _26_repeat > .)
    )               reduce using rule 167 (type -> type_identifier < type _26_repeat > .)


state 304

    (270) _57_items -> _57_items _57_item .
    ,               reduce using rule 270 (_57_items -> _57_items _57_item .)
    MORE_OR_EQ      reduce using rule 270 (_57_items -> _57_items _57_item .)


state 305

    (272) _57_item -> , . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 333
    type_identifier                shift and go to state 198

state 306

    (170) _26_items -> _26_items _26_item .
    ,               reduce using rule 170 (_26_items -> _26_items _26_item .)
    >               reduce using rule 170 (_26_items -> _26_items _26_item .)


state 307

    (272) _57_item -> , type .
    (172) _26_item -> , type .
  ! reduce/reduce conflict for , resolved using rule 272 (_57_item -> , type .)
    ,               reduce using rule 272 (_57_item -> , type .)
    MORE_OR_EQ      reduce using rule 272 (_57_item -> , type .)
    >               reduce using rule 172 (_26_item -> , type .)


state 308

    (109) binary_op_def -> DEF binary_op ( _4_optional param , _5_optional . param _6_optional ) _7_optional do
    (202) param -> . identifier _35_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 334
    identifier                     shift and go to state 231

state 309

    (112) _5_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 112 (_5_optional -> NEWLINE .)


state 310

    (203) _35_optional -> : type .
    ,               reduce using rule 203 (_35_optional -> : type .)
    NEWLINE         reduce using rule 203 (_35_optional -> : type .)
    )               reduce using rule 203 (_35_optional -> : type .)


state 311

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( . _9_optional param , _10_optional param _11_optional ) _12_optional do
    (124) _9_optional -> . NEWLINE
    (125) _9_optional -> .
    NEWLINE         shift and go to state 336
    IDENTIFIER      reduce using rule 125 (_9_optional -> .)

    _9_optional                    shift and go to state 335

state 312

    (140) def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional . do
    (132) do -> . DO _13_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 337

state 313

    (145) _18_optional -> : . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 338
    type_identifier                shift and go to state 198

state 314

    (162) params -> params , _24_optional . param _25_optional
    (202) param -> . identifier _35_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 339
    identifier                     shift and go to state 231

state 315

    (163) _24_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 163 (_24_optional -> NEWLINE .)


state 316

    (147) def_expr -> DEF identifier < type_identifier _19_repeat > ( . _20_optional _21_optional ) _22_optional do
    (153) _20_optional -> . NEWLINE
    (154) _20_optional -> .
    NEWLINE         shift and go to state 341
    IDENTIFIER      reduce using rule 154 (_20_optional -> .)
    )               reduce using rule 154 (_20_optional -> .)

    _20_optional                   shift and go to state 340

state 317

    (260) exprs -> exprs , _55_optional expr _56_optional .
    ,               reduce using rule 260 (exprs -> exprs , _55_optional expr _56_optional .)
    ]               reduce using rule 260 (exprs -> exprs , _55_optional expr _56_optional .)
    )               reduce using rule 260 (exprs -> exprs , _55_optional expr _56_optional .)


state 318

    (263) _56_optional -> NEWLINE .
    ,               reduce using rule 263 (_56_optional -> NEWLINE .)
    ]               reduce using rule 263 (_56_optional -> NEWLINE .)
    )               reduce using rule 263 (_56_optional -> NEWLINE .)


state 319

    (222) cases -> cases pattern do . _42_optional
    (223) _42_optional -> . NEWLINE
    (224) _42_optional -> .
    NEWLINE         shift and go to state 343
    TYPE_IDENTIFIER reduce using rule 224 (_42_optional -> .)
    IDENTIFIER      reduce using rule 224 (_42_optional -> .)
    END             reduce using rule 224 (_42_optional -> .)

    _42_optional                   shift and go to state 342

state 320

    (219) cases -> pattern do _41_optional .
    TYPE_IDENTIFIER reduce using rule 219 (cases -> pattern do _41_optional .)
    IDENTIFIER      reduce using rule 219 (cases -> pattern do _41_optional .)
    END             reduce using rule 219 (cases -> pattern do _41_optional .)


state 321

    (220) _41_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 220 (_41_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 220 (_41_optional -> NEWLINE .)
    END             reduce using rule 220 (_41_optional -> NEWLINE .)


state 322

    (229) match_variant -> type_identifier ( _43_optional . _44_optional )
    (232) _44_optional -> . patterns
    (233) _44_optional -> .
    (234) patterns -> . pattern _45_optional
    (237) patterns -> . patterns , _46_optional pattern _47_optional
    (225) pattern -> . match_variant
    (226) pattern -> . match_as
    (228) match_variant -> . type_identifier
    (229) match_variant -> . type_identifier ( _43_optional _44_optional )
    (227) match_as -> . identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    (265) identifier -> . IDENTIFIER
    )               reduce using rule 233 (_44_optional -> .)
    TYPE_IDENTIFIER shift and go to state 41
    IDENTIFIER      shift and go to state 35

    type_identifier                shift and go to state 251
    _44_optional                   shift and go to state 344
    patterns                       shift and go to state 345
    pattern                        shift and go to state 346
    match_variant                  shift and go to state 249
    match_as                       shift and go to state 250
    identifier                     shift and go to state 252

state 323

    (230) _43_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 230 (_43_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 230 (_43_optional -> NEWLINE .)
    )               reduce using rule 230 (_43_optional -> NEWLINE .)


state 324

    (205) if_expr -> IF expr THEN _36_optional block_statement _37_optional END .
    NEWLINE         reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    (               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_MORE      reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_MORE_OR_EQ reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_LESS      reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_LESS_OR_EQ reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    SOME_SUB        reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    SOME_CONCAT     reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ARROW_BOTH      reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ARROW_RIGHT     reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ARROW_LEFT      reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    DOUBLE_ARROW_RIGHT reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    DOUBLE_ARROW_LEFT reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    BIT_SHIFT_LEFT  reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    BIT_AND         reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    BIT_OR          reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_POW       reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    POW             reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ARRAY_SUB       reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ARRAY_CONCAT    reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    MORE_OR_EQ      reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    LESS_OR_EQ      reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    TEXT_MATCH      reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    STRICT_AND      reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    AND             reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    STRICT_OR       reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    OR              reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    EQUAL           reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    NOT_EQUAL       reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    >               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_MUL       reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_DIV       reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_SUB       reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    FLOAT_SUM       reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    <               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    *               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    /               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    -               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    +               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    CONCAT          reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    $end            reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    )               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    OF              reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    THEN            reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    END             reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ELIF            reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ELSE            reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ,               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)
    ]               reduce using rule 205 (if_expr -> IF expr THEN _36_optional block_statement _37_optional END .)


state 325

    (210) or_else -> ELIF expr . THEN block_statement _38_optional
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 347
    (               shift and go to state 44
    FLOAT_MORE      shift and go to state 45
    FLOAT_MORE_OR_EQ shift and go to state 46
    FLOAT_LESS      shift and go to state 47
    FLOAT_LESS_OR_EQ shift and go to state 48
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    BIT_AND         shift and go to state 57
    BIT_OR          shift and go to state 58
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    MORE_OR_EQ      shift and go to state 63
    LESS_OR_EQ      shift and go to state 64
    TEXT_MATCH      shift and go to state 65
    STRICT_AND      shift and go to state 66
    AND             shift and go to state 67
    STRICT_OR       shift and go to state 68
    OR              shift and go to state 69
    EQUAL           shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    >               shift and go to state 72
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    <               shift and go to state 77
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 326

    (213) or_else -> ELSE block_statement .
    END             reduce using rule 213 (or_else -> ELSE block_statement .)


state 327

    (172) _26_item -> , type .
    ,               reduce using rule 172 (_26_item -> , type .)
    >               reduce using rule 172 (_26_item -> , type .)


state 328

    (196) variant -> type_identifier ( type . _34_repeat )
    (197) _34_repeat -> . _34_items
    (198) _34_repeat -> .
    (199) _34_items -> . _34_items _34_item
    (200) _34_items -> . _34_item
    (201) _34_item -> . , type
    )               reduce using rule 198 (_34_repeat -> .)
    ,               shift and go to state 351

    _34_repeat                     shift and go to state 348
    _34_items                      shift and go to state 349
    _34_item                       shift and go to state 350

state 329

    (192) variants -> variants variant _33_optional .
    TYPE_IDENTIFIER reduce using rule 192 (variants -> variants variant _33_optional .)
    }               reduce using rule 192 (variants -> variants variant _33_optional .)


state 330

    (193) _33_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 193 (_33_optional -> NEWLINE .)
    }               reduce using rule 193 (_33_optional -> NEWLINE .)


state 331

    (179) enum -> ENUM type_identifier < type_identifier _29_repeat > { . _30_optional _31_optional }
    (185) _30_optional -> . NEWLINE
    (186) _30_optional -> .
    NEWLINE         shift and go to state 353
    TYPE_IDENTIFIER reduce using rule 186 (_30_optional -> .)
    }               reduce using rule 186 (_30_optional -> .)

    _30_optional                   shift and go to state 352

state 332

    (267) let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .
    (247) call -> expr . ( _50_optional _51_optional )
    (33) binary_expr -> expr . FLOAT_MORE expr
    (34) binary_expr -> expr . FLOAT_MORE_OR_EQ expr
    (35) binary_expr -> expr . FLOAT_LESS expr
    (36) binary_expr -> expr . FLOAT_LESS_OR_EQ expr
    (37) binary_expr -> expr . SOME_SUB expr
    (38) binary_expr -> expr . SOME_CONCAT expr
    (39) binary_expr -> expr . ARROW_BOTH expr
    (40) binary_expr -> expr . ARROW_RIGHT expr
    (41) binary_expr -> expr . ARROW_LEFT expr
    (42) binary_expr -> expr . DOUBLE_ARROW_RIGHT expr
    (43) binary_expr -> expr . DOUBLE_ARROW_LEFT expr
    (44) binary_expr -> expr . BIT_SHIFT_LEFT expr
    (45) binary_expr -> expr . BIT_AND expr
    (46) binary_expr -> expr . BIT_OR expr
    (47) binary_expr -> expr . FLOAT_POW expr
    (48) binary_expr -> expr . POW expr
    (49) binary_expr -> expr . ARRAY_SUB expr
    (50) binary_expr -> expr . ARRAY_CONCAT expr
    (51) binary_expr -> expr . MORE_OR_EQ expr
    (52) binary_expr -> expr . LESS_OR_EQ expr
    (53) binary_expr -> expr . TEXT_MATCH expr
    (54) binary_expr -> expr . STRICT_AND expr
    (55) binary_expr -> expr . AND expr
    (56) binary_expr -> expr . STRICT_OR expr
    (57) binary_expr -> expr . OR expr
    (58) binary_expr -> expr . EQUAL expr
    (59) binary_expr -> expr . NOT_EQUAL expr
    (60) binary_expr -> expr . > expr
    (61) binary_expr -> expr . FLOAT_MUL expr
    (62) binary_expr -> expr . FLOAT_DIV expr
    (63) binary_expr -> expr . FLOAT_SUB expr
    (64) binary_expr -> expr . FLOAT_SUM expr
    (65) binary_expr -> expr . < expr
    (66) binary_expr -> expr . * expr
    (67) binary_expr -> expr . / expr
    (68) binary_expr -> expr . - expr
    (69) binary_expr -> expr . + expr
    (70) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    FLOAT_MORE      reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    FLOAT_MORE_OR_EQ reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    FLOAT_LESS      reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    FLOAT_LESS_OR_EQ reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    BIT_AND         reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    BIT_OR          reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    MORE_OR_EQ      reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    LESS_OR_EQ      reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    TEXT_MATCH      reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    STRICT_AND      reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    AND             reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    STRICT_OR       reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    OR              reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    EQUAL           reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    NOT_EQUAL       reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    >               reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    <               reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    $end            reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    )               reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    OF              reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    THEN            reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    END             reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    ELIF            reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    ELSE            reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    ,               reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    ]               reduce using rule 267 (let -> identifier : type_identifier < type _57_repeat MORE_OR_EQ expr .)
    (               shift and go to state 44
    SOME_SUB        shift and go to state 49
    SOME_CONCAT     shift and go to state 50
    ARROW_BOTH      shift and go to state 51
    ARROW_RIGHT     shift and go to state 52
    ARROW_LEFT      shift and go to state 53
    DOUBLE_ARROW_RIGHT shift and go to state 54
    DOUBLE_ARROW_LEFT shift and go to state 55
    BIT_SHIFT_LEFT  shift and go to state 56
    FLOAT_POW       shift and go to state 59
    POW             shift and go to state 60
    ARRAY_SUB       shift and go to state 61
    ARRAY_CONCAT    shift and go to state 62
    FLOAT_MUL       shift and go to state 73
    FLOAT_DIV       shift and go to state 74
    FLOAT_SUB       shift and go to state 75
    FLOAT_SUM       shift and go to state 76
    *               shift and go to state 78
    /               shift and go to state 79
    -               shift and go to state 80
    +               shift and go to state 81
    CONCAT          shift and go to state 82


state 333

    (272) _57_item -> , type .
    ,               reduce using rule 272 (_57_item -> , type .)
    MORE_OR_EQ      reduce using rule 272 (_57_item -> , type .)


state 334

    (109) binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param . _6_optional ) _7_optional do
    (114) _6_optional -> . NEWLINE
    (115) _6_optional -> .
    NEWLINE         shift and go to state 355
    )               reduce using rule 115 (_6_optional -> .)

    _6_optional                    shift and go to state 354

state 335

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional . param , _10_optional param _11_optional ) _12_optional do
    (202) param -> . identifier _35_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 356
    identifier                     shift and go to state 231

state 336

    (124) _9_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 124 (_9_optional -> NEWLINE .)


state 337

    (140) def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .
    NEWLINE         reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    (               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_MORE      reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_MORE_OR_EQ reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_LESS      reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_LESS_OR_EQ reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    SOME_SUB        reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    SOME_CONCAT     reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ARROW_BOTH      reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ARROW_RIGHT     reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ARROW_LEFT      reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    BIT_AND         reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    BIT_OR          reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_POW       reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    POW             reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ARRAY_SUB       reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ARRAY_CONCAT    reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    MORE_OR_EQ      reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    LESS_OR_EQ      reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    TEXT_MATCH      reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    STRICT_AND      reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    AND             reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    STRICT_OR       reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    OR              reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    EQUAL           reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    NOT_EQUAL       reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    >               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_MUL       reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_DIV       reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_SUB       reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    FLOAT_SUM       reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    <               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    *               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    /               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    -               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    +               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    CONCAT          reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    $end            reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    )               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    OF              reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    THEN            reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    END             reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ELIF            reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ELSE            reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ,               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)
    ]               reduce using rule 140 (def_expr -> DEF identifier ( _16_optional _17_optional ) _18_optional do .)


state 338

    (145) _18_optional -> : type .
    DO              reduce using rule 145 (_18_optional -> : type .)


state 339

    (162) params -> params , _24_optional param . _25_optional
    (165) _25_optional -> . NEWLINE
    (166) _25_optional -> .
    NEWLINE         shift and go to state 358
    ,               reduce using rule 166 (_25_optional -> .)
    )               reduce using rule 166 (_25_optional -> .)

    _25_optional                   shift and go to state 357

state 340

    (147) def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional . _21_optional ) _22_optional do
    (155) _21_optional -> . params
    (156) _21_optional -> .
    (159) params -> . param _23_optional
    (162) params -> . params , _24_optional param _25_optional
    (202) param -> . identifier _35_optional
    (265) identifier -> . IDENTIFIER
    )               reduce using rule 156 (_21_optional -> .)
    IDENTIFIER      shift and go to state 35

    identifier                     shift and go to state 231
    _21_optional                   shift and go to state 359
    params                         shift and go to state 360
    param                          shift and go to state 238

state 341

    (153) _20_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 153 (_20_optional -> NEWLINE .)
    )               reduce using rule 153 (_20_optional -> NEWLINE .)


state 342

    (222) cases -> cases pattern do _42_optional .
    TYPE_IDENTIFIER reduce using rule 222 (cases -> cases pattern do _42_optional .)
    IDENTIFIER      reduce using rule 222 (cases -> cases pattern do _42_optional .)
    END             reduce using rule 222 (cases -> cases pattern do _42_optional .)


state 343

    (223) _42_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 223 (_42_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 223 (_42_optional -> NEWLINE .)
    END             reduce using rule 223 (_42_optional -> NEWLINE .)


state 344

    (229) match_variant -> type_identifier ( _43_optional _44_optional . )
    )               shift and go to state 361


state 345

    (232) _44_optional -> patterns .
    (237) patterns -> patterns . , _46_optional pattern _47_optional
    )               reduce using rule 232 (_44_optional -> patterns .)
    ,               shift and go to state 362


state 346

    (234) patterns -> pattern . _45_optional
    (235) _45_optional -> . NEWLINE
    (236) _45_optional -> .
    NEWLINE         shift and go to state 364
    ,               reduce using rule 236 (_45_optional -> .)
    )               reduce using rule 236 (_45_optional -> .)

    _45_optional                   shift and go to state 363

state 347

    (210) or_else -> ELIF expr THEN . block_statement _38_optional
    (135) block_statement -> . _14_optional _15_optional
    (136) _14_optional -> . NEWLINE
    (137) _14_optional -> .
    NEWLINE         shift and go to state 196
    (               reduce using rule 137 (_14_optional -> .)
    DEF             reduce using rule 137 (_14_optional -> .)
    +               reduce using rule 137 (_14_optional -> .)
    !               reduce using rule 137 (_14_optional -> .)
    STRICT_NOT      reduce using rule 137 (_14_optional -> .)
    -               reduce using rule 137 (_14_optional -> .)
    STRING          reduce using rule 137 (_14_optional -> .)
    FLOAT           reduce using rule 137 (_14_optional -> .)
    INT             reduce using rule 137 (_14_optional -> .)
    [               reduce using rule 137 (_14_optional -> .)
    IDENTIFIER      reduce using rule 137 (_14_optional -> .)
    CASE            reduce using rule 137 (_14_optional -> .)
    IF              reduce using rule 137 (_14_optional -> .)
    DO              reduce using rule 137 (_14_optional -> .)
    EXTERNAL        reduce using rule 137 (_14_optional -> .)
    ENUM            reduce using rule 137 (_14_optional -> .)
    TYPE_IDENTIFIER reduce using rule 137 (_14_optional -> .)
    ELIF            reduce using rule 137 (_14_optional -> .)
    ELSE            reduce using rule 137 (_14_optional -> .)
    END             reduce using rule 137 (_14_optional -> .)

    block_statement                shift and go to state 365
    _14_optional                   shift and go to state 195

state 348

    (196) variant -> type_identifier ( type _34_repeat . )
    )               shift and go to state 366


state 349

    (197) _34_repeat -> _34_items .
    (199) _34_items -> _34_items . _34_item
    (201) _34_item -> . , type
    )               reduce using rule 197 (_34_repeat -> _34_items .)
    ,               shift and go to state 351

    _34_item                       shift and go to state 367

state 350

    (200) _34_items -> _34_item .
    ,               reduce using rule 200 (_34_items -> _34_item .)
    )               reduce using rule 200 (_34_items -> _34_item .)


state 351

    (201) _34_item -> , . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 368
    type_identifier                shift and go to state 198

state 352

    (179) enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional . _31_optional }
    (187) _31_optional -> . variants
    (188) _31_optional -> .
    (189) variants -> . variant _32_optional
    (192) variants -> . variants variant _33_optional
    (195) variant -> . type_identifier
    (196) variant -> . type_identifier ( type _34_repeat )
    (266) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 188 (_31_optional -> .)
    TYPE_IDENTIFIER shift and go to state 41

    type_identifier                shift and go to state 256
    _31_optional                   shift and go to state 369
    variants                       shift and go to state 370
    variant                        shift and go to state 259

state 353

    (185) _30_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 185 (_30_optional -> NEWLINE .)
    }               reduce using rule 185 (_30_optional -> NEWLINE .)


state 354

    (109) binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional . ) _7_optional do
    )               shift and go to state 371


state 355

    (114) _6_optional -> NEWLINE .
    )               reduce using rule 114 (_6_optional -> NEWLINE .)


state 356

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param . , _10_optional param _11_optional ) _12_optional do
    ,               shift and go to state 372


state 357

    (162) params -> params , _24_optional param _25_optional .
    ,               reduce using rule 162 (params -> params , _24_optional param _25_optional .)
    )               reduce using rule 162 (params -> params , _24_optional param _25_optional .)


state 358

    (165) _25_optional -> NEWLINE .
    ,               reduce using rule 165 (_25_optional -> NEWLINE .)
    )               reduce using rule 165 (_25_optional -> NEWLINE .)


state 359

    (147) def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional . ) _22_optional do
    )               shift and go to state 373


state 360

    (155) _21_optional -> params .
    (162) params -> params . , _24_optional param _25_optional
    )               reduce using rule 155 (_21_optional -> params .)
    ,               shift and go to state 278


state 361

    (229) match_variant -> type_identifier ( _43_optional _44_optional ) .
    DO              reduce using rule 229 (match_variant -> type_identifier ( _43_optional _44_optional ) .)
    NEWLINE         reduce using rule 229 (match_variant -> type_identifier ( _43_optional _44_optional ) .)
    ,               reduce using rule 229 (match_variant -> type_identifier ( _43_optional _44_optional ) .)
    )               reduce using rule 229 (match_variant -> type_identifier ( _43_optional _44_optional ) .)


state 362

    (237) patterns -> patterns , . _46_optional pattern _47_optional
    (238) _46_optional -> . NEWLINE
    (239) _46_optional -> .
    NEWLINE         shift and go to state 375
    TYPE_IDENTIFIER reduce using rule 239 (_46_optional -> .)
    IDENTIFIER      reduce using rule 239 (_46_optional -> .)

    _46_optional                   shift and go to state 374

state 363

    (234) patterns -> pattern _45_optional .
    ,               reduce using rule 234 (patterns -> pattern _45_optional .)
    )               reduce using rule 234 (patterns -> pattern _45_optional .)


state 364

    (235) _45_optional -> NEWLINE .
    ,               reduce using rule 235 (_45_optional -> NEWLINE .)
    )               reduce using rule 235 (_45_optional -> NEWLINE .)


state 365

    (210) or_else -> ELIF expr THEN block_statement . _38_optional
    (211) _38_optional -> . or_else
    (212) _38_optional -> .
    (210) or_else -> . ELIF expr THEN block_statement _38_optional
    (213) or_else -> . ELSE block_statement
    END             reduce using rule 212 (_38_optional -> .)
    ELIF            shift and go to state 291
    ELSE            shift and go to state 292

    _38_optional                   shift and go to state 376
    or_else                        shift and go to state 377

state 366

    (196) variant -> type_identifier ( type _34_repeat ) .
    NEWLINE         reduce using rule 196 (variant -> type_identifier ( type _34_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 196 (variant -> type_identifier ( type _34_repeat ) .)
    }               reduce using rule 196 (variant -> type_identifier ( type _34_repeat ) .)


state 367

    (199) _34_items -> _34_items _34_item .
    ,               reduce using rule 199 (_34_items -> _34_items _34_item .)
    )               reduce using rule 199 (_34_items -> _34_items _34_item .)


state 368

    (201) _34_item -> , type .
    ,               reduce using rule 201 (_34_item -> , type .)
    )               reduce using rule 201 (_34_item -> , type .)


state 369

    (179) enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional . }
    }               shift and go to state 378


state 370

    (187) _31_optional -> variants .
    (192) variants -> variants . variant _33_optional
    (195) variant -> . type_identifier
    (196) variant -> . type_identifier ( type _34_repeat )
    (266) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 187 (_31_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 41

    variant                        shift and go to state 296
    type_identifier                shift and go to state 256

state 371

    (109) binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) . _7_optional do
    (116) _7_optional -> . : type
    (117) _7_optional -> .
    :               shift and go to state 380
    DO              reduce using rule 117 (_7_optional -> .)

    _7_optional                    shift and go to state 379

state 372

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , . _10_optional param _11_optional ) _12_optional do
    (126) _10_optional -> . NEWLINE
    (127) _10_optional -> .
    NEWLINE         shift and go to state 382
    IDENTIFIER      reduce using rule 127 (_10_optional -> .)

    _10_optional                   shift and go to state 381

state 373

    (147) def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) . _22_optional do
    (157) _22_optional -> . : type
    (158) _22_optional -> .
    :               shift and go to state 384
    DO              reduce using rule 158 (_22_optional -> .)

    _22_optional                   shift and go to state 383

state 374

    (237) patterns -> patterns , _46_optional . pattern _47_optional
    (225) pattern -> . match_variant
    (226) pattern -> . match_as
    (228) match_variant -> . type_identifier
    (229) match_variant -> . type_identifier ( _43_optional _44_optional )
    (227) match_as -> . identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    (265) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41
    IDENTIFIER      shift and go to state 35

    pattern                        shift and go to state 385
    match_variant                  shift and go to state 249
    match_as                       shift and go to state 250
    type_identifier                shift and go to state 251
    identifier                     shift and go to state 252

state 375

    (238) _46_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 238 (_46_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 238 (_46_optional -> NEWLINE .)


state 376

    (210) or_else -> ELIF expr THEN block_statement _38_optional .
    END             reduce using rule 210 (or_else -> ELIF expr THEN block_statement _38_optional .)


state 377

    (211) _38_optional -> or_else .
    END             reduce using rule 211 (_38_optional -> or_else .)


state 378

    (179) enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .
    NEWLINE         reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    (               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_MORE      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_MORE_OR_EQ reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_LESS      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_LESS_OR_EQ reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    SOME_SUB        reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    SOME_CONCAT     reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ARROW_BOTH      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ARROW_RIGHT     reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ARROW_LEFT      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    DOUBLE_ARROW_RIGHT reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    DOUBLE_ARROW_LEFT reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    BIT_SHIFT_LEFT  reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    BIT_AND         reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    BIT_OR          reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_POW       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    POW             reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ARRAY_SUB       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ARRAY_CONCAT    reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    MORE_OR_EQ      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    LESS_OR_EQ      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    TEXT_MATCH      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    STRICT_AND      reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    AND             reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    STRICT_OR       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    OR              reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    EQUAL           reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    NOT_EQUAL       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    >               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_MUL       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_DIV       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_SUB       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    FLOAT_SUM       reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    <               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    *               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    /               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    -               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    +               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    CONCAT          reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    $end            reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    )               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    OF              reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    THEN            reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    END             reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ELIF            reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ELSE            reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ,               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)
    ]               reduce using rule 179 (enum -> ENUM type_identifier < type_identifier _29_repeat > { _30_optional _31_optional } .)


state 379

    (109) binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional . do
    (132) do -> . DO _13_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 386

state 380

    (116) _7_optional -> : . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 387
    type_identifier                shift and go to state 198

state 381

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional . param _11_optional ) _12_optional do
    (202) param -> . identifier _35_optional
    (265) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 35

    param                          shift and go to state 388
    identifier                     shift and go to state 231

state 382

    (126) _10_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 126 (_10_optional -> NEWLINE .)


state 383

    (147) def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional . do
    (132) do -> . DO _13_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 389

state 384

    (157) _22_optional -> : . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 390
    type_identifier                shift and go to state 198

state 385

    (237) patterns -> patterns , _46_optional pattern . _47_optional
    (240) _47_optional -> . NEWLINE
    (241) _47_optional -> .
    NEWLINE         shift and go to state 392
    ,               reduce using rule 241 (_47_optional -> .)
    )               reduce using rule 241 (_47_optional -> .)

    _47_optional                   shift and go to state 391

state 386

    (109) binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .
    NEWLINE         reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    (               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_MORE      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_MORE_OR_EQ reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_LESS      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_LESS_OR_EQ reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    SOME_SUB        reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    SOME_CONCAT     reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ARROW_BOTH      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ARROW_RIGHT     reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ARROW_LEFT      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    BIT_AND         reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    BIT_OR          reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_POW       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    POW             reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ARRAY_SUB       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ARRAY_CONCAT    reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    MORE_OR_EQ      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    LESS_OR_EQ      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    TEXT_MATCH      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    STRICT_AND      reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    AND             reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    STRICT_OR       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    OR              reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    EQUAL           reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    NOT_EQUAL       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    >               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_MUL       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_DIV       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_SUB       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    FLOAT_SUM       reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    <               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    *               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    /               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    -               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    +               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    CONCAT          reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    $end            reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    )               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    OF              reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    THEN            reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    END             reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ELIF            reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ELSE            reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ,               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)
    ]               reduce using rule 109 (binary_op_def -> DEF binary_op ( _4_optional param , _5_optional param _6_optional ) _7_optional do .)


state 387

    (116) _7_optional -> : type .
    DO              reduce using rule 116 (_7_optional -> : type .)


state 388

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param . _11_optional ) _12_optional do
    (128) _11_optional -> . NEWLINE
    (129) _11_optional -> .
    NEWLINE         shift and go to state 394
    )               reduce using rule 129 (_11_optional -> .)

    _11_optional                   shift and go to state 393

state 389

    (147) def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .
    NEWLINE         reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    (               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_MORE      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_MORE_OR_EQ reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_LESS      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_LESS_OR_EQ reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    SOME_SUB        reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    SOME_CONCAT     reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ARROW_BOTH      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ARROW_RIGHT     reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ARROW_LEFT      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    BIT_AND         reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    BIT_OR          reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_POW       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    POW             reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ARRAY_SUB       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ARRAY_CONCAT    reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    MORE_OR_EQ      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    LESS_OR_EQ      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    TEXT_MATCH      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    STRICT_AND      reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    AND             reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    STRICT_OR       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    OR              reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    EQUAL           reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    NOT_EQUAL       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    >               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_MUL       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_DIV       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_SUB       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    FLOAT_SUM       reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    <               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    *               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    /               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    -               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    +               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    CONCAT          reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    $end            reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    )               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    OF              reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    THEN            reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    END             reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ELIF            reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ELSE            reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ,               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)
    ]               reduce using rule 147 (def_expr -> DEF identifier < type_identifier _19_repeat > ( _20_optional _21_optional ) _22_optional do .)


state 390

    (157) _22_optional -> : type .
    DO              reduce using rule 157 (_22_optional -> : type .)


state 391

    (237) patterns -> patterns , _46_optional pattern _47_optional .
    ,               reduce using rule 237 (patterns -> patterns , _46_optional pattern _47_optional .)
    )               reduce using rule 237 (patterns -> patterns , _46_optional pattern _47_optional .)


state 392

    (240) _47_optional -> NEWLINE .
    ,               reduce using rule 240 (_47_optional -> NEWLINE .)
    )               reduce using rule 240 (_47_optional -> NEWLINE .)


state 393

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional . ) _12_optional do
    )               shift and go to state 395


state 394

    (128) _11_optional -> NEWLINE .
    )               reduce using rule 128 (_11_optional -> NEWLINE .)


state 395

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) . _12_optional do
    (130) _12_optional -> . : type
    (131) _12_optional -> .
    :               shift and go to state 397
    DO              reduce using rule 131 (_12_optional -> .)

    _12_optional                   shift and go to state 396

state 396

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional . do
    (132) do -> . DO _13_optional block_statement END
    DO              shift and go to state 38

    do                             shift and go to state 398

state 397

    (130) _12_optional -> : . type
    (167) type -> . type_identifier < type _26_repeat >
    (173) type -> . type_identifier
    (266) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 41

    type                           shift and go to state 399
    type_identifier                shift and go to state 198

state 398

    (118) binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .
    NEWLINE         reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    (               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_MORE      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_MORE_OR_EQ reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_LESS      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_LESS_OR_EQ reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    SOME_SUB        reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    SOME_CONCAT     reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ARROW_BOTH      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ARROW_RIGHT     reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ARROW_LEFT      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    DOUBLE_ARROW_RIGHT reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    DOUBLE_ARROW_LEFT reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    BIT_SHIFT_LEFT  reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    BIT_AND         reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    BIT_OR          reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_POW       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    POW             reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ARRAY_SUB       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ARRAY_CONCAT    reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    MORE_OR_EQ      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    LESS_OR_EQ      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    TEXT_MATCH      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    STRICT_AND      reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    AND             reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    STRICT_OR       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    OR              reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    EQUAL           reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    NOT_EQUAL       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    >               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_MUL       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_DIV       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_SUB       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    FLOAT_SUM       reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    <               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    *               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    /               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    -               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    +               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    CONCAT          reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    $end            reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    )               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    OF              reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    THEN            reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    END             reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ELIF            reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ELSE            reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ,               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)
    ]               reduce using rule 118 (binary_op_def -> DEF binary_op < type_identifier _8_repeat > ( _9_optional param , _10_optional param _11_optional ) _12_optional do .)


state 399

    (130) _12_optional -> : type .
    DO              reduce using rule 130 (_12_optional -> : type .)


Conflicts:

shift/reduce conflict for ( in state 141 resolved as shift
shift/reduce conflict for FLOAT_MORE in state 141 resolved as shift
shift/reduce conflict for FLOAT_MORE_OR_EQ in state 141 resolved as shift
shift/reduce conflict for FLOAT_LESS in state 141 resolved as shift
shift/reduce conflict for FLOAT_LESS_OR_EQ in state 141 resolved as shift
shift/reduce conflict for SOME_SUB in state 141 resolved as shift
shift/reduce conflict for SOME_CONCAT in state 141 resolved as shift
shift/reduce conflict for ARROW_BOTH in state 141 resolved as shift
shift/reduce conflict for ARROW_RIGHT in state 141 resolved as shift
shift/reduce conflict for ARROW_LEFT in state 141 resolved as shift
shift/reduce conflict for DOUBLE_ARROW_RIGHT in state 141 resolved as shift
shift/reduce conflict for DOUBLE_ARROW_LEFT in state 141 resolved as shift
shift/reduce conflict for BIT_SHIFT_LEFT in state 141 resolved as shift
shift/reduce conflict for BIT_AND in state 141 resolved as shift
shift/reduce conflict for BIT_OR in state 141 resolved as shift
shift/reduce conflict for FLOAT_POW in state 141 resolved as shift
shift/reduce conflict for POW in state 141 resolved as shift
shift/reduce conflict for ARRAY_SUB in state 141 resolved as shift
shift/reduce conflict for ARRAY_CONCAT in state 141 resolved as shift
shift/reduce conflict for MORE_OR_EQ in state 141 resolved as shift
shift/reduce conflict for LESS_OR_EQ in state 141 resolved as shift
shift/reduce conflict for TEXT_MATCH in state 141 resolved as shift
shift/reduce conflict for STRICT_AND in state 141 resolved as shift
shift/reduce conflict for AND in state 141 resolved as shift
shift/reduce conflict for STRICT_OR in state 141 resolved as shift
shift/reduce conflict for OR in state 141 resolved as shift
shift/reduce conflict for EQUAL in state 141 resolved as shift
shift/reduce conflict for NOT_EQUAL in state 141 resolved as shift
shift/reduce conflict for > in state 141 resolved as shift
shift/reduce conflict for FLOAT_MUL in state 141 resolved as shift
shift/reduce conflict for FLOAT_DIV in state 141 resolved as shift
shift/reduce conflict for FLOAT_SUB in state 141 resolved as shift
shift/reduce conflict for FLOAT_SUM in state 141 resolved as shift
shift/reduce conflict for < in state 141 resolved as shift
shift/reduce conflict for * in state 141 resolved as shift
shift/reduce conflict for / in state 141 resolved as shift
shift/reduce conflict for - in state 141 resolved as shift
shift/reduce conflict for + in state 141 resolved as shift
shift/reduce conflict for CONCAT in state 141 resolved as shift
shift/reduce conflict for ( in state 142 resolved as shift
shift/reduce conflict for FLOAT_MORE in state 142 resolved as shift
shift/reduce conflict for FLOAT_MORE_OR_EQ in state 142 resolved as shift
shift/reduce conflict for FLOAT_LESS in state 142 resolved as shift
shift/reduce conflict for FLOAT_LESS_OR_EQ in state 142 resolved as shift
shift/reduce conflict for SOME_SUB in state 142 resolved as shift
shift/reduce conflict for SOME_CONCAT in state 142 resolved as shift
shift/reduce conflict for ARROW_BOTH in state 142 resolved as shift
shift/reduce conflict for ARROW_RIGHT in state 142 resolved as shift
shift/reduce conflict for ARROW_LEFT in state 142 resolved as shift
shift/reduce conflict for DOUBLE_ARROW_RIGHT in state 142 resolved as shift
shift/reduce conflict for DOUBLE_ARROW_LEFT in state 142 resolved as shift
shift/reduce conflict for BIT_SHIFT_LEFT in state 142 resolved as shift
shift/reduce conflict for BIT_AND in state 142 resolved as shift
shift/reduce conflict for BIT_OR in state 142 resolved as shift
shift/reduce conflict for FLOAT_POW in state 142 resolved as shift
shift/reduce conflict for POW in state 142 resolved as shift
shift/reduce conflict for ARRAY_SUB in state 142 resolved as shift
shift/reduce conflict for ARRAY_CONCAT in state 142 resolved as shift
shift/reduce conflict for MORE_OR_EQ in state 142 resolved as shift
shift/reduce conflict for LESS_OR_EQ in state 142 resolved as shift
shift/reduce conflict for TEXT_MATCH in state 142 resolved as shift
shift/reduce conflict for STRICT_AND in state 142 resolved as shift
shift/reduce conflict for AND in state 142 resolved as shift
shift/reduce conflict for STRICT_OR in state 142 resolved as shift
shift/reduce conflict for OR in state 142 resolved as shift
shift/reduce conflict for EQUAL in state 142 resolved as shift
shift/reduce conflict for NOT_EQUAL in state 142 resolved as shift
shift/reduce conflict for > in state 142 resolved as shift
shift/reduce conflict for FLOAT_MUL in state 142 resolved as shift
shift/reduce conflict for FLOAT_DIV in state 142 resolved as shift
shift/reduce conflict for FLOAT_SUB in state 142 resolved as shift
shift/reduce conflict for FLOAT_SUM in state 142 resolved as shift
shift/reduce conflict for < in state 142 resolved as shift
shift/reduce conflict for * in state 142 resolved as shift
shift/reduce conflict for / in state 142 resolved as shift
shift/reduce conflict for - in state 142 resolved as shift
shift/reduce conflict for + in state 142 resolved as shift
shift/reduce conflict for CONCAT in state 142 resolved as shift
shift/reduce conflict for ( in state 143 resolved as shift
shift/reduce conflict for FLOAT_MORE in state 143 resolved as shift
shift/reduce conflict for FLOAT_MORE_OR_EQ in state 143 resolved as shift
shift/reduce conflict for FLOAT_LESS in state 143 resolved as shift
shift/reduce conflict for FLOAT_LESS_OR_EQ in state 143 resolved as shift
shift/reduce conflict for SOME_SUB in state 143 resolved as shift
shift/reduce conflict for SOME_CONCAT in state 143 resolved as shift
shift/reduce conflict for ARROW_BOTH in state 143 resolved as shift
shift/reduce conflict for ARROW_RIGHT in state 143 resolved as shift
shift/reduce conflict for ARROW_LEFT in state 143 resolved as shift
shift/reduce conflict for DOUBLE_ARROW_RIGHT in state 143 resolved as shift
shift/reduce conflict for DOUBLE_ARROW_LEFT in state 143 resolved as shift
shift/reduce conflict for BIT_SHIFT_LEFT in state 143 resolved as shift
shift/reduce conflict for BIT_AND in state 143 resolved as shift
shift/reduce conflict for BIT_OR in state 143 resolved as shift
shift/reduce conflict for FLOAT_POW in state 143 resolved as shift
shift/reduce conflict for POW in state 143 resolved as shift
shift/reduce conflict for ARRAY_SUB in state 143 resolved as shift
shift/reduce conflict for ARRAY_CONCAT in state 143 resolved as shift
shift/reduce conflict for MORE_OR_EQ in state 143 resolved as shift
shift/reduce conflict for LESS_OR_EQ in state 143 resolved as shift
shift/reduce conflict for TEXT_MATCH in state 143 resolved as shift
shift/reduce conflict for STRICT_AND in state 143 resolved as shift
shift/reduce conflict for AND in state 143 resolved as shift
shift/reduce conflict for STRICT_OR in state 143 resolved as shift
shift/reduce conflict for OR in state 143 resolved as shift
shift/reduce conflict for EQUAL in state 143 resolved as shift
shift/reduce conflict for NOT_EQUAL in state 143 resolved as shift
shift/reduce conflict for > in state 143 resolved as shift
shift/reduce conflict for FLOAT_MUL in state 143 resolved as shift
shift/reduce conflict for FLOAT_DIV in state 143 resolved as shift
shift/reduce conflict for FLOAT_SUB in state 143 resolved as shift
shift/reduce conflict for FLOAT_SUM in state 143 resolved as shift
shift/reduce conflict for < in state 143 resolved as shift
shift/reduce conflict for * in state 143 resolved as shift
shift/reduce conflict for / in state 143 resolved as shift
shift/reduce conflict for - in state 143 resolved as shift
shift/reduce conflict for + in state 143 resolved as shift
shift/reduce conflict for CONCAT in state 143 resolved as shift
shift/reduce conflict for ( in state 144 resolved as shift
shift/reduce conflict for FLOAT_MORE in state 144 resolved as shift
shift/reduce conflict for FLOAT_MORE_OR_EQ in state 144 resolved as shift
shift/reduce conflict for FLOAT_LESS in state 144 resolved as shift
shift/reduce conflict for FLOAT_LESS_OR_EQ in state 144 resolved as shift
shift/reduce conflict for SOME_SUB in state 144 resolved as shift
shift/reduce conflict for SOME_CONCAT in state 144 resolved as shift
shift/reduce conflict for ARROW_BOTH in state 144 resolved as shift
shift/reduce conflict for ARROW_RIGHT in state 144 resolved as shift
shift/reduce conflict for ARROW_LEFT in state 144 resolved as shift
shift/reduce conflict for DOUBLE_ARROW_RIGHT in state 144 resolved as shift
shift/reduce conflict for DOUBLE_ARROW_LEFT in state 144 resolved as shift
shift/reduce conflict for BIT_SHIFT_LEFT in state 144 resolved as shift
shift/reduce conflict for BIT_AND in state 144 resolved as shift
shift/reduce conflict for BIT_OR in state 144 resolved as shift
shift/reduce conflict for FLOAT_POW in state 144 resolved as shift
shift/reduce conflict for POW in state 144 resolved as shift
shift/reduce conflict for ARRAY_SUB in state 144 resolved as shift
shift/reduce conflict for ARRAY_CONCAT in state 144 resolved as shift
shift/reduce conflict for MORE_OR_EQ in state 144 resolved as shift
shift/reduce conflict for LESS_OR_EQ in state 144 resolved as shift
shift/reduce conflict for TEXT_MATCH in state 144 resolved as shift
shift/reduce conflict for STRICT_AND in state 144 resolved as shift
shift/reduce conflict for AND in state 144 resolved as shift
shift/reduce conflict for STRICT_OR in state 144 resolved as shift
shift/reduce conflict for OR in state 144 resolved as shift
shift/reduce conflict for EQUAL in state 144 resolved as shift
shift/reduce conflict for NOT_EQUAL in state 144 resolved as shift
shift/reduce conflict for > in state 144 resolved as shift
shift/reduce conflict for FLOAT_MUL in state 144 resolved as shift
shift/reduce conflict for FLOAT_DIV in state 144 resolved as shift
shift/reduce conflict for FLOAT_SUB in state 144 resolved as shift
shift/reduce conflict for FLOAT_SUM in state 144 resolved as shift
shift/reduce conflict for < in state 144 resolved as shift
shift/reduce conflict for * in state 144 resolved as shift
shift/reduce conflict for / in state 144 resolved as shift
shift/reduce conflict for - in state 144 resolved as shift
shift/reduce conflict for + in state 144 resolved as shift
shift/reduce conflict for CONCAT in state 144 resolved as shift
reduce/reduce conflict in state 307 resolved using rule _57_item -> , type
rejected rule (_26_item -> , type) in state 307