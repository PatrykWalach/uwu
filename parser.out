Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_optional _2_optional
Rule 2     _1_optional -> NEWLINE
Rule 3     _1_optional -> <empty>
Rule 4     _2_optional -> do_exprs
Rule 5     _2_optional -> <empty>
Rule 6     do_exprs -> expr _3_optional
Rule 7     _3_optional -> NEWLINE
Rule 8     _3_optional -> <empty>
Rule 9     do_exprs -> expr NEWLINE do_exprs
Rule 10    expr -> ( expr )  [precedence=left, level=8]
Rule 11    expr -> unary_expr
Rule 12    expr -> str_literal
Rule 13    expr -> float_literal
Rule 14    expr -> int_literal
Rule 15    expr -> array
Rule 16    expr -> variant_call
Rule 17    expr -> identifier
Rule 18    expr -> let
Rule 19    expr -> call
Rule 20    expr -> case_of
Rule 21    expr -> binary_expr
Rule 22    expr -> if_expr
Rule 23    expr -> def_expr
Rule 24    expr -> do
Rule 25    expr -> external
Rule 26    expr -> enum
Rule 27    unary_expr -> - expr  [precedence=right, level=7]
Rule 28    external -> EXTERNAL
Rule 29    binary_expr -> expr EQUAL expr  [precedence=left, level=2]
Rule 30    binary_expr -> expr NOT_EQUAL expr  [precedence=left, level=2]
Rule 31    binary_expr -> expr | expr  [precedence=right, level=4]
Rule 32    binary_expr -> expr > expr  [precedence=left, level=3]
Rule 33    binary_expr -> expr FLOAT_MUL expr  [precedence=left, level=6]
Rule 34    binary_expr -> expr FLOAT_DIV expr  [precedence=left, level=6]
Rule 35    binary_expr -> expr FLOAT_SUB expr  [precedence=left, level=5]
Rule 36    binary_expr -> expr FLOAT_SUM expr  [precedence=left, level=5]
Rule 37    binary_expr -> expr < expr  [precedence=left, level=3]
Rule 38    binary_expr -> expr * expr  [precedence=left, level=6]
Rule 39    binary_expr -> expr / expr  [precedence=left, level=6]
Rule 40    binary_expr -> expr - expr  [precedence=left, level=5]
Rule 41    binary_expr -> expr + expr  [precedence=left, level=5]
Rule 42    binary_expr -> expr CONCAT expr  [precedence=right, level=4]
Rule 43    do -> DO _4_optional block_statement END
Rule 44    _4_optional -> : type
Rule 45    _4_optional -> <empty>
Rule 46    block_statement -> _5_optional _6_optional
Rule 47    _5_optional -> NEWLINE
Rule 48    _5_optional -> <empty>
Rule 49    _6_optional -> do_exprs
Rule 50    _6_optional -> <empty>
Rule 51    def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do  [precedence=left, level=8]
Rule 52    _7_optional -> NEWLINE
Rule 53    _7_optional -> <empty>
Rule 54    _8_optional -> params
Rule 55    _8_optional -> <empty>
Rule 56    _9_optional -> : type
Rule 57    _9_optional -> <empty>
Rule 58    def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do  [precedence=left, level=8]
Rule 59    _10_repeat -> _10_items
Rule 60    _10_repeat -> <empty>
Rule 61    _10_items -> _10_items _10_item
Rule 62    _10_items -> _10_item
Rule 63    _10_item -> , type_identifier
Rule 64    _11_optional -> NEWLINE
Rule 65    _11_optional -> <empty>
Rule 66    _12_optional -> params
Rule 67    _12_optional -> <empty>
Rule 68    _13_optional -> : type
Rule 69    _13_optional -> <empty>
Rule 70    params -> param _14_optional
Rule 71    _14_optional -> NEWLINE
Rule 72    _14_optional -> <empty>
Rule 73    params -> params , _15_optional param _16_optional
Rule 74    _15_optional -> NEWLINE
Rule 75    _15_optional -> <empty>
Rule 76    _16_optional -> NEWLINE
Rule 77    _16_optional -> <empty>
Rule 78    type -> type_identifier < type _17_repeat >  [precedence=left, level=3]
Rule 79    _17_repeat -> _17_items
Rule 80    _17_repeat -> <empty>
Rule 81    _17_items -> _17_items _17_item
Rule 82    _17_items -> _17_item
Rule 83    _17_item -> , type
Rule 84    type -> type_identifier
Rule 85    enum -> ENUM type_identifier { _18_optional _19_optional }
Rule 86    _18_optional -> NEWLINE
Rule 87    _18_optional -> <empty>
Rule 88    _19_optional -> variants
Rule 89    _19_optional -> <empty>
Rule 90    enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
Rule 91    _20_repeat -> _20_items
Rule 92    _20_repeat -> <empty>
Rule 93    _20_items -> _20_items _20_item
Rule 94    _20_items -> _20_item
Rule 95    _20_item -> , type_identifier
Rule 96    _21_optional -> NEWLINE
Rule 97    _21_optional -> <empty>
Rule 98    _22_optional -> variants
Rule 99    _22_optional -> <empty>
Rule 100   variants -> variant _23_optional
Rule 101   _23_optional -> NEWLINE
Rule 102   _23_optional -> <empty>
Rule 103   variants -> variants variant _24_optional
Rule 104   _24_optional -> NEWLINE
Rule 105   _24_optional -> <empty>
Rule 106   variant -> type_identifier
Rule 107   variant -> type_identifier ( type _25_repeat )  [precedence=left, level=8]
Rule 108   _25_repeat -> _25_items
Rule 109   _25_repeat -> <empty>
Rule 110   _25_items -> _25_items _25_item
Rule 111   _25_items -> _25_item
Rule 112   _25_item -> , type
Rule 113   param -> identifier _26_optional
Rule 114   _26_optional -> : type
Rule 115   _26_optional -> <empty>
Rule 116   if_expr -> IF expr THEN _27_optional block_statement _28_optional END
Rule 117   _27_optional -> : type
Rule 118   _27_optional -> <empty>
Rule 119   _28_optional -> or_else
Rule 120   _28_optional -> <empty>
Rule 121   or_else -> ELIF expr THEN block_statement _29_optional
Rule 122   _29_optional -> or_else
Rule 123   _29_optional -> <empty>
Rule 124   or_else -> ELSE block_statement
Rule 125   case_of -> CASE expr OF _30_optional _31_optional END
Rule 126   _30_optional -> NEWLINE
Rule 127   _30_optional -> <empty>
Rule 128   _31_optional -> cases
Rule 129   _31_optional -> <empty>
Rule 130   cases -> pattern do _32_optional
Rule 131   _32_optional -> NEWLINE
Rule 132   _32_optional -> <empty>
Rule 133   cases -> cases pattern do _33_optional
Rule 134   _33_optional -> NEWLINE
Rule 135   _33_optional -> <empty>
Rule 136   pattern -> match_variant
Rule 137   pattern -> match_as
Rule 138   match_as -> identifier
Rule 139   match_variant -> type_identifier
Rule 140   match_variant -> type_identifier ( _34_optional _35_optional )  [precedence=left, level=8]
Rule 141   _34_optional -> NEWLINE
Rule 142   _34_optional -> <empty>
Rule 143   _35_optional -> patterns
Rule 144   _35_optional -> <empty>
Rule 145   patterns -> pattern _36_optional
Rule 146   _36_optional -> NEWLINE
Rule 147   _36_optional -> <empty>
Rule 148   patterns -> patterns , _37_optional pattern _38_optional
Rule 149   _37_optional -> NEWLINE
Rule 150   _37_optional -> <empty>
Rule 151   _38_optional -> NEWLINE
Rule 152   _38_optional -> <empty>
Rule 153   array -> [ _39_optional _40_optional ]
Rule 154   _39_optional -> NEWLINE
Rule 155   _39_optional -> <empty>
Rule 156   _40_optional -> exprs
Rule 157   _40_optional -> <empty>
Rule 158   call -> expr ( _41_optional _42_optional )  [precedence=left, level=8]
Rule 159   _41_optional -> NEWLINE
Rule 160   _41_optional -> <empty>
Rule 161   _42_optional -> exprs
Rule 162   _42_optional -> <empty>
Rule 163   variant_call -> type_identifier ( _43_optional _44_optional )  [precedence=left, level=8]
Rule 164   _43_optional -> NEWLINE
Rule 165   _43_optional -> <empty>
Rule 166   _44_optional -> exprs
Rule 167   _44_optional -> <empty>
Rule 168   exprs -> expr _45_optional
Rule 169   _45_optional -> NEWLINE
Rule 170   _45_optional -> <empty>
Rule 171   exprs -> exprs , _46_optional expr _47_optional
Rule 172   _46_optional -> NEWLINE
Rule 173   _46_optional -> <empty>
Rule 174   _47_optional -> NEWLINE
Rule 175   _47_optional -> <empty>
Rule 176   identifier -> IDENTIFIER
Rule 177   type_identifier -> TYPE_IDENTIFIER
Rule 178   let -> identifier _48_optional = expr  [precedence=right, level=1]
Rule 179   _48_optional -> : type
Rule 180   _48_optional -> <empty>
Rule 181   int_literal -> INT
Rule 182   float_literal -> FLOAT
Rule 183   str_literal -> STRING

Terminals, with rules where they appear:

(                    : 10 51 58 107 140 158 163
)                    : 10 51 58 107 140 158 163
*                    : 38
+                    : 41
,                    : 63 73 83 95 112 148 171
-                    : 27 40
/                    : 39
:                    : 44 56 68 114 117 179
<                    : 37 58 78 90
=                    : 178
>                    : 32 58 78 90
CASE                 : 125
CONCAT               : 42
DEF                  : 51 58
DO                   : 43
ELIF                 : 121
ELSE                 : 124
END                  : 43 116 125
ENUM                 : 85 90
EQUAL                : 29
EXTERNAL             : 28
FLOAT                : 182
FLOAT_DIV            : 34
FLOAT_MUL            : 33
FLOAT_SUB            : 35
FLOAT_SUM            : 36
IDENTIFIER           : 176
IF                   : 116
INT                  : 181
NEWLINE              : 2 7 9 47 52 64 71 74 76 86 96 101 104 126 131 134 141 146 149 151 154 159 164 169 172 174
NOT_EQUAL            : 30
OF                   : 125
STRING               : 183
THEN                 : 116 121
TYPE_IDENTIFIER      : 177
[                    : 153
]                    : 153
error                : 
{                    : 85 90
|                    : 31
}                    : 85 90

Nonterminals, with rules where they appear:

_10_item             : 61 62
_10_items            : 59 61
_10_repeat           : 58
_11_optional         : 58
_12_optional         : 58
_13_optional         : 58
_14_optional         : 70
_15_optional         : 73
_16_optional         : 73
_17_item             : 81 82
_17_items            : 79 81
_17_repeat           : 78
_18_optional         : 85
_19_optional         : 85
_1_optional          : 1
_20_item             : 93 94
_20_items            : 91 93
_20_repeat           : 90
_21_optional         : 90
_22_optional         : 90
_23_optional         : 100
_24_optional         : 103
_25_item             : 110 111
_25_items            : 108 110
_25_repeat           : 107
_26_optional         : 113
_27_optional         : 116
_28_optional         : 116
_29_optional         : 121
_2_optional          : 1
_30_optional         : 125
_31_optional         : 125
_32_optional         : 130
_33_optional         : 133
_34_optional         : 140
_35_optional         : 140
_36_optional         : 145
_37_optional         : 148
_38_optional         : 148
_39_optional         : 153
_3_optional          : 6
_40_optional         : 153
_41_optional         : 158
_42_optional         : 158
_43_optional         : 163
_44_optional         : 163
_45_optional         : 168
_46_optional         : 171
_47_optional         : 171
_48_optional         : 178
_4_optional          : 43
_5_optional          : 46
_6_optional          : 46
_7_optional          : 51
_8_optional          : 51
_9_optional          : 51
array                : 15
binary_expr          : 21
block_statement      : 43 116 121 124
call                 : 19
case_of              : 20
cases                : 128 133
def_expr             : 23
do                   : 24 51 58 130 133
do_exprs             : 4 9 49
enum                 : 26
expr                 : 6 9 10 27 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 116 121 125 158 168 171 178
exprs                : 156 161 166 171
external             : 25
float_literal        : 13
identifier           : 17 51 58 113 138 178
if_expr              : 22
int_literal          : 14
let                  : 18
match_as             : 137
match_variant        : 136
or_else              : 119 122
param                : 70 73
params               : 54 66 73
pattern              : 130 133 145 148
patterns             : 143 148
program              : 0
str_literal          : 12
type                 : 44 56 68 78 83 107 112 114 117 179
type_identifier      : 58 63 78 84 85 90 90 95 106 107 139 140 163
unary_expr           : 11
variant              : 100 103
variant_call         : 16
variants             : 88 98 103


state 0

    (0) S' -> . program
    (1) program -> . _1_optional _2_optional
    (2) _1_optional -> . NEWLINE
    (3) _1_optional -> .
    NEWLINE         shift and go to state 3
    (               reduce using rule 3 (_1_optional -> .)
    -               reduce using rule 3 (_1_optional -> .)
    STRING          reduce using rule 3 (_1_optional -> .)
    FLOAT           reduce using rule 3 (_1_optional -> .)
    INT             reduce using rule 3 (_1_optional -> .)
    [               reduce using rule 3 (_1_optional -> .)
    IDENTIFIER      reduce using rule 3 (_1_optional -> .)
    CASE            reduce using rule 3 (_1_optional -> .)
    IF              reduce using rule 3 (_1_optional -> .)
    DEF             reduce using rule 3 (_1_optional -> .)
    DO              reduce using rule 3 (_1_optional -> .)
    EXTERNAL        reduce using rule 3 (_1_optional -> .)
    ENUM            reduce using rule 3 (_1_optional -> .)
    TYPE_IDENTIFIER reduce using rule 3 (_1_optional -> .)
    $end            reduce using rule 3 (_1_optional -> .)

    program                        shift and go to state 1
    _1_optional                    shift and go to state 2

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_optional . _2_optional
    (4) _2_optional -> . do_exprs
    (5) _2_optional -> .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 5 (_2_optional -> .)
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    _2_optional                    shift and go to state 4
    do_exprs                       shift and go to state 5
    expr                           shift and go to state 6
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 3

    (2) _1_optional -> NEWLINE .
    (               reduce using rule 2 (_1_optional -> NEWLINE .)
    -               reduce using rule 2 (_1_optional -> NEWLINE .)
    STRING          reduce using rule 2 (_1_optional -> NEWLINE .)
    FLOAT           reduce using rule 2 (_1_optional -> NEWLINE .)
    INT             reduce using rule 2 (_1_optional -> NEWLINE .)
    [               reduce using rule 2 (_1_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 2 (_1_optional -> NEWLINE .)
    CASE            reduce using rule 2 (_1_optional -> NEWLINE .)
    IF              reduce using rule 2 (_1_optional -> NEWLINE .)
    DEF             reduce using rule 2 (_1_optional -> NEWLINE .)
    DO              reduce using rule 2 (_1_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 2 (_1_optional -> NEWLINE .)
    ENUM            reduce using rule 2 (_1_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 2 (_1_optional -> NEWLINE .)
    $end            reduce using rule 2 (_1_optional -> NEWLINE .)


state 4

    (1) program -> _1_optional _2_optional .
    $end            reduce using rule 1 (program -> _1_optional _2_optional .)


state 5

    (4) _2_optional -> do_exprs .
    $end            reduce using rule 4 (_2_optional -> do_exprs .)


state 6

    (6) do_exprs -> expr . _3_optional
    (9) do_exprs -> expr . NEWLINE do_exprs
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    (7) _3_optional -> . NEWLINE
    (8) _3_optional -> .
    NEWLINE         shift and go to state 39
    (               shift and go to state 40
    EQUAL           shift and go to state 41
    NOT_EQUAL       shift and go to state 42
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54
    $end            reduce using rule 8 (_3_optional -> .)
    END             reduce using rule 8 (_3_optional -> .)
    ELIF            reduce using rule 8 (_3_optional -> .)
    ELSE            reduce using rule 8 (_3_optional -> .)

    _3_optional                    shift and go to state 38

state 7

    (10) expr -> ( . expr )
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 55
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 8

    (11) expr -> unary_expr .
    NEWLINE         reduce using rule 11 (expr -> unary_expr .)
    (               reduce using rule 11 (expr -> unary_expr .)
    EQUAL           reduce using rule 11 (expr -> unary_expr .)
    NOT_EQUAL       reduce using rule 11 (expr -> unary_expr .)
    |               reduce using rule 11 (expr -> unary_expr .)
    >               reduce using rule 11 (expr -> unary_expr .)
    FLOAT_MUL       reduce using rule 11 (expr -> unary_expr .)
    FLOAT_DIV       reduce using rule 11 (expr -> unary_expr .)
    FLOAT_SUB       reduce using rule 11 (expr -> unary_expr .)
    FLOAT_SUM       reduce using rule 11 (expr -> unary_expr .)
    <               reduce using rule 11 (expr -> unary_expr .)
    *               reduce using rule 11 (expr -> unary_expr .)
    /               reduce using rule 11 (expr -> unary_expr .)
    -               reduce using rule 11 (expr -> unary_expr .)
    +               reduce using rule 11 (expr -> unary_expr .)
    CONCAT          reduce using rule 11 (expr -> unary_expr .)
    $end            reduce using rule 11 (expr -> unary_expr .)
    )               reduce using rule 11 (expr -> unary_expr .)
    OF              reduce using rule 11 (expr -> unary_expr .)
    THEN            reduce using rule 11 (expr -> unary_expr .)
    END             reduce using rule 11 (expr -> unary_expr .)
    ELIF            reduce using rule 11 (expr -> unary_expr .)
    ELSE            reduce using rule 11 (expr -> unary_expr .)
    ,               reduce using rule 11 (expr -> unary_expr .)
    ]               reduce using rule 11 (expr -> unary_expr .)


state 9

    (12) expr -> str_literal .
    NEWLINE         reduce using rule 12 (expr -> str_literal .)
    (               reduce using rule 12 (expr -> str_literal .)
    EQUAL           reduce using rule 12 (expr -> str_literal .)
    NOT_EQUAL       reduce using rule 12 (expr -> str_literal .)
    |               reduce using rule 12 (expr -> str_literal .)
    >               reduce using rule 12 (expr -> str_literal .)
    FLOAT_MUL       reduce using rule 12 (expr -> str_literal .)
    FLOAT_DIV       reduce using rule 12 (expr -> str_literal .)
    FLOAT_SUB       reduce using rule 12 (expr -> str_literal .)
    FLOAT_SUM       reduce using rule 12 (expr -> str_literal .)
    <               reduce using rule 12 (expr -> str_literal .)
    *               reduce using rule 12 (expr -> str_literal .)
    /               reduce using rule 12 (expr -> str_literal .)
    -               reduce using rule 12 (expr -> str_literal .)
    +               reduce using rule 12 (expr -> str_literal .)
    CONCAT          reduce using rule 12 (expr -> str_literal .)
    $end            reduce using rule 12 (expr -> str_literal .)
    )               reduce using rule 12 (expr -> str_literal .)
    OF              reduce using rule 12 (expr -> str_literal .)
    THEN            reduce using rule 12 (expr -> str_literal .)
    END             reduce using rule 12 (expr -> str_literal .)
    ELIF            reduce using rule 12 (expr -> str_literal .)
    ELSE            reduce using rule 12 (expr -> str_literal .)
    ,               reduce using rule 12 (expr -> str_literal .)
    ]               reduce using rule 12 (expr -> str_literal .)


state 10

    (13) expr -> float_literal .
    NEWLINE         reduce using rule 13 (expr -> float_literal .)
    (               reduce using rule 13 (expr -> float_literal .)
    EQUAL           reduce using rule 13 (expr -> float_literal .)
    NOT_EQUAL       reduce using rule 13 (expr -> float_literal .)
    |               reduce using rule 13 (expr -> float_literal .)
    >               reduce using rule 13 (expr -> float_literal .)
    FLOAT_MUL       reduce using rule 13 (expr -> float_literal .)
    FLOAT_DIV       reduce using rule 13 (expr -> float_literal .)
    FLOAT_SUB       reduce using rule 13 (expr -> float_literal .)
    FLOAT_SUM       reduce using rule 13 (expr -> float_literal .)
    <               reduce using rule 13 (expr -> float_literal .)
    *               reduce using rule 13 (expr -> float_literal .)
    /               reduce using rule 13 (expr -> float_literal .)
    -               reduce using rule 13 (expr -> float_literal .)
    +               reduce using rule 13 (expr -> float_literal .)
    CONCAT          reduce using rule 13 (expr -> float_literal .)
    $end            reduce using rule 13 (expr -> float_literal .)
    )               reduce using rule 13 (expr -> float_literal .)
    OF              reduce using rule 13 (expr -> float_literal .)
    THEN            reduce using rule 13 (expr -> float_literal .)
    END             reduce using rule 13 (expr -> float_literal .)
    ELIF            reduce using rule 13 (expr -> float_literal .)
    ELSE            reduce using rule 13 (expr -> float_literal .)
    ,               reduce using rule 13 (expr -> float_literal .)
    ]               reduce using rule 13 (expr -> float_literal .)


state 11

    (14) expr -> int_literal .
    NEWLINE         reduce using rule 14 (expr -> int_literal .)
    (               reduce using rule 14 (expr -> int_literal .)
    EQUAL           reduce using rule 14 (expr -> int_literal .)
    NOT_EQUAL       reduce using rule 14 (expr -> int_literal .)
    |               reduce using rule 14 (expr -> int_literal .)
    >               reduce using rule 14 (expr -> int_literal .)
    FLOAT_MUL       reduce using rule 14 (expr -> int_literal .)
    FLOAT_DIV       reduce using rule 14 (expr -> int_literal .)
    FLOAT_SUB       reduce using rule 14 (expr -> int_literal .)
    FLOAT_SUM       reduce using rule 14 (expr -> int_literal .)
    <               reduce using rule 14 (expr -> int_literal .)
    *               reduce using rule 14 (expr -> int_literal .)
    /               reduce using rule 14 (expr -> int_literal .)
    -               reduce using rule 14 (expr -> int_literal .)
    +               reduce using rule 14 (expr -> int_literal .)
    CONCAT          reduce using rule 14 (expr -> int_literal .)
    $end            reduce using rule 14 (expr -> int_literal .)
    )               reduce using rule 14 (expr -> int_literal .)
    OF              reduce using rule 14 (expr -> int_literal .)
    THEN            reduce using rule 14 (expr -> int_literal .)
    END             reduce using rule 14 (expr -> int_literal .)
    ELIF            reduce using rule 14 (expr -> int_literal .)
    ELSE            reduce using rule 14 (expr -> int_literal .)
    ,               reduce using rule 14 (expr -> int_literal .)
    ]               reduce using rule 14 (expr -> int_literal .)


state 12

    (15) expr -> array .
    NEWLINE         reduce using rule 15 (expr -> array .)
    (               reduce using rule 15 (expr -> array .)
    EQUAL           reduce using rule 15 (expr -> array .)
    NOT_EQUAL       reduce using rule 15 (expr -> array .)
    |               reduce using rule 15 (expr -> array .)
    >               reduce using rule 15 (expr -> array .)
    FLOAT_MUL       reduce using rule 15 (expr -> array .)
    FLOAT_DIV       reduce using rule 15 (expr -> array .)
    FLOAT_SUB       reduce using rule 15 (expr -> array .)
    FLOAT_SUM       reduce using rule 15 (expr -> array .)
    <               reduce using rule 15 (expr -> array .)
    *               reduce using rule 15 (expr -> array .)
    /               reduce using rule 15 (expr -> array .)
    -               reduce using rule 15 (expr -> array .)
    +               reduce using rule 15 (expr -> array .)
    CONCAT          reduce using rule 15 (expr -> array .)
    $end            reduce using rule 15 (expr -> array .)
    )               reduce using rule 15 (expr -> array .)
    OF              reduce using rule 15 (expr -> array .)
    THEN            reduce using rule 15 (expr -> array .)
    END             reduce using rule 15 (expr -> array .)
    ELIF            reduce using rule 15 (expr -> array .)
    ELSE            reduce using rule 15 (expr -> array .)
    ,               reduce using rule 15 (expr -> array .)
    ]               reduce using rule 15 (expr -> array .)


state 13

    (16) expr -> variant_call .
    NEWLINE         reduce using rule 16 (expr -> variant_call .)
    (               reduce using rule 16 (expr -> variant_call .)
    EQUAL           reduce using rule 16 (expr -> variant_call .)
    NOT_EQUAL       reduce using rule 16 (expr -> variant_call .)
    |               reduce using rule 16 (expr -> variant_call .)
    >               reduce using rule 16 (expr -> variant_call .)
    FLOAT_MUL       reduce using rule 16 (expr -> variant_call .)
    FLOAT_DIV       reduce using rule 16 (expr -> variant_call .)
    FLOAT_SUB       reduce using rule 16 (expr -> variant_call .)
    FLOAT_SUM       reduce using rule 16 (expr -> variant_call .)
    <               reduce using rule 16 (expr -> variant_call .)
    *               reduce using rule 16 (expr -> variant_call .)
    /               reduce using rule 16 (expr -> variant_call .)
    -               reduce using rule 16 (expr -> variant_call .)
    +               reduce using rule 16 (expr -> variant_call .)
    CONCAT          reduce using rule 16 (expr -> variant_call .)
    $end            reduce using rule 16 (expr -> variant_call .)
    )               reduce using rule 16 (expr -> variant_call .)
    OF              reduce using rule 16 (expr -> variant_call .)
    THEN            reduce using rule 16 (expr -> variant_call .)
    END             reduce using rule 16 (expr -> variant_call .)
    ELIF            reduce using rule 16 (expr -> variant_call .)
    ELSE            reduce using rule 16 (expr -> variant_call .)
    ,               reduce using rule 16 (expr -> variant_call .)
    ]               reduce using rule 16 (expr -> variant_call .)


state 14

    (17) expr -> identifier .
    (178) let -> identifier . _48_optional = expr
    (179) _48_optional -> . : type
    (180) _48_optional -> .
    NEWLINE         reduce using rule 17 (expr -> identifier .)
    (               reduce using rule 17 (expr -> identifier .)
    EQUAL           reduce using rule 17 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 17 (expr -> identifier .)
    |               reduce using rule 17 (expr -> identifier .)
    >               reduce using rule 17 (expr -> identifier .)
    FLOAT_MUL       reduce using rule 17 (expr -> identifier .)
    FLOAT_DIV       reduce using rule 17 (expr -> identifier .)
    FLOAT_SUB       reduce using rule 17 (expr -> identifier .)
    FLOAT_SUM       reduce using rule 17 (expr -> identifier .)
    <               reduce using rule 17 (expr -> identifier .)
    *               reduce using rule 17 (expr -> identifier .)
    /               reduce using rule 17 (expr -> identifier .)
    -               reduce using rule 17 (expr -> identifier .)
    +               reduce using rule 17 (expr -> identifier .)
    CONCAT          reduce using rule 17 (expr -> identifier .)
    $end            reduce using rule 17 (expr -> identifier .)
    )               reduce using rule 17 (expr -> identifier .)
    OF              reduce using rule 17 (expr -> identifier .)
    THEN            reduce using rule 17 (expr -> identifier .)
    END             reduce using rule 17 (expr -> identifier .)
    ELIF            reduce using rule 17 (expr -> identifier .)
    ELSE            reduce using rule 17 (expr -> identifier .)
    ,               reduce using rule 17 (expr -> identifier .)
    ]               reduce using rule 17 (expr -> identifier .)
    :               shift and go to state 57
    =               reduce using rule 180 (_48_optional -> .)

    _48_optional                   shift and go to state 56

state 15

    (18) expr -> let .
    NEWLINE         reduce using rule 18 (expr -> let .)
    (               reduce using rule 18 (expr -> let .)
    EQUAL           reduce using rule 18 (expr -> let .)
    NOT_EQUAL       reduce using rule 18 (expr -> let .)
    |               reduce using rule 18 (expr -> let .)
    >               reduce using rule 18 (expr -> let .)
    FLOAT_MUL       reduce using rule 18 (expr -> let .)
    FLOAT_DIV       reduce using rule 18 (expr -> let .)
    FLOAT_SUB       reduce using rule 18 (expr -> let .)
    FLOAT_SUM       reduce using rule 18 (expr -> let .)
    <               reduce using rule 18 (expr -> let .)
    *               reduce using rule 18 (expr -> let .)
    /               reduce using rule 18 (expr -> let .)
    -               reduce using rule 18 (expr -> let .)
    +               reduce using rule 18 (expr -> let .)
    CONCAT          reduce using rule 18 (expr -> let .)
    $end            reduce using rule 18 (expr -> let .)
    )               reduce using rule 18 (expr -> let .)
    OF              reduce using rule 18 (expr -> let .)
    THEN            reduce using rule 18 (expr -> let .)
    END             reduce using rule 18 (expr -> let .)
    ELIF            reduce using rule 18 (expr -> let .)
    ELSE            reduce using rule 18 (expr -> let .)
    ,               reduce using rule 18 (expr -> let .)
    ]               reduce using rule 18 (expr -> let .)


state 16

    (19) expr -> call .
    NEWLINE         reduce using rule 19 (expr -> call .)
    (               reduce using rule 19 (expr -> call .)
    EQUAL           reduce using rule 19 (expr -> call .)
    NOT_EQUAL       reduce using rule 19 (expr -> call .)
    |               reduce using rule 19 (expr -> call .)
    >               reduce using rule 19 (expr -> call .)
    FLOAT_MUL       reduce using rule 19 (expr -> call .)
    FLOAT_DIV       reduce using rule 19 (expr -> call .)
    FLOAT_SUB       reduce using rule 19 (expr -> call .)
    FLOAT_SUM       reduce using rule 19 (expr -> call .)
    <               reduce using rule 19 (expr -> call .)
    *               reduce using rule 19 (expr -> call .)
    /               reduce using rule 19 (expr -> call .)
    -               reduce using rule 19 (expr -> call .)
    +               reduce using rule 19 (expr -> call .)
    CONCAT          reduce using rule 19 (expr -> call .)
    $end            reduce using rule 19 (expr -> call .)
    )               reduce using rule 19 (expr -> call .)
    OF              reduce using rule 19 (expr -> call .)
    THEN            reduce using rule 19 (expr -> call .)
    END             reduce using rule 19 (expr -> call .)
    ELIF            reduce using rule 19 (expr -> call .)
    ELSE            reduce using rule 19 (expr -> call .)
    ,               reduce using rule 19 (expr -> call .)
    ]               reduce using rule 19 (expr -> call .)


state 17

    (20) expr -> case_of .
    NEWLINE         reduce using rule 20 (expr -> case_of .)
    (               reduce using rule 20 (expr -> case_of .)
    EQUAL           reduce using rule 20 (expr -> case_of .)
    NOT_EQUAL       reduce using rule 20 (expr -> case_of .)
    |               reduce using rule 20 (expr -> case_of .)
    >               reduce using rule 20 (expr -> case_of .)
    FLOAT_MUL       reduce using rule 20 (expr -> case_of .)
    FLOAT_DIV       reduce using rule 20 (expr -> case_of .)
    FLOAT_SUB       reduce using rule 20 (expr -> case_of .)
    FLOAT_SUM       reduce using rule 20 (expr -> case_of .)
    <               reduce using rule 20 (expr -> case_of .)
    *               reduce using rule 20 (expr -> case_of .)
    /               reduce using rule 20 (expr -> case_of .)
    -               reduce using rule 20 (expr -> case_of .)
    +               reduce using rule 20 (expr -> case_of .)
    CONCAT          reduce using rule 20 (expr -> case_of .)
    $end            reduce using rule 20 (expr -> case_of .)
    )               reduce using rule 20 (expr -> case_of .)
    OF              reduce using rule 20 (expr -> case_of .)
    THEN            reduce using rule 20 (expr -> case_of .)
    END             reduce using rule 20 (expr -> case_of .)
    ELIF            reduce using rule 20 (expr -> case_of .)
    ELSE            reduce using rule 20 (expr -> case_of .)
    ,               reduce using rule 20 (expr -> case_of .)
    ]               reduce using rule 20 (expr -> case_of .)


state 18

    (21) expr -> binary_expr .
    NEWLINE         reduce using rule 21 (expr -> binary_expr .)
    (               reduce using rule 21 (expr -> binary_expr .)
    EQUAL           reduce using rule 21 (expr -> binary_expr .)
    NOT_EQUAL       reduce using rule 21 (expr -> binary_expr .)
    |               reduce using rule 21 (expr -> binary_expr .)
    >               reduce using rule 21 (expr -> binary_expr .)
    FLOAT_MUL       reduce using rule 21 (expr -> binary_expr .)
    FLOAT_DIV       reduce using rule 21 (expr -> binary_expr .)
    FLOAT_SUB       reduce using rule 21 (expr -> binary_expr .)
    FLOAT_SUM       reduce using rule 21 (expr -> binary_expr .)
    <               reduce using rule 21 (expr -> binary_expr .)
    *               reduce using rule 21 (expr -> binary_expr .)
    /               reduce using rule 21 (expr -> binary_expr .)
    -               reduce using rule 21 (expr -> binary_expr .)
    +               reduce using rule 21 (expr -> binary_expr .)
    CONCAT          reduce using rule 21 (expr -> binary_expr .)
    $end            reduce using rule 21 (expr -> binary_expr .)
    )               reduce using rule 21 (expr -> binary_expr .)
    OF              reduce using rule 21 (expr -> binary_expr .)
    THEN            reduce using rule 21 (expr -> binary_expr .)
    END             reduce using rule 21 (expr -> binary_expr .)
    ELIF            reduce using rule 21 (expr -> binary_expr .)
    ELSE            reduce using rule 21 (expr -> binary_expr .)
    ,               reduce using rule 21 (expr -> binary_expr .)
    ]               reduce using rule 21 (expr -> binary_expr .)


state 19

    (22) expr -> if_expr .
    NEWLINE         reduce using rule 22 (expr -> if_expr .)
    (               reduce using rule 22 (expr -> if_expr .)
    EQUAL           reduce using rule 22 (expr -> if_expr .)
    NOT_EQUAL       reduce using rule 22 (expr -> if_expr .)
    |               reduce using rule 22 (expr -> if_expr .)
    >               reduce using rule 22 (expr -> if_expr .)
    FLOAT_MUL       reduce using rule 22 (expr -> if_expr .)
    FLOAT_DIV       reduce using rule 22 (expr -> if_expr .)
    FLOAT_SUB       reduce using rule 22 (expr -> if_expr .)
    FLOAT_SUM       reduce using rule 22 (expr -> if_expr .)
    <               reduce using rule 22 (expr -> if_expr .)
    *               reduce using rule 22 (expr -> if_expr .)
    /               reduce using rule 22 (expr -> if_expr .)
    -               reduce using rule 22 (expr -> if_expr .)
    +               reduce using rule 22 (expr -> if_expr .)
    CONCAT          reduce using rule 22 (expr -> if_expr .)
    $end            reduce using rule 22 (expr -> if_expr .)
    )               reduce using rule 22 (expr -> if_expr .)
    OF              reduce using rule 22 (expr -> if_expr .)
    THEN            reduce using rule 22 (expr -> if_expr .)
    END             reduce using rule 22 (expr -> if_expr .)
    ELIF            reduce using rule 22 (expr -> if_expr .)
    ELSE            reduce using rule 22 (expr -> if_expr .)
    ,               reduce using rule 22 (expr -> if_expr .)
    ]               reduce using rule 22 (expr -> if_expr .)


state 20

    (23) expr -> def_expr .
    NEWLINE         reduce using rule 23 (expr -> def_expr .)
    (               reduce using rule 23 (expr -> def_expr .)
    EQUAL           reduce using rule 23 (expr -> def_expr .)
    NOT_EQUAL       reduce using rule 23 (expr -> def_expr .)
    |               reduce using rule 23 (expr -> def_expr .)
    >               reduce using rule 23 (expr -> def_expr .)
    FLOAT_MUL       reduce using rule 23 (expr -> def_expr .)
    FLOAT_DIV       reduce using rule 23 (expr -> def_expr .)
    FLOAT_SUB       reduce using rule 23 (expr -> def_expr .)
    FLOAT_SUM       reduce using rule 23 (expr -> def_expr .)
    <               reduce using rule 23 (expr -> def_expr .)
    *               reduce using rule 23 (expr -> def_expr .)
    /               reduce using rule 23 (expr -> def_expr .)
    -               reduce using rule 23 (expr -> def_expr .)
    +               reduce using rule 23 (expr -> def_expr .)
    CONCAT          reduce using rule 23 (expr -> def_expr .)
    $end            reduce using rule 23 (expr -> def_expr .)
    )               reduce using rule 23 (expr -> def_expr .)
    OF              reduce using rule 23 (expr -> def_expr .)
    THEN            reduce using rule 23 (expr -> def_expr .)
    END             reduce using rule 23 (expr -> def_expr .)
    ELIF            reduce using rule 23 (expr -> def_expr .)
    ELSE            reduce using rule 23 (expr -> def_expr .)
    ,               reduce using rule 23 (expr -> def_expr .)
    ]               reduce using rule 23 (expr -> def_expr .)


state 21

    (24) expr -> do .
    NEWLINE         reduce using rule 24 (expr -> do .)
    (               reduce using rule 24 (expr -> do .)
    EQUAL           reduce using rule 24 (expr -> do .)
    NOT_EQUAL       reduce using rule 24 (expr -> do .)
    |               reduce using rule 24 (expr -> do .)
    >               reduce using rule 24 (expr -> do .)
    FLOAT_MUL       reduce using rule 24 (expr -> do .)
    FLOAT_DIV       reduce using rule 24 (expr -> do .)
    FLOAT_SUB       reduce using rule 24 (expr -> do .)
    FLOAT_SUM       reduce using rule 24 (expr -> do .)
    <               reduce using rule 24 (expr -> do .)
    *               reduce using rule 24 (expr -> do .)
    /               reduce using rule 24 (expr -> do .)
    -               reduce using rule 24 (expr -> do .)
    +               reduce using rule 24 (expr -> do .)
    CONCAT          reduce using rule 24 (expr -> do .)
    $end            reduce using rule 24 (expr -> do .)
    )               reduce using rule 24 (expr -> do .)
    OF              reduce using rule 24 (expr -> do .)
    THEN            reduce using rule 24 (expr -> do .)
    END             reduce using rule 24 (expr -> do .)
    ELIF            reduce using rule 24 (expr -> do .)
    ELSE            reduce using rule 24 (expr -> do .)
    ,               reduce using rule 24 (expr -> do .)
    ]               reduce using rule 24 (expr -> do .)


state 22

    (25) expr -> external .
    NEWLINE         reduce using rule 25 (expr -> external .)
    (               reduce using rule 25 (expr -> external .)
    EQUAL           reduce using rule 25 (expr -> external .)
    NOT_EQUAL       reduce using rule 25 (expr -> external .)
    |               reduce using rule 25 (expr -> external .)
    >               reduce using rule 25 (expr -> external .)
    FLOAT_MUL       reduce using rule 25 (expr -> external .)
    FLOAT_DIV       reduce using rule 25 (expr -> external .)
    FLOAT_SUB       reduce using rule 25 (expr -> external .)
    FLOAT_SUM       reduce using rule 25 (expr -> external .)
    <               reduce using rule 25 (expr -> external .)
    *               reduce using rule 25 (expr -> external .)
    /               reduce using rule 25 (expr -> external .)
    -               reduce using rule 25 (expr -> external .)
    +               reduce using rule 25 (expr -> external .)
    CONCAT          reduce using rule 25 (expr -> external .)
    $end            reduce using rule 25 (expr -> external .)
    )               reduce using rule 25 (expr -> external .)
    OF              reduce using rule 25 (expr -> external .)
    THEN            reduce using rule 25 (expr -> external .)
    END             reduce using rule 25 (expr -> external .)
    ELIF            reduce using rule 25 (expr -> external .)
    ELSE            reduce using rule 25 (expr -> external .)
    ,               reduce using rule 25 (expr -> external .)
    ]               reduce using rule 25 (expr -> external .)


state 23

    (26) expr -> enum .
    NEWLINE         reduce using rule 26 (expr -> enum .)
    (               reduce using rule 26 (expr -> enum .)
    EQUAL           reduce using rule 26 (expr -> enum .)
    NOT_EQUAL       reduce using rule 26 (expr -> enum .)
    |               reduce using rule 26 (expr -> enum .)
    >               reduce using rule 26 (expr -> enum .)
    FLOAT_MUL       reduce using rule 26 (expr -> enum .)
    FLOAT_DIV       reduce using rule 26 (expr -> enum .)
    FLOAT_SUB       reduce using rule 26 (expr -> enum .)
    FLOAT_SUM       reduce using rule 26 (expr -> enum .)
    <               reduce using rule 26 (expr -> enum .)
    *               reduce using rule 26 (expr -> enum .)
    /               reduce using rule 26 (expr -> enum .)
    -               reduce using rule 26 (expr -> enum .)
    +               reduce using rule 26 (expr -> enum .)
    CONCAT          reduce using rule 26 (expr -> enum .)
    $end            reduce using rule 26 (expr -> enum .)
    )               reduce using rule 26 (expr -> enum .)
    OF              reduce using rule 26 (expr -> enum .)
    THEN            reduce using rule 26 (expr -> enum .)
    END             reduce using rule 26 (expr -> enum .)
    ELIF            reduce using rule 26 (expr -> enum .)
    ELSE            reduce using rule 26 (expr -> enum .)
    ,               reduce using rule 26 (expr -> enum .)
    ]               reduce using rule 26 (expr -> enum .)


state 24

    (27) unary_expr -> - . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 58
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 25

    (183) str_literal -> STRING .
    NEWLINE         reduce using rule 183 (str_literal -> STRING .)
    (               reduce using rule 183 (str_literal -> STRING .)
    EQUAL           reduce using rule 183 (str_literal -> STRING .)
    NOT_EQUAL       reduce using rule 183 (str_literal -> STRING .)
    |               reduce using rule 183 (str_literal -> STRING .)
    >               reduce using rule 183 (str_literal -> STRING .)
    FLOAT_MUL       reduce using rule 183 (str_literal -> STRING .)
    FLOAT_DIV       reduce using rule 183 (str_literal -> STRING .)
    FLOAT_SUB       reduce using rule 183 (str_literal -> STRING .)
    FLOAT_SUM       reduce using rule 183 (str_literal -> STRING .)
    <               reduce using rule 183 (str_literal -> STRING .)
    *               reduce using rule 183 (str_literal -> STRING .)
    /               reduce using rule 183 (str_literal -> STRING .)
    -               reduce using rule 183 (str_literal -> STRING .)
    +               reduce using rule 183 (str_literal -> STRING .)
    CONCAT          reduce using rule 183 (str_literal -> STRING .)
    $end            reduce using rule 183 (str_literal -> STRING .)
    )               reduce using rule 183 (str_literal -> STRING .)
    OF              reduce using rule 183 (str_literal -> STRING .)
    THEN            reduce using rule 183 (str_literal -> STRING .)
    END             reduce using rule 183 (str_literal -> STRING .)
    ELIF            reduce using rule 183 (str_literal -> STRING .)
    ELSE            reduce using rule 183 (str_literal -> STRING .)
    ,               reduce using rule 183 (str_literal -> STRING .)
    ]               reduce using rule 183 (str_literal -> STRING .)


state 26

    (182) float_literal -> FLOAT .
    NEWLINE         reduce using rule 182 (float_literal -> FLOAT .)
    (               reduce using rule 182 (float_literal -> FLOAT .)
    EQUAL           reduce using rule 182 (float_literal -> FLOAT .)
    NOT_EQUAL       reduce using rule 182 (float_literal -> FLOAT .)
    |               reduce using rule 182 (float_literal -> FLOAT .)
    >               reduce using rule 182 (float_literal -> FLOAT .)
    FLOAT_MUL       reduce using rule 182 (float_literal -> FLOAT .)
    FLOAT_DIV       reduce using rule 182 (float_literal -> FLOAT .)
    FLOAT_SUB       reduce using rule 182 (float_literal -> FLOAT .)
    FLOAT_SUM       reduce using rule 182 (float_literal -> FLOAT .)
    <               reduce using rule 182 (float_literal -> FLOAT .)
    *               reduce using rule 182 (float_literal -> FLOAT .)
    /               reduce using rule 182 (float_literal -> FLOAT .)
    -               reduce using rule 182 (float_literal -> FLOAT .)
    +               reduce using rule 182 (float_literal -> FLOAT .)
    CONCAT          reduce using rule 182 (float_literal -> FLOAT .)
    $end            reduce using rule 182 (float_literal -> FLOAT .)
    )               reduce using rule 182 (float_literal -> FLOAT .)
    OF              reduce using rule 182 (float_literal -> FLOAT .)
    THEN            reduce using rule 182 (float_literal -> FLOAT .)
    END             reduce using rule 182 (float_literal -> FLOAT .)
    ELIF            reduce using rule 182 (float_literal -> FLOAT .)
    ELSE            reduce using rule 182 (float_literal -> FLOAT .)
    ,               reduce using rule 182 (float_literal -> FLOAT .)
    ]               reduce using rule 182 (float_literal -> FLOAT .)


state 27

    (181) int_literal -> INT .
    NEWLINE         reduce using rule 181 (int_literal -> INT .)
    (               reduce using rule 181 (int_literal -> INT .)
    EQUAL           reduce using rule 181 (int_literal -> INT .)
    NOT_EQUAL       reduce using rule 181 (int_literal -> INT .)
    |               reduce using rule 181 (int_literal -> INT .)
    >               reduce using rule 181 (int_literal -> INT .)
    FLOAT_MUL       reduce using rule 181 (int_literal -> INT .)
    FLOAT_DIV       reduce using rule 181 (int_literal -> INT .)
    FLOAT_SUB       reduce using rule 181 (int_literal -> INT .)
    FLOAT_SUM       reduce using rule 181 (int_literal -> INT .)
    <               reduce using rule 181 (int_literal -> INT .)
    *               reduce using rule 181 (int_literal -> INT .)
    /               reduce using rule 181 (int_literal -> INT .)
    -               reduce using rule 181 (int_literal -> INT .)
    +               reduce using rule 181 (int_literal -> INT .)
    CONCAT          reduce using rule 181 (int_literal -> INT .)
    $end            reduce using rule 181 (int_literal -> INT .)
    )               reduce using rule 181 (int_literal -> INT .)
    OF              reduce using rule 181 (int_literal -> INT .)
    THEN            reduce using rule 181 (int_literal -> INT .)
    END             reduce using rule 181 (int_literal -> INT .)
    ELIF            reduce using rule 181 (int_literal -> INT .)
    ELSE            reduce using rule 181 (int_literal -> INT .)
    ,               reduce using rule 181 (int_literal -> INT .)
    ]               reduce using rule 181 (int_literal -> INT .)


state 28

    (153) array -> [ . _39_optional _40_optional ]
    (154) _39_optional -> . NEWLINE
    (155) _39_optional -> .
    NEWLINE         shift and go to state 60
    (               reduce using rule 155 (_39_optional -> .)
    -               reduce using rule 155 (_39_optional -> .)
    STRING          reduce using rule 155 (_39_optional -> .)
    FLOAT           reduce using rule 155 (_39_optional -> .)
    INT             reduce using rule 155 (_39_optional -> .)
    [               reduce using rule 155 (_39_optional -> .)
    IDENTIFIER      reduce using rule 155 (_39_optional -> .)
    CASE            reduce using rule 155 (_39_optional -> .)
    IF              reduce using rule 155 (_39_optional -> .)
    DEF             reduce using rule 155 (_39_optional -> .)
    DO              reduce using rule 155 (_39_optional -> .)
    EXTERNAL        reduce using rule 155 (_39_optional -> .)
    ENUM            reduce using rule 155 (_39_optional -> .)
    TYPE_IDENTIFIER reduce using rule 155 (_39_optional -> .)
    ]               reduce using rule 155 (_39_optional -> .)

    _39_optional                   shift and go to state 59

state 29

    (163) variant_call -> type_identifier . ( _43_optional _44_optional )
    (               shift and go to state 61


state 30

    (176) identifier -> IDENTIFIER .
    :               reduce using rule 176 (identifier -> IDENTIFIER .)
    =               reduce using rule 176 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 176 (identifier -> IDENTIFIER .)
    (               reduce using rule 176 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 176 (identifier -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 176 (identifier -> IDENTIFIER .)
    |               reduce using rule 176 (identifier -> IDENTIFIER .)
    >               reduce using rule 176 (identifier -> IDENTIFIER .)
    FLOAT_MUL       reduce using rule 176 (identifier -> IDENTIFIER .)
    FLOAT_DIV       reduce using rule 176 (identifier -> IDENTIFIER .)
    FLOAT_SUB       reduce using rule 176 (identifier -> IDENTIFIER .)
    FLOAT_SUM       reduce using rule 176 (identifier -> IDENTIFIER .)
    <               reduce using rule 176 (identifier -> IDENTIFIER .)
    *               reduce using rule 176 (identifier -> IDENTIFIER .)
    /               reduce using rule 176 (identifier -> IDENTIFIER .)
    -               reduce using rule 176 (identifier -> IDENTIFIER .)
    +               reduce using rule 176 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 176 (identifier -> IDENTIFIER .)
    $end            reduce using rule 176 (identifier -> IDENTIFIER .)
    )               reduce using rule 176 (identifier -> IDENTIFIER .)
    OF              reduce using rule 176 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 176 (identifier -> IDENTIFIER .)
    END             reduce using rule 176 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 176 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 176 (identifier -> IDENTIFIER .)
    ,               reduce using rule 176 (identifier -> IDENTIFIER .)
    ]               reduce using rule 176 (identifier -> IDENTIFIER .)
    DO              reduce using rule 176 (identifier -> IDENTIFIER .)


state 31

    (125) case_of -> CASE . expr OF _30_optional _31_optional END
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 62
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 32

    (116) if_expr -> IF . expr THEN _27_optional block_statement _28_optional END
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 63
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 33

    (51) def_expr -> DEF . identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> DEF . identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (176) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 64

state 34

    (43) do -> DO . _4_optional block_statement END
    (44) _4_optional -> . : type
    (45) _4_optional -> .
    :               shift and go to state 66
    NEWLINE         reduce using rule 45 (_4_optional -> .)
    END             reduce using rule 45 (_4_optional -> .)
    (               reduce using rule 45 (_4_optional -> .)
    -               reduce using rule 45 (_4_optional -> .)
    STRING          reduce using rule 45 (_4_optional -> .)
    FLOAT           reduce using rule 45 (_4_optional -> .)
    INT             reduce using rule 45 (_4_optional -> .)
    [               reduce using rule 45 (_4_optional -> .)
    IDENTIFIER      reduce using rule 45 (_4_optional -> .)
    CASE            reduce using rule 45 (_4_optional -> .)
    IF              reduce using rule 45 (_4_optional -> .)
    DEF             reduce using rule 45 (_4_optional -> .)
    DO              reduce using rule 45 (_4_optional -> .)
    EXTERNAL        reduce using rule 45 (_4_optional -> .)
    ENUM            reduce using rule 45 (_4_optional -> .)
    TYPE_IDENTIFIER reduce using rule 45 (_4_optional -> .)

    _4_optional                    shift and go to state 65

state 35

    (28) external -> EXTERNAL .
    NEWLINE         reduce using rule 28 (external -> EXTERNAL .)
    (               reduce using rule 28 (external -> EXTERNAL .)
    EQUAL           reduce using rule 28 (external -> EXTERNAL .)
    NOT_EQUAL       reduce using rule 28 (external -> EXTERNAL .)
    |               reduce using rule 28 (external -> EXTERNAL .)
    >               reduce using rule 28 (external -> EXTERNAL .)
    FLOAT_MUL       reduce using rule 28 (external -> EXTERNAL .)
    FLOAT_DIV       reduce using rule 28 (external -> EXTERNAL .)
    FLOAT_SUB       reduce using rule 28 (external -> EXTERNAL .)
    FLOAT_SUM       reduce using rule 28 (external -> EXTERNAL .)
    <               reduce using rule 28 (external -> EXTERNAL .)
    *               reduce using rule 28 (external -> EXTERNAL .)
    /               reduce using rule 28 (external -> EXTERNAL .)
    -               reduce using rule 28 (external -> EXTERNAL .)
    +               reduce using rule 28 (external -> EXTERNAL .)
    CONCAT          reduce using rule 28 (external -> EXTERNAL .)
    $end            reduce using rule 28 (external -> EXTERNAL .)
    )               reduce using rule 28 (external -> EXTERNAL .)
    OF              reduce using rule 28 (external -> EXTERNAL .)
    THEN            reduce using rule 28 (external -> EXTERNAL .)
    END             reduce using rule 28 (external -> EXTERNAL .)
    ELIF            reduce using rule 28 (external -> EXTERNAL .)
    ELSE            reduce using rule 28 (external -> EXTERNAL .)
    ,               reduce using rule 28 (external -> EXTERNAL .)
    ]               reduce using rule 28 (external -> EXTERNAL .)


state 36

    (85) enum -> ENUM . type_identifier { _18_optional _19_optional }
    (90) enum -> ENUM . type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 67

state 37

    (177) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    FLOAT           reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    INT             reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 177 (type_identifier -> TYPE_IDENTIFIER .)


state 38

    (6) do_exprs -> expr _3_optional .
    $end            reduce using rule 6 (do_exprs -> expr _3_optional .)
    END             reduce using rule 6 (do_exprs -> expr _3_optional .)
    ELIF            reduce using rule 6 (do_exprs -> expr _3_optional .)
    ELSE            reduce using rule 6 (do_exprs -> expr _3_optional .)


state 39

    (9) do_exprs -> expr NEWLINE . do_exprs
    (7) _3_optional -> NEWLINE .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 7 (_3_optional -> NEWLINE .)
    END             reduce using rule 7 (_3_optional -> NEWLINE .)
    ELIF            reduce using rule 7 (_3_optional -> NEWLINE .)
    ELSE            reduce using rule 7 (_3_optional -> NEWLINE .)
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 6
    do_exprs                       shift and go to state 68
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 40

    (158) call -> expr ( . _41_optional _42_optional )
    (159) _41_optional -> . NEWLINE
    (160) _41_optional -> .
    NEWLINE         shift and go to state 70
    (               reduce using rule 160 (_41_optional -> .)
    -               reduce using rule 160 (_41_optional -> .)
    STRING          reduce using rule 160 (_41_optional -> .)
    FLOAT           reduce using rule 160 (_41_optional -> .)
    INT             reduce using rule 160 (_41_optional -> .)
    [               reduce using rule 160 (_41_optional -> .)
    IDENTIFIER      reduce using rule 160 (_41_optional -> .)
    CASE            reduce using rule 160 (_41_optional -> .)
    IF              reduce using rule 160 (_41_optional -> .)
    DEF             reduce using rule 160 (_41_optional -> .)
    DO              reduce using rule 160 (_41_optional -> .)
    EXTERNAL        reduce using rule 160 (_41_optional -> .)
    ENUM            reduce using rule 160 (_41_optional -> .)
    TYPE_IDENTIFIER reduce using rule 160 (_41_optional -> .)
    )               reduce using rule 160 (_41_optional -> .)

    _41_optional                   shift and go to state 69

state 41

    (29) binary_expr -> expr EQUAL . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 71
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 42

    (30) binary_expr -> expr NOT_EQUAL . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 72
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 43

    (31) binary_expr -> expr | . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 73
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 44

    (32) binary_expr -> expr > . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 74
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 45

    (33) binary_expr -> expr FLOAT_MUL . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 75
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 46

    (34) binary_expr -> expr FLOAT_DIV . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 76
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 47

    (35) binary_expr -> expr FLOAT_SUB . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 77
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 48

    (36) binary_expr -> expr FLOAT_SUM . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 78
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 49

    (37) binary_expr -> expr < . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 79
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 50

    (38) binary_expr -> expr * . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 80
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 51

    (39) binary_expr -> expr / . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 81
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 52

    (40) binary_expr -> expr - . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 82
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 53

    (41) binary_expr -> expr + . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 83
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 54

    (42) binary_expr -> expr CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 84
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 55

    (10) expr -> ( expr . )
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    )               shift and go to state 85
    (               shift and go to state 40
    EQUAL           shift and go to state 41
    NOT_EQUAL       shift and go to state 42
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 56

    (178) let -> identifier _48_optional . = expr
    =               shift and go to state 86


state 57

    (179) _48_optional -> : . type
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type                           shift and go to state 87
    type_identifier                shift and go to state 88

state 58

    (27) unary_expr -> - expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 27 (unary_expr -> - expr .)
    EQUAL           reduce using rule 27 (unary_expr -> - expr .)
    NOT_EQUAL       reduce using rule 27 (unary_expr -> - expr .)
    |               reduce using rule 27 (unary_expr -> - expr .)
    >               reduce using rule 27 (unary_expr -> - expr .)
    FLOAT_MUL       reduce using rule 27 (unary_expr -> - expr .)
    FLOAT_DIV       reduce using rule 27 (unary_expr -> - expr .)
    FLOAT_SUB       reduce using rule 27 (unary_expr -> - expr .)
    FLOAT_SUM       reduce using rule 27 (unary_expr -> - expr .)
    <               reduce using rule 27 (unary_expr -> - expr .)
    *               reduce using rule 27 (unary_expr -> - expr .)
    /               reduce using rule 27 (unary_expr -> - expr .)
    -               reduce using rule 27 (unary_expr -> - expr .)
    +               reduce using rule 27 (unary_expr -> - expr .)
    CONCAT          reduce using rule 27 (unary_expr -> - expr .)
    $end            reduce using rule 27 (unary_expr -> - expr .)
    )               reduce using rule 27 (unary_expr -> - expr .)
    OF              reduce using rule 27 (unary_expr -> - expr .)
    THEN            reduce using rule 27 (unary_expr -> - expr .)
    END             reduce using rule 27 (unary_expr -> - expr .)
    ELIF            reduce using rule 27 (unary_expr -> - expr .)
    ELSE            reduce using rule 27 (unary_expr -> - expr .)
    ,               reduce using rule 27 (unary_expr -> - expr .)
    ]               reduce using rule 27 (unary_expr -> - expr .)
    (               shift and go to state 40


state 59

    (153) array -> [ _39_optional . _40_optional ]
    (156) _40_optional -> . exprs
    (157) _40_optional -> .
    (168) exprs -> . expr _45_optional
    (171) exprs -> . exprs , _46_optional expr _47_optional
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    ]               reduce using rule 157 (_40_optional -> .)
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    _40_optional                   shift and go to state 89
    exprs                          shift and go to state 90
    expr                           shift and go to state 91
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 60

    (154) _39_optional -> NEWLINE .
    (               reduce using rule 154 (_39_optional -> NEWLINE .)
    -               reduce using rule 154 (_39_optional -> NEWLINE .)
    STRING          reduce using rule 154 (_39_optional -> NEWLINE .)
    FLOAT           reduce using rule 154 (_39_optional -> NEWLINE .)
    INT             reduce using rule 154 (_39_optional -> NEWLINE .)
    [               reduce using rule 154 (_39_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 154 (_39_optional -> NEWLINE .)
    CASE            reduce using rule 154 (_39_optional -> NEWLINE .)
    IF              reduce using rule 154 (_39_optional -> NEWLINE .)
    DEF             reduce using rule 154 (_39_optional -> NEWLINE .)
    DO              reduce using rule 154 (_39_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 154 (_39_optional -> NEWLINE .)
    ENUM            reduce using rule 154 (_39_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 154 (_39_optional -> NEWLINE .)
    ]               reduce using rule 154 (_39_optional -> NEWLINE .)


state 61

    (163) variant_call -> type_identifier ( . _43_optional _44_optional )
    (164) _43_optional -> . NEWLINE
    (165) _43_optional -> .
    NEWLINE         shift and go to state 93
    (               reduce using rule 165 (_43_optional -> .)
    -               reduce using rule 165 (_43_optional -> .)
    STRING          reduce using rule 165 (_43_optional -> .)
    FLOAT           reduce using rule 165 (_43_optional -> .)
    INT             reduce using rule 165 (_43_optional -> .)
    [               reduce using rule 165 (_43_optional -> .)
    IDENTIFIER      reduce using rule 165 (_43_optional -> .)
    CASE            reduce using rule 165 (_43_optional -> .)
    IF              reduce using rule 165 (_43_optional -> .)
    DEF             reduce using rule 165 (_43_optional -> .)
    DO              reduce using rule 165 (_43_optional -> .)
    EXTERNAL        reduce using rule 165 (_43_optional -> .)
    ENUM            reduce using rule 165 (_43_optional -> .)
    TYPE_IDENTIFIER reduce using rule 165 (_43_optional -> .)
    )               reduce using rule 165 (_43_optional -> .)

    _43_optional                   shift and go to state 92

state 62

    (125) case_of -> CASE expr . OF _30_optional _31_optional END
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 94
    (               shift and go to state 40
    EQUAL           shift and go to state 41
    NOT_EQUAL       shift and go to state 42
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 63

    (116) if_expr -> IF expr . THEN _27_optional block_statement _28_optional END
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 95
    (               shift and go to state 40
    EQUAL           shift and go to state 41
    NOT_EQUAL       shift and go to state 42
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 64

    (51) def_expr -> DEF identifier . ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> DEF identifier . < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (               shift and go to state 96
    <               shift and go to state 97


state 65

    (43) do -> DO _4_optional . block_statement END
    (46) block_statement -> . _5_optional _6_optional
    (47) _5_optional -> . NEWLINE
    (48) _5_optional -> .
    NEWLINE         shift and go to state 100
    (               reduce using rule 48 (_5_optional -> .)
    -               reduce using rule 48 (_5_optional -> .)
    STRING          reduce using rule 48 (_5_optional -> .)
    FLOAT           reduce using rule 48 (_5_optional -> .)
    INT             reduce using rule 48 (_5_optional -> .)
    [               reduce using rule 48 (_5_optional -> .)
    IDENTIFIER      reduce using rule 48 (_5_optional -> .)
    CASE            reduce using rule 48 (_5_optional -> .)
    IF              reduce using rule 48 (_5_optional -> .)
    DEF             reduce using rule 48 (_5_optional -> .)
    DO              reduce using rule 48 (_5_optional -> .)
    EXTERNAL        reduce using rule 48 (_5_optional -> .)
    ENUM            reduce using rule 48 (_5_optional -> .)
    TYPE_IDENTIFIER reduce using rule 48 (_5_optional -> .)
    END             reduce using rule 48 (_5_optional -> .)

    block_statement                shift and go to state 98
    _5_optional                    shift and go to state 99

state 66

    (44) _4_optional -> : . type
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type                           shift and go to state 101
    type_identifier                shift and go to state 88

state 67

    (85) enum -> ENUM type_identifier . { _18_optional _19_optional }
    (90) enum -> ENUM type_identifier . < type_identifier _20_repeat > { _21_optional _22_optional }
    {               shift and go to state 102
    <               shift and go to state 103


state 68

    (9) do_exprs -> expr NEWLINE do_exprs .
    $end            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    END             reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELIF            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELSE            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)


state 69

    (158) call -> expr ( _41_optional . _42_optional )
    (161) _42_optional -> . exprs
    (162) _42_optional -> .
    (168) exprs -> . expr _45_optional
    (171) exprs -> . exprs , _46_optional expr _47_optional
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 162 (_42_optional -> .)
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 91
    _42_optional                   shift and go to state 104
    exprs                          shift and go to state 105
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 70

    (159) _41_optional -> NEWLINE .
    (               reduce using rule 159 (_41_optional -> NEWLINE .)
    -               reduce using rule 159 (_41_optional -> NEWLINE .)
    STRING          reduce using rule 159 (_41_optional -> NEWLINE .)
    FLOAT           reduce using rule 159 (_41_optional -> NEWLINE .)
    INT             reduce using rule 159 (_41_optional -> NEWLINE .)
    [               reduce using rule 159 (_41_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 159 (_41_optional -> NEWLINE .)
    CASE            reduce using rule 159 (_41_optional -> NEWLINE .)
    IF              reduce using rule 159 (_41_optional -> NEWLINE .)
    DEF             reduce using rule 159 (_41_optional -> NEWLINE .)
    DO              reduce using rule 159 (_41_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 159 (_41_optional -> NEWLINE .)
    ENUM            reduce using rule 159 (_41_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 159 (_41_optional -> NEWLINE .)
    )               reduce using rule 159 (_41_optional -> NEWLINE .)


state 71

    (29) binary_expr -> expr EQUAL expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    $end            reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    )               reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    OF              reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    THEN            reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    END             reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    ,               reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    ]               reduce using rule 29 (binary_expr -> expr EQUAL expr .)
    (               shift and go to state 40
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 72

    (30) binary_expr -> expr NOT_EQUAL expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    END             reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    ]               reduce using rule 30 (binary_expr -> expr NOT_EQUAL expr .)
    (               shift and go to state 40
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 73

    (31) binary_expr -> expr | expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 31 (binary_expr -> expr | expr .)
    EQUAL           reduce using rule 31 (binary_expr -> expr | expr .)
    NOT_EQUAL       reduce using rule 31 (binary_expr -> expr | expr .)
    >               reduce using rule 31 (binary_expr -> expr | expr .)
    <               reduce using rule 31 (binary_expr -> expr | expr .)
    $end            reduce using rule 31 (binary_expr -> expr | expr .)
    )               reduce using rule 31 (binary_expr -> expr | expr .)
    OF              reduce using rule 31 (binary_expr -> expr | expr .)
    THEN            reduce using rule 31 (binary_expr -> expr | expr .)
    END             reduce using rule 31 (binary_expr -> expr | expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr | expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr | expr .)
    ,               reduce using rule 31 (binary_expr -> expr | expr .)
    ]               reduce using rule 31 (binary_expr -> expr | expr .)
    (               shift and go to state 40
    |               shift and go to state 43
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 74

    (32) binary_expr -> expr > expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 32 (binary_expr -> expr > expr .)
    EQUAL           reduce using rule 32 (binary_expr -> expr > expr .)
    NOT_EQUAL       reduce using rule 32 (binary_expr -> expr > expr .)
    >               reduce using rule 32 (binary_expr -> expr > expr .)
    <               reduce using rule 32 (binary_expr -> expr > expr .)
    $end            reduce using rule 32 (binary_expr -> expr > expr .)
    )               reduce using rule 32 (binary_expr -> expr > expr .)
    OF              reduce using rule 32 (binary_expr -> expr > expr .)
    THEN            reduce using rule 32 (binary_expr -> expr > expr .)
    END             reduce using rule 32 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr > expr .)
    ,               reduce using rule 32 (binary_expr -> expr > expr .)
    ]               reduce using rule 32 (binary_expr -> expr > expr .)
    (               shift and go to state 40
    |               shift and go to state 43
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 75

    (33) binary_expr -> expr FLOAT_MUL expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    EQUAL           reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    NOT_EQUAL       reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    |               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    >               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_MUL       reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_DIV       reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_SUB       reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    FLOAT_SUM       reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    <               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    *               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    /               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    -               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    +               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    CONCAT          reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    $end            reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    )               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    OF              reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    THEN            reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    END             reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    ,               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    ]               reduce using rule 33 (binary_expr -> expr FLOAT_MUL expr .)
    (               shift and go to state 40


state 76

    (34) binary_expr -> expr FLOAT_DIV expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    EQUAL           reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    NOT_EQUAL       reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    |               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    >               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_MUL       reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_DIV       reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_SUB       reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    FLOAT_SUM       reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    <               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    *               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    /               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    -               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    +               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    $end            reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    )               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    OF              reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    THEN            reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    END             reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    ,               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    ]               reduce using rule 34 (binary_expr -> expr FLOAT_DIV expr .)
    (               shift and go to state 40


state 77

    (35) binary_expr -> expr FLOAT_SUB expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    EQUAL           reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    NOT_EQUAL       reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    |               reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    >               reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_SUB       reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    FLOAT_SUM       reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    <               reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    -               reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    +               reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    CONCAT          reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    $end            reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    )               reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    OF              reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    THEN            reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    END             reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    ,               reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    ]               reduce using rule 35 (binary_expr -> expr FLOAT_SUB expr .)
    (               shift and go to state 40
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    *               shift and go to state 50
    /               shift and go to state 51


state 78

    (36) binary_expr -> expr FLOAT_SUM expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    EQUAL           reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    NOT_EQUAL       reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    |               reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    >               reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_SUB       reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    FLOAT_SUM       reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    <               reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    -               reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    +               reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    CONCAT          reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    $end            reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    )               reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    OF              reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    THEN            reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    END             reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    ELIF            reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    ELSE            reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    ,               reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    ]               reduce using rule 36 (binary_expr -> expr FLOAT_SUM expr .)
    (               shift and go to state 40
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    *               shift and go to state 50
    /               shift and go to state 51


state 79

    (37) binary_expr -> expr < expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 37 (binary_expr -> expr < expr .)
    EQUAL           reduce using rule 37 (binary_expr -> expr < expr .)
    NOT_EQUAL       reduce using rule 37 (binary_expr -> expr < expr .)
    >               reduce using rule 37 (binary_expr -> expr < expr .)
    <               reduce using rule 37 (binary_expr -> expr < expr .)
    $end            reduce using rule 37 (binary_expr -> expr < expr .)
    )               reduce using rule 37 (binary_expr -> expr < expr .)
    OF              reduce using rule 37 (binary_expr -> expr < expr .)
    THEN            reduce using rule 37 (binary_expr -> expr < expr .)
    END             reduce using rule 37 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 37 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 37 (binary_expr -> expr < expr .)
    ,               reduce using rule 37 (binary_expr -> expr < expr .)
    ]               reduce using rule 37 (binary_expr -> expr < expr .)
    (               shift and go to state 40
    |               shift and go to state 43
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 80

    (38) binary_expr -> expr * expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 38 (binary_expr -> expr * expr .)
    EQUAL           reduce using rule 38 (binary_expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 38 (binary_expr -> expr * expr .)
    |               reduce using rule 38 (binary_expr -> expr * expr .)
    >               reduce using rule 38 (binary_expr -> expr * expr .)
    FLOAT_MUL       reduce using rule 38 (binary_expr -> expr * expr .)
    FLOAT_DIV       reduce using rule 38 (binary_expr -> expr * expr .)
    FLOAT_SUB       reduce using rule 38 (binary_expr -> expr * expr .)
    FLOAT_SUM       reduce using rule 38 (binary_expr -> expr * expr .)
    <               reduce using rule 38 (binary_expr -> expr * expr .)
    *               reduce using rule 38 (binary_expr -> expr * expr .)
    /               reduce using rule 38 (binary_expr -> expr * expr .)
    -               reduce using rule 38 (binary_expr -> expr * expr .)
    +               reduce using rule 38 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 38 (binary_expr -> expr * expr .)
    $end            reduce using rule 38 (binary_expr -> expr * expr .)
    )               reduce using rule 38 (binary_expr -> expr * expr .)
    OF              reduce using rule 38 (binary_expr -> expr * expr .)
    THEN            reduce using rule 38 (binary_expr -> expr * expr .)
    END             reduce using rule 38 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 38 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 38 (binary_expr -> expr * expr .)
    ,               reduce using rule 38 (binary_expr -> expr * expr .)
    ]               reduce using rule 38 (binary_expr -> expr * expr .)
    (               shift and go to state 40


state 81

    (39) binary_expr -> expr / expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 39 (binary_expr -> expr / expr .)
    EQUAL           reduce using rule 39 (binary_expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 39 (binary_expr -> expr / expr .)
    |               reduce using rule 39 (binary_expr -> expr / expr .)
    >               reduce using rule 39 (binary_expr -> expr / expr .)
    FLOAT_MUL       reduce using rule 39 (binary_expr -> expr / expr .)
    FLOAT_DIV       reduce using rule 39 (binary_expr -> expr / expr .)
    FLOAT_SUB       reduce using rule 39 (binary_expr -> expr / expr .)
    FLOAT_SUM       reduce using rule 39 (binary_expr -> expr / expr .)
    <               reduce using rule 39 (binary_expr -> expr / expr .)
    *               reduce using rule 39 (binary_expr -> expr / expr .)
    /               reduce using rule 39 (binary_expr -> expr / expr .)
    -               reduce using rule 39 (binary_expr -> expr / expr .)
    +               reduce using rule 39 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 39 (binary_expr -> expr / expr .)
    $end            reduce using rule 39 (binary_expr -> expr / expr .)
    )               reduce using rule 39 (binary_expr -> expr / expr .)
    OF              reduce using rule 39 (binary_expr -> expr / expr .)
    THEN            reduce using rule 39 (binary_expr -> expr / expr .)
    END             reduce using rule 39 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 39 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 39 (binary_expr -> expr / expr .)
    ,               reduce using rule 39 (binary_expr -> expr / expr .)
    ]               reduce using rule 39 (binary_expr -> expr / expr .)
    (               shift and go to state 40


state 82

    (40) binary_expr -> expr - expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 40 (binary_expr -> expr - expr .)
    EQUAL           reduce using rule 40 (binary_expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 40 (binary_expr -> expr - expr .)
    |               reduce using rule 40 (binary_expr -> expr - expr .)
    >               reduce using rule 40 (binary_expr -> expr - expr .)
    FLOAT_SUB       reduce using rule 40 (binary_expr -> expr - expr .)
    FLOAT_SUM       reduce using rule 40 (binary_expr -> expr - expr .)
    <               reduce using rule 40 (binary_expr -> expr - expr .)
    -               reduce using rule 40 (binary_expr -> expr - expr .)
    +               reduce using rule 40 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 40 (binary_expr -> expr - expr .)
    $end            reduce using rule 40 (binary_expr -> expr - expr .)
    )               reduce using rule 40 (binary_expr -> expr - expr .)
    OF              reduce using rule 40 (binary_expr -> expr - expr .)
    THEN            reduce using rule 40 (binary_expr -> expr - expr .)
    END             reduce using rule 40 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 40 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 40 (binary_expr -> expr - expr .)
    ,               reduce using rule 40 (binary_expr -> expr - expr .)
    ]               reduce using rule 40 (binary_expr -> expr - expr .)
    (               shift and go to state 40
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    *               shift and go to state 50
    /               shift and go to state 51


state 83

    (41) binary_expr -> expr + expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 41 (binary_expr -> expr + expr .)
    EQUAL           reduce using rule 41 (binary_expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 41 (binary_expr -> expr + expr .)
    |               reduce using rule 41 (binary_expr -> expr + expr .)
    >               reduce using rule 41 (binary_expr -> expr + expr .)
    FLOAT_SUB       reduce using rule 41 (binary_expr -> expr + expr .)
    FLOAT_SUM       reduce using rule 41 (binary_expr -> expr + expr .)
    <               reduce using rule 41 (binary_expr -> expr + expr .)
    -               reduce using rule 41 (binary_expr -> expr + expr .)
    +               reduce using rule 41 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 41 (binary_expr -> expr + expr .)
    $end            reduce using rule 41 (binary_expr -> expr + expr .)
    )               reduce using rule 41 (binary_expr -> expr + expr .)
    OF              reduce using rule 41 (binary_expr -> expr + expr .)
    THEN            reduce using rule 41 (binary_expr -> expr + expr .)
    END             reduce using rule 41 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 41 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 41 (binary_expr -> expr + expr .)
    ,               reduce using rule 41 (binary_expr -> expr + expr .)
    ]               reduce using rule 41 (binary_expr -> expr + expr .)
    (               shift and go to state 40
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    *               shift and go to state 50
    /               shift and go to state 51


state 84

    (42) binary_expr -> expr CONCAT expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    EQUAL           reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    NOT_EQUAL       reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 42 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 40
    |               shift and go to state 43
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 85

    (10) expr -> ( expr ) .
    NEWLINE         reduce using rule 10 (expr -> ( expr ) .)
    (               reduce using rule 10 (expr -> ( expr ) .)
    EQUAL           reduce using rule 10 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 10 (expr -> ( expr ) .)
    |               reduce using rule 10 (expr -> ( expr ) .)
    >               reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_MUL       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_DIV       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_SUB       reduce using rule 10 (expr -> ( expr ) .)
    FLOAT_SUM       reduce using rule 10 (expr -> ( expr ) .)
    <               reduce using rule 10 (expr -> ( expr ) .)
    *               reduce using rule 10 (expr -> ( expr ) .)
    /               reduce using rule 10 (expr -> ( expr ) .)
    -               reduce using rule 10 (expr -> ( expr ) .)
    +               reduce using rule 10 (expr -> ( expr ) .)
    CONCAT          reduce using rule 10 (expr -> ( expr ) .)
    $end            reduce using rule 10 (expr -> ( expr ) .)
    )               reduce using rule 10 (expr -> ( expr ) .)
    OF              reduce using rule 10 (expr -> ( expr ) .)
    THEN            reduce using rule 10 (expr -> ( expr ) .)
    END             reduce using rule 10 (expr -> ( expr ) .)
    ELIF            reduce using rule 10 (expr -> ( expr ) .)
    ELSE            reduce using rule 10 (expr -> ( expr ) .)
    ,               reduce using rule 10 (expr -> ( expr ) .)
    ]               reduce using rule 10 (expr -> ( expr ) .)


state 86

    (178) let -> identifier _48_optional = . expr
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    identifier                     shift and go to state 14
    expr                           shift and go to state 106
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 87

    (179) _48_optional -> : type .
    =               reduce using rule 179 (_48_optional -> : type .)


state 88

    (78) type -> type_identifier . < type _17_repeat >
    (84) type -> type_identifier .
    <               shift and go to state 107
    =               reduce using rule 84 (type -> type_identifier .)
    NEWLINE         reduce using rule 84 (type -> type_identifier .)
    END             reduce using rule 84 (type -> type_identifier .)
    (               reduce using rule 84 (type -> type_identifier .)
    -               reduce using rule 84 (type -> type_identifier .)
    STRING          reduce using rule 84 (type -> type_identifier .)
    FLOAT           reduce using rule 84 (type -> type_identifier .)
    INT             reduce using rule 84 (type -> type_identifier .)
    [               reduce using rule 84 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 84 (type -> type_identifier .)
    CASE            reduce using rule 84 (type -> type_identifier .)
    IF              reduce using rule 84 (type -> type_identifier .)
    DEF             reduce using rule 84 (type -> type_identifier .)
    DO              reduce using rule 84 (type -> type_identifier .)
    EXTERNAL        reduce using rule 84 (type -> type_identifier .)
    ENUM            reduce using rule 84 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 84 (type -> type_identifier .)
    ,               reduce using rule 84 (type -> type_identifier .)
    >               reduce using rule 84 (type -> type_identifier .)
    ELIF            reduce using rule 84 (type -> type_identifier .)
    ELSE            reduce using rule 84 (type -> type_identifier .)
    )               reduce using rule 84 (type -> type_identifier .)


state 89

    (153) array -> [ _39_optional _40_optional . ]
    ]               shift and go to state 108


state 90

    (156) _40_optional -> exprs .
    (171) exprs -> exprs . , _46_optional expr _47_optional
    ]               reduce using rule 156 (_40_optional -> exprs .)
    ,               shift and go to state 109


state 91

    (168) exprs -> expr . _45_optional
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    (169) _45_optional -> . NEWLINE
    (170) _45_optional -> .
    (               shift and go to state 40
    EQUAL           shift and go to state 41
    NOT_EQUAL       shift and go to state 42
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54
    NEWLINE         shift and go to state 111
    ,               reduce using rule 170 (_45_optional -> .)
    ]               reduce using rule 170 (_45_optional -> .)
    )               reduce using rule 170 (_45_optional -> .)

    _45_optional                   shift and go to state 110

state 92

    (163) variant_call -> type_identifier ( _43_optional . _44_optional )
    (166) _44_optional -> . exprs
    (167) _44_optional -> .
    (168) exprs -> . expr _45_optional
    (171) exprs -> . exprs , _46_optional expr _47_optional
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 167 (_44_optional -> .)
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 29
    _44_optional                   shift and go to state 112
    exprs                          shift and go to state 113
    expr                           shift and go to state 91
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23

state 93

    (164) _43_optional -> NEWLINE .
    (               reduce using rule 164 (_43_optional -> NEWLINE .)
    -               reduce using rule 164 (_43_optional -> NEWLINE .)
    STRING          reduce using rule 164 (_43_optional -> NEWLINE .)
    FLOAT           reduce using rule 164 (_43_optional -> NEWLINE .)
    INT             reduce using rule 164 (_43_optional -> NEWLINE .)
    [               reduce using rule 164 (_43_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 164 (_43_optional -> NEWLINE .)
    CASE            reduce using rule 164 (_43_optional -> NEWLINE .)
    IF              reduce using rule 164 (_43_optional -> NEWLINE .)
    DEF             reduce using rule 164 (_43_optional -> NEWLINE .)
    DO              reduce using rule 164 (_43_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 164 (_43_optional -> NEWLINE .)
    ENUM            reduce using rule 164 (_43_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 164 (_43_optional -> NEWLINE .)
    )               reduce using rule 164 (_43_optional -> NEWLINE .)


state 94

    (125) case_of -> CASE expr OF . _30_optional _31_optional END
    (126) _30_optional -> . NEWLINE
    (127) _30_optional -> .
    NEWLINE         shift and go to state 115
    TYPE_IDENTIFIER reduce using rule 127 (_30_optional -> .)
    IDENTIFIER      reduce using rule 127 (_30_optional -> .)
    END             reduce using rule 127 (_30_optional -> .)

    _30_optional                   shift and go to state 114

state 95

    (116) if_expr -> IF expr THEN . _27_optional block_statement _28_optional END
    (117) _27_optional -> . : type
    (118) _27_optional -> .
    :               shift and go to state 117
    NEWLINE         reduce using rule 118 (_27_optional -> .)
    ELIF            reduce using rule 118 (_27_optional -> .)
    ELSE            reduce using rule 118 (_27_optional -> .)
    END             reduce using rule 118 (_27_optional -> .)
    (               reduce using rule 118 (_27_optional -> .)
    -               reduce using rule 118 (_27_optional -> .)
    STRING          reduce using rule 118 (_27_optional -> .)
    FLOAT           reduce using rule 118 (_27_optional -> .)
    INT             reduce using rule 118 (_27_optional -> .)
    [               reduce using rule 118 (_27_optional -> .)
    IDENTIFIER      reduce using rule 118 (_27_optional -> .)
    CASE            reduce using rule 118 (_27_optional -> .)
    IF              reduce using rule 118 (_27_optional -> .)
    DEF             reduce using rule 118 (_27_optional -> .)
    DO              reduce using rule 118 (_27_optional -> .)
    EXTERNAL        reduce using rule 118 (_27_optional -> .)
    ENUM            reduce using rule 118 (_27_optional -> .)
    TYPE_IDENTIFIER reduce using rule 118 (_27_optional -> .)

    _27_optional                   shift and go to state 116

state 96

    (51) def_expr -> DEF identifier ( . _7_optional _8_optional ) _9_optional do
    (52) _7_optional -> . NEWLINE
    (53) _7_optional -> .
    NEWLINE         shift and go to state 119
    IDENTIFIER      reduce using rule 53 (_7_optional -> .)
    )               reduce using rule 53 (_7_optional -> .)

    _7_optional                    shift and go to state 118

state 97

    (58) def_expr -> DEF identifier < . type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 120

state 98

    (43) do -> DO _4_optional block_statement . END
    END             shift and go to state 121


state 99

    (46) block_statement -> _5_optional . _6_optional
    (49) _6_optional -> . do_exprs
    (50) _6_optional -> .
    (6) do_exprs -> . expr _3_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 50 (_6_optional -> .)
    ELIF            reduce using rule 50 (_6_optional -> .)
    ELSE            reduce using rule 50 (_6_optional -> .)
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    _6_optional                    shift and go to state 122
    do_exprs                       shift and go to state 123
    expr                           shift and go to state 6
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 100

    (47) _5_optional -> NEWLINE .
    (               reduce using rule 47 (_5_optional -> NEWLINE .)
    -               reduce using rule 47 (_5_optional -> NEWLINE .)
    STRING          reduce using rule 47 (_5_optional -> NEWLINE .)
    FLOAT           reduce using rule 47 (_5_optional -> NEWLINE .)
    INT             reduce using rule 47 (_5_optional -> NEWLINE .)
    [               reduce using rule 47 (_5_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 47 (_5_optional -> NEWLINE .)
    CASE            reduce using rule 47 (_5_optional -> NEWLINE .)
    IF              reduce using rule 47 (_5_optional -> NEWLINE .)
    DEF             reduce using rule 47 (_5_optional -> NEWLINE .)
    DO              reduce using rule 47 (_5_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 47 (_5_optional -> NEWLINE .)
    ENUM            reduce using rule 47 (_5_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 47 (_5_optional -> NEWLINE .)
    END             reduce using rule 47 (_5_optional -> NEWLINE .)
    ELIF            reduce using rule 47 (_5_optional -> NEWLINE .)
    ELSE            reduce using rule 47 (_5_optional -> NEWLINE .)


state 101

    (44) _4_optional -> : type .
    NEWLINE         reduce using rule 44 (_4_optional -> : type .)
    END             reduce using rule 44 (_4_optional -> : type .)
    (               reduce using rule 44 (_4_optional -> : type .)
    -               reduce using rule 44 (_4_optional -> : type .)
    STRING          reduce using rule 44 (_4_optional -> : type .)
    FLOAT           reduce using rule 44 (_4_optional -> : type .)
    INT             reduce using rule 44 (_4_optional -> : type .)
    [               reduce using rule 44 (_4_optional -> : type .)
    IDENTIFIER      reduce using rule 44 (_4_optional -> : type .)
    CASE            reduce using rule 44 (_4_optional -> : type .)
    IF              reduce using rule 44 (_4_optional -> : type .)
    DEF             reduce using rule 44 (_4_optional -> : type .)
    DO              reduce using rule 44 (_4_optional -> : type .)
    EXTERNAL        reduce using rule 44 (_4_optional -> : type .)
    ENUM            reduce using rule 44 (_4_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 44 (_4_optional -> : type .)


state 102

    (85) enum -> ENUM type_identifier { . _18_optional _19_optional }
    (86) _18_optional -> . NEWLINE
    (87) _18_optional -> .
    NEWLINE         shift and go to state 125
    TYPE_IDENTIFIER reduce using rule 87 (_18_optional -> .)
    }               reduce using rule 87 (_18_optional -> .)

    _18_optional                   shift and go to state 124

state 103

    (90) enum -> ENUM type_identifier < . type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 126

state 104

    (158) call -> expr ( _41_optional _42_optional . )
    )               shift and go to state 127


state 105

    (161) _42_optional -> exprs .
    (171) exprs -> exprs . , _46_optional expr _47_optional
    )               reduce using rule 161 (_42_optional -> exprs .)
    ,               shift and go to state 109


state 106

    (178) let -> identifier _48_optional = expr .
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 178 (let -> identifier _48_optional = expr .)
    $end            reduce using rule 178 (let -> identifier _48_optional = expr .)
    )               reduce using rule 178 (let -> identifier _48_optional = expr .)
    OF              reduce using rule 178 (let -> identifier _48_optional = expr .)
    THEN            reduce using rule 178 (let -> identifier _48_optional = expr .)
    END             reduce using rule 178 (let -> identifier _48_optional = expr .)
    ELIF            reduce using rule 178 (let -> identifier _48_optional = expr .)
    ELSE            reduce using rule 178 (let -> identifier _48_optional = expr .)
    ,               reduce using rule 178 (let -> identifier _48_optional = expr .)
    ]               reduce using rule 178 (let -> identifier _48_optional = expr .)
    (               shift and go to state 40
    EQUAL           shift and go to state 41
    NOT_EQUAL       shift and go to state 42
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 107

    (78) type -> type_identifier < . type _17_repeat >
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 88
    type                           shift and go to state 128

state 108

    (153) array -> [ _39_optional _40_optional ] .
    NEWLINE         reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    (               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    EQUAL           reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    NOT_EQUAL       reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    |               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    >               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    FLOAT_MUL       reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    FLOAT_DIV       reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    FLOAT_SUB       reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    FLOAT_SUM       reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    <               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    *               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    /               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    -               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    +               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    CONCAT          reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    $end            reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    )               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    OF              reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    THEN            reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    END             reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    ELIF            reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    ELSE            reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    ,               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)
    ]               reduce using rule 153 (array -> [ _39_optional _40_optional ] .)


state 109

    (171) exprs -> exprs , . _46_optional expr _47_optional
    (172) _46_optional -> . NEWLINE
    (173) _46_optional -> .
    NEWLINE         shift and go to state 130
    (               reduce using rule 173 (_46_optional -> .)
    -               reduce using rule 173 (_46_optional -> .)
    STRING          reduce using rule 173 (_46_optional -> .)
    FLOAT           reduce using rule 173 (_46_optional -> .)
    INT             reduce using rule 173 (_46_optional -> .)
    [               reduce using rule 173 (_46_optional -> .)
    IDENTIFIER      reduce using rule 173 (_46_optional -> .)
    CASE            reduce using rule 173 (_46_optional -> .)
    IF              reduce using rule 173 (_46_optional -> .)
    DEF             reduce using rule 173 (_46_optional -> .)
    DO              reduce using rule 173 (_46_optional -> .)
    EXTERNAL        reduce using rule 173 (_46_optional -> .)
    ENUM            reduce using rule 173 (_46_optional -> .)
    TYPE_IDENTIFIER reduce using rule 173 (_46_optional -> .)

    _46_optional                   shift and go to state 129

state 110

    (168) exprs -> expr _45_optional .
    ,               reduce using rule 168 (exprs -> expr _45_optional .)
    ]               reduce using rule 168 (exprs -> expr _45_optional .)
    )               reduce using rule 168 (exprs -> expr _45_optional .)


state 111

    (169) _45_optional -> NEWLINE .
    ,               reduce using rule 169 (_45_optional -> NEWLINE .)
    ]               reduce using rule 169 (_45_optional -> NEWLINE .)
    )               reduce using rule 169 (_45_optional -> NEWLINE .)


state 112

    (163) variant_call -> type_identifier ( _43_optional _44_optional . )
    )               shift and go to state 131


state 113

    (166) _44_optional -> exprs .
    (171) exprs -> exprs . , _46_optional expr _47_optional
    )               reduce using rule 166 (_44_optional -> exprs .)
    ,               shift and go to state 109


state 114

    (125) case_of -> CASE expr OF _30_optional . _31_optional END
    (128) _31_optional -> . cases
    (129) _31_optional -> .
    (130) cases -> . pattern do _32_optional
    (133) cases -> . cases pattern do _33_optional
    (136) pattern -> . match_variant
    (137) pattern -> . match_as
    (139) match_variant -> . type_identifier
    (140) match_variant -> . type_identifier ( _34_optional _35_optional )
    (138) match_as -> . identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    (176) identifier -> . IDENTIFIER
    END             reduce using rule 129 (_31_optional -> .)
    TYPE_IDENTIFIER shift and go to state 37
    IDENTIFIER      shift and go to state 30

    _31_optional                   shift and go to state 132
    cases                          shift and go to state 133
    pattern                        shift and go to state 134
    match_variant                  shift and go to state 135
    match_as                       shift and go to state 136
    type_identifier                shift and go to state 137
    identifier                     shift and go to state 138

state 115

    (126) _30_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 126 (_30_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 126 (_30_optional -> NEWLINE .)
    END             reduce using rule 126 (_30_optional -> NEWLINE .)


state 116

    (116) if_expr -> IF expr THEN _27_optional . block_statement _28_optional END
    (46) block_statement -> . _5_optional _6_optional
    (47) _5_optional -> . NEWLINE
    (48) _5_optional -> .
    NEWLINE         shift and go to state 100
    (               reduce using rule 48 (_5_optional -> .)
    -               reduce using rule 48 (_5_optional -> .)
    STRING          reduce using rule 48 (_5_optional -> .)
    FLOAT           reduce using rule 48 (_5_optional -> .)
    INT             reduce using rule 48 (_5_optional -> .)
    [               reduce using rule 48 (_5_optional -> .)
    IDENTIFIER      reduce using rule 48 (_5_optional -> .)
    CASE            reduce using rule 48 (_5_optional -> .)
    IF              reduce using rule 48 (_5_optional -> .)
    DEF             reduce using rule 48 (_5_optional -> .)
    DO              reduce using rule 48 (_5_optional -> .)
    EXTERNAL        reduce using rule 48 (_5_optional -> .)
    ENUM            reduce using rule 48 (_5_optional -> .)
    TYPE_IDENTIFIER reduce using rule 48 (_5_optional -> .)
    ELIF            reduce using rule 48 (_5_optional -> .)
    ELSE            reduce using rule 48 (_5_optional -> .)
    END             reduce using rule 48 (_5_optional -> .)

    block_statement                shift and go to state 139
    _5_optional                    shift and go to state 99

state 117

    (117) _27_optional -> : . type
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type                           shift and go to state 140
    type_identifier                shift and go to state 88

state 118

    (51) def_expr -> DEF identifier ( _7_optional . _8_optional ) _9_optional do
    (54) _8_optional -> . params
    (55) _8_optional -> .
    (70) params -> . param _14_optional
    (73) params -> . params , _15_optional param _16_optional
    (113) param -> . identifier _26_optional
    (176) identifier -> . IDENTIFIER
    )               reduce using rule 55 (_8_optional -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 141
    _8_optional                    shift and go to state 142
    params                         shift and go to state 143
    param                          shift and go to state 144

state 119

    (52) _7_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 52 (_7_optional -> NEWLINE .)
    )               reduce using rule 52 (_7_optional -> NEWLINE .)


state 120

    (58) def_expr -> DEF identifier < type_identifier . _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (59) _10_repeat -> . _10_items
    (60) _10_repeat -> .
    (61) _10_items -> . _10_items _10_item
    (62) _10_items -> . _10_item
    (63) _10_item -> . , type_identifier
    >               reduce using rule 60 (_10_repeat -> .)
    ,               shift and go to state 148

    _10_repeat                     shift and go to state 145
    _10_items                      shift and go to state 146
    _10_item                       shift and go to state 147

state 121

    (43) do -> DO _4_optional block_statement END .
    NEWLINE         reduce using rule 43 (do -> DO _4_optional block_statement END .)
    (               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    EQUAL           reduce using rule 43 (do -> DO _4_optional block_statement END .)
    NOT_EQUAL       reduce using rule 43 (do -> DO _4_optional block_statement END .)
    |               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    >               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    FLOAT_MUL       reduce using rule 43 (do -> DO _4_optional block_statement END .)
    FLOAT_DIV       reduce using rule 43 (do -> DO _4_optional block_statement END .)
    FLOAT_SUB       reduce using rule 43 (do -> DO _4_optional block_statement END .)
    FLOAT_SUM       reduce using rule 43 (do -> DO _4_optional block_statement END .)
    <               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    *               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    /               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    -               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    +               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    CONCAT          reduce using rule 43 (do -> DO _4_optional block_statement END .)
    $end            reduce using rule 43 (do -> DO _4_optional block_statement END .)
    )               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    OF              reduce using rule 43 (do -> DO _4_optional block_statement END .)
    THEN            reduce using rule 43 (do -> DO _4_optional block_statement END .)
    END             reduce using rule 43 (do -> DO _4_optional block_statement END .)
    ELIF            reduce using rule 43 (do -> DO _4_optional block_statement END .)
    ELSE            reduce using rule 43 (do -> DO _4_optional block_statement END .)
    ,               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    ]               reduce using rule 43 (do -> DO _4_optional block_statement END .)
    TYPE_IDENTIFIER reduce using rule 43 (do -> DO _4_optional block_statement END .)
    IDENTIFIER      reduce using rule 43 (do -> DO _4_optional block_statement END .)


state 122

    (46) block_statement -> _5_optional _6_optional .
    END             reduce using rule 46 (block_statement -> _5_optional _6_optional .)
    ELIF            reduce using rule 46 (block_statement -> _5_optional _6_optional .)
    ELSE            reduce using rule 46 (block_statement -> _5_optional _6_optional .)


state 123

    (49) _6_optional -> do_exprs .
    END             reduce using rule 49 (_6_optional -> do_exprs .)
    ELIF            reduce using rule 49 (_6_optional -> do_exprs .)
    ELSE            reduce using rule 49 (_6_optional -> do_exprs .)


state 124

    (85) enum -> ENUM type_identifier { _18_optional . _19_optional }
    (88) _19_optional -> . variants
    (89) _19_optional -> .
    (100) variants -> . variant _23_optional
    (103) variants -> . variants variant _24_optional
    (106) variant -> . type_identifier
    (107) variant -> . type_identifier ( type _25_repeat )
    (177) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 89 (_19_optional -> .)
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 149
    _19_optional                   shift and go to state 150
    variants                       shift and go to state 151
    variant                        shift and go to state 152

state 125

    (86) _18_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 86 (_18_optional -> NEWLINE .)
    }               reduce using rule 86 (_18_optional -> NEWLINE .)


state 126

    (90) enum -> ENUM type_identifier < type_identifier . _20_repeat > { _21_optional _22_optional }
    (91) _20_repeat -> . _20_items
    (92) _20_repeat -> .
    (93) _20_items -> . _20_items _20_item
    (94) _20_items -> . _20_item
    (95) _20_item -> . , type_identifier
    >               reduce using rule 92 (_20_repeat -> .)
    ,               shift and go to state 156

    _20_repeat                     shift and go to state 153
    _20_items                      shift and go to state 154
    _20_item                       shift and go to state 155

state 127

    (158) call -> expr ( _41_optional _42_optional ) .
    NEWLINE         reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    (               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    EQUAL           reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    NOT_EQUAL       reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    |               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    >               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    FLOAT_MUL       reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    FLOAT_DIV       reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    FLOAT_SUB       reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    FLOAT_SUM       reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    <               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    *               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    /               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    -               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    +               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    CONCAT          reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    $end            reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    )               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    OF              reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    THEN            reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    END             reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    ELIF            reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    ELSE            reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    ,               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)
    ]               reduce using rule 158 (call -> expr ( _41_optional _42_optional ) .)


state 128

    (78) type -> type_identifier < type . _17_repeat >
    (79) _17_repeat -> . _17_items
    (80) _17_repeat -> .
    (81) _17_items -> . _17_items _17_item
    (82) _17_items -> . _17_item
    (83) _17_item -> . , type
    >               reduce using rule 80 (_17_repeat -> .)
    ,               shift and go to state 160

    _17_repeat                     shift and go to state 157
    _17_items                      shift and go to state 158
    _17_item                       shift and go to state 159

state 129

    (171) exprs -> exprs , _46_optional . expr _47_optional
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 161
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 130

    (172) _46_optional -> NEWLINE .
    (               reduce using rule 172 (_46_optional -> NEWLINE .)
    -               reduce using rule 172 (_46_optional -> NEWLINE .)
    STRING          reduce using rule 172 (_46_optional -> NEWLINE .)
    FLOAT           reduce using rule 172 (_46_optional -> NEWLINE .)
    INT             reduce using rule 172 (_46_optional -> NEWLINE .)
    [               reduce using rule 172 (_46_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 172 (_46_optional -> NEWLINE .)
    CASE            reduce using rule 172 (_46_optional -> NEWLINE .)
    IF              reduce using rule 172 (_46_optional -> NEWLINE .)
    DEF             reduce using rule 172 (_46_optional -> NEWLINE .)
    DO              reduce using rule 172 (_46_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 172 (_46_optional -> NEWLINE .)
    ENUM            reduce using rule 172 (_46_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 172 (_46_optional -> NEWLINE .)


state 131

    (163) variant_call -> type_identifier ( _43_optional _44_optional ) .
    NEWLINE         reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    (               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    EQUAL           reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    NOT_EQUAL       reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    |               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    >               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    FLOAT_MUL       reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    FLOAT_DIV       reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    FLOAT_SUB       reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    FLOAT_SUM       reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    <               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    *               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    /               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    -               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    +               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    CONCAT          reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    $end            reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    )               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    OF              reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    THEN            reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    END             reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    ELIF            reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    ELSE            reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    ,               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)
    ]               reduce using rule 163 (variant_call -> type_identifier ( _43_optional _44_optional ) .)


state 132

    (125) case_of -> CASE expr OF _30_optional _31_optional . END
    END             shift and go to state 162


state 133

    (128) _31_optional -> cases .
    (133) cases -> cases . pattern do _33_optional
    (136) pattern -> . match_variant
    (137) pattern -> . match_as
    (139) match_variant -> . type_identifier
    (140) match_variant -> . type_identifier ( _34_optional _35_optional )
    (138) match_as -> . identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    (176) identifier -> . IDENTIFIER
    END             reduce using rule 128 (_31_optional -> cases .)
    TYPE_IDENTIFIER shift and go to state 37
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 163
    match_variant                  shift and go to state 135
    match_as                       shift and go to state 136
    type_identifier                shift and go to state 137
    identifier                     shift and go to state 138

state 134

    (130) cases -> pattern . do _32_optional
    (43) do -> . DO _4_optional block_statement END
    DO              shift and go to state 34

    do                             shift and go to state 164

state 135

    (136) pattern -> match_variant .
    DO              reduce using rule 136 (pattern -> match_variant .)
    NEWLINE         reduce using rule 136 (pattern -> match_variant .)
    ,               reduce using rule 136 (pattern -> match_variant .)
    )               reduce using rule 136 (pattern -> match_variant .)


state 136

    (137) pattern -> match_as .
    DO              reduce using rule 137 (pattern -> match_as .)
    NEWLINE         reduce using rule 137 (pattern -> match_as .)
    ,               reduce using rule 137 (pattern -> match_as .)
    )               reduce using rule 137 (pattern -> match_as .)


state 137

    (139) match_variant -> type_identifier .
    (140) match_variant -> type_identifier . ( _34_optional _35_optional )
    DO              reduce using rule 139 (match_variant -> type_identifier .)
    NEWLINE         reduce using rule 139 (match_variant -> type_identifier .)
    ,               reduce using rule 139 (match_variant -> type_identifier .)
    )               reduce using rule 139 (match_variant -> type_identifier .)
    (               shift and go to state 165


state 138

    (138) match_as -> identifier .
    DO              reduce using rule 138 (match_as -> identifier .)
    NEWLINE         reduce using rule 138 (match_as -> identifier .)
    ,               reduce using rule 138 (match_as -> identifier .)
    )               reduce using rule 138 (match_as -> identifier .)


state 139

    (116) if_expr -> IF expr THEN _27_optional block_statement . _28_optional END
    (119) _28_optional -> . or_else
    (120) _28_optional -> .
    (121) or_else -> . ELIF expr THEN block_statement _29_optional
    (124) or_else -> . ELSE block_statement
    END             reduce using rule 120 (_28_optional -> .)
    ELIF            shift and go to state 168
    ELSE            shift and go to state 169

    _28_optional                   shift and go to state 166
    or_else                        shift and go to state 167

state 140

    (117) _27_optional -> : type .
    NEWLINE         reduce using rule 117 (_27_optional -> : type .)
    ELIF            reduce using rule 117 (_27_optional -> : type .)
    ELSE            reduce using rule 117 (_27_optional -> : type .)
    END             reduce using rule 117 (_27_optional -> : type .)
    (               reduce using rule 117 (_27_optional -> : type .)
    -               reduce using rule 117 (_27_optional -> : type .)
    STRING          reduce using rule 117 (_27_optional -> : type .)
    FLOAT           reduce using rule 117 (_27_optional -> : type .)
    INT             reduce using rule 117 (_27_optional -> : type .)
    [               reduce using rule 117 (_27_optional -> : type .)
    IDENTIFIER      reduce using rule 117 (_27_optional -> : type .)
    CASE            reduce using rule 117 (_27_optional -> : type .)
    IF              reduce using rule 117 (_27_optional -> : type .)
    DEF             reduce using rule 117 (_27_optional -> : type .)
    DO              reduce using rule 117 (_27_optional -> : type .)
    EXTERNAL        reduce using rule 117 (_27_optional -> : type .)
    ENUM            reduce using rule 117 (_27_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 117 (_27_optional -> : type .)


state 141

    (113) param -> identifier . _26_optional
    (114) _26_optional -> . : type
    (115) _26_optional -> .
    :               shift and go to state 171
    NEWLINE         reduce using rule 115 (_26_optional -> .)
    ,               reduce using rule 115 (_26_optional -> .)
    )               reduce using rule 115 (_26_optional -> .)

    _26_optional                   shift and go to state 170

state 142

    (51) def_expr -> DEF identifier ( _7_optional _8_optional . ) _9_optional do
    )               shift and go to state 172


state 143

    (54) _8_optional -> params .
    (73) params -> params . , _15_optional param _16_optional
    )               reduce using rule 54 (_8_optional -> params .)
    ,               shift and go to state 173


state 144

    (70) params -> param . _14_optional
    (71) _14_optional -> . NEWLINE
    (72) _14_optional -> .
    NEWLINE         shift and go to state 175
    ,               reduce using rule 72 (_14_optional -> .)
    )               reduce using rule 72 (_14_optional -> .)

    _14_optional                   shift and go to state 174

state 145

    (58) def_expr -> DEF identifier < type_identifier _10_repeat . > ( _11_optional _12_optional ) _13_optional do
    >               shift and go to state 176


state 146

    (59) _10_repeat -> _10_items .
    (61) _10_items -> _10_items . _10_item
    (63) _10_item -> . , type_identifier
    >               reduce using rule 59 (_10_repeat -> _10_items .)
    ,               shift and go to state 148

    _10_item                       shift and go to state 177

state 147

    (62) _10_items -> _10_item .
    ,               reduce using rule 62 (_10_items -> _10_item .)
    >               reduce using rule 62 (_10_items -> _10_item .)


state 148

    (63) _10_item -> , . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 178

state 149

    (106) variant -> type_identifier .
    (107) variant -> type_identifier . ( type _25_repeat )
    NEWLINE         reduce using rule 106 (variant -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 106 (variant -> type_identifier .)
    }               reduce using rule 106 (variant -> type_identifier .)
    (               shift and go to state 179


state 150

    (85) enum -> ENUM type_identifier { _18_optional _19_optional . }
    }               shift and go to state 180


state 151

    (88) _19_optional -> variants .
    (103) variants -> variants . variant _24_optional
    (106) variant -> . type_identifier
    (107) variant -> . type_identifier ( type _25_repeat )
    (177) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 88 (_19_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 37

    variant                        shift and go to state 181
    type_identifier                shift and go to state 149

state 152

    (100) variants -> variant . _23_optional
    (101) _23_optional -> . NEWLINE
    (102) _23_optional -> .
    NEWLINE         shift and go to state 183
    TYPE_IDENTIFIER reduce using rule 102 (_23_optional -> .)
    }               reduce using rule 102 (_23_optional -> .)

    _23_optional                   shift and go to state 182

state 153

    (90) enum -> ENUM type_identifier < type_identifier _20_repeat . > { _21_optional _22_optional }
    >               shift and go to state 184


state 154

    (91) _20_repeat -> _20_items .
    (93) _20_items -> _20_items . _20_item
    (95) _20_item -> . , type_identifier
    >               reduce using rule 91 (_20_repeat -> _20_items .)
    ,               shift and go to state 156

    _20_item                       shift and go to state 185

state 155

    (94) _20_items -> _20_item .
    ,               reduce using rule 94 (_20_items -> _20_item .)
    >               reduce using rule 94 (_20_items -> _20_item .)


state 156

    (95) _20_item -> , . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 186

state 157

    (78) type -> type_identifier < type _17_repeat . >
    >               shift and go to state 187


state 158

    (79) _17_repeat -> _17_items .
    (81) _17_items -> _17_items . _17_item
    (83) _17_item -> . , type
    >               reduce using rule 79 (_17_repeat -> _17_items .)
    ,               shift and go to state 160

    _17_item                       shift and go to state 188

state 159

    (82) _17_items -> _17_item .
    ,               reduce using rule 82 (_17_items -> _17_item .)
    >               reduce using rule 82 (_17_items -> _17_item .)


state 160

    (83) _17_item -> , . type
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type                           shift and go to state 189
    type_identifier                shift and go to state 88

state 161

    (171) exprs -> exprs , _46_optional expr . _47_optional
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    (174) _47_optional -> . NEWLINE
    (175) _47_optional -> .
    (               shift and go to state 40
    EQUAL           shift and go to state 41
    NOT_EQUAL       shift and go to state 42
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54
    NEWLINE         shift and go to state 191
    ,               reduce using rule 175 (_47_optional -> .)
    ]               reduce using rule 175 (_47_optional -> .)
    )               reduce using rule 175 (_47_optional -> .)

    _47_optional                   shift and go to state 190

state 162

    (125) case_of -> CASE expr OF _30_optional _31_optional END .
    NEWLINE         reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    (               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    EQUAL           reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    NOT_EQUAL       reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    |               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    >               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    FLOAT_MUL       reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    FLOAT_DIV       reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    FLOAT_SUB       reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    FLOAT_SUM       reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    <               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    *               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    /               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    -               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    +               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    CONCAT          reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    $end            reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    )               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    OF              reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    THEN            reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    END             reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    ELIF            reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    ELSE            reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    ,               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)
    ]               reduce using rule 125 (case_of -> CASE expr OF _30_optional _31_optional END .)


state 163

    (133) cases -> cases pattern . do _33_optional
    (43) do -> . DO _4_optional block_statement END
    DO              shift and go to state 34

    do                             shift and go to state 192

state 164

    (130) cases -> pattern do . _32_optional
    (131) _32_optional -> . NEWLINE
    (132) _32_optional -> .
    NEWLINE         shift and go to state 194
    TYPE_IDENTIFIER reduce using rule 132 (_32_optional -> .)
    IDENTIFIER      reduce using rule 132 (_32_optional -> .)
    END             reduce using rule 132 (_32_optional -> .)

    _32_optional                   shift and go to state 193

state 165

    (140) match_variant -> type_identifier ( . _34_optional _35_optional )
    (141) _34_optional -> . NEWLINE
    (142) _34_optional -> .
    NEWLINE         shift and go to state 196
    TYPE_IDENTIFIER reduce using rule 142 (_34_optional -> .)
    IDENTIFIER      reduce using rule 142 (_34_optional -> .)
    )               reduce using rule 142 (_34_optional -> .)

    _34_optional                   shift and go to state 195

state 166

    (116) if_expr -> IF expr THEN _27_optional block_statement _28_optional . END
    END             shift and go to state 197


state 167

    (119) _28_optional -> or_else .
    END             reduce using rule 119 (_28_optional -> or_else .)


state 168

    (121) or_else -> ELIF . expr THEN block_statement _29_optional
    (10) expr -> . ( expr )
    (11) expr -> . unary_expr
    (12) expr -> . str_literal
    (13) expr -> . float_literal
    (14) expr -> . int_literal
    (15) expr -> . array
    (16) expr -> . variant_call
    (17) expr -> . identifier
    (18) expr -> . let
    (19) expr -> . call
    (20) expr -> . case_of
    (21) expr -> . binary_expr
    (22) expr -> . if_expr
    (23) expr -> . def_expr
    (24) expr -> . do
    (25) expr -> . external
    (26) expr -> . enum
    (27) unary_expr -> . - expr
    (183) str_literal -> . STRING
    (182) float_literal -> . FLOAT
    (181) int_literal -> . INT
    (153) array -> . [ _39_optional _40_optional ]
    (163) variant_call -> . type_identifier ( _43_optional _44_optional )
    (176) identifier -> . IDENTIFIER
    (178) let -> . identifier _48_optional = expr
    (158) call -> . expr ( _41_optional _42_optional )
    (125) case_of -> . CASE expr OF _30_optional _31_optional END
    (29) binary_expr -> . expr EQUAL expr
    (30) binary_expr -> . expr NOT_EQUAL expr
    (31) binary_expr -> . expr | expr
    (32) binary_expr -> . expr > expr
    (33) binary_expr -> . expr FLOAT_MUL expr
    (34) binary_expr -> . expr FLOAT_DIV expr
    (35) binary_expr -> . expr FLOAT_SUB expr
    (36) binary_expr -> . expr FLOAT_SUM expr
    (37) binary_expr -> . expr < expr
    (38) binary_expr -> . expr * expr
    (39) binary_expr -> . expr / expr
    (40) binary_expr -> . expr - expr
    (41) binary_expr -> . expr + expr
    (42) binary_expr -> . expr CONCAT expr
    (116) if_expr -> . IF expr THEN _27_optional block_statement _28_optional END
    (51) def_expr -> . DEF identifier ( _7_optional _8_optional ) _9_optional do
    (58) def_expr -> . DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do
    (43) do -> . DO _4_optional block_statement END
    (28) external -> . EXTERNAL
    (85) enum -> . ENUM type_identifier { _18_optional _19_optional }
    (90) enum -> . ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional }
    (177) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 7
    -               shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    [               shift and go to state 28
    IDENTIFIER      shift and go to state 30
    CASE            shift and go to state 31
    IF              shift and go to state 32
    DEF             shift and go to state 33
    DO              shift and go to state 34
    EXTERNAL        shift and go to state 35
    ENUM            shift and go to state 36
    TYPE_IDENTIFIER shift and go to state 37

    expr                           shift and go to state 198
    unary_expr                     shift and go to state 8
    str_literal                    shift and go to state 9
    float_literal                  shift and go to state 10
    int_literal                    shift and go to state 11
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    let                            shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    do                             shift and go to state 21
    external                       shift and go to state 22
    enum                           shift and go to state 23
    type_identifier                shift and go to state 29

state 169

    (124) or_else -> ELSE . block_statement
    (46) block_statement -> . _5_optional _6_optional
    (47) _5_optional -> . NEWLINE
    (48) _5_optional -> .
    NEWLINE         shift and go to state 100
    (               reduce using rule 48 (_5_optional -> .)
    -               reduce using rule 48 (_5_optional -> .)
    STRING          reduce using rule 48 (_5_optional -> .)
    FLOAT           reduce using rule 48 (_5_optional -> .)
    INT             reduce using rule 48 (_5_optional -> .)
    [               reduce using rule 48 (_5_optional -> .)
    IDENTIFIER      reduce using rule 48 (_5_optional -> .)
    CASE            reduce using rule 48 (_5_optional -> .)
    IF              reduce using rule 48 (_5_optional -> .)
    DEF             reduce using rule 48 (_5_optional -> .)
    DO              reduce using rule 48 (_5_optional -> .)
    EXTERNAL        reduce using rule 48 (_5_optional -> .)
    ENUM            reduce using rule 48 (_5_optional -> .)
    TYPE_IDENTIFIER reduce using rule 48 (_5_optional -> .)
    END             reduce using rule 48 (_5_optional -> .)

    block_statement                shift and go to state 199
    _5_optional                    shift and go to state 99

state 170

    (113) param -> identifier _26_optional .
    NEWLINE         reduce using rule 113 (param -> identifier _26_optional .)
    ,               reduce using rule 113 (param -> identifier _26_optional .)
    )               reduce using rule 113 (param -> identifier _26_optional .)


state 171

    (114) _26_optional -> : . type
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type                           shift and go to state 200
    type_identifier                shift and go to state 88

state 172

    (51) def_expr -> DEF identifier ( _7_optional _8_optional ) . _9_optional do
    (56) _9_optional -> . : type
    (57) _9_optional -> .
    :               shift and go to state 202
    DO              reduce using rule 57 (_9_optional -> .)

    _9_optional                    shift and go to state 201

state 173

    (73) params -> params , . _15_optional param _16_optional
    (74) _15_optional -> . NEWLINE
    (75) _15_optional -> .
    NEWLINE         shift and go to state 204
    IDENTIFIER      reduce using rule 75 (_15_optional -> .)

    _15_optional                   shift and go to state 203

state 174

    (70) params -> param _14_optional .
    ,               reduce using rule 70 (params -> param _14_optional .)
    )               reduce using rule 70 (params -> param _14_optional .)


state 175

    (71) _14_optional -> NEWLINE .
    ,               reduce using rule 71 (_14_optional -> NEWLINE .)
    )               reduce using rule 71 (_14_optional -> NEWLINE .)


state 176

    (58) def_expr -> DEF identifier < type_identifier _10_repeat > . ( _11_optional _12_optional ) _13_optional do
    (               shift and go to state 205


state 177

    (61) _10_items -> _10_items _10_item .
    ,               reduce using rule 61 (_10_items -> _10_items _10_item .)
    >               reduce using rule 61 (_10_items -> _10_items _10_item .)


state 178

    (63) _10_item -> , type_identifier .
    ,               reduce using rule 63 (_10_item -> , type_identifier .)
    >               reduce using rule 63 (_10_item -> , type_identifier .)


state 179

    (107) variant -> type_identifier ( . type _25_repeat )
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 88
    type                           shift and go to state 206

state 180

    (85) enum -> ENUM type_identifier { _18_optional _19_optional } .
    NEWLINE         reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    (               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    EQUAL           reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    NOT_EQUAL       reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    |               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    >               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    FLOAT_MUL       reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    FLOAT_DIV       reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    FLOAT_SUB       reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    FLOAT_SUM       reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    <               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    *               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    /               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    -               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    +               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    CONCAT          reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    $end            reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    )               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    OF              reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    THEN            reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    END             reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    ELIF            reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    ELSE            reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    ,               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)
    ]               reduce using rule 85 (enum -> ENUM type_identifier { _18_optional _19_optional } .)


state 181

    (103) variants -> variants variant . _24_optional
    (104) _24_optional -> . NEWLINE
    (105) _24_optional -> .
    NEWLINE         shift and go to state 208
    TYPE_IDENTIFIER reduce using rule 105 (_24_optional -> .)
    }               reduce using rule 105 (_24_optional -> .)

    _24_optional                   shift and go to state 207

state 182

    (100) variants -> variant _23_optional .
    TYPE_IDENTIFIER reduce using rule 100 (variants -> variant _23_optional .)
    }               reduce using rule 100 (variants -> variant _23_optional .)


state 183

    (101) _23_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 101 (_23_optional -> NEWLINE .)
    }               reduce using rule 101 (_23_optional -> NEWLINE .)


state 184

    (90) enum -> ENUM type_identifier < type_identifier _20_repeat > . { _21_optional _22_optional }
    {               shift and go to state 209


state 185

    (93) _20_items -> _20_items _20_item .
    ,               reduce using rule 93 (_20_items -> _20_items _20_item .)
    >               reduce using rule 93 (_20_items -> _20_items _20_item .)


state 186

    (95) _20_item -> , type_identifier .
    ,               reduce using rule 95 (_20_item -> , type_identifier .)
    >               reduce using rule 95 (_20_item -> , type_identifier .)


state 187

    (78) type -> type_identifier < type _17_repeat > .
    =               reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    NEWLINE         reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    END             reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    (               reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    -               reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    STRING          reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    FLOAT           reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    INT             reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    [               reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    IDENTIFIER      reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    CASE            reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    IF              reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    DEF             reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    DO              reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    EXTERNAL        reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    ENUM            reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    TYPE_IDENTIFIER reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    ,               reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    >               reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    ELIF            reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    ELSE            reduce using rule 78 (type -> type_identifier < type _17_repeat > .)
    )               reduce using rule 78 (type -> type_identifier < type _17_repeat > .)


state 188

    (81) _17_items -> _17_items _17_item .
    ,               reduce using rule 81 (_17_items -> _17_items _17_item .)
    >               reduce using rule 81 (_17_items -> _17_items _17_item .)


state 189

    (83) _17_item -> , type .
    ,               reduce using rule 83 (_17_item -> , type .)
    >               reduce using rule 83 (_17_item -> , type .)


state 190

    (171) exprs -> exprs , _46_optional expr _47_optional .
    ,               reduce using rule 171 (exprs -> exprs , _46_optional expr _47_optional .)
    ]               reduce using rule 171 (exprs -> exprs , _46_optional expr _47_optional .)
    )               reduce using rule 171 (exprs -> exprs , _46_optional expr _47_optional .)


state 191

    (174) _47_optional -> NEWLINE .
    ,               reduce using rule 174 (_47_optional -> NEWLINE .)
    ]               reduce using rule 174 (_47_optional -> NEWLINE .)
    )               reduce using rule 174 (_47_optional -> NEWLINE .)


state 192

    (133) cases -> cases pattern do . _33_optional
    (134) _33_optional -> . NEWLINE
    (135) _33_optional -> .
    NEWLINE         shift and go to state 211
    TYPE_IDENTIFIER reduce using rule 135 (_33_optional -> .)
    IDENTIFIER      reduce using rule 135 (_33_optional -> .)
    END             reduce using rule 135 (_33_optional -> .)

    _33_optional                   shift and go to state 210

state 193

    (130) cases -> pattern do _32_optional .
    TYPE_IDENTIFIER reduce using rule 130 (cases -> pattern do _32_optional .)
    IDENTIFIER      reduce using rule 130 (cases -> pattern do _32_optional .)
    END             reduce using rule 130 (cases -> pattern do _32_optional .)


state 194

    (131) _32_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 131 (_32_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 131 (_32_optional -> NEWLINE .)
    END             reduce using rule 131 (_32_optional -> NEWLINE .)


state 195

    (140) match_variant -> type_identifier ( _34_optional . _35_optional )
    (143) _35_optional -> . patterns
    (144) _35_optional -> .
    (145) patterns -> . pattern _36_optional
    (148) patterns -> . patterns , _37_optional pattern _38_optional
    (136) pattern -> . match_variant
    (137) pattern -> . match_as
    (139) match_variant -> . type_identifier
    (140) match_variant -> . type_identifier ( _34_optional _35_optional )
    (138) match_as -> . identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    (176) identifier -> . IDENTIFIER
    )               reduce using rule 144 (_35_optional -> .)
    TYPE_IDENTIFIER shift and go to state 37
    IDENTIFIER      shift and go to state 30

    type_identifier                shift and go to state 137
    _35_optional                   shift and go to state 212
    patterns                       shift and go to state 213
    pattern                        shift and go to state 214
    match_variant                  shift and go to state 135
    match_as                       shift and go to state 136
    identifier                     shift and go to state 138

state 196

    (141) _34_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 141 (_34_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 141 (_34_optional -> NEWLINE .)
    )               reduce using rule 141 (_34_optional -> NEWLINE .)


state 197

    (116) if_expr -> IF expr THEN _27_optional block_statement _28_optional END .
    NEWLINE         reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    (               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    EQUAL           reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    NOT_EQUAL       reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    |               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    >               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    FLOAT_MUL       reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    FLOAT_DIV       reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    FLOAT_SUB       reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    FLOAT_SUM       reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    <               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    *               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    /               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    -               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    +               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    CONCAT          reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    $end            reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    )               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    OF              reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    THEN            reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    END             reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    ELIF            reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    ELSE            reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    ,               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)
    ]               reduce using rule 116 (if_expr -> IF expr THEN _27_optional block_statement _28_optional END .)


state 198

    (121) or_else -> ELIF expr . THEN block_statement _29_optional
    (158) call -> expr . ( _41_optional _42_optional )
    (29) binary_expr -> expr . EQUAL expr
    (30) binary_expr -> expr . NOT_EQUAL expr
    (31) binary_expr -> expr . | expr
    (32) binary_expr -> expr . > expr
    (33) binary_expr -> expr . FLOAT_MUL expr
    (34) binary_expr -> expr . FLOAT_DIV expr
    (35) binary_expr -> expr . FLOAT_SUB expr
    (36) binary_expr -> expr . FLOAT_SUM expr
    (37) binary_expr -> expr . < expr
    (38) binary_expr -> expr . * expr
    (39) binary_expr -> expr . / expr
    (40) binary_expr -> expr . - expr
    (41) binary_expr -> expr . + expr
    (42) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 215
    (               shift and go to state 40
    EQUAL           shift and go to state 41
    NOT_EQUAL       shift and go to state 42
    |               shift and go to state 43
    >               shift and go to state 44
    FLOAT_MUL       shift and go to state 45
    FLOAT_DIV       shift and go to state 46
    FLOAT_SUB       shift and go to state 47
    FLOAT_SUM       shift and go to state 48
    <               shift and go to state 49
    *               shift and go to state 50
    /               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    CONCAT          shift and go to state 54


state 199

    (124) or_else -> ELSE block_statement .
    END             reduce using rule 124 (or_else -> ELSE block_statement .)


state 200

    (114) _26_optional -> : type .
    NEWLINE         reduce using rule 114 (_26_optional -> : type .)
    ,               reduce using rule 114 (_26_optional -> : type .)
    )               reduce using rule 114 (_26_optional -> : type .)


state 201

    (51) def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional . do
    (43) do -> . DO _4_optional block_statement END
    DO              shift and go to state 34

    do                             shift and go to state 216

state 202

    (56) _9_optional -> : . type
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type                           shift and go to state 217
    type_identifier                shift and go to state 88

state 203

    (73) params -> params , _15_optional . param _16_optional
    (113) param -> . identifier _26_optional
    (176) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    param                          shift and go to state 218
    identifier                     shift and go to state 141

state 204

    (74) _15_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 74 (_15_optional -> NEWLINE .)


state 205

    (58) def_expr -> DEF identifier < type_identifier _10_repeat > ( . _11_optional _12_optional ) _13_optional do
    (64) _11_optional -> . NEWLINE
    (65) _11_optional -> .
    NEWLINE         shift and go to state 220
    IDENTIFIER      reduce using rule 65 (_11_optional -> .)
    )               reduce using rule 65 (_11_optional -> .)

    _11_optional                   shift and go to state 219

state 206

    (107) variant -> type_identifier ( type . _25_repeat )
    (108) _25_repeat -> . _25_items
    (109) _25_repeat -> .
    (110) _25_items -> . _25_items _25_item
    (111) _25_items -> . _25_item
    (112) _25_item -> . , type
    )               reduce using rule 109 (_25_repeat -> .)
    ,               shift and go to state 224

    _25_repeat                     shift and go to state 221
    _25_items                      shift and go to state 222
    _25_item                       shift and go to state 223

state 207

    (103) variants -> variants variant _24_optional .
    TYPE_IDENTIFIER reduce using rule 103 (variants -> variants variant _24_optional .)
    }               reduce using rule 103 (variants -> variants variant _24_optional .)


state 208

    (104) _24_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 104 (_24_optional -> NEWLINE .)
    }               reduce using rule 104 (_24_optional -> NEWLINE .)


state 209

    (90) enum -> ENUM type_identifier < type_identifier _20_repeat > { . _21_optional _22_optional }
    (96) _21_optional -> . NEWLINE
    (97) _21_optional -> .
    NEWLINE         shift and go to state 226
    TYPE_IDENTIFIER reduce using rule 97 (_21_optional -> .)
    }               reduce using rule 97 (_21_optional -> .)

    _21_optional                   shift and go to state 225

state 210

    (133) cases -> cases pattern do _33_optional .
    TYPE_IDENTIFIER reduce using rule 133 (cases -> cases pattern do _33_optional .)
    IDENTIFIER      reduce using rule 133 (cases -> cases pattern do _33_optional .)
    END             reduce using rule 133 (cases -> cases pattern do _33_optional .)


state 211

    (134) _33_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 134 (_33_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 134 (_33_optional -> NEWLINE .)
    END             reduce using rule 134 (_33_optional -> NEWLINE .)


state 212

    (140) match_variant -> type_identifier ( _34_optional _35_optional . )
    )               shift and go to state 227


state 213

    (143) _35_optional -> patterns .
    (148) patterns -> patterns . , _37_optional pattern _38_optional
    )               reduce using rule 143 (_35_optional -> patterns .)
    ,               shift and go to state 228


state 214

    (145) patterns -> pattern . _36_optional
    (146) _36_optional -> . NEWLINE
    (147) _36_optional -> .
    NEWLINE         shift and go to state 230
    ,               reduce using rule 147 (_36_optional -> .)
    )               reduce using rule 147 (_36_optional -> .)

    _36_optional                   shift and go to state 229

state 215

    (121) or_else -> ELIF expr THEN . block_statement _29_optional
    (46) block_statement -> . _5_optional _6_optional
    (47) _5_optional -> . NEWLINE
    (48) _5_optional -> .
    NEWLINE         shift and go to state 100
    (               reduce using rule 48 (_5_optional -> .)
    -               reduce using rule 48 (_5_optional -> .)
    STRING          reduce using rule 48 (_5_optional -> .)
    FLOAT           reduce using rule 48 (_5_optional -> .)
    INT             reduce using rule 48 (_5_optional -> .)
    [               reduce using rule 48 (_5_optional -> .)
    IDENTIFIER      reduce using rule 48 (_5_optional -> .)
    CASE            reduce using rule 48 (_5_optional -> .)
    IF              reduce using rule 48 (_5_optional -> .)
    DEF             reduce using rule 48 (_5_optional -> .)
    DO              reduce using rule 48 (_5_optional -> .)
    EXTERNAL        reduce using rule 48 (_5_optional -> .)
    ENUM            reduce using rule 48 (_5_optional -> .)
    TYPE_IDENTIFIER reduce using rule 48 (_5_optional -> .)
    ELIF            reduce using rule 48 (_5_optional -> .)
    ELSE            reduce using rule 48 (_5_optional -> .)
    END             reduce using rule 48 (_5_optional -> .)

    block_statement                shift and go to state 231
    _5_optional                    shift and go to state 99

state 216

    (51) def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .
    NEWLINE         reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    (               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    EQUAL           reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    NOT_EQUAL       reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    |               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    >               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    FLOAT_MUL       reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    FLOAT_DIV       reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    FLOAT_SUB       reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    FLOAT_SUM       reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    <               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    *               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    /               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    -               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    +               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    CONCAT          reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    $end            reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    )               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    OF              reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    THEN            reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    END             reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    ELIF            reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    ELSE            reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    ,               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)
    ]               reduce using rule 51 (def_expr -> DEF identifier ( _7_optional _8_optional ) _9_optional do .)


state 217

    (56) _9_optional -> : type .
    DO              reduce using rule 56 (_9_optional -> : type .)


state 218

    (73) params -> params , _15_optional param . _16_optional
    (76) _16_optional -> . NEWLINE
    (77) _16_optional -> .
    NEWLINE         shift and go to state 233
    ,               reduce using rule 77 (_16_optional -> .)
    )               reduce using rule 77 (_16_optional -> .)

    _16_optional                   shift and go to state 232

state 219

    (58) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional . _12_optional ) _13_optional do
    (66) _12_optional -> . params
    (67) _12_optional -> .
    (70) params -> . param _14_optional
    (73) params -> . params , _15_optional param _16_optional
    (113) param -> . identifier _26_optional
    (176) identifier -> . IDENTIFIER
    )               reduce using rule 67 (_12_optional -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 141
    _12_optional                   shift and go to state 234
    params                         shift and go to state 235
    param                          shift and go to state 144

state 220

    (64) _11_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 64 (_11_optional -> NEWLINE .)
    )               reduce using rule 64 (_11_optional -> NEWLINE .)


state 221

    (107) variant -> type_identifier ( type _25_repeat . )
    )               shift and go to state 236


state 222

    (108) _25_repeat -> _25_items .
    (110) _25_items -> _25_items . _25_item
    (112) _25_item -> . , type
    )               reduce using rule 108 (_25_repeat -> _25_items .)
    ,               shift and go to state 224

    _25_item                       shift and go to state 237

state 223

    (111) _25_items -> _25_item .
    ,               reduce using rule 111 (_25_items -> _25_item .)
    )               reduce using rule 111 (_25_items -> _25_item .)


state 224

    (112) _25_item -> , . type
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type                           shift and go to state 238
    type_identifier                shift and go to state 88

state 225

    (90) enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional . _22_optional }
    (98) _22_optional -> . variants
    (99) _22_optional -> .
    (100) variants -> . variant _23_optional
    (103) variants -> . variants variant _24_optional
    (106) variant -> . type_identifier
    (107) variant -> . type_identifier ( type _25_repeat )
    (177) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 99 (_22_optional -> .)
    TYPE_IDENTIFIER shift and go to state 37

    type_identifier                shift and go to state 149
    _22_optional                   shift and go to state 239
    variants                       shift and go to state 240
    variant                        shift and go to state 152

state 226

    (96) _21_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 96 (_21_optional -> NEWLINE .)
    }               reduce using rule 96 (_21_optional -> NEWLINE .)


state 227

    (140) match_variant -> type_identifier ( _34_optional _35_optional ) .
    DO              reduce using rule 140 (match_variant -> type_identifier ( _34_optional _35_optional ) .)
    NEWLINE         reduce using rule 140 (match_variant -> type_identifier ( _34_optional _35_optional ) .)
    ,               reduce using rule 140 (match_variant -> type_identifier ( _34_optional _35_optional ) .)
    )               reduce using rule 140 (match_variant -> type_identifier ( _34_optional _35_optional ) .)


state 228

    (148) patterns -> patterns , . _37_optional pattern _38_optional
    (149) _37_optional -> . NEWLINE
    (150) _37_optional -> .
    NEWLINE         shift and go to state 242
    TYPE_IDENTIFIER reduce using rule 150 (_37_optional -> .)
    IDENTIFIER      reduce using rule 150 (_37_optional -> .)

    _37_optional                   shift and go to state 241

state 229

    (145) patterns -> pattern _36_optional .
    ,               reduce using rule 145 (patterns -> pattern _36_optional .)
    )               reduce using rule 145 (patterns -> pattern _36_optional .)


state 230

    (146) _36_optional -> NEWLINE .
    ,               reduce using rule 146 (_36_optional -> NEWLINE .)
    )               reduce using rule 146 (_36_optional -> NEWLINE .)


state 231

    (121) or_else -> ELIF expr THEN block_statement . _29_optional
    (122) _29_optional -> . or_else
    (123) _29_optional -> .
    (121) or_else -> . ELIF expr THEN block_statement _29_optional
    (124) or_else -> . ELSE block_statement
    END             reduce using rule 123 (_29_optional -> .)
    ELIF            shift and go to state 168
    ELSE            shift and go to state 169

    _29_optional                   shift and go to state 243
    or_else                        shift and go to state 244

state 232

    (73) params -> params , _15_optional param _16_optional .
    ,               reduce using rule 73 (params -> params , _15_optional param _16_optional .)
    )               reduce using rule 73 (params -> params , _15_optional param _16_optional .)


state 233

    (76) _16_optional -> NEWLINE .
    ,               reduce using rule 76 (_16_optional -> NEWLINE .)
    )               reduce using rule 76 (_16_optional -> NEWLINE .)


state 234

    (58) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional . ) _13_optional do
    )               shift and go to state 245


state 235

    (66) _12_optional -> params .
    (73) params -> params . , _15_optional param _16_optional
    )               reduce using rule 66 (_12_optional -> params .)
    ,               shift and go to state 173


state 236

    (107) variant -> type_identifier ( type _25_repeat ) .
    NEWLINE         reduce using rule 107 (variant -> type_identifier ( type _25_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 107 (variant -> type_identifier ( type _25_repeat ) .)
    }               reduce using rule 107 (variant -> type_identifier ( type _25_repeat ) .)


state 237

    (110) _25_items -> _25_items _25_item .
    ,               reduce using rule 110 (_25_items -> _25_items _25_item .)
    )               reduce using rule 110 (_25_items -> _25_items _25_item .)


state 238

    (112) _25_item -> , type .
    ,               reduce using rule 112 (_25_item -> , type .)
    )               reduce using rule 112 (_25_item -> , type .)


state 239

    (90) enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional . }
    }               shift and go to state 246


state 240

    (98) _22_optional -> variants .
    (103) variants -> variants . variant _24_optional
    (106) variant -> . type_identifier
    (107) variant -> . type_identifier ( type _25_repeat )
    (177) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 98 (_22_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 37

    variant                        shift and go to state 181
    type_identifier                shift and go to state 149

state 241

    (148) patterns -> patterns , _37_optional . pattern _38_optional
    (136) pattern -> . match_variant
    (137) pattern -> . match_as
    (139) match_variant -> . type_identifier
    (140) match_variant -> . type_identifier ( _34_optional _35_optional )
    (138) match_as -> . identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    (176) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 247
    match_variant                  shift and go to state 135
    match_as                       shift and go to state 136
    type_identifier                shift and go to state 137
    identifier                     shift and go to state 138

state 242

    (149) _37_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 149 (_37_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 149 (_37_optional -> NEWLINE .)


state 243

    (121) or_else -> ELIF expr THEN block_statement _29_optional .
    END             reduce using rule 121 (or_else -> ELIF expr THEN block_statement _29_optional .)


state 244

    (122) _29_optional -> or_else .
    END             reduce using rule 122 (_29_optional -> or_else .)


state 245

    (58) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) . _13_optional do
    (68) _13_optional -> . : type
    (69) _13_optional -> .
    :               shift and go to state 249
    DO              reduce using rule 69 (_13_optional -> .)

    _13_optional                   shift and go to state 248

state 246

    (90) enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .
    NEWLINE         reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    (               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    EQUAL           reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    NOT_EQUAL       reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    |               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    >               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    FLOAT_MUL       reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    FLOAT_DIV       reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    FLOAT_SUB       reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    FLOAT_SUM       reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    <               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    *               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    /               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    -               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    +               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    CONCAT          reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    $end            reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    )               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    OF              reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    THEN            reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    END             reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    ELIF            reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    ELSE            reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    ,               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)
    ]               reduce using rule 90 (enum -> ENUM type_identifier < type_identifier _20_repeat > { _21_optional _22_optional } .)


state 247

    (148) patterns -> patterns , _37_optional pattern . _38_optional
    (151) _38_optional -> . NEWLINE
    (152) _38_optional -> .
    NEWLINE         shift and go to state 251
    ,               reduce using rule 152 (_38_optional -> .)
    )               reduce using rule 152 (_38_optional -> .)

    _38_optional                   shift and go to state 250

state 248

    (58) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional . do
    (43) do -> . DO _4_optional block_statement END
    DO              shift and go to state 34

    do                             shift and go to state 252

state 249

    (68) _13_optional -> : . type
    (78) type -> . type_identifier < type _17_repeat >
    (84) type -> . type_identifier
    (177) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 37

    type                           shift and go to state 253
    type_identifier                shift and go to state 88

state 250

    (148) patterns -> patterns , _37_optional pattern _38_optional .
    ,               reduce using rule 148 (patterns -> patterns , _37_optional pattern _38_optional .)
    )               reduce using rule 148 (patterns -> patterns , _37_optional pattern _38_optional .)


state 251

    (151) _38_optional -> NEWLINE .
    ,               reduce using rule 151 (_38_optional -> NEWLINE .)
    )               reduce using rule 151 (_38_optional -> NEWLINE .)


state 252

    (58) def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .
    NEWLINE         reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    (               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    EQUAL           reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    NOT_EQUAL       reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    |               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    >               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    FLOAT_MUL       reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    FLOAT_DIV       reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    FLOAT_SUB       reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    FLOAT_SUM       reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    <               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    *               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    /               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    -               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    +               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    CONCAT          reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    $end            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    )               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    OF              reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    THEN            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    END             reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    ELIF            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    ELSE            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    ,               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)
    ]               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _10_repeat > ( _11_optional _12_optional ) _13_optional do .)


state 253

    (68) _13_optional -> : type .
    DO              reduce using rule 68 (_13_optional -> : type .)
