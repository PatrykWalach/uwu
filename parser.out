Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_optional _2_repeat
Rule 2     _1_optional -> body
Rule 3     _1_optional -> <empty>
Rule 4     _2_repeat -> _2_items
Rule 5     _2_repeat -> <empty>
Rule 6     _2_items -> _2_items _2_item
Rule 7     _2_items -> _2_item
Rule 8     _2_item -> NEWLINE body
Rule 9     body -> enum
Rule 10    body -> struct
Rule 11    body -> expr
Rule 12    expr -> ( expr )
Rule 13    expr -> - expr  [precedence=right, level=4]
Rule 14    expr -> tuple
Rule 15    expr -> array
Rule 16    expr -> binary_expr
Rule 17    expr -> variable_declaration
Rule 18    expr -> case_of
Rule 19    expr -> call
Rule 20    expr -> _if
Rule 21    expr -> _def
Rule 22    expr -> literal
Rule 23    expr -> identifier
Rule 24    expr -> do
Rule 25    binary_expr -> expr INT_DIV expr  [precedence=left, level=3]
Rule 26    binary_expr -> expr * expr  [precedence=left, level=3]
Rule 27    binary_expr -> expr / expr  [precedence=left, level=3]
Rule 28    binary_expr -> expr - expr  [precedence=left, level=2]
Rule 29    binary_expr -> expr + expr  [precedence=left, level=2]
Rule 30    binary_expr -> expr CONCAT expr  [precedence=left, level=1]
Rule 31    do -> DO _3_optional _4_optional _5_repeat END
Rule 32    _3_optional -> type
Rule 33    _3_optional -> <empty>
Rule 34    _4_optional -> expr
Rule 35    _4_optional -> <empty>
Rule 36    _5_repeat -> _5_items
Rule 37    _5_repeat -> <empty>
Rule 38    _5_items -> _5_items _5_item
Rule 39    _5_items -> _5_item
Rule 40    _5_item -> NEWLINE expr
Rule 41    _def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do
Rule 42    _6_optional -> param
Rule 43    _6_optional -> <empty>
Rule 44    _7_repeat -> _7_items
Rule 45    _7_repeat -> <empty>
Rule 46    _7_items -> _7_items _7_item
Rule 47    _7_items -> _7_item
Rule 48    _7_item -> , param
Rule 49    _8_optional -> type
Rule 50    _8_optional -> <empty>
Rule 51    type -> : identifier _9_optional
Rule 52    _9_optional -> < identifier _10_repeat >
Rule 53    _10_repeat -> _10_items
Rule 54    _10_repeat -> <empty>
Rule 55    _10_items -> _10_items _10_item
Rule 56    _10_items -> _10_item
Rule 57    _10_item -> , identifier
Rule 58    _9_optional -> <empty>
Rule 59    struct -> STRUCT identifier _11_optional { _13_repeat }
Rule 60    _11_optional -> < identifier _12_repeat >
Rule 61    _12_repeat -> _12_items
Rule 62    _12_repeat -> <empty>
Rule 63    _12_items -> _12_items _12_item
Rule 64    _12_items -> _12_item
Rule 65    _12_item -> , identifier
Rule 66    _11_optional -> <empty>
Rule 67    _13_repeat -> _13_items
Rule 68    _13_repeat -> <empty>
Rule 69    _13_items -> _13_items _13_item
Rule 70    _13_items -> _13_item
Rule 71    _13_item -> identifier type
Rule 72    enum -> ENUM identifier _14_optional { _16_repeat }
Rule 73    _14_optional -> < identifier _15_repeat >
Rule 74    _15_repeat -> _15_items
Rule 75    _15_repeat -> <empty>
Rule 76    _15_items -> _15_items _15_item
Rule 77    _15_items -> _15_item
Rule 78    _15_item -> , identifier
Rule 79    _14_optional -> <empty>
Rule 80    _16_repeat -> _16_items
Rule 81    _16_repeat -> <empty>
Rule 82    _16_items -> _16_items _16_item
Rule 83    _16_items -> _16_item
Rule 84    _16_item -> enum_key
Rule 85    enum_key -> identifier _17_optional
Rule 86    _17_optional -> ( identifier _18_repeat )
Rule 87    _18_repeat -> _18_items
Rule 88    _18_repeat -> <empty>
Rule 89    _18_items -> _18_items _18_item
Rule 90    _18_items -> _18_item
Rule 91    _18_item -> , identifier
Rule 92    _17_optional -> <empty>
Rule 93    param -> identifier _19_optional
Rule 94    _19_optional -> type
Rule 95    _19_optional -> <empty>
Rule 96    _if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
Rule 97    _20_optional -> type
Rule 98    _20_optional -> <empty>
Rule 99    _21_optional -> expr
Rule 100   _21_optional -> <empty>
Rule 101   _22_repeat -> _22_items
Rule 102   _22_repeat -> <empty>
Rule 103   _22_items -> _22_items _22_item
Rule 104   _22_items -> _22_item
Rule 105   _22_item -> NEWLINE expr
Rule 106   _23_repeat -> _23_items
Rule 107   _23_repeat -> <empty>
Rule 108   _23_items -> _23_items _23_item
Rule 109   _23_items -> _23_item
Rule 110   _23_item -> _elif
Rule 111   _24_optional -> _else
Rule 112   _24_optional -> <empty>
Rule 113   _else -> ELSE _25_optional _26_repeat
Rule 114   _25_optional -> expr
Rule 115   _25_optional -> <empty>
Rule 116   _26_repeat -> _26_items
Rule 117   _26_repeat -> <empty>
Rule 118   _26_items -> _26_items _26_item
Rule 119   _26_items -> _26_item
Rule 120   _26_item -> NEWLINE expr
Rule 121   _elif -> ELIF expr THEN _27_optional _28_optional _29_repeat
Rule 122   _27_optional -> type
Rule 123   _27_optional -> <empty>
Rule 124   _28_optional -> expr
Rule 125   _28_optional -> <empty>
Rule 126   _29_repeat -> _29_items
Rule 127   _29_repeat -> <empty>
Rule 128   _29_items -> _29_items _29_item
Rule 129   _29_items -> _29_item
Rule 130   _29_item -> NEWLINE expr
Rule 131   case_of -> CASE expr OF case _30_repeat END
Rule 132   _30_repeat -> _30_items
Rule 133   _30_repeat -> <empty>
Rule 134   _30_items -> _30_items _30_item
Rule 135   _30_items -> _30_item
Rule 136   _30_item -> case
Rule 137   case -> pattern _31_repeat do
Rule 138   _31_repeat -> _31_items
Rule 139   _31_repeat -> <empty>
Rule 140   _31_items -> _31_items _31_item
Rule 141   _31_items -> _31_item
Rule 142   _31_item -> , pattern
Rule 143   pattern -> array_pattern
Rule 144   pattern -> tuple_pattern
Rule 145   pattern -> enum_pattern
Rule 146   array_pattern -> [ _32_repeat _33_optional ]
Rule 147   _32_repeat -> _32_items
Rule 148   _32_repeat -> <empty>
Rule 149   _32_items -> _32_items _32_item
Rule 150   _32_items -> _32_item
Rule 151   _32_item -> pattern ,
Rule 152   _33_optional -> SPREAD identifier _34_repeat
Rule 153   _34_repeat -> _34_items
Rule 154   _34_repeat -> <empty>
Rule 155   _34_items -> _34_items _34_item
Rule 156   _34_items -> _34_item
Rule 157   _34_item -> , pattern
Rule 158   _33_optional -> <empty>
Rule 159   enum_pattern -> identifier _35_optional
Rule 160   _35_optional -> ( pattern _36_repeat )
Rule 161   _36_repeat -> _36_items
Rule 162   _36_repeat -> <empty>
Rule 163   _36_items -> _36_items _36_item
Rule 164   _36_items -> _36_item
Rule 165   _36_item -> , pattern
Rule 166   _35_optional -> <empty>
Rule 167   tuple_pattern -> { _37_repeat _38_optional }
Rule 168   _37_repeat -> _37_items
Rule 169   _37_repeat -> <empty>
Rule 170   _37_items -> _37_items _37_item
Rule 171   _37_items -> _37_item
Rule 172   _37_item -> pattern ,
Rule 173   _38_optional -> SPREAD identifier _39_repeat
Rule 174   _39_repeat -> _39_items
Rule 175   _39_repeat -> <empty>
Rule 176   _39_items -> _39_items _39_item
Rule 177   _39_items -> _39_item
Rule 178   _39_item -> , pattern
Rule 179   _38_optional -> <empty>
Rule 180   array -> [ _40_optional _41_repeat ]
Rule 181   _40_optional -> expr
Rule 182   _40_optional -> <empty>
Rule 183   _41_repeat -> _41_items
Rule 184   _41_repeat -> <empty>
Rule 185   _41_items -> _41_items _41_item
Rule 186   _41_items -> _41_item
Rule 187   _41_item -> , expr
Rule 188   tuple -> { _42_optional _43_repeat }
Rule 189   _42_optional -> expr
Rule 190   _42_optional -> <empty>
Rule 191   _43_repeat -> _43_items
Rule 192   _43_repeat -> <empty>
Rule 193   _43_items -> _43_items _43_item
Rule 194   _43_items -> _43_item
Rule 195   _43_item -> , expr
Rule 196   call -> callee ( _44_optional _45_repeat )
Rule 197   _44_optional -> expr
Rule 198   _44_optional -> <empty>
Rule 199   _45_repeat -> _45_items
Rule 200   _45_repeat -> <empty>
Rule 201   _45_items -> _45_items _45_item
Rule 202   _45_items -> _45_item
Rule 203   _45_item -> , expr
Rule 204   callee -> identifier
Rule 205   identifier -> IDENTIFIER
Rule 206   variable_declaration -> identifier _46_optional = expr
Rule 207   _46_optional -> type
Rule 208   _46_optional -> <empty>
Rule 209   literal -> STRING
Rule 210   literal -> NUMBER

Terminals, with rules where they appear:

(                    : 12 41 86 160 196
)                    : 12 41 86 160 196
*                    : 26
+                    : 29
,                    : 48 57 65 78 91 142 151 157 165 172 178 187 195 203
-                    : 13 28
/                    : 27
:                    : 51
<                    : 52 60 73
=                    : 206
>                    : 52 60 73
CASE                 : 131
CONCAT               : 30
DEF                  : 41
DO                   : 31
ELIF                 : 121
ELSE                 : 113
END                  : 31 96 131
ENUM                 : 72
IDENTIFIER           : 205
IF                   : 96
INT_DIV              : 25
NEWLINE              : 8 40 105 120 130
NUMBER               : 210
OF                   : 131
SPREAD               : 152 173
STRING               : 209
STRUCT               : 59
THEN                 : 96 121
[                    : 146 180
]                    : 146 180
error                : 
{                    : 59 72 167 188
}                    : 59 72 167 188

Nonterminals, with rules where they appear:

_10_item             : 55 56
_10_items            : 53 55
_10_repeat           : 52
_11_optional         : 59
_12_item             : 63 64
_12_items            : 61 63
_12_repeat           : 60
_13_item             : 69 70
_13_items            : 67 69
_13_repeat           : 59
_14_optional         : 72
_15_item             : 76 77
_15_items            : 74 76
_15_repeat           : 73
_16_item             : 82 83
_16_items            : 80 82
_16_repeat           : 72
_17_optional         : 85
_18_item             : 89 90
_18_items            : 87 89
_18_repeat           : 86
_19_optional         : 93
_1_optional          : 1
_20_optional         : 96
_21_optional         : 96
_22_item             : 103 104
_22_items            : 101 103
_22_repeat           : 96
_23_item             : 108 109
_23_items            : 106 108
_23_repeat           : 96
_24_optional         : 96
_25_optional         : 113
_26_item             : 118 119
_26_items            : 116 118
_26_repeat           : 113
_27_optional         : 121
_28_optional         : 121
_29_item             : 128 129
_29_items            : 126 128
_29_repeat           : 121
_2_item              : 6 7
_2_items             : 4 6
_2_repeat            : 1
_30_item             : 134 135
_30_items            : 132 134
_30_repeat           : 131
_31_item             : 140 141
_31_items            : 138 140
_31_repeat           : 137
_32_item             : 149 150
_32_items            : 147 149
_32_repeat           : 146
_33_optional         : 146
_34_item             : 155 156
_34_items            : 153 155
_34_repeat           : 152
_35_optional         : 159
_36_item             : 163 164
_36_items            : 161 163
_36_repeat           : 160
_37_item             : 170 171
_37_items            : 168 170
_37_repeat           : 167
_38_optional         : 167
_39_item             : 176 177
_39_items            : 174 176
_39_repeat           : 173
_3_optional          : 31
_40_optional         : 180
_41_item             : 185 186
_41_items            : 183 185
_41_repeat           : 180
_42_optional         : 188
_43_item             : 193 194
_43_items            : 191 193
_43_repeat           : 188
_44_optional         : 196
_45_item             : 201 202
_45_items            : 199 201
_45_repeat           : 196
_46_optional         : 206
_4_optional          : 31
_5_item              : 38 39
_5_items             : 36 38
_5_repeat            : 31
_6_optional          : 41
_7_item              : 46 47
_7_items             : 44 46
_7_repeat            : 41
_8_optional          : 41
_9_optional          : 51
_def                 : 21
_elif                : 110
_else                : 111
_if                  : 20
array                : 15
array_pattern        : 143
binary_expr          : 16
body                 : 2 8
call                 : 19
callee               : 196
case                 : 131 136
case_of              : 18
do                   : 24 41 137
enum                 : 9
enum_key             : 84
enum_pattern         : 145
expr                 : 11 12 13 25 25 26 26 27 27 28 28 29 29 30 30 34 40 96 99 105 114 120 121 124 130 131 181 187 189 195 197 203 206
identifier           : 23 41 51 52 57 59 60 65 71 72 73 78 85 86 91 93 152 159 173 204 206
literal              : 22
param                : 42 48
pattern              : 137 142 151 157 160 165 172 178
program              : 0
struct               : 10
tuple                : 14
tuple_pattern        : 144
type                 : 32 49 71 94 97 122 207
variable_declaration : 17


state 0

    (0) S' -> . program
    (1) program -> . _1_optional _2_repeat
    (2) _1_optional -> . body
    (3) _1_optional -> .
    (9) body -> . enum
    (10) body -> . struct
    (11) body -> . expr
    (72) enum -> . ENUM identifier _14_optional { _16_repeat }
    (59) struct -> . STRUCT identifier _11_optional { _13_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    NEWLINE         reduce using rule 3 (_1_optional -> .)
    $end            reduce using rule 3 (_1_optional -> .)
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    program                        shift and go to state 1
    _1_optional                    shift and go to state 2
    body                           shift and go to state 3
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    identifier                     shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_optional . _2_repeat
    (4) _2_repeat -> . _2_items
    (5) _2_repeat -> .
    (6) _2_items -> . _2_items _2_item
    (7) _2_items -> . _2_item
    (8) _2_item -> . NEWLINE body
    $end            reduce using rule 5 (_2_repeat -> .)
    NEWLINE         shift and go to state 35

    _2_repeat                      shift and go to state 32
    _2_items                       shift and go to state 33
    _2_item                        shift and go to state 34

state 3

    (2) _1_optional -> body .
    NEWLINE         reduce using rule 2 (_1_optional -> body .)
    $end            reduce using rule 2 (_1_optional -> body .)


state 4

    (9) body -> enum .
    NEWLINE         reduce using rule 9 (body -> enum .)
    $end            reduce using rule 9 (body -> enum .)


state 5

    (10) body -> struct .
    NEWLINE         reduce using rule 10 (body -> struct .)
    $end            reduce using rule 10 (body -> struct .)


state 6

    (11) body -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 11 (body -> expr .)
    $end            reduce using rule 11 (body -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 7

    (72) enum -> ENUM . identifier _14_optional { _16_repeat }
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 42

state 8

    (23) expr -> identifier .
    (206) variable_declaration -> identifier . _46_optional = expr
    (204) callee -> identifier .
    (207) _46_optional -> . type
    (208) _46_optional -> .
    (51) type -> . : identifier _9_optional
    INT_DIV         reduce using rule 23 (expr -> identifier .)
    *               reduce using rule 23 (expr -> identifier .)
    /               reduce using rule 23 (expr -> identifier .)
    -               reduce using rule 23 (expr -> identifier .)
    +               reduce using rule 23 (expr -> identifier .)
    CONCAT          reduce using rule 23 (expr -> identifier .)
    NEWLINE         reduce using rule 23 (expr -> identifier .)
    $end            reduce using rule 23 (expr -> identifier .)
    ,               reduce using rule 23 (expr -> identifier .)
    }               reduce using rule 23 (expr -> identifier .)
    )               reduce using rule 23 (expr -> identifier .)
    ]               reduce using rule 23 (expr -> identifier .)
    OF              reduce using rule 23 (expr -> identifier .)
    THEN            reduce using rule 23 (expr -> identifier .)
    END             reduce using rule 23 (expr -> identifier .)
    ELIF            reduce using rule 23 (expr -> identifier .)
    ELSE            reduce using rule 23 (expr -> identifier .)
    (               reduce using rule 204 (callee -> identifier .)
    =               reduce using rule 208 (_46_optional -> .)
    :               shift and go to state 45

    _46_optional                   shift and go to state 43
    type                           shift and go to state 44

state 9

    (188) tuple -> { . _42_optional _43_repeat }
    (189) _42_optional -> . expr
    (190) _42_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    ,               reduce using rule 190 (_42_optional -> .)
    }               reduce using rule 190 (_42_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    _42_optional                   shift and go to state 46
    expr                           shift and go to state 47
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 10

    (59) struct -> STRUCT . identifier _11_optional { _13_repeat }
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 48

state 11

    (12) expr -> ( . expr )
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 49
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 12

    (13) expr -> - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 50
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 13

    (14) expr -> tuple .
    INT_DIV         reduce using rule 14 (expr -> tuple .)
    *               reduce using rule 14 (expr -> tuple .)
    /               reduce using rule 14 (expr -> tuple .)
    -               reduce using rule 14 (expr -> tuple .)
    +               reduce using rule 14 (expr -> tuple .)
    CONCAT          reduce using rule 14 (expr -> tuple .)
    NEWLINE         reduce using rule 14 (expr -> tuple .)
    $end            reduce using rule 14 (expr -> tuple .)
    ,               reduce using rule 14 (expr -> tuple .)
    }               reduce using rule 14 (expr -> tuple .)
    )               reduce using rule 14 (expr -> tuple .)
    ]               reduce using rule 14 (expr -> tuple .)
    OF              reduce using rule 14 (expr -> tuple .)
    THEN            reduce using rule 14 (expr -> tuple .)
    END             reduce using rule 14 (expr -> tuple .)
    ELIF            reduce using rule 14 (expr -> tuple .)
    ELSE            reduce using rule 14 (expr -> tuple .)


state 14

    (15) expr -> array .
    INT_DIV         reduce using rule 15 (expr -> array .)
    *               reduce using rule 15 (expr -> array .)
    /               reduce using rule 15 (expr -> array .)
    -               reduce using rule 15 (expr -> array .)
    +               reduce using rule 15 (expr -> array .)
    CONCAT          reduce using rule 15 (expr -> array .)
    NEWLINE         reduce using rule 15 (expr -> array .)
    $end            reduce using rule 15 (expr -> array .)
    ,               reduce using rule 15 (expr -> array .)
    }               reduce using rule 15 (expr -> array .)
    )               reduce using rule 15 (expr -> array .)
    ]               reduce using rule 15 (expr -> array .)
    OF              reduce using rule 15 (expr -> array .)
    THEN            reduce using rule 15 (expr -> array .)
    END             reduce using rule 15 (expr -> array .)
    ELIF            reduce using rule 15 (expr -> array .)
    ELSE            reduce using rule 15 (expr -> array .)


state 15

    (16) expr -> binary_expr .
    INT_DIV         reduce using rule 16 (expr -> binary_expr .)
    *               reduce using rule 16 (expr -> binary_expr .)
    /               reduce using rule 16 (expr -> binary_expr .)
    -               reduce using rule 16 (expr -> binary_expr .)
    +               reduce using rule 16 (expr -> binary_expr .)
    CONCAT          reduce using rule 16 (expr -> binary_expr .)
    NEWLINE         reduce using rule 16 (expr -> binary_expr .)
    $end            reduce using rule 16 (expr -> binary_expr .)
    ,               reduce using rule 16 (expr -> binary_expr .)
    }               reduce using rule 16 (expr -> binary_expr .)
    )               reduce using rule 16 (expr -> binary_expr .)
    ]               reduce using rule 16 (expr -> binary_expr .)
    OF              reduce using rule 16 (expr -> binary_expr .)
    THEN            reduce using rule 16 (expr -> binary_expr .)
    END             reduce using rule 16 (expr -> binary_expr .)
    ELIF            reduce using rule 16 (expr -> binary_expr .)
    ELSE            reduce using rule 16 (expr -> binary_expr .)


state 16

    (17) expr -> variable_declaration .
    INT_DIV         reduce using rule 17 (expr -> variable_declaration .)
    *               reduce using rule 17 (expr -> variable_declaration .)
    /               reduce using rule 17 (expr -> variable_declaration .)
    -               reduce using rule 17 (expr -> variable_declaration .)
    +               reduce using rule 17 (expr -> variable_declaration .)
    CONCAT          reduce using rule 17 (expr -> variable_declaration .)
    NEWLINE         reduce using rule 17 (expr -> variable_declaration .)
    $end            reduce using rule 17 (expr -> variable_declaration .)
    ,               reduce using rule 17 (expr -> variable_declaration .)
    }               reduce using rule 17 (expr -> variable_declaration .)
    )               reduce using rule 17 (expr -> variable_declaration .)
    ]               reduce using rule 17 (expr -> variable_declaration .)
    OF              reduce using rule 17 (expr -> variable_declaration .)
    THEN            reduce using rule 17 (expr -> variable_declaration .)
    END             reduce using rule 17 (expr -> variable_declaration .)
    ELIF            reduce using rule 17 (expr -> variable_declaration .)
    ELSE            reduce using rule 17 (expr -> variable_declaration .)


state 17

    (18) expr -> case_of .
    INT_DIV         reduce using rule 18 (expr -> case_of .)
    *               reduce using rule 18 (expr -> case_of .)
    /               reduce using rule 18 (expr -> case_of .)
    -               reduce using rule 18 (expr -> case_of .)
    +               reduce using rule 18 (expr -> case_of .)
    CONCAT          reduce using rule 18 (expr -> case_of .)
    NEWLINE         reduce using rule 18 (expr -> case_of .)
    $end            reduce using rule 18 (expr -> case_of .)
    ,               reduce using rule 18 (expr -> case_of .)
    }               reduce using rule 18 (expr -> case_of .)
    )               reduce using rule 18 (expr -> case_of .)
    ]               reduce using rule 18 (expr -> case_of .)
    OF              reduce using rule 18 (expr -> case_of .)
    THEN            reduce using rule 18 (expr -> case_of .)
    END             reduce using rule 18 (expr -> case_of .)
    ELIF            reduce using rule 18 (expr -> case_of .)
    ELSE            reduce using rule 18 (expr -> case_of .)


state 18

    (19) expr -> call .
    INT_DIV         reduce using rule 19 (expr -> call .)
    *               reduce using rule 19 (expr -> call .)
    /               reduce using rule 19 (expr -> call .)
    -               reduce using rule 19 (expr -> call .)
    +               reduce using rule 19 (expr -> call .)
    CONCAT          reduce using rule 19 (expr -> call .)
    NEWLINE         reduce using rule 19 (expr -> call .)
    $end            reduce using rule 19 (expr -> call .)
    ,               reduce using rule 19 (expr -> call .)
    }               reduce using rule 19 (expr -> call .)
    )               reduce using rule 19 (expr -> call .)
    ]               reduce using rule 19 (expr -> call .)
    OF              reduce using rule 19 (expr -> call .)
    THEN            reduce using rule 19 (expr -> call .)
    END             reduce using rule 19 (expr -> call .)
    ELIF            reduce using rule 19 (expr -> call .)
    ELSE            reduce using rule 19 (expr -> call .)


state 19

    (20) expr -> _if .
    INT_DIV         reduce using rule 20 (expr -> _if .)
    *               reduce using rule 20 (expr -> _if .)
    /               reduce using rule 20 (expr -> _if .)
    -               reduce using rule 20 (expr -> _if .)
    +               reduce using rule 20 (expr -> _if .)
    CONCAT          reduce using rule 20 (expr -> _if .)
    NEWLINE         reduce using rule 20 (expr -> _if .)
    $end            reduce using rule 20 (expr -> _if .)
    ,               reduce using rule 20 (expr -> _if .)
    }               reduce using rule 20 (expr -> _if .)
    )               reduce using rule 20 (expr -> _if .)
    ]               reduce using rule 20 (expr -> _if .)
    OF              reduce using rule 20 (expr -> _if .)
    THEN            reduce using rule 20 (expr -> _if .)
    END             reduce using rule 20 (expr -> _if .)
    ELIF            reduce using rule 20 (expr -> _if .)
    ELSE            reduce using rule 20 (expr -> _if .)


state 20

    (21) expr -> _def .
    INT_DIV         reduce using rule 21 (expr -> _def .)
    *               reduce using rule 21 (expr -> _def .)
    /               reduce using rule 21 (expr -> _def .)
    -               reduce using rule 21 (expr -> _def .)
    +               reduce using rule 21 (expr -> _def .)
    CONCAT          reduce using rule 21 (expr -> _def .)
    NEWLINE         reduce using rule 21 (expr -> _def .)
    $end            reduce using rule 21 (expr -> _def .)
    ,               reduce using rule 21 (expr -> _def .)
    }               reduce using rule 21 (expr -> _def .)
    )               reduce using rule 21 (expr -> _def .)
    ]               reduce using rule 21 (expr -> _def .)
    OF              reduce using rule 21 (expr -> _def .)
    THEN            reduce using rule 21 (expr -> _def .)
    END             reduce using rule 21 (expr -> _def .)
    ELIF            reduce using rule 21 (expr -> _def .)
    ELSE            reduce using rule 21 (expr -> _def .)


state 21

    (22) expr -> literal .
    INT_DIV         reduce using rule 22 (expr -> literal .)
    *               reduce using rule 22 (expr -> literal .)
    /               reduce using rule 22 (expr -> literal .)
    -               reduce using rule 22 (expr -> literal .)
    +               reduce using rule 22 (expr -> literal .)
    CONCAT          reduce using rule 22 (expr -> literal .)
    NEWLINE         reduce using rule 22 (expr -> literal .)
    $end            reduce using rule 22 (expr -> literal .)
    ,               reduce using rule 22 (expr -> literal .)
    }               reduce using rule 22 (expr -> literal .)
    )               reduce using rule 22 (expr -> literal .)
    ]               reduce using rule 22 (expr -> literal .)
    OF              reduce using rule 22 (expr -> literal .)
    THEN            reduce using rule 22 (expr -> literal .)
    END             reduce using rule 22 (expr -> literal .)
    ELIF            reduce using rule 22 (expr -> literal .)
    ELSE            reduce using rule 22 (expr -> literal .)


state 22

    (24) expr -> do .
    INT_DIV         reduce using rule 24 (expr -> do .)
    *               reduce using rule 24 (expr -> do .)
    /               reduce using rule 24 (expr -> do .)
    -               reduce using rule 24 (expr -> do .)
    +               reduce using rule 24 (expr -> do .)
    CONCAT          reduce using rule 24 (expr -> do .)
    NEWLINE         reduce using rule 24 (expr -> do .)
    $end            reduce using rule 24 (expr -> do .)
    ,               reduce using rule 24 (expr -> do .)
    }               reduce using rule 24 (expr -> do .)
    )               reduce using rule 24 (expr -> do .)
    ]               reduce using rule 24 (expr -> do .)
    OF              reduce using rule 24 (expr -> do .)
    THEN            reduce using rule 24 (expr -> do .)
    END             reduce using rule 24 (expr -> do .)
    ELIF            reduce using rule 24 (expr -> do .)
    ELSE            reduce using rule 24 (expr -> do .)


state 23

    (180) array -> [ . _40_optional _41_repeat ]
    (181) _40_optional -> . expr
    (182) _40_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    ,               reduce using rule 182 (_40_optional -> .)
    ]               reduce using rule 182 (_40_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    _40_optional                   shift and go to state 51
    expr                           shift and go to state 52
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 24

    (131) case_of -> CASE . expr OF case _30_repeat END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 53
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 25

    (196) call -> callee . ( _44_optional _45_repeat )
    (               shift and go to state 54


state 26

    (96) _if -> IF . expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 55
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 27

    (41) _def -> DEF . identifier ( _6_optional _7_repeat ) _8_optional do
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 56

state 28

    (209) literal -> STRING .
    INT_DIV         reduce using rule 209 (literal -> STRING .)
    *               reduce using rule 209 (literal -> STRING .)
    /               reduce using rule 209 (literal -> STRING .)
    -               reduce using rule 209 (literal -> STRING .)
    +               reduce using rule 209 (literal -> STRING .)
    CONCAT          reduce using rule 209 (literal -> STRING .)
    NEWLINE         reduce using rule 209 (literal -> STRING .)
    $end            reduce using rule 209 (literal -> STRING .)
    ,               reduce using rule 209 (literal -> STRING .)
    }               reduce using rule 209 (literal -> STRING .)
    )               reduce using rule 209 (literal -> STRING .)
    ]               reduce using rule 209 (literal -> STRING .)
    OF              reduce using rule 209 (literal -> STRING .)
    THEN            reduce using rule 209 (literal -> STRING .)
    END             reduce using rule 209 (literal -> STRING .)
    ELIF            reduce using rule 209 (literal -> STRING .)
    ELSE            reduce using rule 209 (literal -> STRING .)


state 29

    (210) literal -> NUMBER .
    INT_DIV         reduce using rule 210 (literal -> NUMBER .)
    *               reduce using rule 210 (literal -> NUMBER .)
    /               reduce using rule 210 (literal -> NUMBER .)
    -               reduce using rule 210 (literal -> NUMBER .)
    +               reduce using rule 210 (literal -> NUMBER .)
    CONCAT          reduce using rule 210 (literal -> NUMBER .)
    NEWLINE         reduce using rule 210 (literal -> NUMBER .)
    $end            reduce using rule 210 (literal -> NUMBER .)
    ,               reduce using rule 210 (literal -> NUMBER .)
    }               reduce using rule 210 (literal -> NUMBER .)
    )               reduce using rule 210 (literal -> NUMBER .)
    ]               reduce using rule 210 (literal -> NUMBER .)
    OF              reduce using rule 210 (literal -> NUMBER .)
    THEN            reduce using rule 210 (literal -> NUMBER .)
    END             reduce using rule 210 (literal -> NUMBER .)
    ELIF            reduce using rule 210 (literal -> NUMBER .)
    ELSE            reduce using rule 210 (literal -> NUMBER .)


state 30

    (205) identifier -> IDENTIFIER .
    :               reduce using rule 205 (identifier -> IDENTIFIER .)
    =               reduce using rule 205 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 205 (identifier -> IDENTIFIER .)
    *               reduce using rule 205 (identifier -> IDENTIFIER .)
    /               reduce using rule 205 (identifier -> IDENTIFIER .)
    -               reduce using rule 205 (identifier -> IDENTIFIER .)
    +               reduce using rule 205 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 205 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 205 (identifier -> IDENTIFIER .)
    $end            reduce using rule 205 (identifier -> IDENTIFIER .)
    (               reduce using rule 205 (identifier -> IDENTIFIER .)
    <               reduce using rule 205 (identifier -> IDENTIFIER .)
    {               reduce using rule 205 (identifier -> IDENTIFIER .)
    ,               reduce using rule 205 (identifier -> IDENTIFIER .)
    }               reduce using rule 205 (identifier -> IDENTIFIER .)
    )               reduce using rule 205 (identifier -> IDENTIFIER .)
    ]               reduce using rule 205 (identifier -> IDENTIFIER .)
    OF              reduce using rule 205 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 205 (identifier -> IDENTIFIER .)
    END             reduce using rule 205 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 205 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 205 (identifier -> IDENTIFIER .)
    [               reduce using rule 205 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 205 (identifier -> IDENTIFIER .)
    IF              reduce using rule 205 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 205 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 205 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 205 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 205 (identifier -> IDENTIFIER .)
    DO              reduce using rule 205 (identifier -> IDENTIFIER .)
    >               reduce using rule 205 (identifier -> IDENTIFIER .)


state 31

    (31) do -> DO . _3_optional _4_optional _5_repeat END
    (32) _3_optional -> . type
    (33) _3_optional -> .
    (51) type -> . : identifier _9_optional
    (               reduce using rule 33 (_3_optional -> .)
    -               reduce using rule 33 (_3_optional -> .)
    {               reduce using rule 33 (_3_optional -> .)
    [               reduce using rule 33 (_3_optional -> .)
    CASE            reduce using rule 33 (_3_optional -> .)
    IF              reduce using rule 33 (_3_optional -> .)
    DEF             reduce using rule 33 (_3_optional -> .)
    STRING          reduce using rule 33 (_3_optional -> .)
    NUMBER          reduce using rule 33 (_3_optional -> .)
    IDENTIFIER      reduce using rule 33 (_3_optional -> .)
    DO              reduce using rule 33 (_3_optional -> .)
    NEWLINE         reduce using rule 33 (_3_optional -> .)
    END             reduce using rule 33 (_3_optional -> .)
    :               shift and go to state 45

    _3_optional                    shift and go to state 57
    type                           shift and go to state 58

state 32

    (1) program -> _1_optional _2_repeat .
    $end            reduce using rule 1 (program -> _1_optional _2_repeat .)


state 33

    (4) _2_repeat -> _2_items .
    (6) _2_items -> _2_items . _2_item
    (8) _2_item -> . NEWLINE body
    $end            reduce using rule 4 (_2_repeat -> _2_items .)
    NEWLINE         shift and go to state 35

    _2_item                        shift and go to state 59

state 34

    (7) _2_items -> _2_item .
    NEWLINE         reduce using rule 7 (_2_items -> _2_item .)
    $end            reduce using rule 7 (_2_items -> _2_item .)


state 35

    (8) _2_item -> NEWLINE . body
    (9) body -> . enum
    (10) body -> . struct
    (11) body -> . expr
    (72) enum -> . ENUM identifier _14_optional { _16_repeat }
    (59) struct -> . STRUCT identifier _11_optional { _13_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    body                           shift and go to state 60
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    identifier                     shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 36

    (25) binary_expr -> expr INT_DIV . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 61
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 37

    (26) binary_expr -> expr * . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 62
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 38

    (27) binary_expr -> expr / . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 63
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 39

    (28) binary_expr -> expr - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 64
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 40

    (29) binary_expr -> expr + . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 65
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 41

    (30) binary_expr -> expr CONCAT . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 66
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 42

    (72) enum -> ENUM identifier . _14_optional { _16_repeat }
    (73) _14_optional -> . < identifier _15_repeat >
    (79) _14_optional -> .
    <               shift and go to state 68
    {               reduce using rule 79 (_14_optional -> .)

    _14_optional                   shift and go to state 67

state 43

    (206) variable_declaration -> identifier _46_optional . = expr
    =               shift and go to state 69


state 44

    (207) _46_optional -> type .
    =               reduce using rule 207 (_46_optional -> type .)


state 45

    (51) type -> : . identifier _9_optional
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 70

state 46

    (188) tuple -> { _42_optional . _43_repeat }
    (191) _43_repeat -> . _43_items
    (192) _43_repeat -> .
    (193) _43_items -> . _43_items _43_item
    (194) _43_items -> . _43_item
    (195) _43_item -> . , expr
    }               reduce using rule 192 (_43_repeat -> .)
    ,               shift and go to state 74

    _43_repeat                     shift and go to state 71
    _43_items                      shift and go to state 72
    _43_item                       shift and go to state 73

state 47

    (189) _42_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 189 (_42_optional -> expr .)
    }               reduce using rule 189 (_42_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 48

    (59) struct -> STRUCT identifier . _11_optional { _13_repeat }
    (60) _11_optional -> . < identifier _12_repeat >
    (66) _11_optional -> .
    <               shift and go to state 76
    {               reduce using rule 66 (_11_optional -> .)

    _11_optional                   shift and go to state 75

state 49

    (12) expr -> ( expr . )
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    )               shift and go to state 77
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 50

    (13) expr -> - expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 13 (expr -> - expr .)
    *               reduce using rule 13 (expr -> - expr .)
    /               reduce using rule 13 (expr -> - expr .)
    -               reduce using rule 13 (expr -> - expr .)
    +               reduce using rule 13 (expr -> - expr .)
    CONCAT          reduce using rule 13 (expr -> - expr .)
    NEWLINE         reduce using rule 13 (expr -> - expr .)
    $end            reduce using rule 13 (expr -> - expr .)
    ,               reduce using rule 13 (expr -> - expr .)
    }               reduce using rule 13 (expr -> - expr .)
    )               reduce using rule 13 (expr -> - expr .)
    ]               reduce using rule 13 (expr -> - expr .)
    OF              reduce using rule 13 (expr -> - expr .)
    THEN            reduce using rule 13 (expr -> - expr .)
    END             reduce using rule 13 (expr -> - expr .)
    ELIF            reduce using rule 13 (expr -> - expr .)
    ELSE            reduce using rule 13 (expr -> - expr .)


state 51

    (180) array -> [ _40_optional . _41_repeat ]
    (183) _41_repeat -> . _41_items
    (184) _41_repeat -> .
    (185) _41_items -> . _41_items _41_item
    (186) _41_items -> . _41_item
    (187) _41_item -> . , expr
    ]               reduce using rule 184 (_41_repeat -> .)
    ,               shift and go to state 81

    _41_repeat                     shift and go to state 78
    _41_items                      shift and go to state 79
    _41_item                       shift and go to state 80

state 52

    (181) _40_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 181 (_40_optional -> expr .)
    ]               reduce using rule 181 (_40_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 53

    (131) case_of -> CASE expr . OF case _30_repeat END
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 82
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 54

    (196) call -> callee ( . _44_optional _45_repeat )
    (197) _44_optional -> . expr
    (198) _44_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    ,               reduce using rule 198 (_44_optional -> .)
    )               reduce using rule 198 (_44_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    callee                         shift and go to state 25
    _44_optional                   shift and go to state 83
    expr                           shift and go to state 84
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22

state 55

    (96) _if -> IF expr . THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 85
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 56

    (41) _def -> DEF identifier . ( _6_optional _7_repeat ) _8_optional do
    (               shift and go to state 86


state 57

    (31) do -> DO _3_optional . _4_optional _5_repeat END
    (34) _4_optional -> . expr
    (35) _4_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    NEWLINE         reduce using rule 35 (_4_optional -> .)
    END             reduce using rule 35 (_4_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    _4_optional                    shift and go to state 87
    expr                           shift and go to state 88
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 58

    (32) _3_optional -> type .
    (               reduce using rule 32 (_3_optional -> type .)
    -               reduce using rule 32 (_3_optional -> type .)
    {               reduce using rule 32 (_3_optional -> type .)
    [               reduce using rule 32 (_3_optional -> type .)
    CASE            reduce using rule 32 (_3_optional -> type .)
    IF              reduce using rule 32 (_3_optional -> type .)
    DEF             reduce using rule 32 (_3_optional -> type .)
    STRING          reduce using rule 32 (_3_optional -> type .)
    NUMBER          reduce using rule 32 (_3_optional -> type .)
    IDENTIFIER      reduce using rule 32 (_3_optional -> type .)
    DO              reduce using rule 32 (_3_optional -> type .)
    NEWLINE         reduce using rule 32 (_3_optional -> type .)
    END             reduce using rule 32 (_3_optional -> type .)


state 59

    (6) _2_items -> _2_items _2_item .
    NEWLINE         reduce using rule 6 (_2_items -> _2_items _2_item .)
    $end            reduce using rule 6 (_2_items -> _2_items _2_item .)


state 60

    (8) _2_item -> NEWLINE body .
    NEWLINE         reduce using rule 8 (_2_item -> NEWLINE body .)
    $end            reduce using rule 8 (_2_item -> NEWLINE body .)


state 61

    (25) binary_expr -> expr INT_DIV expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    NEWLINE         reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    }               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)


state 62

    (26) binary_expr -> expr * expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 26 (binary_expr -> expr * expr .)
    *               reduce using rule 26 (binary_expr -> expr * expr .)
    /               reduce using rule 26 (binary_expr -> expr * expr .)
    -               reduce using rule 26 (binary_expr -> expr * expr .)
    +               reduce using rule 26 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr * expr .)
    NEWLINE         reduce using rule 26 (binary_expr -> expr * expr .)
    $end            reduce using rule 26 (binary_expr -> expr * expr .)
    ,               reduce using rule 26 (binary_expr -> expr * expr .)
    }               reduce using rule 26 (binary_expr -> expr * expr .)
    )               reduce using rule 26 (binary_expr -> expr * expr .)
    ]               reduce using rule 26 (binary_expr -> expr * expr .)
    OF              reduce using rule 26 (binary_expr -> expr * expr .)
    THEN            reduce using rule 26 (binary_expr -> expr * expr .)
    END             reduce using rule 26 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr * expr .)


state 63

    (27) binary_expr -> expr / expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 27 (binary_expr -> expr / expr .)
    *               reduce using rule 27 (binary_expr -> expr / expr .)
    /               reduce using rule 27 (binary_expr -> expr / expr .)
    -               reduce using rule 27 (binary_expr -> expr / expr .)
    +               reduce using rule 27 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 27 (binary_expr -> expr / expr .)
    NEWLINE         reduce using rule 27 (binary_expr -> expr / expr .)
    $end            reduce using rule 27 (binary_expr -> expr / expr .)
    ,               reduce using rule 27 (binary_expr -> expr / expr .)
    }               reduce using rule 27 (binary_expr -> expr / expr .)
    )               reduce using rule 27 (binary_expr -> expr / expr .)
    ]               reduce using rule 27 (binary_expr -> expr / expr .)
    OF              reduce using rule 27 (binary_expr -> expr / expr .)
    THEN            reduce using rule 27 (binary_expr -> expr / expr .)
    END             reduce using rule 27 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr / expr .)


state 64

    (28) binary_expr -> expr - expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    -               reduce using rule 28 (binary_expr -> expr - expr .)
    +               reduce using rule 28 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 28 (binary_expr -> expr - expr .)
    NEWLINE         reduce using rule 28 (binary_expr -> expr - expr .)
    $end            reduce using rule 28 (binary_expr -> expr - expr .)
    ,               reduce using rule 28 (binary_expr -> expr - expr .)
    }               reduce using rule 28 (binary_expr -> expr - expr .)
    )               reduce using rule 28 (binary_expr -> expr - expr .)
    ]               reduce using rule 28 (binary_expr -> expr - expr .)
    OF              reduce using rule 28 (binary_expr -> expr - expr .)
    THEN            reduce using rule 28 (binary_expr -> expr - expr .)
    END             reduce using rule 28 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr - expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38


state 65

    (29) binary_expr -> expr + expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    -               reduce using rule 29 (binary_expr -> expr + expr .)
    +               reduce using rule 29 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 29 (binary_expr -> expr + expr .)
    NEWLINE         reduce using rule 29 (binary_expr -> expr + expr .)
    $end            reduce using rule 29 (binary_expr -> expr + expr .)
    ,               reduce using rule 29 (binary_expr -> expr + expr .)
    }               reduce using rule 29 (binary_expr -> expr + expr .)
    )               reduce using rule 29 (binary_expr -> expr + expr .)
    ]               reduce using rule 29 (binary_expr -> expr + expr .)
    OF              reduce using rule 29 (binary_expr -> expr + expr .)
    THEN            reduce using rule 29 (binary_expr -> expr + expr .)
    END             reduce using rule 29 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr + expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38


state 66

    (30) binary_expr -> expr CONCAT expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    CONCAT          reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    NEWLINE         reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    }               reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 67

    (72) enum -> ENUM identifier _14_optional . { _16_repeat }
    {               shift and go to state 89


state 68

    (73) _14_optional -> < . identifier _15_repeat >
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 90

state 69

    (206) variable_declaration -> identifier _46_optional = . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    identifier                     shift and go to state 8
    expr                           shift and go to state 91
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 70

    (51) type -> : identifier . _9_optional
    (52) _9_optional -> . < identifier _10_repeat >
    (58) _9_optional -> .
    <               shift and go to state 93
    =               reduce using rule 58 (_9_optional -> .)
    (               reduce using rule 58 (_9_optional -> .)
    -               reduce using rule 58 (_9_optional -> .)
    {               reduce using rule 58 (_9_optional -> .)
    [               reduce using rule 58 (_9_optional -> .)
    CASE            reduce using rule 58 (_9_optional -> .)
    IF              reduce using rule 58 (_9_optional -> .)
    DEF             reduce using rule 58 (_9_optional -> .)
    STRING          reduce using rule 58 (_9_optional -> .)
    NUMBER          reduce using rule 58 (_9_optional -> .)
    IDENTIFIER      reduce using rule 58 (_9_optional -> .)
    DO              reduce using rule 58 (_9_optional -> .)
    NEWLINE         reduce using rule 58 (_9_optional -> .)
    END             reduce using rule 58 (_9_optional -> .)
    ELIF            reduce using rule 58 (_9_optional -> .)
    ELSE            reduce using rule 58 (_9_optional -> .)
    ,               reduce using rule 58 (_9_optional -> .)
    )               reduce using rule 58 (_9_optional -> .)
    }               reduce using rule 58 (_9_optional -> .)

    _9_optional                    shift and go to state 92

state 71

    (188) tuple -> { _42_optional _43_repeat . }
    }               shift and go to state 94


state 72

    (191) _43_repeat -> _43_items .
    (193) _43_items -> _43_items . _43_item
    (195) _43_item -> . , expr
    }               reduce using rule 191 (_43_repeat -> _43_items .)
    ,               shift and go to state 74

    _43_item                       shift and go to state 95

state 73

    (194) _43_items -> _43_item .
    ,               reduce using rule 194 (_43_items -> _43_item .)
    }               reduce using rule 194 (_43_items -> _43_item .)


state 74

    (195) _43_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 96
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 75

    (59) struct -> STRUCT identifier _11_optional . { _13_repeat }
    {               shift and go to state 97


state 76

    (60) _11_optional -> < . identifier _12_repeat >
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 98

state 77

    (12) expr -> ( expr ) .
    INT_DIV         reduce using rule 12 (expr -> ( expr ) .)
    *               reduce using rule 12 (expr -> ( expr ) .)
    /               reduce using rule 12 (expr -> ( expr ) .)
    -               reduce using rule 12 (expr -> ( expr ) .)
    +               reduce using rule 12 (expr -> ( expr ) .)
    CONCAT          reduce using rule 12 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 12 (expr -> ( expr ) .)
    $end            reduce using rule 12 (expr -> ( expr ) .)
    ,               reduce using rule 12 (expr -> ( expr ) .)
    }               reduce using rule 12 (expr -> ( expr ) .)
    )               reduce using rule 12 (expr -> ( expr ) .)
    ]               reduce using rule 12 (expr -> ( expr ) .)
    OF              reduce using rule 12 (expr -> ( expr ) .)
    THEN            reduce using rule 12 (expr -> ( expr ) .)
    END             reduce using rule 12 (expr -> ( expr ) .)
    ELIF            reduce using rule 12 (expr -> ( expr ) .)
    ELSE            reduce using rule 12 (expr -> ( expr ) .)


state 78

    (180) array -> [ _40_optional _41_repeat . ]
    ]               shift and go to state 99


state 79

    (183) _41_repeat -> _41_items .
    (185) _41_items -> _41_items . _41_item
    (187) _41_item -> . , expr
    ]               reduce using rule 183 (_41_repeat -> _41_items .)
    ,               shift and go to state 81

    _41_item                       shift and go to state 100

state 80

    (186) _41_items -> _41_item .
    ,               reduce using rule 186 (_41_items -> _41_item .)
    ]               reduce using rule 186 (_41_items -> _41_item .)


state 81

    (187) _41_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 101
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 82

    (131) case_of -> CASE expr OF . case _30_repeat END
    (137) case -> . pattern _31_repeat do
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    case                           shift and go to state 102
    pattern                        shift and go to state 103
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 83

    (196) call -> callee ( _44_optional . _45_repeat )
    (199) _45_repeat -> . _45_items
    (200) _45_repeat -> .
    (201) _45_items -> . _45_items _45_item
    (202) _45_items -> . _45_item
    (203) _45_item -> . , expr
    )               reduce using rule 200 (_45_repeat -> .)
    ,               shift and go to state 113

    _45_repeat                     shift and go to state 110
    _45_items                      shift and go to state 111
    _45_item                       shift and go to state 112

state 84

    (197) _44_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 197 (_44_optional -> expr .)
    )               reduce using rule 197 (_44_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 85

    (96) _if -> IF expr THEN . _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (97) _20_optional -> . type
    (98) _20_optional -> .
    (51) type -> . : identifier _9_optional
    (               reduce using rule 98 (_20_optional -> .)
    -               reduce using rule 98 (_20_optional -> .)
    {               reduce using rule 98 (_20_optional -> .)
    [               reduce using rule 98 (_20_optional -> .)
    CASE            reduce using rule 98 (_20_optional -> .)
    IF              reduce using rule 98 (_20_optional -> .)
    DEF             reduce using rule 98 (_20_optional -> .)
    STRING          reduce using rule 98 (_20_optional -> .)
    NUMBER          reduce using rule 98 (_20_optional -> .)
    IDENTIFIER      reduce using rule 98 (_20_optional -> .)
    DO              reduce using rule 98 (_20_optional -> .)
    NEWLINE         reduce using rule 98 (_20_optional -> .)
    ELIF            reduce using rule 98 (_20_optional -> .)
    ELSE            reduce using rule 98 (_20_optional -> .)
    END             reduce using rule 98 (_20_optional -> .)
    :               shift and go to state 45

    _20_optional                   shift and go to state 114
    type                           shift and go to state 115

state 86

    (41) _def -> DEF identifier ( . _6_optional _7_repeat ) _8_optional do
    (42) _6_optional -> . param
    (43) _6_optional -> .
    (93) param -> . identifier _19_optional
    (205) identifier -> . IDENTIFIER
    ,               reduce using rule 43 (_6_optional -> .)
    )               reduce using rule 43 (_6_optional -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 116
    _6_optional                    shift and go to state 117
    param                          shift and go to state 118

state 87

    (31) do -> DO _3_optional _4_optional . _5_repeat END
    (36) _5_repeat -> . _5_items
    (37) _5_repeat -> .
    (38) _5_items -> . _5_items _5_item
    (39) _5_items -> . _5_item
    (40) _5_item -> . NEWLINE expr
    END             reduce using rule 37 (_5_repeat -> .)
    NEWLINE         shift and go to state 122

    _5_repeat                      shift and go to state 119
    _5_items                       shift and go to state 120
    _5_item                        shift and go to state 121

state 88

    (34) _4_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 34 (_4_optional -> expr .)
    END             reduce using rule 34 (_4_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 89

    (72) enum -> ENUM identifier _14_optional { . _16_repeat }
    (80) _16_repeat -> . _16_items
    (81) _16_repeat -> .
    (82) _16_items -> . _16_items _16_item
    (83) _16_items -> . _16_item
    (84) _16_item -> . enum_key
    (85) enum_key -> . identifier _17_optional
    (205) identifier -> . IDENTIFIER
    }               reduce using rule 81 (_16_repeat -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 123
    _16_repeat                     shift and go to state 124
    _16_items                      shift and go to state 125
    _16_item                       shift and go to state 126
    enum_key                       shift and go to state 127

state 90

    (73) _14_optional -> < identifier . _15_repeat >
    (74) _15_repeat -> . _15_items
    (75) _15_repeat -> .
    (76) _15_items -> . _15_items _15_item
    (77) _15_items -> . _15_item
    (78) _15_item -> . , identifier
    >               reduce using rule 75 (_15_repeat -> .)
    ,               shift and go to state 131

    _15_repeat                     shift and go to state 128
    _15_items                      shift and go to state 129
    _15_item                       shift and go to state 130

state 91

    (206) variable_declaration -> identifier _46_optional = expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    NEWLINE         reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    $end            reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    ,               reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    }               reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    )               reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    ]               reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    OF              reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    THEN            reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    END             reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    ELIF            reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    ELSE            reduce using rule 206 (variable_declaration -> identifier _46_optional = expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 92

    (51) type -> : identifier _9_optional .
    =               reduce using rule 51 (type -> : identifier _9_optional .)
    (               reduce using rule 51 (type -> : identifier _9_optional .)
    -               reduce using rule 51 (type -> : identifier _9_optional .)
    {               reduce using rule 51 (type -> : identifier _9_optional .)
    [               reduce using rule 51 (type -> : identifier _9_optional .)
    CASE            reduce using rule 51 (type -> : identifier _9_optional .)
    IF              reduce using rule 51 (type -> : identifier _9_optional .)
    DEF             reduce using rule 51 (type -> : identifier _9_optional .)
    STRING          reduce using rule 51 (type -> : identifier _9_optional .)
    NUMBER          reduce using rule 51 (type -> : identifier _9_optional .)
    IDENTIFIER      reduce using rule 51 (type -> : identifier _9_optional .)
    DO              reduce using rule 51 (type -> : identifier _9_optional .)
    NEWLINE         reduce using rule 51 (type -> : identifier _9_optional .)
    END             reduce using rule 51 (type -> : identifier _9_optional .)
    ELIF            reduce using rule 51 (type -> : identifier _9_optional .)
    ELSE            reduce using rule 51 (type -> : identifier _9_optional .)
    ,               reduce using rule 51 (type -> : identifier _9_optional .)
    )               reduce using rule 51 (type -> : identifier _9_optional .)
    }               reduce using rule 51 (type -> : identifier _9_optional .)


state 93

    (52) _9_optional -> < . identifier _10_repeat >
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 132

state 94

    (188) tuple -> { _42_optional _43_repeat } .
    INT_DIV         reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    *               reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    /               reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    -               reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    +               reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    CONCAT          reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    NEWLINE         reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    $end            reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    ,               reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    }               reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    )               reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    ]               reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    OF              reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    THEN            reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    END             reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    ELIF            reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)
    ELSE            reduce using rule 188 (tuple -> { _42_optional _43_repeat } .)


state 95

    (193) _43_items -> _43_items _43_item .
    ,               reduce using rule 193 (_43_items -> _43_items _43_item .)
    }               reduce using rule 193 (_43_items -> _43_items _43_item .)


state 96

    (195) _43_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 195 (_43_item -> , expr .)
    }               reduce using rule 195 (_43_item -> , expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 97

    (59) struct -> STRUCT identifier _11_optional { . _13_repeat }
    (67) _13_repeat -> . _13_items
    (68) _13_repeat -> .
    (69) _13_items -> . _13_items _13_item
    (70) _13_items -> . _13_item
    (71) _13_item -> . identifier type
    (205) identifier -> . IDENTIFIER
    }               reduce using rule 68 (_13_repeat -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 133
    _13_repeat                     shift and go to state 134
    _13_items                      shift and go to state 135
    _13_item                       shift and go to state 136

state 98

    (60) _11_optional -> < identifier . _12_repeat >
    (61) _12_repeat -> . _12_items
    (62) _12_repeat -> .
    (63) _12_items -> . _12_items _12_item
    (64) _12_items -> . _12_item
    (65) _12_item -> . , identifier
    >               reduce using rule 62 (_12_repeat -> .)
    ,               shift and go to state 140

    _12_repeat                     shift and go to state 137
    _12_items                      shift and go to state 138
    _12_item                       shift and go to state 139

state 99

    (180) array -> [ _40_optional _41_repeat ] .
    INT_DIV         reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    *               reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    /               reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    -               reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    +               reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    CONCAT          reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    NEWLINE         reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    $end            reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    ,               reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    }               reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    )               reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    ]               reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    OF              reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    THEN            reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    END             reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    ELIF            reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)
    ELSE            reduce using rule 180 (array -> [ _40_optional _41_repeat ] .)


state 100

    (185) _41_items -> _41_items _41_item .
    ,               reduce using rule 185 (_41_items -> _41_items _41_item .)
    ]               reduce using rule 185 (_41_items -> _41_items _41_item .)


state 101

    (187) _41_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 187 (_41_item -> , expr .)
    ]               reduce using rule 187 (_41_item -> , expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 102

    (131) case_of -> CASE expr OF case . _30_repeat END
    (132) _30_repeat -> . _30_items
    (133) _30_repeat -> .
    (134) _30_items -> . _30_items _30_item
    (135) _30_items -> . _30_item
    (136) _30_item -> . case
    (137) case -> . pattern _31_repeat do
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    END             reduce using rule 133 (_30_repeat -> .)
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    case                           shift and go to state 141
    _30_repeat                     shift and go to state 142
    _30_items                      shift and go to state 143
    _30_item                       shift and go to state 144
    pattern                        shift and go to state 103
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 103

    (137) case -> pattern . _31_repeat do
    (138) _31_repeat -> . _31_items
    (139) _31_repeat -> .
    (140) _31_items -> . _31_items _31_item
    (141) _31_items -> . _31_item
    (142) _31_item -> . , pattern
    DO              reduce using rule 139 (_31_repeat -> .)
    ,               shift and go to state 148

    _31_repeat                     shift and go to state 145
    _31_items                      shift and go to state 146
    _31_item                       shift and go to state 147

state 104

    (143) pattern -> array_pattern .
    ,               reduce using rule 143 (pattern -> array_pattern .)
    DO              reduce using rule 143 (pattern -> array_pattern .)
    )               reduce using rule 143 (pattern -> array_pattern .)
    ]               reduce using rule 143 (pattern -> array_pattern .)
    }               reduce using rule 143 (pattern -> array_pattern .)


state 105

    (144) pattern -> tuple_pattern .
    ,               reduce using rule 144 (pattern -> tuple_pattern .)
    DO              reduce using rule 144 (pattern -> tuple_pattern .)
    )               reduce using rule 144 (pattern -> tuple_pattern .)
    ]               reduce using rule 144 (pattern -> tuple_pattern .)
    }               reduce using rule 144 (pattern -> tuple_pattern .)


state 106

    (145) pattern -> enum_pattern .
    ,               reduce using rule 145 (pattern -> enum_pattern .)
    DO              reduce using rule 145 (pattern -> enum_pattern .)
    )               reduce using rule 145 (pattern -> enum_pattern .)
    ]               reduce using rule 145 (pattern -> enum_pattern .)
    }               reduce using rule 145 (pattern -> enum_pattern .)


state 107

    (146) array_pattern -> [ . _32_repeat _33_optional ]
    (147) _32_repeat -> . _32_items
    (148) _32_repeat -> .
    (149) _32_items -> . _32_items _32_item
    (150) _32_items -> . _32_item
    (151) _32_item -> . pattern ,
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    SPREAD          reduce using rule 148 (_32_repeat -> .)
    ]               reduce using rule 148 (_32_repeat -> .)
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    _32_repeat                     shift and go to state 149
    _32_items                      shift and go to state 150
    _32_item                       shift and go to state 151
    pattern                        shift and go to state 152
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 108

    (167) tuple_pattern -> { . _37_repeat _38_optional }
    (168) _37_repeat -> . _37_items
    (169) _37_repeat -> .
    (170) _37_items -> . _37_items _37_item
    (171) _37_items -> . _37_item
    (172) _37_item -> . pattern ,
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    SPREAD          reduce using rule 169 (_37_repeat -> .)
    }               reduce using rule 169 (_37_repeat -> .)
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    _37_repeat                     shift and go to state 153
    _37_items                      shift and go to state 154
    _37_item                       shift and go to state 155
    pattern                        shift and go to state 156
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 109

    (159) enum_pattern -> identifier . _35_optional
    (160) _35_optional -> . ( pattern _36_repeat )
    (166) _35_optional -> .
    (               shift and go to state 158
    ,               reduce using rule 166 (_35_optional -> .)
    DO              reduce using rule 166 (_35_optional -> .)
    )               reduce using rule 166 (_35_optional -> .)
    ]               reduce using rule 166 (_35_optional -> .)
    }               reduce using rule 166 (_35_optional -> .)

    _35_optional                   shift and go to state 157

state 110

    (196) call -> callee ( _44_optional _45_repeat . )
    )               shift and go to state 159


state 111

    (199) _45_repeat -> _45_items .
    (201) _45_items -> _45_items . _45_item
    (203) _45_item -> . , expr
    )               reduce using rule 199 (_45_repeat -> _45_items .)
    ,               shift and go to state 113

    _45_item                       shift and go to state 160

state 112

    (202) _45_items -> _45_item .
    ,               reduce using rule 202 (_45_items -> _45_item .)
    )               reduce using rule 202 (_45_items -> _45_item .)


state 113

    (203) _45_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 161
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 114

    (96) _if -> IF expr THEN _20_optional . _21_optional _22_repeat _23_repeat _24_optional END
    (99) _21_optional -> . expr
    (100) _21_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    NEWLINE         reduce using rule 100 (_21_optional -> .)
    ELIF            reduce using rule 100 (_21_optional -> .)
    ELSE            reduce using rule 100 (_21_optional -> .)
    END             reduce using rule 100 (_21_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 162
    _21_optional                   shift and go to state 163
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 115

    (97) _20_optional -> type .
    (               reduce using rule 97 (_20_optional -> type .)
    -               reduce using rule 97 (_20_optional -> type .)
    {               reduce using rule 97 (_20_optional -> type .)
    [               reduce using rule 97 (_20_optional -> type .)
    CASE            reduce using rule 97 (_20_optional -> type .)
    IF              reduce using rule 97 (_20_optional -> type .)
    DEF             reduce using rule 97 (_20_optional -> type .)
    STRING          reduce using rule 97 (_20_optional -> type .)
    NUMBER          reduce using rule 97 (_20_optional -> type .)
    IDENTIFIER      reduce using rule 97 (_20_optional -> type .)
    DO              reduce using rule 97 (_20_optional -> type .)
    NEWLINE         reduce using rule 97 (_20_optional -> type .)
    ELIF            reduce using rule 97 (_20_optional -> type .)
    ELSE            reduce using rule 97 (_20_optional -> type .)
    END             reduce using rule 97 (_20_optional -> type .)


state 116

    (93) param -> identifier . _19_optional
    (94) _19_optional -> . type
    (95) _19_optional -> .
    (51) type -> . : identifier _9_optional
    ,               reduce using rule 95 (_19_optional -> .)
    )               reduce using rule 95 (_19_optional -> .)
    :               shift and go to state 45

    _19_optional                   shift and go to state 164
    type                           shift and go to state 165

state 117

    (41) _def -> DEF identifier ( _6_optional . _7_repeat ) _8_optional do
    (44) _7_repeat -> . _7_items
    (45) _7_repeat -> .
    (46) _7_items -> . _7_items _7_item
    (47) _7_items -> . _7_item
    (48) _7_item -> . , param
    )               reduce using rule 45 (_7_repeat -> .)
    ,               shift and go to state 169

    _7_repeat                      shift and go to state 166
    _7_items                       shift and go to state 167
    _7_item                        shift and go to state 168

state 118

    (42) _6_optional -> param .
    ,               reduce using rule 42 (_6_optional -> param .)
    )               reduce using rule 42 (_6_optional -> param .)


state 119

    (31) do -> DO _3_optional _4_optional _5_repeat . END
    END             shift and go to state 170


state 120

    (36) _5_repeat -> _5_items .
    (38) _5_items -> _5_items . _5_item
    (40) _5_item -> . NEWLINE expr
    END             reduce using rule 36 (_5_repeat -> _5_items .)
    NEWLINE         shift and go to state 122

    _5_item                        shift and go to state 171

state 121

    (39) _5_items -> _5_item .
    NEWLINE         reduce using rule 39 (_5_items -> _5_item .)
    END             reduce using rule 39 (_5_items -> _5_item .)


state 122

    (40) _5_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 172
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 123

    (85) enum_key -> identifier . _17_optional
    (86) _17_optional -> . ( identifier _18_repeat )
    (92) _17_optional -> .
    (               shift and go to state 174
    IDENTIFIER      reduce using rule 92 (_17_optional -> .)
    }               reduce using rule 92 (_17_optional -> .)

    _17_optional                   shift and go to state 173

state 124

    (72) enum -> ENUM identifier _14_optional { _16_repeat . }
    }               shift and go to state 175


state 125

    (80) _16_repeat -> _16_items .
    (82) _16_items -> _16_items . _16_item
    (84) _16_item -> . enum_key
    (85) enum_key -> . identifier _17_optional
    (205) identifier -> . IDENTIFIER
    }               reduce using rule 80 (_16_repeat -> _16_items .)
    IDENTIFIER      shift and go to state 30

    _16_item                       shift and go to state 176
    enum_key                       shift and go to state 127
    identifier                     shift and go to state 123

state 126

    (83) _16_items -> _16_item .
    IDENTIFIER      reduce using rule 83 (_16_items -> _16_item .)
    }               reduce using rule 83 (_16_items -> _16_item .)


state 127

    (84) _16_item -> enum_key .
    IDENTIFIER      reduce using rule 84 (_16_item -> enum_key .)
    }               reduce using rule 84 (_16_item -> enum_key .)


state 128

    (73) _14_optional -> < identifier _15_repeat . >
    >               shift and go to state 177


state 129

    (74) _15_repeat -> _15_items .
    (76) _15_items -> _15_items . _15_item
    (78) _15_item -> . , identifier
    >               reduce using rule 74 (_15_repeat -> _15_items .)
    ,               shift and go to state 131

    _15_item                       shift and go to state 178

state 130

    (77) _15_items -> _15_item .
    ,               reduce using rule 77 (_15_items -> _15_item .)
    >               reduce using rule 77 (_15_items -> _15_item .)


state 131

    (78) _15_item -> , . identifier
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 179

state 132

    (52) _9_optional -> < identifier . _10_repeat >
    (53) _10_repeat -> . _10_items
    (54) _10_repeat -> .
    (55) _10_items -> . _10_items _10_item
    (56) _10_items -> . _10_item
    (57) _10_item -> . , identifier
    >               reduce using rule 54 (_10_repeat -> .)
    ,               shift and go to state 183

    _10_repeat                     shift and go to state 180
    _10_items                      shift and go to state 181
    _10_item                       shift and go to state 182

state 133

    (71) _13_item -> identifier . type
    (51) type -> . : identifier _9_optional
    :               shift and go to state 45

    type                           shift and go to state 184

state 134

    (59) struct -> STRUCT identifier _11_optional { _13_repeat . }
    }               shift and go to state 185


state 135

    (67) _13_repeat -> _13_items .
    (69) _13_items -> _13_items . _13_item
    (71) _13_item -> . identifier type
    (205) identifier -> . IDENTIFIER
    }               reduce using rule 67 (_13_repeat -> _13_items .)
    IDENTIFIER      shift and go to state 30

    _13_item                       shift and go to state 186
    identifier                     shift and go to state 133

state 136

    (70) _13_items -> _13_item .
    IDENTIFIER      reduce using rule 70 (_13_items -> _13_item .)
    }               reduce using rule 70 (_13_items -> _13_item .)


state 137

    (60) _11_optional -> < identifier _12_repeat . >
    >               shift and go to state 187


state 138

    (61) _12_repeat -> _12_items .
    (63) _12_items -> _12_items . _12_item
    (65) _12_item -> . , identifier
    >               reduce using rule 61 (_12_repeat -> _12_items .)
    ,               shift and go to state 140

    _12_item                       shift and go to state 188

state 139

    (64) _12_items -> _12_item .
    ,               reduce using rule 64 (_12_items -> _12_item .)
    >               reduce using rule 64 (_12_items -> _12_item .)


state 140

    (65) _12_item -> , . identifier
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 189

state 141

    (136) _30_item -> case .
    [               reduce using rule 136 (_30_item -> case .)
    {               reduce using rule 136 (_30_item -> case .)
    IDENTIFIER      reduce using rule 136 (_30_item -> case .)
    END             reduce using rule 136 (_30_item -> case .)


state 142

    (131) case_of -> CASE expr OF case _30_repeat . END
    END             shift and go to state 190


state 143

    (132) _30_repeat -> _30_items .
    (134) _30_items -> _30_items . _30_item
    (136) _30_item -> . case
    (137) case -> . pattern _31_repeat do
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    END             reduce using rule 132 (_30_repeat -> _30_items .)
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    _30_item                       shift and go to state 191
    case                           shift and go to state 141
    pattern                        shift and go to state 103
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 144

    (135) _30_items -> _30_item .
    [               reduce using rule 135 (_30_items -> _30_item .)
    {               reduce using rule 135 (_30_items -> _30_item .)
    IDENTIFIER      reduce using rule 135 (_30_items -> _30_item .)
    END             reduce using rule 135 (_30_items -> _30_item .)


state 145

    (137) case -> pattern _31_repeat . do
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    DO              shift and go to state 31

    do                             shift and go to state 192

state 146

    (138) _31_repeat -> _31_items .
    (140) _31_items -> _31_items . _31_item
    (142) _31_item -> . , pattern
    DO              reduce using rule 138 (_31_repeat -> _31_items .)
    ,               shift and go to state 148

    _31_item                       shift and go to state 193

state 147

    (141) _31_items -> _31_item .
    ,               reduce using rule 141 (_31_items -> _31_item .)
    DO              reduce using rule 141 (_31_items -> _31_item .)


state 148

    (142) _31_item -> , . pattern
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 194
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 149

    (146) array_pattern -> [ _32_repeat . _33_optional ]
    (152) _33_optional -> . SPREAD identifier _34_repeat
    (158) _33_optional -> .
    SPREAD          shift and go to state 196
    ]               reduce using rule 158 (_33_optional -> .)

    _33_optional                   shift and go to state 195

state 150

    (147) _32_repeat -> _32_items .
    (149) _32_items -> _32_items . _32_item
    (151) _32_item -> . pattern ,
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    SPREAD          reduce using rule 147 (_32_repeat -> _32_items .)
    ]               reduce using rule 147 (_32_repeat -> _32_items .)
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    _32_item                       shift and go to state 197
    pattern                        shift and go to state 152
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 151

    (150) _32_items -> _32_item .
    [               reduce using rule 150 (_32_items -> _32_item .)
    {               reduce using rule 150 (_32_items -> _32_item .)
    IDENTIFIER      reduce using rule 150 (_32_items -> _32_item .)
    SPREAD          reduce using rule 150 (_32_items -> _32_item .)
    ]               reduce using rule 150 (_32_items -> _32_item .)


state 152

    (151) _32_item -> pattern . ,
    ,               shift and go to state 198


state 153

    (167) tuple_pattern -> { _37_repeat . _38_optional }
    (173) _38_optional -> . SPREAD identifier _39_repeat
    (179) _38_optional -> .
    SPREAD          shift and go to state 200
    }               reduce using rule 179 (_38_optional -> .)

    _38_optional                   shift and go to state 199

state 154

    (168) _37_repeat -> _37_items .
    (170) _37_items -> _37_items . _37_item
    (172) _37_item -> . pattern ,
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    SPREAD          reduce using rule 168 (_37_repeat -> _37_items .)
    }               reduce using rule 168 (_37_repeat -> _37_items .)
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    _37_item                       shift and go to state 201
    pattern                        shift and go to state 156
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 155

    (171) _37_items -> _37_item .
    [               reduce using rule 171 (_37_items -> _37_item .)
    {               reduce using rule 171 (_37_items -> _37_item .)
    IDENTIFIER      reduce using rule 171 (_37_items -> _37_item .)
    SPREAD          reduce using rule 171 (_37_items -> _37_item .)
    }               reduce using rule 171 (_37_items -> _37_item .)


state 156

    (172) _37_item -> pattern . ,
    ,               shift and go to state 202


state 157

    (159) enum_pattern -> identifier _35_optional .
    ,               reduce using rule 159 (enum_pattern -> identifier _35_optional .)
    DO              reduce using rule 159 (enum_pattern -> identifier _35_optional .)
    )               reduce using rule 159 (enum_pattern -> identifier _35_optional .)
    ]               reduce using rule 159 (enum_pattern -> identifier _35_optional .)
    }               reduce using rule 159 (enum_pattern -> identifier _35_optional .)


state 158

    (160) _35_optional -> ( . pattern _36_repeat )
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 203
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 159

    (196) call -> callee ( _44_optional _45_repeat ) .
    INT_DIV         reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    *               reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    /               reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    -               reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    +               reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    CONCAT          reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    NEWLINE         reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    $end            reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    ,               reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    }               reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    )               reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    ]               reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    OF              reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    THEN            reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    END             reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    ELIF            reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)
    ELSE            reduce using rule 196 (call -> callee ( _44_optional _45_repeat ) .)


state 160

    (201) _45_items -> _45_items _45_item .
    ,               reduce using rule 201 (_45_items -> _45_items _45_item .)
    )               reduce using rule 201 (_45_items -> _45_items _45_item .)


state 161

    (203) _45_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 203 (_45_item -> , expr .)
    )               reduce using rule 203 (_45_item -> , expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 162

    (99) _21_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 99 (_21_optional -> expr .)
    ELIF            reduce using rule 99 (_21_optional -> expr .)
    ELSE            reduce using rule 99 (_21_optional -> expr .)
    END             reduce using rule 99 (_21_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 163

    (96) _if -> IF expr THEN _20_optional _21_optional . _22_repeat _23_repeat _24_optional END
    (101) _22_repeat -> . _22_items
    (102) _22_repeat -> .
    (103) _22_items -> . _22_items _22_item
    (104) _22_items -> . _22_item
    (105) _22_item -> . NEWLINE expr
    ELIF            reduce using rule 102 (_22_repeat -> .)
    ELSE            reduce using rule 102 (_22_repeat -> .)
    END             reduce using rule 102 (_22_repeat -> .)
    NEWLINE         shift and go to state 207

    _22_repeat                     shift and go to state 204
    _22_items                      shift and go to state 205
    _22_item                       shift and go to state 206

state 164

    (93) param -> identifier _19_optional .
    ,               reduce using rule 93 (param -> identifier _19_optional .)
    )               reduce using rule 93 (param -> identifier _19_optional .)


state 165

    (94) _19_optional -> type .
    ,               reduce using rule 94 (_19_optional -> type .)
    )               reduce using rule 94 (_19_optional -> type .)


state 166

    (41) _def -> DEF identifier ( _6_optional _7_repeat . ) _8_optional do
    )               shift and go to state 208


state 167

    (44) _7_repeat -> _7_items .
    (46) _7_items -> _7_items . _7_item
    (48) _7_item -> . , param
    )               reduce using rule 44 (_7_repeat -> _7_items .)
    ,               shift and go to state 169

    _7_item                        shift and go to state 209

state 168

    (47) _7_items -> _7_item .
    ,               reduce using rule 47 (_7_items -> _7_item .)
    )               reduce using rule 47 (_7_items -> _7_item .)


state 169

    (48) _7_item -> , . param
    (93) param -> . identifier _19_optional
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    param                          shift and go to state 210
    identifier                     shift and go to state 116

state 170

    (31) do -> DO _3_optional _4_optional _5_repeat END .
    INT_DIV         reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    *               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    /               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    -               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    +               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    CONCAT          reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    NEWLINE         reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    $end            reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    ,               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    }               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    )               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    ]               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    OF              reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    THEN            reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    END             reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    ELIF            reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    ELSE            reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    [               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    {               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    IDENTIFIER      reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)


state 171

    (38) _5_items -> _5_items _5_item .
    NEWLINE         reduce using rule 38 (_5_items -> _5_items _5_item .)
    END             reduce using rule 38 (_5_items -> _5_items _5_item .)


state 172

    (40) _5_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 40 (_5_item -> NEWLINE expr .)
    END             reduce using rule 40 (_5_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 173

    (85) enum_key -> identifier _17_optional .
    IDENTIFIER      reduce using rule 85 (enum_key -> identifier _17_optional .)
    }               reduce using rule 85 (enum_key -> identifier _17_optional .)


state 174

    (86) _17_optional -> ( . identifier _18_repeat )
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 211

state 175

    (72) enum -> ENUM identifier _14_optional { _16_repeat } .
    NEWLINE         reduce using rule 72 (enum -> ENUM identifier _14_optional { _16_repeat } .)
    $end            reduce using rule 72 (enum -> ENUM identifier _14_optional { _16_repeat } .)


state 176

    (82) _16_items -> _16_items _16_item .
    IDENTIFIER      reduce using rule 82 (_16_items -> _16_items _16_item .)
    }               reduce using rule 82 (_16_items -> _16_items _16_item .)


state 177

    (73) _14_optional -> < identifier _15_repeat > .
    {               reduce using rule 73 (_14_optional -> < identifier _15_repeat > .)


state 178

    (76) _15_items -> _15_items _15_item .
    ,               reduce using rule 76 (_15_items -> _15_items _15_item .)
    >               reduce using rule 76 (_15_items -> _15_items _15_item .)


state 179

    (78) _15_item -> , identifier .
    ,               reduce using rule 78 (_15_item -> , identifier .)
    >               reduce using rule 78 (_15_item -> , identifier .)


state 180

    (52) _9_optional -> < identifier _10_repeat . >
    >               shift and go to state 212


state 181

    (53) _10_repeat -> _10_items .
    (55) _10_items -> _10_items . _10_item
    (57) _10_item -> . , identifier
    >               reduce using rule 53 (_10_repeat -> _10_items .)
    ,               shift and go to state 183

    _10_item                       shift and go to state 213

state 182

    (56) _10_items -> _10_item .
    ,               reduce using rule 56 (_10_items -> _10_item .)
    >               reduce using rule 56 (_10_items -> _10_item .)


state 183

    (57) _10_item -> , . identifier
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 214

state 184

    (71) _13_item -> identifier type .
    IDENTIFIER      reduce using rule 71 (_13_item -> identifier type .)
    }               reduce using rule 71 (_13_item -> identifier type .)


state 185

    (59) struct -> STRUCT identifier _11_optional { _13_repeat } .
    NEWLINE         reduce using rule 59 (struct -> STRUCT identifier _11_optional { _13_repeat } .)
    $end            reduce using rule 59 (struct -> STRUCT identifier _11_optional { _13_repeat } .)


state 186

    (69) _13_items -> _13_items _13_item .
    IDENTIFIER      reduce using rule 69 (_13_items -> _13_items _13_item .)
    }               reduce using rule 69 (_13_items -> _13_items _13_item .)


state 187

    (60) _11_optional -> < identifier _12_repeat > .
    {               reduce using rule 60 (_11_optional -> < identifier _12_repeat > .)


state 188

    (63) _12_items -> _12_items _12_item .
    ,               reduce using rule 63 (_12_items -> _12_items _12_item .)
    >               reduce using rule 63 (_12_items -> _12_items _12_item .)


state 189

    (65) _12_item -> , identifier .
    ,               reduce using rule 65 (_12_item -> , identifier .)
    >               reduce using rule 65 (_12_item -> , identifier .)


state 190

    (131) case_of -> CASE expr OF case _30_repeat END .
    INT_DIV         reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    *               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    /               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    -               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    +               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    CONCAT          reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    NEWLINE         reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    $end            reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    ,               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    }               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    )               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    ]               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    OF              reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    THEN            reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    END             reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    ELIF            reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    ELSE            reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)


state 191

    (134) _30_items -> _30_items _30_item .
    [               reduce using rule 134 (_30_items -> _30_items _30_item .)
    {               reduce using rule 134 (_30_items -> _30_items _30_item .)
    IDENTIFIER      reduce using rule 134 (_30_items -> _30_items _30_item .)
    END             reduce using rule 134 (_30_items -> _30_items _30_item .)


state 192

    (137) case -> pattern _31_repeat do .
    [               reduce using rule 137 (case -> pattern _31_repeat do .)
    {               reduce using rule 137 (case -> pattern _31_repeat do .)
    IDENTIFIER      reduce using rule 137 (case -> pattern _31_repeat do .)
    END             reduce using rule 137 (case -> pattern _31_repeat do .)


state 193

    (140) _31_items -> _31_items _31_item .
    ,               reduce using rule 140 (_31_items -> _31_items _31_item .)
    DO              reduce using rule 140 (_31_items -> _31_items _31_item .)


state 194

    (142) _31_item -> , pattern .
    ,               reduce using rule 142 (_31_item -> , pattern .)
    DO              reduce using rule 142 (_31_item -> , pattern .)


state 195

    (146) array_pattern -> [ _32_repeat _33_optional . ]
    ]               shift and go to state 215


state 196

    (152) _33_optional -> SPREAD . identifier _34_repeat
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 216

state 197

    (149) _32_items -> _32_items _32_item .
    [               reduce using rule 149 (_32_items -> _32_items _32_item .)
    {               reduce using rule 149 (_32_items -> _32_items _32_item .)
    IDENTIFIER      reduce using rule 149 (_32_items -> _32_items _32_item .)
    SPREAD          reduce using rule 149 (_32_items -> _32_items _32_item .)
    ]               reduce using rule 149 (_32_items -> _32_items _32_item .)


state 198

    (151) _32_item -> pattern , .
    [               reduce using rule 151 (_32_item -> pattern , .)
    {               reduce using rule 151 (_32_item -> pattern , .)
    IDENTIFIER      reduce using rule 151 (_32_item -> pattern , .)
    SPREAD          reduce using rule 151 (_32_item -> pattern , .)
    ]               reduce using rule 151 (_32_item -> pattern , .)


state 199

    (167) tuple_pattern -> { _37_repeat _38_optional . }
    }               shift and go to state 217


state 200

    (173) _38_optional -> SPREAD . identifier _39_repeat
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 218

state 201

    (170) _37_items -> _37_items _37_item .
    [               reduce using rule 170 (_37_items -> _37_items _37_item .)
    {               reduce using rule 170 (_37_items -> _37_items _37_item .)
    IDENTIFIER      reduce using rule 170 (_37_items -> _37_items _37_item .)
    SPREAD          reduce using rule 170 (_37_items -> _37_items _37_item .)
    }               reduce using rule 170 (_37_items -> _37_items _37_item .)


state 202

    (172) _37_item -> pattern , .
    [               reduce using rule 172 (_37_item -> pattern , .)
    {               reduce using rule 172 (_37_item -> pattern , .)
    IDENTIFIER      reduce using rule 172 (_37_item -> pattern , .)
    SPREAD          reduce using rule 172 (_37_item -> pattern , .)
    }               reduce using rule 172 (_37_item -> pattern , .)


state 203

    (160) _35_optional -> ( pattern . _36_repeat )
    (161) _36_repeat -> . _36_items
    (162) _36_repeat -> .
    (163) _36_items -> . _36_items _36_item
    (164) _36_items -> . _36_item
    (165) _36_item -> . , pattern
    )               reduce using rule 162 (_36_repeat -> .)
    ,               shift and go to state 222

    _36_repeat                     shift and go to state 219
    _36_items                      shift and go to state 220
    _36_item                       shift and go to state 221

state 204

    (96) _if -> IF expr THEN _20_optional _21_optional _22_repeat . _23_repeat _24_optional END
    (106) _23_repeat -> . _23_items
    (107) _23_repeat -> .
    (108) _23_items -> . _23_items _23_item
    (109) _23_items -> . _23_item
    (110) _23_item -> . _elif
    (121) _elif -> . ELIF expr THEN _27_optional _28_optional _29_repeat
    ELSE            reduce using rule 107 (_23_repeat -> .)
    END             reduce using rule 107 (_23_repeat -> .)
    ELIF            shift and go to state 227

    _23_repeat                     shift and go to state 223
    _23_items                      shift and go to state 224
    _23_item                       shift and go to state 225
    _elif                          shift and go to state 226

state 205

    (101) _22_repeat -> _22_items .
    (103) _22_items -> _22_items . _22_item
    (105) _22_item -> . NEWLINE expr
    ELIF            reduce using rule 101 (_22_repeat -> _22_items .)
    ELSE            reduce using rule 101 (_22_repeat -> _22_items .)
    END             reduce using rule 101 (_22_repeat -> _22_items .)
    NEWLINE         shift and go to state 207

    _22_item                       shift and go to state 228

state 206

    (104) _22_items -> _22_item .
    NEWLINE         reduce using rule 104 (_22_items -> _22_item .)
    ELIF            reduce using rule 104 (_22_items -> _22_item .)
    ELSE            reduce using rule 104 (_22_items -> _22_item .)
    END             reduce using rule 104 (_22_items -> _22_item .)


state 207

    (105) _22_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 229
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 208

    (41) _def -> DEF identifier ( _6_optional _7_repeat ) . _8_optional do
    (49) _8_optional -> . type
    (50) _8_optional -> .
    (51) type -> . : identifier _9_optional
    DO              reduce using rule 50 (_8_optional -> .)
    :               shift and go to state 45

    _8_optional                    shift and go to state 230
    type                           shift and go to state 231

state 209

    (46) _7_items -> _7_items _7_item .
    ,               reduce using rule 46 (_7_items -> _7_items _7_item .)
    )               reduce using rule 46 (_7_items -> _7_items _7_item .)


state 210

    (48) _7_item -> , param .
    ,               reduce using rule 48 (_7_item -> , param .)
    )               reduce using rule 48 (_7_item -> , param .)


state 211

    (86) _17_optional -> ( identifier . _18_repeat )
    (87) _18_repeat -> . _18_items
    (88) _18_repeat -> .
    (89) _18_items -> . _18_items _18_item
    (90) _18_items -> . _18_item
    (91) _18_item -> . , identifier
    )               reduce using rule 88 (_18_repeat -> .)
    ,               shift and go to state 235

    _18_repeat                     shift and go to state 232
    _18_items                      shift and go to state 233
    _18_item                       shift and go to state 234

state 212

    (52) _9_optional -> < identifier _10_repeat > .
    =               reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    (               reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    -               reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    {               reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    [               reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    CASE            reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    IF              reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    DEF             reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    STRING          reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    NUMBER          reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    IDENTIFIER      reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    DO              reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    NEWLINE         reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    END             reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    ELIF            reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    ELSE            reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    ,               reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    )               reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)
    }               reduce using rule 52 (_9_optional -> < identifier _10_repeat > .)


state 213

    (55) _10_items -> _10_items _10_item .
    ,               reduce using rule 55 (_10_items -> _10_items _10_item .)
    >               reduce using rule 55 (_10_items -> _10_items _10_item .)


state 214

    (57) _10_item -> , identifier .
    ,               reduce using rule 57 (_10_item -> , identifier .)
    >               reduce using rule 57 (_10_item -> , identifier .)


state 215

    (146) array_pattern -> [ _32_repeat _33_optional ] .
    ,               reduce using rule 146 (array_pattern -> [ _32_repeat _33_optional ] .)
    DO              reduce using rule 146 (array_pattern -> [ _32_repeat _33_optional ] .)
    )               reduce using rule 146 (array_pattern -> [ _32_repeat _33_optional ] .)
    ]               reduce using rule 146 (array_pattern -> [ _32_repeat _33_optional ] .)
    }               reduce using rule 146 (array_pattern -> [ _32_repeat _33_optional ] .)


state 216

    (152) _33_optional -> SPREAD identifier . _34_repeat
    (153) _34_repeat -> . _34_items
    (154) _34_repeat -> .
    (155) _34_items -> . _34_items _34_item
    (156) _34_items -> . _34_item
    (157) _34_item -> . , pattern
    ]               reduce using rule 154 (_34_repeat -> .)
    ,               shift and go to state 239

    _34_repeat                     shift and go to state 236
    _34_items                      shift and go to state 237
    _34_item                       shift and go to state 238

state 217

    (167) tuple_pattern -> { _37_repeat _38_optional } .
    ,               reduce using rule 167 (tuple_pattern -> { _37_repeat _38_optional } .)
    DO              reduce using rule 167 (tuple_pattern -> { _37_repeat _38_optional } .)
    )               reduce using rule 167 (tuple_pattern -> { _37_repeat _38_optional } .)
    ]               reduce using rule 167 (tuple_pattern -> { _37_repeat _38_optional } .)
    }               reduce using rule 167 (tuple_pattern -> { _37_repeat _38_optional } .)


state 218

    (173) _38_optional -> SPREAD identifier . _39_repeat
    (174) _39_repeat -> . _39_items
    (175) _39_repeat -> .
    (176) _39_items -> . _39_items _39_item
    (177) _39_items -> . _39_item
    (178) _39_item -> . , pattern
    }               reduce using rule 175 (_39_repeat -> .)
    ,               shift and go to state 243

    _39_repeat                     shift and go to state 240
    _39_items                      shift and go to state 241
    _39_item                       shift and go to state 242

state 219

    (160) _35_optional -> ( pattern _36_repeat . )
    )               shift and go to state 244


state 220

    (161) _36_repeat -> _36_items .
    (163) _36_items -> _36_items . _36_item
    (165) _36_item -> . , pattern
    )               reduce using rule 161 (_36_repeat -> _36_items .)
    ,               shift and go to state 222

    _36_item                       shift and go to state 245

state 221

    (164) _36_items -> _36_item .
    ,               reduce using rule 164 (_36_items -> _36_item .)
    )               reduce using rule 164 (_36_items -> _36_item .)


state 222

    (165) _36_item -> , . pattern
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 246
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 223

    (96) _if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat . _24_optional END
    (111) _24_optional -> . _else
    (112) _24_optional -> .
    (113) _else -> . ELSE _25_optional _26_repeat
    END             reduce using rule 112 (_24_optional -> .)
    ELSE            shift and go to state 249

    _24_optional                   shift and go to state 247
    _else                          shift and go to state 248

state 224

    (106) _23_repeat -> _23_items .
    (108) _23_items -> _23_items . _23_item
    (110) _23_item -> . _elif
    (121) _elif -> . ELIF expr THEN _27_optional _28_optional _29_repeat
    ELSE            reduce using rule 106 (_23_repeat -> _23_items .)
    END             reduce using rule 106 (_23_repeat -> _23_items .)
    ELIF            shift and go to state 227

    _23_item                       shift and go to state 250
    _elif                          shift and go to state 226

state 225

    (109) _23_items -> _23_item .
    ELIF            reduce using rule 109 (_23_items -> _23_item .)
    ELSE            reduce using rule 109 (_23_items -> _23_item .)
    END             reduce using rule 109 (_23_items -> _23_item .)


state 226

    (110) _23_item -> _elif .
    ELIF            reduce using rule 110 (_23_item -> _elif .)
    ELSE            reduce using rule 110 (_23_item -> _elif .)
    END             reduce using rule 110 (_23_item -> _elif .)


state 227

    (121) _elif -> ELIF . expr THEN _27_optional _28_optional _29_repeat
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 251
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 228

    (103) _22_items -> _22_items _22_item .
    NEWLINE         reduce using rule 103 (_22_items -> _22_items _22_item .)
    ELIF            reduce using rule 103 (_22_items -> _22_items _22_item .)
    ELSE            reduce using rule 103 (_22_items -> _22_items _22_item .)
    END             reduce using rule 103 (_22_items -> _22_items _22_item .)


state 229

    (105) _22_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 105 (_22_item -> NEWLINE expr .)
    ELIF            reduce using rule 105 (_22_item -> NEWLINE expr .)
    ELSE            reduce using rule 105 (_22_item -> NEWLINE expr .)
    END             reduce using rule 105 (_22_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 230

    (41) _def -> DEF identifier ( _6_optional _7_repeat ) _8_optional . do
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    DO              shift and go to state 31

    do                             shift and go to state 252

state 231

    (49) _8_optional -> type .
    DO              reduce using rule 49 (_8_optional -> type .)


state 232

    (86) _17_optional -> ( identifier _18_repeat . )
    )               shift and go to state 253


state 233

    (87) _18_repeat -> _18_items .
    (89) _18_items -> _18_items . _18_item
    (91) _18_item -> . , identifier
    )               reduce using rule 87 (_18_repeat -> _18_items .)
    ,               shift and go to state 235

    _18_item                       shift and go to state 254

state 234

    (90) _18_items -> _18_item .
    ,               reduce using rule 90 (_18_items -> _18_item .)
    )               reduce using rule 90 (_18_items -> _18_item .)


state 235

    (91) _18_item -> , . identifier
    (205) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 255

state 236

    (152) _33_optional -> SPREAD identifier _34_repeat .
    ]               reduce using rule 152 (_33_optional -> SPREAD identifier _34_repeat .)


state 237

    (153) _34_repeat -> _34_items .
    (155) _34_items -> _34_items . _34_item
    (157) _34_item -> . , pattern
    ]               reduce using rule 153 (_34_repeat -> _34_items .)
    ,               shift and go to state 239

    _34_item                       shift and go to state 256

state 238

    (156) _34_items -> _34_item .
    ,               reduce using rule 156 (_34_items -> _34_item .)
    ]               reduce using rule 156 (_34_items -> _34_item .)


state 239

    (157) _34_item -> , . pattern
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 257
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 240

    (173) _38_optional -> SPREAD identifier _39_repeat .
    }               reduce using rule 173 (_38_optional -> SPREAD identifier _39_repeat .)


state 241

    (174) _39_repeat -> _39_items .
    (176) _39_items -> _39_items . _39_item
    (178) _39_item -> . , pattern
    }               reduce using rule 174 (_39_repeat -> _39_items .)
    ,               shift and go to state 243

    _39_item                       shift and go to state 258

state 242

    (177) _39_items -> _39_item .
    ,               reduce using rule 177 (_39_items -> _39_item .)
    }               reduce using rule 177 (_39_items -> _39_item .)


state 243

    (178) _39_item -> , . pattern
    (143) pattern -> . array_pattern
    (144) pattern -> . tuple_pattern
    (145) pattern -> . enum_pattern
    (146) array_pattern -> . [ _32_repeat _33_optional ]
    (167) tuple_pattern -> . { _37_repeat _38_optional }
    (159) enum_pattern -> . identifier _35_optional
    (205) identifier -> . IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 259
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    identifier                     shift and go to state 109

state 244

    (160) _35_optional -> ( pattern _36_repeat ) .
    ,               reduce using rule 160 (_35_optional -> ( pattern _36_repeat ) .)
    DO              reduce using rule 160 (_35_optional -> ( pattern _36_repeat ) .)
    )               reduce using rule 160 (_35_optional -> ( pattern _36_repeat ) .)
    ]               reduce using rule 160 (_35_optional -> ( pattern _36_repeat ) .)
    }               reduce using rule 160 (_35_optional -> ( pattern _36_repeat ) .)


state 245

    (163) _36_items -> _36_items _36_item .
    ,               reduce using rule 163 (_36_items -> _36_items _36_item .)
    )               reduce using rule 163 (_36_items -> _36_items _36_item .)


state 246

    (165) _36_item -> , pattern .
    ,               reduce using rule 165 (_36_item -> , pattern .)
    )               reduce using rule 165 (_36_item -> , pattern .)


state 247

    (96) _if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional . END
    END             shift and go to state 260


state 248

    (111) _24_optional -> _else .
    END             reduce using rule 111 (_24_optional -> _else .)


state 249

    (113) _else -> ELSE . _25_optional _26_repeat
    (114) _25_optional -> . expr
    (115) _25_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    NEWLINE         reduce using rule 115 (_25_optional -> .)
    END             reduce using rule 115 (_25_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    _25_optional                   shift and go to state 261
    expr                           shift and go to state 262
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 250

    (108) _23_items -> _23_items _23_item .
    ELIF            reduce using rule 108 (_23_items -> _23_items _23_item .)
    ELSE            reduce using rule 108 (_23_items -> _23_items _23_item .)
    END             reduce using rule 108 (_23_items -> _23_items _23_item .)


state 251

    (121) _elif -> ELIF expr . THEN _27_optional _28_optional _29_repeat
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 263
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 252

    (41) _def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .
    INT_DIV         reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    *               reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    /               reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    -               reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    +               reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    CONCAT          reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    NEWLINE         reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    $end            reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    ,               reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    }               reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    )               reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    ]               reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    OF              reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    THEN            reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    END             reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    ELIF            reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    ELSE            reduce using rule 41 (_def -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)


state 253

    (86) _17_optional -> ( identifier _18_repeat ) .
    IDENTIFIER      reduce using rule 86 (_17_optional -> ( identifier _18_repeat ) .)
    }               reduce using rule 86 (_17_optional -> ( identifier _18_repeat ) .)


state 254

    (89) _18_items -> _18_items _18_item .
    ,               reduce using rule 89 (_18_items -> _18_items _18_item .)
    )               reduce using rule 89 (_18_items -> _18_items _18_item .)


state 255

    (91) _18_item -> , identifier .
    ,               reduce using rule 91 (_18_item -> , identifier .)
    )               reduce using rule 91 (_18_item -> , identifier .)


state 256

    (155) _34_items -> _34_items _34_item .
    ,               reduce using rule 155 (_34_items -> _34_items _34_item .)
    ]               reduce using rule 155 (_34_items -> _34_items _34_item .)


state 257

    (157) _34_item -> , pattern .
    ,               reduce using rule 157 (_34_item -> , pattern .)
    ]               reduce using rule 157 (_34_item -> , pattern .)


state 258

    (176) _39_items -> _39_items _39_item .
    ,               reduce using rule 176 (_39_items -> _39_items _39_item .)
    }               reduce using rule 176 (_39_items -> _39_items _39_item .)


state 259

    (178) _39_item -> , pattern .
    ,               reduce using rule 178 (_39_item -> , pattern .)
    }               reduce using rule 178 (_39_item -> , pattern .)


state 260

    (96) _if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .
    INT_DIV         reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    *               reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    /               reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    -               reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    +               reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    CONCAT          reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    NEWLINE         reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    $end            reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    ,               reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    }               reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    )               reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    ]               reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    OF              reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    THEN            reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    END             reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    ELIF            reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    ELSE            reduce using rule 96 (_if -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)


state 261

    (113) _else -> ELSE _25_optional . _26_repeat
    (116) _26_repeat -> . _26_items
    (117) _26_repeat -> .
    (118) _26_items -> . _26_items _26_item
    (119) _26_items -> . _26_item
    (120) _26_item -> . NEWLINE expr
    END             reduce using rule 117 (_26_repeat -> .)
    NEWLINE         shift and go to state 267

    _26_repeat                     shift and go to state 264
    _26_items                      shift and go to state 265
    _26_item                       shift and go to state 266

state 262

    (114) _25_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 114 (_25_optional -> expr .)
    END             reduce using rule 114 (_25_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 263

    (121) _elif -> ELIF expr THEN . _27_optional _28_optional _29_repeat
    (122) _27_optional -> . type
    (123) _27_optional -> .
    (51) type -> . : identifier _9_optional
    (               reduce using rule 123 (_27_optional -> .)
    -               reduce using rule 123 (_27_optional -> .)
    {               reduce using rule 123 (_27_optional -> .)
    [               reduce using rule 123 (_27_optional -> .)
    CASE            reduce using rule 123 (_27_optional -> .)
    IF              reduce using rule 123 (_27_optional -> .)
    DEF             reduce using rule 123 (_27_optional -> .)
    STRING          reduce using rule 123 (_27_optional -> .)
    NUMBER          reduce using rule 123 (_27_optional -> .)
    IDENTIFIER      reduce using rule 123 (_27_optional -> .)
    DO              reduce using rule 123 (_27_optional -> .)
    NEWLINE         reduce using rule 123 (_27_optional -> .)
    ELIF            reduce using rule 123 (_27_optional -> .)
    ELSE            reduce using rule 123 (_27_optional -> .)
    END             reduce using rule 123 (_27_optional -> .)
    :               shift and go to state 45

    _27_optional                   shift and go to state 268
    type                           shift and go to state 269

state 264

    (113) _else -> ELSE _25_optional _26_repeat .
    END             reduce using rule 113 (_else -> ELSE _25_optional _26_repeat .)


state 265

    (116) _26_repeat -> _26_items .
    (118) _26_items -> _26_items . _26_item
    (120) _26_item -> . NEWLINE expr
    END             reduce using rule 116 (_26_repeat -> _26_items .)
    NEWLINE         shift and go to state 267

    _26_item                       shift and go to state 270

state 266

    (119) _26_items -> _26_item .
    NEWLINE         reduce using rule 119 (_26_items -> _26_item .)
    END             reduce using rule 119 (_26_items -> _26_item .)


state 267

    (120) _26_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 271
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 268

    (121) _elif -> ELIF expr THEN _27_optional . _28_optional _29_repeat
    (124) _28_optional -> . expr
    (125) _28_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    NEWLINE         reduce using rule 125 (_28_optional -> .)
    ELIF            reduce using rule 125 (_28_optional -> .)
    ELSE            reduce using rule 125 (_28_optional -> .)
    END             reduce using rule 125 (_28_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 272
    _28_optional                   shift and go to state 273
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 269

    (122) _27_optional -> type .
    (               reduce using rule 122 (_27_optional -> type .)
    -               reduce using rule 122 (_27_optional -> type .)
    {               reduce using rule 122 (_27_optional -> type .)
    [               reduce using rule 122 (_27_optional -> type .)
    CASE            reduce using rule 122 (_27_optional -> type .)
    IF              reduce using rule 122 (_27_optional -> type .)
    DEF             reduce using rule 122 (_27_optional -> type .)
    STRING          reduce using rule 122 (_27_optional -> type .)
    NUMBER          reduce using rule 122 (_27_optional -> type .)
    IDENTIFIER      reduce using rule 122 (_27_optional -> type .)
    DO              reduce using rule 122 (_27_optional -> type .)
    NEWLINE         reduce using rule 122 (_27_optional -> type .)
    ELIF            reduce using rule 122 (_27_optional -> type .)
    ELSE            reduce using rule 122 (_27_optional -> type .)
    END             reduce using rule 122 (_27_optional -> type .)


state 270

    (118) _26_items -> _26_items _26_item .
    NEWLINE         reduce using rule 118 (_26_items -> _26_items _26_item .)
    END             reduce using rule 118 (_26_items -> _26_items _26_item .)


state 271

    (120) _26_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 120 (_26_item -> NEWLINE expr .)
    END             reduce using rule 120 (_26_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 272

    (124) _28_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 124 (_28_optional -> expr .)
    ELIF            reduce using rule 124 (_28_optional -> expr .)
    ELSE            reduce using rule 124 (_28_optional -> expr .)
    END             reduce using rule 124 (_28_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 273

    (121) _elif -> ELIF expr THEN _27_optional _28_optional . _29_repeat
    (126) _29_repeat -> . _29_items
    (127) _29_repeat -> .
    (128) _29_items -> . _29_items _29_item
    (129) _29_items -> . _29_item
    (130) _29_item -> . NEWLINE expr
    ELIF            reduce using rule 127 (_29_repeat -> .)
    ELSE            reduce using rule 127 (_29_repeat -> .)
    END             reduce using rule 127 (_29_repeat -> .)
    NEWLINE         shift and go to state 277

    _29_repeat                     shift and go to state 274
    _29_items                      shift and go to state 275
    _29_item                       shift and go to state 276

state 274

    (121) _elif -> ELIF expr THEN _27_optional _28_optional _29_repeat .
    ELIF            reduce using rule 121 (_elif -> ELIF expr THEN _27_optional _28_optional _29_repeat .)
    ELSE            reduce using rule 121 (_elif -> ELIF expr THEN _27_optional _28_optional _29_repeat .)
    END             reduce using rule 121 (_elif -> ELIF expr THEN _27_optional _28_optional _29_repeat .)


state 275

    (126) _29_repeat -> _29_items .
    (128) _29_items -> _29_items . _29_item
    (130) _29_item -> . NEWLINE expr
    ELIF            reduce using rule 126 (_29_repeat -> _29_items .)
    ELSE            reduce using rule 126 (_29_repeat -> _29_items .)
    END             reduce using rule 126 (_29_repeat -> _29_items .)
    NEWLINE         shift and go to state 277

    _29_item                       shift and go to state 278

state 276

    (129) _29_items -> _29_item .
    NEWLINE         reduce using rule 129 (_29_items -> _29_item .)
    ELIF            reduce using rule 129 (_29_items -> _29_item .)
    ELSE            reduce using rule 129 (_29_items -> _29_item .)
    END             reduce using rule 129 (_29_items -> _29_item .)


state 277

    (130) _29_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . _if
    (21) expr -> . _def
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (188) tuple -> . { _42_optional _43_repeat }
    (180) array -> . [ _40_optional _41_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (206) variable_declaration -> . identifier _46_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (196) call -> . callee ( _44_optional _45_repeat )
    (96) _if -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) _def -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (209) literal -> . STRING
    (210) literal -> . NUMBER
    (205) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (204) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 279
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    _if                            shift and go to state 19
    _def                           shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 278

    (128) _29_items -> _29_items _29_item .
    NEWLINE         reduce using rule 128 (_29_items -> _29_items _29_item .)
    ELIF            reduce using rule 128 (_29_items -> _29_items _29_item .)
    ELSE            reduce using rule 128 (_29_items -> _29_items _29_item .)
    END             reduce using rule 128 (_29_items -> _29_items _29_item .)


state 279

    (130) _29_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 130 (_29_item -> NEWLINE expr .)
    ELIF            reduce using rule 130 (_29_item -> NEWLINE expr .)
    ELSE            reduce using rule 130 (_29_item -> NEWLINE expr .)
    END             reduce using rule 130 (_29_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


Conflicts:

shift/reduce conflict for INT_DIV in state 91 resolved as shift
shift/reduce conflict for * in state 91 resolved as shift
shift/reduce conflict for / in state 91 resolved as shift
shift/reduce conflict for - in state 91 resolved as shift
shift/reduce conflict for + in state 91 resolved as shift
shift/reduce conflict for CONCAT in state 91 resolved as shift