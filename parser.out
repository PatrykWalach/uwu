Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_NEWLINE_optional _2_do_exprs_optional
Rule 2     _1_NEWLINE_optional -> NEWLINE
Rule 3     _1_NEWLINE_optional -> <empty>
Rule 4     _2_do_exprs_optional -> do_exprs
Rule 5     _2_do_exprs_optional -> <empty>
Rule 6     do_exprs -> expr _3_NEWLINE_optional
Rule 7     _3_NEWLINE_optional -> NEWLINE
Rule 8     _3_NEWLINE_optional -> <empty>
Rule 9     do_exprs -> expr NEWLINE do_exprs
Rule 10    expr -> - expr  [precedence=right, level=6]
Rule 11    expr -> ( expr )  [precedence=left, level=7]
Rule 12    expr -> array
Rule 13    expr -> variant_call
Rule 14    expr -> identifier
Rule 15    expr -> let
Rule 16    expr -> call
Rule 17    expr -> case_of
Rule 18    expr -> binary_expr
Rule 19    expr -> if_expr
Rule 20    expr -> def_expr
Rule 21    expr -> literal
Rule 22    expr -> do
Rule 23    expr -> external
Rule 24    expr -> enum
Rule 25    external -> EXTERNAL
Rule 26    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 27    binary_expr -> expr EQUAL expr  [precedence=left, level=2]
Rule 28    binary_expr -> expr NOT_EQUAL expr  [precedence=left, level=2]
Rule 29    binary_expr -> expr | expr  [precedence=left, level=4]
Rule 30    binary_expr -> expr > expr  [precedence=left, level=3]
Rule 31    binary_expr -> expr % expr  [precedence=left, level=5]
Rule 32    binary_expr -> expr < expr  [precedence=left, level=3]
Rule 33    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 34    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 35    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 36    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 37    binary_expr -> expr CONCAT expr  [precedence=left, level=4]
Rule 38    do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
Rule 39    _4_0x3a_type_optional -> : type
Rule 40    _4_0x3a_type_optional -> <empty>
Rule 41    _5_NEWLINE_optional -> NEWLINE
Rule 42    _5_NEWLINE_optional -> <empty>
Rule 43    _6_do_exprs_optional -> do_exprs
Rule 44    _6_do_exprs_optional -> <empty>
Rule 45    block_statement -> _7_NEWLINE_optional _8_do_exprs_optional
Rule 46    _7_NEWLINE_optional -> NEWLINE
Rule 47    _7_NEWLINE_optional -> <empty>
Rule 48    _8_do_exprs_optional -> do_exprs
Rule 49    _8_do_exprs_optional -> <empty>
Rule 50    def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do  [precedence=left, level=7]
Rule 51    _9_NEWLINE_optional -> NEWLINE
Rule 52    _9_NEWLINE_optional -> <empty>
Rule 53    _10_params_optional -> params
Rule 54    _10_params_optional -> <empty>
Rule 55    _11_0x3a_type_optional -> : type
Rule 56    _11_0x3a_type_optional -> <empty>
Rule 57    def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do  [precedence=left, level=7]
Rule 58    _12_0x2c_type_identifier_repeat -> _12_0x2c_type_identifier_items
Rule 59    _12_0x2c_type_identifier_repeat -> <empty>
Rule 60    _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item
Rule 61    _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_item
Rule 62    _12_0x2c_type_identifier_item -> , type_identifier
Rule 63    _13_NEWLINE_optional -> NEWLINE
Rule 64    _13_NEWLINE_optional -> <empty>
Rule 65    _14_params_optional -> params
Rule 66    _14_params_optional -> <empty>
Rule 67    _15_0x3a_type_optional -> : type
Rule 68    _15_0x3a_type_optional -> <empty>
Rule 69    params -> param _16_NEWLINE_optional
Rule 70    _16_NEWLINE_optional -> NEWLINE
Rule 71    _16_NEWLINE_optional -> <empty>
Rule 72    params -> params , _17_NEWLINE_optional param _18_NEWLINE_optional
Rule 73    _17_NEWLINE_optional -> NEWLINE
Rule 74    _17_NEWLINE_optional -> <empty>
Rule 75    _18_NEWLINE_optional -> NEWLINE
Rule 76    _18_NEWLINE_optional -> <empty>
Rule 77    type -> type_identifier < type _19_0x2c_type_repeat >  [precedence=left, level=3]
Rule 78    _19_0x2c_type_repeat -> _19_0x2c_type_items
Rule 79    _19_0x2c_type_repeat -> <empty>
Rule 80    _19_0x2c_type_items -> _19_0x2c_type_items _19_0x2c_type_item
Rule 81    _19_0x2c_type_items -> _19_0x2c_type_item
Rule 82    _19_0x2c_type_item -> , type
Rule 83    type -> type_identifier
Rule 84    enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
Rule 85    _20_NEWLINE_optional -> NEWLINE
Rule 86    _20_NEWLINE_optional -> <empty>
Rule 87    _21_variants_optional -> variants
Rule 88    _21_variants_optional -> <empty>
Rule 89    enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
Rule 90    _22_0x2c_type_identifier_repeat -> _22_0x2c_type_identifier_items
Rule 91    _22_0x2c_type_identifier_repeat -> <empty>
Rule 92    _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item
Rule 93    _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_item
Rule 94    _22_0x2c_type_identifier_item -> , type_identifier
Rule 95    _23_NEWLINE_optional -> NEWLINE
Rule 96    _23_NEWLINE_optional -> <empty>
Rule 97    _24_variants_optional -> variants
Rule 98    _24_variants_optional -> <empty>
Rule 99    variants -> variant _25_NEWLINE_optional
Rule 100   _25_NEWLINE_optional -> NEWLINE
Rule 101   _25_NEWLINE_optional -> <empty>
Rule 102   variants -> variants variant _26_NEWLINE_optional
Rule 103   _26_NEWLINE_optional -> NEWLINE
Rule 104   _26_NEWLINE_optional -> <empty>
Rule 105   variant -> type_identifier
Rule 106   variant -> type_identifier ( type _27_0x2c_type_repeat )  [precedence=left, level=7]
Rule 107   _27_0x2c_type_repeat -> _27_0x2c_type_items
Rule 108   _27_0x2c_type_repeat -> <empty>
Rule 109   _27_0x2c_type_items -> _27_0x2c_type_items _27_0x2c_type_item
Rule 110   _27_0x2c_type_items -> _27_0x2c_type_item
Rule 111   _27_0x2c_type_item -> , type
Rule 112   param -> identifier _28_0x3a_type_optional
Rule 113   _28_0x3a_type_optional -> : type
Rule 114   _28_0x3a_type_optional -> <empty>
Rule 115   if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
Rule 116   _29_0x3a_type_optional -> : type
Rule 117   _29_0x3a_type_optional -> <empty>
Rule 118   _30_or_else_optional -> or_else
Rule 119   _30_or_else_optional -> <empty>
Rule 120   or_else -> ELIF expr THEN block_statement _31_or_else_optional
Rule 121   _31_or_else_optional -> or_else
Rule 122   _31_or_else_optional -> <empty>
Rule 123   or_else -> ELSE block_statement
Rule 124   case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END
Rule 125   _32_NEWLINE_optional -> NEWLINE
Rule 126   _32_NEWLINE_optional -> <empty>
Rule 127   _33_cases_optional -> cases
Rule 128   _33_cases_optional -> <empty>
Rule 129   cases -> pattern do _34_NEWLINE_optional
Rule 130   _34_NEWLINE_optional -> NEWLINE
Rule 131   _34_NEWLINE_optional -> <empty>
Rule 132   cases -> cases pattern do _35_NEWLINE_optional
Rule 133   _35_NEWLINE_optional -> NEWLINE
Rule 134   _35_NEWLINE_optional -> <empty>
Rule 135   pattern -> match_variant
Rule 136   pattern -> match_as
Rule 137   match_as -> identifier
Rule 138   match_variant -> type_identifier
Rule 139   match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional )  [precedence=left, level=7]
Rule 140   _36_NEWLINE_optional -> NEWLINE
Rule 141   _36_NEWLINE_optional -> <empty>
Rule 142   _37_patterns_optional -> patterns
Rule 143   _37_patterns_optional -> <empty>
Rule 144   patterns -> pattern _38_NEWLINE_optional
Rule 145   _38_NEWLINE_optional -> NEWLINE
Rule 146   _38_NEWLINE_optional -> <empty>
Rule 147   patterns -> patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional
Rule 148   _39_NEWLINE_optional -> NEWLINE
Rule 149   _39_NEWLINE_optional -> <empty>
Rule 150   _40_NEWLINE_optional -> NEWLINE
Rule 151   _40_NEWLINE_optional -> <empty>
Rule 152   array -> [ _41_NEWLINE_optional _42_exprs_optional ]
Rule 153   _41_NEWLINE_optional -> NEWLINE
Rule 154   _41_NEWLINE_optional -> <empty>
Rule 155   _42_exprs_optional -> exprs
Rule 156   _42_exprs_optional -> <empty>
Rule 157   call -> expr ( _43_NEWLINE_optional _44_exprs_optional )  [precedence=left, level=7]
Rule 158   _43_NEWLINE_optional -> NEWLINE
Rule 159   _43_NEWLINE_optional -> <empty>
Rule 160   _44_exprs_optional -> exprs
Rule 161   _44_exprs_optional -> <empty>
Rule 162   variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional )  [precedence=left, level=7]
Rule 163   _45_NEWLINE_optional -> NEWLINE
Rule 164   _45_NEWLINE_optional -> <empty>
Rule 165   _46_exprs_optional -> exprs
Rule 166   _46_exprs_optional -> <empty>
Rule 167   exprs -> expr _47_NEWLINE_optional
Rule 168   _47_NEWLINE_optional -> NEWLINE
Rule 169   _47_NEWLINE_optional -> <empty>
Rule 170   exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional
Rule 171   _48_NEWLINE_optional -> NEWLINE
Rule 172   _48_NEWLINE_optional -> <empty>
Rule 173   _49_NEWLINE_optional -> NEWLINE
Rule 174   _49_NEWLINE_optional -> <empty>
Rule 175   identifier -> IDENTIFIER
Rule 176   type_identifier -> TYPE_IDENTIFIER
Rule 177   let -> identifier _50_0x3a_type_optional = expr  [precedence=left, level=1]
Rule 178   _50_0x3a_type_optional -> : type
Rule 179   _50_0x3a_type_optional -> <empty>
Rule 180   literal -> STRING
Rule 181   literal -> NUMBER

Terminals, with rules where they appear:

%                    : 31
(                    : 11 50 57 106 139 157 162
)                    : 11 50 57 106 139 157 162
*                    : 33
+                    : 36
,                    : 62 72 82 94 111 147 170
-                    : 10 35
/                    : 34
:                    : 39 55 67 113 116 178
<                    : 32 57 77 89
=                    : 177
>                    : 30 57 77 89
CASE                 : 124
CONCAT               : 37
DEF                  : 50 57
DO                   : 38
ELIF                 : 120
ELSE                 : 123
END                  : 38 115 124
ENUM                 : 84 89
EQUAL                : 27
EXTERNAL             : 25
IDENTIFIER           : 175
IF                   : 115
INT_DIV              : 26
NEWLINE              : 2 7 9 41 46 51 63 70 73 75 85 95 100 103 125 130 133 140 145 148 150 153 158 163 168 171 173
NOT_EQUAL            : 28
NUMBER               : 181
OF                   : 124
STRING               : 180
THEN                 : 115 120
TYPE_IDENTIFIER      : 176
[                    : 152
]                    : 152
error                : 
{                    : 84 89
|                    : 29
}                    : 84 89

Nonterminals, with rules where they appear:

_10_params_optional  : 50
_11_0x3a_type_optional : 50
_12_0x2c_type_identifier_item : 60 61
_12_0x2c_type_identifier_items : 58 60
_12_0x2c_type_identifier_repeat : 57
_13_NEWLINE_optional : 57
_14_params_optional  : 57
_15_0x3a_type_optional : 57
_16_NEWLINE_optional : 69
_17_NEWLINE_optional : 72
_18_NEWLINE_optional : 72
_19_0x2c_type_item   : 80 81
_19_0x2c_type_items  : 78 80
_19_0x2c_type_repeat : 77
_1_NEWLINE_optional  : 1
_20_NEWLINE_optional : 84
_21_variants_optional : 84
_22_0x2c_type_identifier_item : 92 93
_22_0x2c_type_identifier_items : 90 92
_22_0x2c_type_identifier_repeat : 89
_23_NEWLINE_optional : 89
_24_variants_optional : 89
_25_NEWLINE_optional : 99
_26_NEWLINE_optional : 102
_27_0x2c_type_item   : 109 110
_27_0x2c_type_items  : 107 109
_27_0x2c_type_repeat : 106
_28_0x3a_type_optional : 112
_29_0x3a_type_optional : 115
_2_do_exprs_optional : 1
_30_or_else_optional : 115
_31_or_else_optional : 120
_32_NEWLINE_optional : 124
_33_cases_optional   : 124
_34_NEWLINE_optional : 129
_35_NEWLINE_optional : 132
_36_NEWLINE_optional : 139
_37_patterns_optional : 139
_38_NEWLINE_optional : 144
_39_NEWLINE_optional : 147
_3_NEWLINE_optional  : 6
_40_NEWLINE_optional : 147
_41_NEWLINE_optional : 152
_42_exprs_optional   : 152
_43_NEWLINE_optional : 157
_44_exprs_optional   : 157
_45_NEWLINE_optional : 162
_46_exprs_optional   : 162
_47_NEWLINE_optional : 167
_48_NEWLINE_optional : 170
_49_NEWLINE_optional : 170
_4_0x3a_type_optional : 38
_50_0x3a_type_optional : 177
_5_NEWLINE_optional  : 38
_6_do_exprs_optional : 38
_7_NEWLINE_optional  : 45
_8_do_exprs_optional : 45
_9_NEWLINE_optional  : 50
array                : 12
binary_expr          : 18
block_statement      : 115 120 123
call                 : 16
case_of              : 17
cases                : 127 132
def_expr             : 20
do                   : 22 50 57 129 132
do_exprs             : 4 9 43 48
enum                 : 24
expr                 : 6 9 10 11 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 115 120 124 157 167 170 177
exprs                : 155 160 165 170
external             : 23
identifier           : 14 50 57 112 137 177
if_expr              : 19
let                  : 15
literal              : 21
match_as             : 136
match_variant        : 135
or_else              : 118 121
param                : 69 72
params               : 53 65 72
pattern              : 129 132 144 147
patterns             : 142 147
program              : 0
type                 : 39 55 67 77 82 106 111 113 116 178
type_identifier      : 57 62 77 83 84 89 89 94 105 106 138 139 162
variant              : 99 102
variant_call         : 13
variants             : 87 97 102


state 0

    (0) S' -> . program
    (1) program -> . _1_NEWLINE_optional _2_do_exprs_optional
    (2) _1_NEWLINE_optional -> . NEWLINE
    (3) _1_NEWLINE_optional -> .
    NEWLINE         shift and go to state 3
    -               reduce using rule 3 (_1_NEWLINE_optional -> .)
    (               reduce using rule 3 (_1_NEWLINE_optional -> .)
    [               reduce using rule 3 (_1_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 3 (_1_NEWLINE_optional -> .)
    CASE            reduce using rule 3 (_1_NEWLINE_optional -> .)
    IF              reduce using rule 3 (_1_NEWLINE_optional -> .)
    DEF             reduce using rule 3 (_1_NEWLINE_optional -> .)
    STRING          reduce using rule 3 (_1_NEWLINE_optional -> .)
    NUMBER          reduce using rule 3 (_1_NEWLINE_optional -> .)
    DO              reduce using rule 3 (_1_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 3 (_1_NEWLINE_optional -> .)
    ENUM            reduce using rule 3 (_1_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 3 (_1_NEWLINE_optional -> .)
    $end            reduce using rule 3 (_1_NEWLINE_optional -> .)

    program                        shift and go to state 1
    _1_NEWLINE_optional            shift and go to state 2

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_NEWLINE_optional . _2_do_exprs_optional
    (4) _2_do_exprs_optional -> . do_exprs
    (5) _2_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 5 (_2_do_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _2_do_exprs_optional           shift and go to state 4
    do_exprs                       shift and go to state 5
    expr                           shift and go to state 6
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 3

    (2) _1_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)
    $end            reduce using rule 2 (_1_NEWLINE_optional -> NEWLINE .)


state 4

    (1) program -> _1_NEWLINE_optional _2_do_exprs_optional .
    $end            reduce using rule 1 (program -> _1_NEWLINE_optional _2_do_exprs_optional .)


state 5

    (4) _2_do_exprs_optional -> do_exprs .
    $end            reduce using rule 4 (_2_do_exprs_optional -> do_exprs .)


state 6

    (6) do_exprs -> expr . _3_NEWLINE_optional
    (9) do_exprs -> expr . NEWLINE do_exprs
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    (7) _3_NEWLINE_optional -> . NEWLINE
    (8) _3_NEWLINE_optional -> .
    NEWLINE         shift and go to state 35
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48
    $end            reduce using rule 8 (_3_NEWLINE_optional -> .)
    END             reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELIF            reduce using rule 8 (_3_NEWLINE_optional -> .)
    ELSE            reduce using rule 8 (_3_NEWLINE_optional -> .)

    _3_NEWLINE_optional            shift and go to state 34

state 7

    (10) expr -> - . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 49
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 8

    (11) expr -> ( . expr )
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 50
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 9

    (12) expr -> array .
    NEWLINE         reduce using rule 12 (expr -> array .)
    (               reduce using rule 12 (expr -> array .)
    INT_DIV         reduce using rule 12 (expr -> array .)
    EQUAL           reduce using rule 12 (expr -> array .)
    NOT_EQUAL       reduce using rule 12 (expr -> array .)
    |               reduce using rule 12 (expr -> array .)
    >               reduce using rule 12 (expr -> array .)
    %               reduce using rule 12 (expr -> array .)
    <               reduce using rule 12 (expr -> array .)
    *               reduce using rule 12 (expr -> array .)
    /               reduce using rule 12 (expr -> array .)
    -               reduce using rule 12 (expr -> array .)
    +               reduce using rule 12 (expr -> array .)
    CONCAT          reduce using rule 12 (expr -> array .)
    $end            reduce using rule 12 (expr -> array .)
    )               reduce using rule 12 (expr -> array .)
    OF              reduce using rule 12 (expr -> array .)
    THEN            reduce using rule 12 (expr -> array .)
    END             reduce using rule 12 (expr -> array .)
    ELIF            reduce using rule 12 (expr -> array .)
    ELSE            reduce using rule 12 (expr -> array .)
    ,               reduce using rule 12 (expr -> array .)
    ]               reduce using rule 12 (expr -> array .)


state 10

    (13) expr -> variant_call .
    NEWLINE         reduce using rule 13 (expr -> variant_call .)
    (               reduce using rule 13 (expr -> variant_call .)
    INT_DIV         reduce using rule 13 (expr -> variant_call .)
    EQUAL           reduce using rule 13 (expr -> variant_call .)
    NOT_EQUAL       reduce using rule 13 (expr -> variant_call .)
    |               reduce using rule 13 (expr -> variant_call .)
    >               reduce using rule 13 (expr -> variant_call .)
    %               reduce using rule 13 (expr -> variant_call .)
    <               reduce using rule 13 (expr -> variant_call .)
    *               reduce using rule 13 (expr -> variant_call .)
    /               reduce using rule 13 (expr -> variant_call .)
    -               reduce using rule 13 (expr -> variant_call .)
    +               reduce using rule 13 (expr -> variant_call .)
    CONCAT          reduce using rule 13 (expr -> variant_call .)
    $end            reduce using rule 13 (expr -> variant_call .)
    )               reduce using rule 13 (expr -> variant_call .)
    OF              reduce using rule 13 (expr -> variant_call .)
    THEN            reduce using rule 13 (expr -> variant_call .)
    END             reduce using rule 13 (expr -> variant_call .)
    ELIF            reduce using rule 13 (expr -> variant_call .)
    ELSE            reduce using rule 13 (expr -> variant_call .)
    ,               reduce using rule 13 (expr -> variant_call .)
    ]               reduce using rule 13 (expr -> variant_call .)


state 11

    (14) expr -> identifier .
    (177) let -> identifier . _50_0x3a_type_optional = expr
    (178) _50_0x3a_type_optional -> . : type
    (179) _50_0x3a_type_optional -> .
    NEWLINE         reduce using rule 14 (expr -> identifier .)
    (               reduce using rule 14 (expr -> identifier .)
    INT_DIV         reduce using rule 14 (expr -> identifier .)
    EQUAL           reduce using rule 14 (expr -> identifier .)
    NOT_EQUAL       reduce using rule 14 (expr -> identifier .)
    |               reduce using rule 14 (expr -> identifier .)
    >               reduce using rule 14 (expr -> identifier .)
    %               reduce using rule 14 (expr -> identifier .)
    <               reduce using rule 14 (expr -> identifier .)
    *               reduce using rule 14 (expr -> identifier .)
    /               reduce using rule 14 (expr -> identifier .)
    -               reduce using rule 14 (expr -> identifier .)
    +               reduce using rule 14 (expr -> identifier .)
    CONCAT          reduce using rule 14 (expr -> identifier .)
    $end            reduce using rule 14 (expr -> identifier .)
    )               reduce using rule 14 (expr -> identifier .)
    OF              reduce using rule 14 (expr -> identifier .)
    THEN            reduce using rule 14 (expr -> identifier .)
    END             reduce using rule 14 (expr -> identifier .)
    ELIF            reduce using rule 14 (expr -> identifier .)
    ELSE            reduce using rule 14 (expr -> identifier .)
    ,               reduce using rule 14 (expr -> identifier .)
    ]               reduce using rule 14 (expr -> identifier .)
    :               shift and go to state 52
    =               reduce using rule 179 (_50_0x3a_type_optional -> .)

    _50_0x3a_type_optional         shift and go to state 51

state 12

    (15) expr -> let .
    NEWLINE         reduce using rule 15 (expr -> let .)
    (               reduce using rule 15 (expr -> let .)
    INT_DIV         reduce using rule 15 (expr -> let .)
    EQUAL           reduce using rule 15 (expr -> let .)
    NOT_EQUAL       reduce using rule 15 (expr -> let .)
    |               reduce using rule 15 (expr -> let .)
    >               reduce using rule 15 (expr -> let .)
    %               reduce using rule 15 (expr -> let .)
    <               reduce using rule 15 (expr -> let .)
    *               reduce using rule 15 (expr -> let .)
    /               reduce using rule 15 (expr -> let .)
    -               reduce using rule 15 (expr -> let .)
    +               reduce using rule 15 (expr -> let .)
    CONCAT          reduce using rule 15 (expr -> let .)
    $end            reduce using rule 15 (expr -> let .)
    )               reduce using rule 15 (expr -> let .)
    OF              reduce using rule 15 (expr -> let .)
    THEN            reduce using rule 15 (expr -> let .)
    END             reduce using rule 15 (expr -> let .)
    ELIF            reduce using rule 15 (expr -> let .)
    ELSE            reduce using rule 15 (expr -> let .)
    ,               reduce using rule 15 (expr -> let .)
    ]               reduce using rule 15 (expr -> let .)


state 13

    (16) expr -> call .
    NEWLINE         reduce using rule 16 (expr -> call .)
    (               reduce using rule 16 (expr -> call .)
    INT_DIV         reduce using rule 16 (expr -> call .)
    EQUAL           reduce using rule 16 (expr -> call .)
    NOT_EQUAL       reduce using rule 16 (expr -> call .)
    |               reduce using rule 16 (expr -> call .)
    >               reduce using rule 16 (expr -> call .)
    %               reduce using rule 16 (expr -> call .)
    <               reduce using rule 16 (expr -> call .)
    *               reduce using rule 16 (expr -> call .)
    /               reduce using rule 16 (expr -> call .)
    -               reduce using rule 16 (expr -> call .)
    +               reduce using rule 16 (expr -> call .)
    CONCAT          reduce using rule 16 (expr -> call .)
    $end            reduce using rule 16 (expr -> call .)
    )               reduce using rule 16 (expr -> call .)
    OF              reduce using rule 16 (expr -> call .)
    THEN            reduce using rule 16 (expr -> call .)
    END             reduce using rule 16 (expr -> call .)
    ELIF            reduce using rule 16 (expr -> call .)
    ELSE            reduce using rule 16 (expr -> call .)
    ,               reduce using rule 16 (expr -> call .)
    ]               reduce using rule 16 (expr -> call .)


state 14

    (17) expr -> case_of .
    NEWLINE         reduce using rule 17 (expr -> case_of .)
    (               reduce using rule 17 (expr -> case_of .)
    INT_DIV         reduce using rule 17 (expr -> case_of .)
    EQUAL           reduce using rule 17 (expr -> case_of .)
    NOT_EQUAL       reduce using rule 17 (expr -> case_of .)
    |               reduce using rule 17 (expr -> case_of .)
    >               reduce using rule 17 (expr -> case_of .)
    %               reduce using rule 17 (expr -> case_of .)
    <               reduce using rule 17 (expr -> case_of .)
    *               reduce using rule 17 (expr -> case_of .)
    /               reduce using rule 17 (expr -> case_of .)
    -               reduce using rule 17 (expr -> case_of .)
    +               reduce using rule 17 (expr -> case_of .)
    CONCAT          reduce using rule 17 (expr -> case_of .)
    $end            reduce using rule 17 (expr -> case_of .)
    )               reduce using rule 17 (expr -> case_of .)
    OF              reduce using rule 17 (expr -> case_of .)
    THEN            reduce using rule 17 (expr -> case_of .)
    END             reduce using rule 17 (expr -> case_of .)
    ELIF            reduce using rule 17 (expr -> case_of .)
    ELSE            reduce using rule 17 (expr -> case_of .)
    ,               reduce using rule 17 (expr -> case_of .)
    ]               reduce using rule 17 (expr -> case_of .)


state 15

    (18) expr -> binary_expr .
    NEWLINE         reduce using rule 18 (expr -> binary_expr .)
    (               reduce using rule 18 (expr -> binary_expr .)
    INT_DIV         reduce using rule 18 (expr -> binary_expr .)
    EQUAL           reduce using rule 18 (expr -> binary_expr .)
    NOT_EQUAL       reduce using rule 18 (expr -> binary_expr .)
    |               reduce using rule 18 (expr -> binary_expr .)
    >               reduce using rule 18 (expr -> binary_expr .)
    %               reduce using rule 18 (expr -> binary_expr .)
    <               reduce using rule 18 (expr -> binary_expr .)
    *               reduce using rule 18 (expr -> binary_expr .)
    /               reduce using rule 18 (expr -> binary_expr .)
    -               reduce using rule 18 (expr -> binary_expr .)
    +               reduce using rule 18 (expr -> binary_expr .)
    CONCAT          reduce using rule 18 (expr -> binary_expr .)
    $end            reduce using rule 18 (expr -> binary_expr .)
    )               reduce using rule 18 (expr -> binary_expr .)
    OF              reduce using rule 18 (expr -> binary_expr .)
    THEN            reduce using rule 18 (expr -> binary_expr .)
    END             reduce using rule 18 (expr -> binary_expr .)
    ELIF            reduce using rule 18 (expr -> binary_expr .)
    ELSE            reduce using rule 18 (expr -> binary_expr .)
    ,               reduce using rule 18 (expr -> binary_expr .)
    ]               reduce using rule 18 (expr -> binary_expr .)


state 16

    (19) expr -> if_expr .
    NEWLINE         reduce using rule 19 (expr -> if_expr .)
    (               reduce using rule 19 (expr -> if_expr .)
    INT_DIV         reduce using rule 19 (expr -> if_expr .)
    EQUAL           reduce using rule 19 (expr -> if_expr .)
    NOT_EQUAL       reduce using rule 19 (expr -> if_expr .)
    |               reduce using rule 19 (expr -> if_expr .)
    >               reduce using rule 19 (expr -> if_expr .)
    %               reduce using rule 19 (expr -> if_expr .)
    <               reduce using rule 19 (expr -> if_expr .)
    *               reduce using rule 19 (expr -> if_expr .)
    /               reduce using rule 19 (expr -> if_expr .)
    -               reduce using rule 19 (expr -> if_expr .)
    +               reduce using rule 19 (expr -> if_expr .)
    CONCAT          reduce using rule 19 (expr -> if_expr .)
    $end            reduce using rule 19 (expr -> if_expr .)
    )               reduce using rule 19 (expr -> if_expr .)
    OF              reduce using rule 19 (expr -> if_expr .)
    THEN            reduce using rule 19 (expr -> if_expr .)
    END             reduce using rule 19 (expr -> if_expr .)
    ELIF            reduce using rule 19 (expr -> if_expr .)
    ELSE            reduce using rule 19 (expr -> if_expr .)
    ,               reduce using rule 19 (expr -> if_expr .)
    ]               reduce using rule 19 (expr -> if_expr .)


state 17

    (20) expr -> def_expr .
    NEWLINE         reduce using rule 20 (expr -> def_expr .)
    (               reduce using rule 20 (expr -> def_expr .)
    INT_DIV         reduce using rule 20 (expr -> def_expr .)
    EQUAL           reduce using rule 20 (expr -> def_expr .)
    NOT_EQUAL       reduce using rule 20 (expr -> def_expr .)
    |               reduce using rule 20 (expr -> def_expr .)
    >               reduce using rule 20 (expr -> def_expr .)
    %               reduce using rule 20 (expr -> def_expr .)
    <               reduce using rule 20 (expr -> def_expr .)
    *               reduce using rule 20 (expr -> def_expr .)
    /               reduce using rule 20 (expr -> def_expr .)
    -               reduce using rule 20 (expr -> def_expr .)
    +               reduce using rule 20 (expr -> def_expr .)
    CONCAT          reduce using rule 20 (expr -> def_expr .)
    $end            reduce using rule 20 (expr -> def_expr .)
    )               reduce using rule 20 (expr -> def_expr .)
    OF              reduce using rule 20 (expr -> def_expr .)
    THEN            reduce using rule 20 (expr -> def_expr .)
    END             reduce using rule 20 (expr -> def_expr .)
    ELIF            reduce using rule 20 (expr -> def_expr .)
    ELSE            reduce using rule 20 (expr -> def_expr .)
    ,               reduce using rule 20 (expr -> def_expr .)
    ]               reduce using rule 20 (expr -> def_expr .)


state 18

    (21) expr -> literal .
    NEWLINE         reduce using rule 21 (expr -> literal .)
    (               reduce using rule 21 (expr -> literal .)
    INT_DIV         reduce using rule 21 (expr -> literal .)
    EQUAL           reduce using rule 21 (expr -> literal .)
    NOT_EQUAL       reduce using rule 21 (expr -> literal .)
    |               reduce using rule 21 (expr -> literal .)
    >               reduce using rule 21 (expr -> literal .)
    %               reduce using rule 21 (expr -> literal .)
    <               reduce using rule 21 (expr -> literal .)
    *               reduce using rule 21 (expr -> literal .)
    /               reduce using rule 21 (expr -> literal .)
    -               reduce using rule 21 (expr -> literal .)
    +               reduce using rule 21 (expr -> literal .)
    CONCAT          reduce using rule 21 (expr -> literal .)
    $end            reduce using rule 21 (expr -> literal .)
    )               reduce using rule 21 (expr -> literal .)
    OF              reduce using rule 21 (expr -> literal .)
    THEN            reduce using rule 21 (expr -> literal .)
    END             reduce using rule 21 (expr -> literal .)
    ELIF            reduce using rule 21 (expr -> literal .)
    ELSE            reduce using rule 21 (expr -> literal .)
    ,               reduce using rule 21 (expr -> literal .)
    ]               reduce using rule 21 (expr -> literal .)


state 19

    (22) expr -> do .
    NEWLINE         reduce using rule 22 (expr -> do .)
    (               reduce using rule 22 (expr -> do .)
    INT_DIV         reduce using rule 22 (expr -> do .)
    EQUAL           reduce using rule 22 (expr -> do .)
    NOT_EQUAL       reduce using rule 22 (expr -> do .)
    |               reduce using rule 22 (expr -> do .)
    >               reduce using rule 22 (expr -> do .)
    %               reduce using rule 22 (expr -> do .)
    <               reduce using rule 22 (expr -> do .)
    *               reduce using rule 22 (expr -> do .)
    /               reduce using rule 22 (expr -> do .)
    -               reduce using rule 22 (expr -> do .)
    +               reduce using rule 22 (expr -> do .)
    CONCAT          reduce using rule 22 (expr -> do .)
    $end            reduce using rule 22 (expr -> do .)
    )               reduce using rule 22 (expr -> do .)
    OF              reduce using rule 22 (expr -> do .)
    THEN            reduce using rule 22 (expr -> do .)
    END             reduce using rule 22 (expr -> do .)
    ELIF            reduce using rule 22 (expr -> do .)
    ELSE            reduce using rule 22 (expr -> do .)
    ,               reduce using rule 22 (expr -> do .)
    ]               reduce using rule 22 (expr -> do .)


state 20

    (23) expr -> external .
    NEWLINE         reduce using rule 23 (expr -> external .)
    (               reduce using rule 23 (expr -> external .)
    INT_DIV         reduce using rule 23 (expr -> external .)
    EQUAL           reduce using rule 23 (expr -> external .)
    NOT_EQUAL       reduce using rule 23 (expr -> external .)
    |               reduce using rule 23 (expr -> external .)
    >               reduce using rule 23 (expr -> external .)
    %               reduce using rule 23 (expr -> external .)
    <               reduce using rule 23 (expr -> external .)
    *               reduce using rule 23 (expr -> external .)
    /               reduce using rule 23 (expr -> external .)
    -               reduce using rule 23 (expr -> external .)
    +               reduce using rule 23 (expr -> external .)
    CONCAT          reduce using rule 23 (expr -> external .)
    $end            reduce using rule 23 (expr -> external .)
    )               reduce using rule 23 (expr -> external .)
    OF              reduce using rule 23 (expr -> external .)
    THEN            reduce using rule 23 (expr -> external .)
    END             reduce using rule 23 (expr -> external .)
    ELIF            reduce using rule 23 (expr -> external .)
    ELSE            reduce using rule 23 (expr -> external .)
    ,               reduce using rule 23 (expr -> external .)
    ]               reduce using rule 23 (expr -> external .)


state 21

    (24) expr -> enum .
    NEWLINE         reduce using rule 24 (expr -> enum .)
    (               reduce using rule 24 (expr -> enum .)
    INT_DIV         reduce using rule 24 (expr -> enum .)
    EQUAL           reduce using rule 24 (expr -> enum .)
    NOT_EQUAL       reduce using rule 24 (expr -> enum .)
    |               reduce using rule 24 (expr -> enum .)
    >               reduce using rule 24 (expr -> enum .)
    %               reduce using rule 24 (expr -> enum .)
    <               reduce using rule 24 (expr -> enum .)
    *               reduce using rule 24 (expr -> enum .)
    /               reduce using rule 24 (expr -> enum .)
    -               reduce using rule 24 (expr -> enum .)
    +               reduce using rule 24 (expr -> enum .)
    CONCAT          reduce using rule 24 (expr -> enum .)
    $end            reduce using rule 24 (expr -> enum .)
    )               reduce using rule 24 (expr -> enum .)
    OF              reduce using rule 24 (expr -> enum .)
    THEN            reduce using rule 24 (expr -> enum .)
    END             reduce using rule 24 (expr -> enum .)
    ELIF            reduce using rule 24 (expr -> enum .)
    ELSE            reduce using rule 24 (expr -> enum .)
    ,               reduce using rule 24 (expr -> enum .)
    ]               reduce using rule 24 (expr -> enum .)


state 22

    (152) array -> [ . _41_NEWLINE_optional _42_exprs_optional ]
    (153) _41_NEWLINE_optional -> . NEWLINE
    (154) _41_NEWLINE_optional -> .
    NEWLINE         shift and go to state 54
    -               reduce using rule 154 (_41_NEWLINE_optional -> .)
    (               reduce using rule 154 (_41_NEWLINE_optional -> .)
    [               reduce using rule 154 (_41_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 154 (_41_NEWLINE_optional -> .)
    CASE            reduce using rule 154 (_41_NEWLINE_optional -> .)
    IF              reduce using rule 154 (_41_NEWLINE_optional -> .)
    DEF             reduce using rule 154 (_41_NEWLINE_optional -> .)
    STRING          reduce using rule 154 (_41_NEWLINE_optional -> .)
    NUMBER          reduce using rule 154 (_41_NEWLINE_optional -> .)
    DO              reduce using rule 154 (_41_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 154 (_41_NEWLINE_optional -> .)
    ENUM            reduce using rule 154 (_41_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 154 (_41_NEWLINE_optional -> .)
    ]               reduce using rule 154 (_41_NEWLINE_optional -> .)

    _41_NEWLINE_optional           shift and go to state 53

state 23

    (162) variant_call -> type_identifier . ( _45_NEWLINE_optional _46_exprs_optional )
    (               shift and go to state 55


state 24

    (175) identifier -> IDENTIFIER .
    :               reduce using rule 175 (identifier -> IDENTIFIER .)
    =               reduce using rule 175 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 175 (identifier -> IDENTIFIER .)
    (               reduce using rule 175 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 175 (identifier -> IDENTIFIER .)
    EQUAL           reduce using rule 175 (identifier -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 175 (identifier -> IDENTIFIER .)
    |               reduce using rule 175 (identifier -> IDENTIFIER .)
    >               reduce using rule 175 (identifier -> IDENTIFIER .)
    %               reduce using rule 175 (identifier -> IDENTIFIER .)
    <               reduce using rule 175 (identifier -> IDENTIFIER .)
    *               reduce using rule 175 (identifier -> IDENTIFIER .)
    /               reduce using rule 175 (identifier -> IDENTIFIER .)
    -               reduce using rule 175 (identifier -> IDENTIFIER .)
    +               reduce using rule 175 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 175 (identifier -> IDENTIFIER .)
    $end            reduce using rule 175 (identifier -> IDENTIFIER .)
    )               reduce using rule 175 (identifier -> IDENTIFIER .)
    OF              reduce using rule 175 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 175 (identifier -> IDENTIFIER .)
    END             reduce using rule 175 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 175 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 175 (identifier -> IDENTIFIER .)
    ,               reduce using rule 175 (identifier -> IDENTIFIER .)
    ]               reduce using rule 175 (identifier -> IDENTIFIER .)
    DO              reduce using rule 175 (identifier -> IDENTIFIER .)


state 25

    (124) case_of -> CASE . expr OF _32_NEWLINE_optional _33_cases_optional END
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 56
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 26

    (115) if_expr -> IF . expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 57
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 27

    (50) def_expr -> DEF . identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> DEF . identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 58

state 28

    (180) literal -> STRING .
    NEWLINE         reduce using rule 180 (literal -> STRING .)
    (               reduce using rule 180 (literal -> STRING .)
    INT_DIV         reduce using rule 180 (literal -> STRING .)
    EQUAL           reduce using rule 180 (literal -> STRING .)
    NOT_EQUAL       reduce using rule 180 (literal -> STRING .)
    |               reduce using rule 180 (literal -> STRING .)
    >               reduce using rule 180 (literal -> STRING .)
    %               reduce using rule 180 (literal -> STRING .)
    <               reduce using rule 180 (literal -> STRING .)
    *               reduce using rule 180 (literal -> STRING .)
    /               reduce using rule 180 (literal -> STRING .)
    -               reduce using rule 180 (literal -> STRING .)
    +               reduce using rule 180 (literal -> STRING .)
    CONCAT          reduce using rule 180 (literal -> STRING .)
    $end            reduce using rule 180 (literal -> STRING .)
    )               reduce using rule 180 (literal -> STRING .)
    OF              reduce using rule 180 (literal -> STRING .)
    THEN            reduce using rule 180 (literal -> STRING .)
    END             reduce using rule 180 (literal -> STRING .)
    ELIF            reduce using rule 180 (literal -> STRING .)
    ELSE            reduce using rule 180 (literal -> STRING .)
    ,               reduce using rule 180 (literal -> STRING .)
    ]               reduce using rule 180 (literal -> STRING .)


state 29

    (181) literal -> NUMBER .
    NEWLINE         reduce using rule 181 (literal -> NUMBER .)
    (               reduce using rule 181 (literal -> NUMBER .)
    INT_DIV         reduce using rule 181 (literal -> NUMBER .)
    EQUAL           reduce using rule 181 (literal -> NUMBER .)
    NOT_EQUAL       reduce using rule 181 (literal -> NUMBER .)
    |               reduce using rule 181 (literal -> NUMBER .)
    >               reduce using rule 181 (literal -> NUMBER .)
    %               reduce using rule 181 (literal -> NUMBER .)
    <               reduce using rule 181 (literal -> NUMBER .)
    *               reduce using rule 181 (literal -> NUMBER .)
    /               reduce using rule 181 (literal -> NUMBER .)
    -               reduce using rule 181 (literal -> NUMBER .)
    +               reduce using rule 181 (literal -> NUMBER .)
    CONCAT          reduce using rule 181 (literal -> NUMBER .)
    $end            reduce using rule 181 (literal -> NUMBER .)
    )               reduce using rule 181 (literal -> NUMBER .)
    OF              reduce using rule 181 (literal -> NUMBER .)
    THEN            reduce using rule 181 (literal -> NUMBER .)
    END             reduce using rule 181 (literal -> NUMBER .)
    ELIF            reduce using rule 181 (literal -> NUMBER .)
    ELSE            reduce using rule 181 (literal -> NUMBER .)
    ,               reduce using rule 181 (literal -> NUMBER .)
    ]               reduce using rule 181 (literal -> NUMBER .)


state 30

    (38) do -> DO . _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (39) _4_0x3a_type_optional -> . : type
    (40) _4_0x3a_type_optional -> .
    :               shift and go to state 60
    NEWLINE         reduce using rule 40 (_4_0x3a_type_optional -> .)
    -               reduce using rule 40 (_4_0x3a_type_optional -> .)
    (               reduce using rule 40 (_4_0x3a_type_optional -> .)
    [               reduce using rule 40 (_4_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 40 (_4_0x3a_type_optional -> .)
    CASE            reduce using rule 40 (_4_0x3a_type_optional -> .)
    IF              reduce using rule 40 (_4_0x3a_type_optional -> .)
    DEF             reduce using rule 40 (_4_0x3a_type_optional -> .)
    STRING          reduce using rule 40 (_4_0x3a_type_optional -> .)
    NUMBER          reduce using rule 40 (_4_0x3a_type_optional -> .)
    DO              reduce using rule 40 (_4_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 40 (_4_0x3a_type_optional -> .)
    ENUM            reduce using rule 40 (_4_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 40 (_4_0x3a_type_optional -> .)
    END             reduce using rule 40 (_4_0x3a_type_optional -> .)

    _4_0x3a_type_optional          shift and go to state 59

state 31

    (25) external -> EXTERNAL .
    NEWLINE         reduce using rule 25 (external -> EXTERNAL .)
    (               reduce using rule 25 (external -> EXTERNAL .)
    INT_DIV         reduce using rule 25 (external -> EXTERNAL .)
    EQUAL           reduce using rule 25 (external -> EXTERNAL .)
    NOT_EQUAL       reduce using rule 25 (external -> EXTERNAL .)
    |               reduce using rule 25 (external -> EXTERNAL .)
    >               reduce using rule 25 (external -> EXTERNAL .)
    %               reduce using rule 25 (external -> EXTERNAL .)
    <               reduce using rule 25 (external -> EXTERNAL .)
    *               reduce using rule 25 (external -> EXTERNAL .)
    /               reduce using rule 25 (external -> EXTERNAL .)
    -               reduce using rule 25 (external -> EXTERNAL .)
    +               reduce using rule 25 (external -> EXTERNAL .)
    CONCAT          reduce using rule 25 (external -> EXTERNAL .)
    $end            reduce using rule 25 (external -> EXTERNAL .)
    )               reduce using rule 25 (external -> EXTERNAL .)
    OF              reduce using rule 25 (external -> EXTERNAL .)
    THEN            reduce using rule 25 (external -> EXTERNAL .)
    END             reduce using rule 25 (external -> EXTERNAL .)
    ELIF            reduce using rule 25 (external -> EXTERNAL .)
    ELSE            reduce using rule 25 (external -> EXTERNAL .)
    ,               reduce using rule 25 (external -> EXTERNAL .)
    ]               reduce using rule 25 (external -> EXTERNAL .)


state 32

    (84) enum -> ENUM . type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> ENUM . type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 61

state 33

    (176) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    NEWLINE         reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 176 (type_identifier -> TYPE_IDENTIFIER .)


state 34

    (6) do_exprs -> expr _3_NEWLINE_optional .
    $end            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    END             reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    ELIF            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)
    ELSE            reduce using rule 6 (do_exprs -> expr _3_NEWLINE_optional .)


state 35

    (9) do_exprs -> expr NEWLINE . do_exprs
    (7) _3_NEWLINE_optional -> NEWLINE .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 7 (_3_NEWLINE_optional -> NEWLINE .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 6
    do_exprs                       shift and go to state 62
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 36

    (157) call -> expr ( . _43_NEWLINE_optional _44_exprs_optional )
    (158) _43_NEWLINE_optional -> . NEWLINE
    (159) _43_NEWLINE_optional -> .
    NEWLINE         shift and go to state 64
    -               reduce using rule 159 (_43_NEWLINE_optional -> .)
    (               reduce using rule 159 (_43_NEWLINE_optional -> .)
    [               reduce using rule 159 (_43_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 159 (_43_NEWLINE_optional -> .)
    CASE            reduce using rule 159 (_43_NEWLINE_optional -> .)
    IF              reduce using rule 159 (_43_NEWLINE_optional -> .)
    DEF             reduce using rule 159 (_43_NEWLINE_optional -> .)
    STRING          reduce using rule 159 (_43_NEWLINE_optional -> .)
    NUMBER          reduce using rule 159 (_43_NEWLINE_optional -> .)
    DO              reduce using rule 159 (_43_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 159 (_43_NEWLINE_optional -> .)
    ENUM            reduce using rule 159 (_43_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 159 (_43_NEWLINE_optional -> .)
    )               reduce using rule 159 (_43_NEWLINE_optional -> .)

    _43_NEWLINE_optional           shift and go to state 63

state 37

    (26) binary_expr -> expr INT_DIV . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 65
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 38

    (27) binary_expr -> expr EQUAL . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 66
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 39

    (28) binary_expr -> expr NOT_EQUAL . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 67
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 40

    (29) binary_expr -> expr | . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 68
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 41

    (30) binary_expr -> expr > . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 69
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 42

    (31) binary_expr -> expr % . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 70
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 43

    (32) binary_expr -> expr < . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 71
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 44

    (33) binary_expr -> expr * . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 72
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 45

    (34) binary_expr -> expr / . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 73
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 46

    (35) binary_expr -> expr - . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 74
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 47

    (36) binary_expr -> expr + . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 75
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 48

    (37) binary_expr -> expr CONCAT . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 76
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 49

    (10) expr -> - expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 10 (expr -> - expr .)
    INT_DIV         reduce using rule 10 (expr -> - expr .)
    EQUAL           reduce using rule 10 (expr -> - expr .)
    NOT_EQUAL       reduce using rule 10 (expr -> - expr .)
    |               reduce using rule 10 (expr -> - expr .)
    >               reduce using rule 10 (expr -> - expr .)
    %               reduce using rule 10 (expr -> - expr .)
    <               reduce using rule 10 (expr -> - expr .)
    *               reduce using rule 10 (expr -> - expr .)
    /               reduce using rule 10 (expr -> - expr .)
    -               reduce using rule 10 (expr -> - expr .)
    +               reduce using rule 10 (expr -> - expr .)
    CONCAT          reduce using rule 10 (expr -> - expr .)
    $end            reduce using rule 10 (expr -> - expr .)
    )               reduce using rule 10 (expr -> - expr .)
    OF              reduce using rule 10 (expr -> - expr .)
    THEN            reduce using rule 10 (expr -> - expr .)
    END             reduce using rule 10 (expr -> - expr .)
    ELIF            reduce using rule 10 (expr -> - expr .)
    ELSE            reduce using rule 10 (expr -> - expr .)
    ,               reduce using rule 10 (expr -> - expr .)
    ]               reduce using rule 10 (expr -> - expr .)
    (               shift and go to state 36


state 50

    (11) expr -> ( expr . )
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    )               shift and go to state 77
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 51

    (177) let -> identifier _50_0x3a_type_optional . = expr
    =               shift and go to state 78


state 52

    (178) _50_0x3a_type_optional -> : . type
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 79
    type_identifier                shift and go to state 80

state 53

    (152) array -> [ _41_NEWLINE_optional . _42_exprs_optional ]
    (155) _42_exprs_optional -> . exprs
    (156) _42_exprs_optional -> .
    (167) exprs -> . expr _47_NEWLINE_optional
    (170) exprs -> . exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    ]               reduce using rule 156 (_42_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _42_exprs_optional             shift and go to state 81
    exprs                          shift and go to state 82
    expr                           shift and go to state 83
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 54

    (153) _41_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 153 (_41_NEWLINE_optional -> NEWLINE .)


state 55

    (162) variant_call -> type_identifier ( . _45_NEWLINE_optional _46_exprs_optional )
    (163) _45_NEWLINE_optional -> . NEWLINE
    (164) _45_NEWLINE_optional -> .
    NEWLINE         shift and go to state 85
    -               reduce using rule 164 (_45_NEWLINE_optional -> .)
    (               reduce using rule 164 (_45_NEWLINE_optional -> .)
    [               reduce using rule 164 (_45_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 164 (_45_NEWLINE_optional -> .)
    CASE            reduce using rule 164 (_45_NEWLINE_optional -> .)
    IF              reduce using rule 164 (_45_NEWLINE_optional -> .)
    DEF             reduce using rule 164 (_45_NEWLINE_optional -> .)
    STRING          reduce using rule 164 (_45_NEWLINE_optional -> .)
    NUMBER          reduce using rule 164 (_45_NEWLINE_optional -> .)
    DO              reduce using rule 164 (_45_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 164 (_45_NEWLINE_optional -> .)
    ENUM            reduce using rule 164 (_45_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 164 (_45_NEWLINE_optional -> .)
    )               reduce using rule 164 (_45_NEWLINE_optional -> .)

    _45_NEWLINE_optional           shift and go to state 84

state 56

    (124) case_of -> CASE expr . OF _32_NEWLINE_optional _33_cases_optional END
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 86
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 57

    (115) if_expr -> IF expr . THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 87
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 58

    (50) def_expr -> DEF identifier . ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> DEF identifier . < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (               shift and go to state 88
    <               shift and go to state 89


state 59

    (38) do -> DO _4_0x3a_type_optional . _5_NEWLINE_optional _6_do_exprs_optional END
    (41) _5_NEWLINE_optional -> . NEWLINE
    (42) _5_NEWLINE_optional -> .
    NEWLINE         shift and go to state 91
    -               reduce using rule 42 (_5_NEWLINE_optional -> .)
    (               reduce using rule 42 (_5_NEWLINE_optional -> .)
    [               reduce using rule 42 (_5_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 42 (_5_NEWLINE_optional -> .)
    CASE            reduce using rule 42 (_5_NEWLINE_optional -> .)
    IF              reduce using rule 42 (_5_NEWLINE_optional -> .)
    DEF             reduce using rule 42 (_5_NEWLINE_optional -> .)
    STRING          reduce using rule 42 (_5_NEWLINE_optional -> .)
    NUMBER          reduce using rule 42 (_5_NEWLINE_optional -> .)
    DO              reduce using rule 42 (_5_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 42 (_5_NEWLINE_optional -> .)
    ENUM            reduce using rule 42 (_5_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 42 (_5_NEWLINE_optional -> .)
    END             reduce using rule 42 (_5_NEWLINE_optional -> .)

    _5_NEWLINE_optional            shift and go to state 90

state 60

    (39) _4_0x3a_type_optional -> : . type
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 92
    type_identifier                shift and go to state 80

state 61

    (84) enum -> ENUM type_identifier . { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> ENUM type_identifier . < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    {               shift and go to state 93
    <               shift and go to state 94


state 62

    (9) do_exprs -> expr NEWLINE do_exprs .
    $end            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    END             reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELIF            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)
    ELSE            reduce using rule 9 (do_exprs -> expr NEWLINE do_exprs .)


state 63

    (157) call -> expr ( _43_NEWLINE_optional . _44_exprs_optional )
    (160) _44_exprs_optional -> . exprs
    (161) _44_exprs_optional -> .
    (167) exprs -> . expr _47_NEWLINE_optional
    (170) exprs -> . exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 161 (_44_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 83
    _44_exprs_optional             shift and go to state 95
    exprs                          shift and go to state 96
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 64

    (158) _43_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 158 (_43_NEWLINE_optional -> NEWLINE .)


state 65

    (26) binary_expr -> expr INT_DIV expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    INT_DIV         reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    EQUAL           reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    NOT_EQUAL       reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    |               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    %               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 26 (binary_expr -> expr INT_DIV expr .)
    (               shift and go to state 36


state 66

    (27) binary_expr -> expr EQUAL expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    $end            reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    )               reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    OF              reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    THEN            reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    END             reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    ,               reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    ]               reduce using rule 27 (binary_expr -> expr EQUAL expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 67

    (28) binary_expr -> expr NOT_EQUAL expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    $end            reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    OF              reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    END             reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    ]               reduce using rule 28 (binary_expr -> expr NOT_EQUAL expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 68

    (29) binary_expr -> expr | expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 29 (binary_expr -> expr | expr .)
    EQUAL           reduce using rule 29 (binary_expr -> expr | expr .)
    NOT_EQUAL       reduce using rule 29 (binary_expr -> expr | expr .)
    |               reduce using rule 29 (binary_expr -> expr | expr .)
    >               reduce using rule 29 (binary_expr -> expr | expr .)
    <               reduce using rule 29 (binary_expr -> expr | expr .)
    -               reduce using rule 29 (binary_expr -> expr | expr .)
    +               reduce using rule 29 (binary_expr -> expr | expr .)
    CONCAT          reduce using rule 29 (binary_expr -> expr | expr .)
    $end            reduce using rule 29 (binary_expr -> expr | expr .)
    )               reduce using rule 29 (binary_expr -> expr | expr .)
    OF              reduce using rule 29 (binary_expr -> expr | expr .)
    THEN            reduce using rule 29 (binary_expr -> expr | expr .)
    END             reduce using rule 29 (binary_expr -> expr | expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr | expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr | expr .)
    ,               reduce using rule 29 (binary_expr -> expr | expr .)
    ]               reduce using rule 29 (binary_expr -> expr | expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45


state 69

    (30) binary_expr -> expr > expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 30 (binary_expr -> expr > expr .)
    EQUAL           reduce using rule 30 (binary_expr -> expr > expr .)
    NOT_EQUAL       reduce using rule 30 (binary_expr -> expr > expr .)
    >               reduce using rule 30 (binary_expr -> expr > expr .)
    <               reduce using rule 30 (binary_expr -> expr > expr .)
    $end            reduce using rule 30 (binary_expr -> expr > expr .)
    )               reduce using rule 30 (binary_expr -> expr > expr .)
    OF              reduce using rule 30 (binary_expr -> expr > expr .)
    THEN            reduce using rule 30 (binary_expr -> expr > expr .)
    END             reduce using rule 30 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr > expr .)
    ,               reduce using rule 30 (binary_expr -> expr > expr .)
    ]               reduce using rule 30 (binary_expr -> expr > expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    |               shift and go to state 40
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 70

    (31) binary_expr -> expr % expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 31 (binary_expr -> expr % expr .)
    INT_DIV         reduce using rule 31 (binary_expr -> expr % expr .)
    EQUAL           reduce using rule 31 (binary_expr -> expr % expr .)
    NOT_EQUAL       reduce using rule 31 (binary_expr -> expr % expr .)
    |               reduce using rule 31 (binary_expr -> expr % expr .)
    >               reduce using rule 31 (binary_expr -> expr % expr .)
    %               reduce using rule 31 (binary_expr -> expr % expr .)
    <               reduce using rule 31 (binary_expr -> expr % expr .)
    *               reduce using rule 31 (binary_expr -> expr % expr .)
    /               reduce using rule 31 (binary_expr -> expr % expr .)
    -               reduce using rule 31 (binary_expr -> expr % expr .)
    +               reduce using rule 31 (binary_expr -> expr % expr .)
    CONCAT          reduce using rule 31 (binary_expr -> expr % expr .)
    $end            reduce using rule 31 (binary_expr -> expr % expr .)
    )               reduce using rule 31 (binary_expr -> expr % expr .)
    OF              reduce using rule 31 (binary_expr -> expr % expr .)
    THEN            reduce using rule 31 (binary_expr -> expr % expr .)
    END             reduce using rule 31 (binary_expr -> expr % expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr % expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr % expr .)
    ,               reduce using rule 31 (binary_expr -> expr % expr .)
    ]               reduce using rule 31 (binary_expr -> expr % expr .)
    (               shift and go to state 36


state 71

    (32) binary_expr -> expr < expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 32 (binary_expr -> expr < expr .)
    EQUAL           reduce using rule 32 (binary_expr -> expr < expr .)
    NOT_EQUAL       reduce using rule 32 (binary_expr -> expr < expr .)
    >               reduce using rule 32 (binary_expr -> expr < expr .)
    <               reduce using rule 32 (binary_expr -> expr < expr .)
    $end            reduce using rule 32 (binary_expr -> expr < expr .)
    )               reduce using rule 32 (binary_expr -> expr < expr .)
    OF              reduce using rule 32 (binary_expr -> expr < expr .)
    THEN            reduce using rule 32 (binary_expr -> expr < expr .)
    END             reduce using rule 32 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr < expr .)
    ,               reduce using rule 32 (binary_expr -> expr < expr .)
    ]               reduce using rule 32 (binary_expr -> expr < expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    |               shift and go to state 40
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 72

    (33) binary_expr -> expr * expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 33 (binary_expr -> expr * expr .)
    INT_DIV         reduce using rule 33 (binary_expr -> expr * expr .)
    EQUAL           reduce using rule 33 (binary_expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 33 (binary_expr -> expr * expr .)
    |               reduce using rule 33 (binary_expr -> expr * expr .)
    >               reduce using rule 33 (binary_expr -> expr * expr .)
    %               reduce using rule 33 (binary_expr -> expr * expr .)
    <               reduce using rule 33 (binary_expr -> expr * expr .)
    *               reduce using rule 33 (binary_expr -> expr * expr .)
    /               reduce using rule 33 (binary_expr -> expr * expr .)
    -               reduce using rule 33 (binary_expr -> expr * expr .)
    +               reduce using rule 33 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 33 (binary_expr -> expr * expr .)
    $end            reduce using rule 33 (binary_expr -> expr * expr .)
    )               reduce using rule 33 (binary_expr -> expr * expr .)
    OF              reduce using rule 33 (binary_expr -> expr * expr .)
    THEN            reduce using rule 33 (binary_expr -> expr * expr .)
    END             reduce using rule 33 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr * expr .)
    ,               reduce using rule 33 (binary_expr -> expr * expr .)
    ]               reduce using rule 33 (binary_expr -> expr * expr .)
    (               shift and go to state 36


state 73

    (34) binary_expr -> expr / expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 34 (binary_expr -> expr / expr .)
    INT_DIV         reduce using rule 34 (binary_expr -> expr / expr .)
    EQUAL           reduce using rule 34 (binary_expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 34 (binary_expr -> expr / expr .)
    |               reduce using rule 34 (binary_expr -> expr / expr .)
    >               reduce using rule 34 (binary_expr -> expr / expr .)
    %               reduce using rule 34 (binary_expr -> expr / expr .)
    <               reduce using rule 34 (binary_expr -> expr / expr .)
    *               reduce using rule 34 (binary_expr -> expr / expr .)
    /               reduce using rule 34 (binary_expr -> expr / expr .)
    -               reduce using rule 34 (binary_expr -> expr / expr .)
    +               reduce using rule 34 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr / expr .)
    $end            reduce using rule 34 (binary_expr -> expr / expr .)
    )               reduce using rule 34 (binary_expr -> expr / expr .)
    OF              reduce using rule 34 (binary_expr -> expr / expr .)
    THEN            reduce using rule 34 (binary_expr -> expr / expr .)
    END             reduce using rule 34 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr / expr .)
    ,               reduce using rule 34 (binary_expr -> expr / expr .)
    ]               reduce using rule 34 (binary_expr -> expr / expr .)
    (               shift and go to state 36


state 74

    (35) binary_expr -> expr - expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 35 (binary_expr -> expr - expr .)
    EQUAL           reduce using rule 35 (binary_expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 35 (binary_expr -> expr - expr .)
    |               reduce using rule 35 (binary_expr -> expr - expr .)
    >               reduce using rule 35 (binary_expr -> expr - expr .)
    <               reduce using rule 35 (binary_expr -> expr - expr .)
    -               reduce using rule 35 (binary_expr -> expr - expr .)
    +               reduce using rule 35 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 35 (binary_expr -> expr - expr .)
    $end            reduce using rule 35 (binary_expr -> expr - expr .)
    )               reduce using rule 35 (binary_expr -> expr - expr .)
    OF              reduce using rule 35 (binary_expr -> expr - expr .)
    THEN            reduce using rule 35 (binary_expr -> expr - expr .)
    END             reduce using rule 35 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 35 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 35 (binary_expr -> expr - expr .)
    ,               reduce using rule 35 (binary_expr -> expr - expr .)
    ]               reduce using rule 35 (binary_expr -> expr - expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45


state 75

    (36) binary_expr -> expr + expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 36 (binary_expr -> expr + expr .)
    EQUAL           reduce using rule 36 (binary_expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 36 (binary_expr -> expr + expr .)
    |               reduce using rule 36 (binary_expr -> expr + expr .)
    >               reduce using rule 36 (binary_expr -> expr + expr .)
    <               reduce using rule 36 (binary_expr -> expr + expr .)
    -               reduce using rule 36 (binary_expr -> expr + expr .)
    +               reduce using rule 36 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 36 (binary_expr -> expr + expr .)
    $end            reduce using rule 36 (binary_expr -> expr + expr .)
    )               reduce using rule 36 (binary_expr -> expr + expr .)
    OF              reduce using rule 36 (binary_expr -> expr + expr .)
    THEN            reduce using rule 36 (binary_expr -> expr + expr .)
    END             reduce using rule 36 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 36 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 36 (binary_expr -> expr + expr .)
    ,               reduce using rule 36 (binary_expr -> expr + expr .)
    ]               reduce using rule 36 (binary_expr -> expr + expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45


state 76

    (37) binary_expr -> expr CONCAT expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    EQUAL           reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    NOT_EQUAL       reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    |               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    -               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    +               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 37 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 42
    *               shift and go to state 44
    /               shift and go to state 45


state 77

    (11) expr -> ( expr ) .
    NEWLINE         reduce using rule 11 (expr -> ( expr ) .)
    (               reduce using rule 11 (expr -> ( expr ) .)
    INT_DIV         reduce using rule 11 (expr -> ( expr ) .)
    EQUAL           reduce using rule 11 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 11 (expr -> ( expr ) .)
    |               reduce using rule 11 (expr -> ( expr ) .)
    >               reduce using rule 11 (expr -> ( expr ) .)
    %               reduce using rule 11 (expr -> ( expr ) .)
    <               reduce using rule 11 (expr -> ( expr ) .)
    *               reduce using rule 11 (expr -> ( expr ) .)
    /               reduce using rule 11 (expr -> ( expr ) .)
    -               reduce using rule 11 (expr -> ( expr ) .)
    +               reduce using rule 11 (expr -> ( expr ) .)
    CONCAT          reduce using rule 11 (expr -> ( expr ) .)
    $end            reduce using rule 11 (expr -> ( expr ) .)
    )               reduce using rule 11 (expr -> ( expr ) .)
    OF              reduce using rule 11 (expr -> ( expr ) .)
    THEN            reduce using rule 11 (expr -> ( expr ) .)
    END             reduce using rule 11 (expr -> ( expr ) .)
    ELIF            reduce using rule 11 (expr -> ( expr ) .)
    ELSE            reduce using rule 11 (expr -> ( expr ) .)
    ,               reduce using rule 11 (expr -> ( expr ) .)
    ]               reduce using rule 11 (expr -> ( expr ) .)


state 78

    (177) let -> identifier _50_0x3a_type_optional = . expr
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    identifier                     shift and go to state 11
    expr                           shift and go to state 97
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 79

    (178) _50_0x3a_type_optional -> : type .
    =               reduce using rule 178 (_50_0x3a_type_optional -> : type .)


state 80

    (77) type -> type_identifier . < type _19_0x2c_type_repeat >
    (83) type -> type_identifier .
    <               shift and go to state 98
    =               reduce using rule 83 (type -> type_identifier .)
    NEWLINE         reduce using rule 83 (type -> type_identifier .)
    -               reduce using rule 83 (type -> type_identifier .)
    (               reduce using rule 83 (type -> type_identifier .)
    [               reduce using rule 83 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 83 (type -> type_identifier .)
    CASE            reduce using rule 83 (type -> type_identifier .)
    IF              reduce using rule 83 (type -> type_identifier .)
    DEF             reduce using rule 83 (type -> type_identifier .)
    STRING          reduce using rule 83 (type -> type_identifier .)
    NUMBER          reduce using rule 83 (type -> type_identifier .)
    DO              reduce using rule 83 (type -> type_identifier .)
    EXTERNAL        reduce using rule 83 (type -> type_identifier .)
    ENUM            reduce using rule 83 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 83 (type -> type_identifier .)
    END             reduce using rule 83 (type -> type_identifier .)
    ,               reduce using rule 83 (type -> type_identifier .)
    >               reduce using rule 83 (type -> type_identifier .)
    ELIF            reduce using rule 83 (type -> type_identifier .)
    ELSE            reduce using rule 83 (type -> type_identifier .)
    )               reduce using rule 83 (type -> type_identifier .)


state 81

    (152) array -> [ _41_NEWLINE_optional _42_exprs_optional . ]
    ]               shift and go to state 99


state 82

    (155) _42_exprs_optional -> exprs .
    (170) exprs -> exprs . , _48_NEWLINE_optional expr _49_NEWLINE_optional
    ]               reduce using rule 155 (_42_exprs_optional -> exprs .)
    ,               shift and go to state 100


state 83

    (167) exprs -> expr . _47_NEWLINE_optional
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    (168) _47_NEWLINE_optional -> . NEWLINE
    (169) _47_NEWLINE_optional -> .
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48
    NEWLINE         shift and go to state 102
    ,               reduce using rule 169 (_47_NEWLINE_optional -> .)
    ]               reduce using rule 169 (_47_NEWLINE_optional -> .)
    )               reduce using rule 169 (_47_NEWLINE_optional -> .)

    _47_NEWLINE_optional           shift and go to state 101

state 84

    (162) variant_call -> type_identifier ( _45_NEWLINE_optional . _46_exprs_optional )
    (165) _46_exprs_optional -> . exprs
    (166) _46_exprs_optional -> .
    (167) exprs -> . expr _47_NEWLINE_optional
    (170) exprs -> . exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    )               reduce using rule 166 (_46_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 23
    _46_exprs_optional             shift and go to state 103
    exprs                          shift and go to state 104
    expr                           shift and go to state 83
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21

state 85

    (163) _45_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 163 (_45_NEWLINE_optional -> NEWLINE .)


state 86

    (124) case_of -> CASE expr OF . _32_NEWLINE_optional _33_cases_optional END
    (125) _32_NEWLINE_optional -> . NEWLINE
    (126) _32_NEWLINE_optional -> .
    NEWLINE         shift and go to state 106
    TYPE_IDENTIFIER reduce using rule 126 (_32_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 126 (_32_NEWLINE_optional -> .)
    END             reduce using rule 126 (_32_NEWLINE_optional -> .)

    _32_NEWLINE_optional           shift and go to state 105

state 87

    (115) if_expr -> IF expr THEN . _29_0x3a_type_optional block_statement _30_or_else_optional END
    (116) _29_0x3a_type_optional -> . : type
    (117) _29_0x3a_type_optional -> .
    :               shift and go to state 108
    NEWLINE         reduce using rule 117 (_29_0x3a_type_optional -> .)
    ELIF            reduce using rule 117 (_29_0x3a_type_optional -> .)
    ELSE            reduce using rule 117 (_29_0x3a_type_optional -> .)
    END             reduce using rule 117 (_29_0x3a_type_optional -> .)
    -               reduce using rule 117 (_29_0x3a_type_optional -> .)
    (               reduce using rule 117 (_29_0x3a_type_optional -> .)
    [               reduce using rule 117 (_29_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 117 (_29_0x3a_type_optional -> .)
    CASE            reduce using rule 117 (_29_0x3a_type_optional -> .)
    IF              reduce using rule 117 (_29_0x3a_type_optional -> .)
    DEF             reduce using rule 117 (_29_0x3a_type_optional -> .)
    STRING          reduce using rule 117 (_29_0x3a_type_optional -> .)
    NUMBER          reduce using rule 117 (_29_0x3a_type_optional -> .)
    DO              reduce using rule 117 (_29_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 117 (_29_0x3a_type_optional -> .)
    ENUM            reduce using rule 117 (_29_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 117 (_29_0x3a_type_optional -> .)

    _29_0x3a_type_optional         shift and go to state 107

state 88

    (50) def_expr -> DEF identifier ( . _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (51) _9_NEWLINE_optional -> . NEWLINE
    (52) _9_NEWLINE_optional -> .
    NEWLINE         shift and go to state 110
    IDENTIFIER      reduce using rule 52 (_9_NEWLINE_optional -> .)
    )               reduce using rule 52 (_9_NEWLINE_optional -> .)

    _9_NEWLINE_optional            shift and go to state 109

state 89

    (57) def_expr -> DEF identifier < . type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 111

state 90

    (38) do -> DO _4_0x3a_type_optional _5_NEWLINE_optional . _6_do_exprs_optional END
    (43) _6_do_exprs_optional -> . do_exprs
    (44) _6_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 44 (_6_do_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _6_do_exprs_optional           shift and go to state 112
    do_exprs                       shift and go to state 113
    expr                           shift and go to state 6
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 91

    (41) _5_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 41 (_5_NEWLINE_optional -> NEWLINE .)


state 92

    (39) _4_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    -               reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    (               reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    [               reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    CASE            reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    IF              reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    DEF             reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    STRING          reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    NUMBER          reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    DO              reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 39 (_4_0x3a_type_optional -> : type .)
    END             reduce using rule 39 (_4_0x3a_type_optional -> : type .)


state 93

    (84) enum -> ENUM type_identifier { . _20_NEWLINE_optional _21_variants_optional }
    (85) _20_NEWLINE_optional -> . NEWLINE
    (86) _20_NEWLINE_optional -> .
    NEWLINE         shift and go to state 115
    TYPE_IDENTIFIER reduce using rule 86 (_20_NEWLINE_optional -> .)
    }               reduce using rule 86 (_20_NEWLINE_optional -> .)

    _20_NEWLINE_optional           shift and go to state 114

state 94

    (89) enum -> ENUM type_identifier < . type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 116

state 95

    (157) call -> expr ( _43_NEWLINE_optional _44_exprs_optional . )
    )               shift and go to state 117


state 96

    (160) _44_exprs_optional -> exprs .
    (170) exprs -> exprs . , _48_NEWLINE_optional expr _49_NEWLINE_optional
    )               reduce using rule 160 (_44_exprs_optional -> exprs .)
    ,               shift and go to state 100


state 97

    (177) let -> identifier _50_0x3a_type_optional = expr .
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    $end            reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    )               reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    OF              reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    THEN            reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    END             reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    ELIF            reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    ELSE            reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    ,               reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    ]               reduce using rule 177 (let -> identifier _50_0x3a_type_optional = expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 98

    (77) type -> type_identifier < . type _19_0x2c_type_repeat >
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 80
    type                           shift and go to state 118

state 99

    (152) array -> [ _41_NEWLINE_optional _42_exprs_optional ] .
    NEWLINE         reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    (               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    INT_DIV         reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    EQUAL           reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    NOT_EQUAL       reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    |               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    >               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    %               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    <               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    *               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    /               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    -               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    +               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    CONCAT          reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    $end            reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    )               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    OF              reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    THEN            reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    END             reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    ELIF            reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    ELSE            reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    ,               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)
    ]               reduce using rule 152 (array -> [ _41_NEWLINE_optional _42_exprs_optional ] .)


state 100

    (170) exprs -> exprs , . _48_NEWLINE_optional expr _49_NEWLINE_optional
    (171) _48_NEWLINE_optional -> . NEWLINE
    (172) _48_NEWLINE_optional -> .
    NEWLINE         shift and go to state 120
    -               reduce using rule 172 (_48_NEWLINE_optional -> .)
    (               reduce using rule 172 (_48_NEWLINE_optional -> .)
    [               reduce using rule 172 (_48_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 172 (_48_NEWLINE_optional -> .)
    CASE            reduce using rule 172 (_48_NEWLINE_optional -> .)
    IF              reduce using rule 172 (_48_NEWLINE_optional -> .)
    DEF             reduce using rule 172 (_48_NEWLINE_optional -> .)
    STRING          reduce using rule 172 (_48_NEWLINE_optional -> .)
    NUMBER          reduce using rule 172 (_48_NEWLINE_optional -> .)
    DO              reduce using rule 172 (_48_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 172 (_48_NEWLINE_optional -> .)
    ENUM            reduce using rule 172 (_48_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 172 (_48_NEWLINE_optional -> .)

    _48_NEWLINE_optional           shift and go to state 119

state 101

    (167) exprs -> expr _47_NEWLINE_optional .
    ,               reduce using rule 167 (exprs -> expr _47_NEWLINE_optional .)
    ]               reduce using rule 167 (exprs -> expr _47_NEWLINE_optional .)
    )               reduce using rule 167 (exprs -> expr _47_NEWLINE_optional .)


state 102

    (168) _47_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 168 (_47_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 168 (_47_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 168 (_47_NEWLINE_optional -> NEWLINE .)


state 103

    (162) variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional . )
    )               shift and go to state 121


state 104

    (165) _46_exprs_optional -> exprs .
    (170) exprs -> exprs . , _48_NEWLINE_optional expr _49_NEWLINE_optional
    )               reduce using rule 165 (_46_exprs_optional -> exprs .)
    ,               shift and go to state 100


state 105

    (124) case_of -> CASE expr OF _32_NEWLINE_optional . _33_cases_optional END
    (127) _33_cases_optional -> . cases
    (128) _33_cases_optional -> .
    (129) cases -> . pattern do _34_NEWLINE_optional
    (132) cases -> . cases pattern do _35_NEWLINE_optional
    (135) pattern -> . match_variant
    (136) pattern -> . match_as
    (138) match_variant -> . type_identifier
    (139) match_variant -> . type_identifier ( _36_NEWLINE_optional _37_patterns_optional )
    (137) match_as -> . identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    END             reduce using rule 128 (_33_cases_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 24

    _33_cases_optional             shift and go to state 122
    cases                          shift and go to state 123
    pattern                        shift and go to state 124
    match_variant                  shift and go to state 125
    match_as                       shift and go to state 126
    type_identifier                shift and go to state 127
    identifier                     shift and go to state 128

state 106

    (125) _32_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 125 (_32_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 125 (_32_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 125 (_32_NEWLINE_optional -> NEWLINE .)


state 107

    (115) if_expr -> IF expr THEN _29_0x3a_type_optional . block_statement _30_or_else_optional END
    (45) block_statement -> . _7_NEWLINE_optional _8_do_exprs_optional
    (46) _7_NEWLINE_optional -> . NEWLINE
    (47) _7_NEWLINE_optional -> .
    NEWLINE         shift and go to state 131
    -               reduce using rule 47 (_7_NEWLINE_optional -> .)
    (               reduce using rule 47 (_7_NEWLINE_optional -> .)
    [               reduce using rule 47 (_7_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 47 (_7_NEWLINE_optional -> .)
    CASE            reduce using rule 47 (_7_NEWLINE_optional -> .)
    IF              reduce using rule 47 (_7_NEWLINE_optional -> .)
    DEF             reduce using rule 47 (_7_NEWLINE_optional -> .)
    STRING          reduce using rule 47 (_7_NEWLINE_optional -> .)
    NUMBER          reduce using rule 47 (_7_NEWLINE_optional -> .)
    DO              reduce using rule 47 (_7_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 47 (_7_NEWLINE_optional -> .)
    ENUM            reduce using rule 47 (_7_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 47 (_7_NEWLINE_optional -> .)
    ELIF            reduce using rule 47 (_7_NEWLINE_optional -> .)
    ELSE            reduce using rule 47 (_7_NEWLINE_optional -> .)
    END             reduce using rule 47 (_7_NEWLINE_optional -> .)

    block_statement                shift and go to state 129
    _7_NEWLINE_optional            shift and go to state 130

state 108

    (116) _29_0x3a_type_optional -> : . type
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 132
    type_identifier                shift and go to state 80

state 109

    (50) def_expr -> DEF identifier ( _9_NEWLINE_optional . _10_params_optional ) _11_0x3a_type_optional do
    (53) _10_params_optional -> . params
    (54) _10_params_optional -> .
    (69) params -> . param _16_NEWLINE_optional
    (72) params -> . params , _17_NEWLINE_optional param _18_NEWLINE_optional
    (112) param -> . identifier _28_0x3a_type_optional
    (175) identifier -> . IDENTIFIER
    )               reduce using rule 54 (_10_params_optional -> .)
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 133
    _10_params_optional            shift and go to state 134
    params                         shift and go to state 135
    param                          shift and go to state 136

state 110

    (51) _9_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 51 (_9_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 51 (_9_NEWLINE_optional -> NEWLINE .)


state 111

    (57) def_expr -> DEF identifier < type_identifier . _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (58) _12_0x2c_type_identifier_repeat -> . _12_0x2c_type_identifier_items
    (59) _12_0x2c_type_identifier_repeat -> .
    (60) _12_0x2c_type_identifier_items -> . _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item
    (61) _12_0x2c_type_identifier_items -> . _12_0x2c_type_identifier_item
    (62) _12_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 59 (_12_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 140

    _12_0x2c_type_identifier_repeat shift and go to state 137
    _12_0x2c_type_identifier_items shift and go to state 138
    _12_0x2c_type_identifier_item  shift and go to state 139

state 112

    (38) do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional . END
    END             shift and go to state 141


state 113

    (43) _6_do_exprs_optional -> do_exprs .
    END             reduce using rule 43 (_6_do_exprs_optional -> do_exprs .)


state 114

    (84) enum -> ENUM type_identifier { _20_NEWLINE_optional . _21_variants_optional }
    (87) _21_variants_optional -> . variants
    (88) _21_variants_optional -> .
    (99) variants -> . variant _25_NEWLINE_optional
    (102) variants -> . variants variant _26_NEWLINE_optional
    (105) variant -> . type_identifier
    (106) variant -> . type_identifier ( type _27_0x2c_type_repeat )
    (176) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 88 (_21_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 142
    _21_variants_optional          shift and go to state 143
    variants                       shift and go to state 144
    variant                        shift and go to state 145

state 115

    (85) _20_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 85 (_20_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 85 (_20_NEWLINE_optional -> NEWLINE .)


state 116

    (89) enum -> ENUM type_identifier < type_identifier . _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (90) _22_0x2c_type_identifier_repeat -> . _22_0x2c_type_identifier_items
    (91) _22_0x2c_type_identifier_repeat -> .
    (92) _22_0x2c_type_identifier_items -> . _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item
    (93) _22_0x2c_type_identifier_items -> . _22_0x2c_type_identifier_item
    (94) _22_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 91 (_22_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 149

    _22_0x2c_type_identifier_repeat shift and go to state 146
    _22_0x2c_type_identifier_items shift and go to state 147
    _22_0x2c_type_identifier_item  shift and go to state 148

state 117

    (157) call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .
    NEWLINE         reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    (               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    INT_DIV         reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    EQUAL           reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    |               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    >               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    %               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    <               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    *               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    /               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    -               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    +               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    CONCAT          reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    $end            reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    )               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    OF              reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    THEN            reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    END             reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ELIF            reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ELSE            reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ,               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)
    ]               reduce using rule 157 (call -> expr ( _43_NEWLINE_optional _44_exprs_optional ) .)


state 118

    (77) type -> type_identifier < type . _19_0x2c_type_repeat >
    (78) _19_0x2c_type_repeat -> . _19_0x2c_type_items
    (79) _19_0x2c_type_repeat -> .
    (80) _19_0x2c_type_items -> . _19_0x2c_type_items _19_0x2c_type_item
    (81) _19_0x2c_type_items -> . _19_0x2c_type_item
    (82) _19_0x2c_type_item -> . , type
    >               reduce using rule 79 (_19_0x2c_type_repeat -> .)
    ,               shift and go to state 153

    _19_0x2c_type_repeat           shift and go to state 150
    _19_0x2c_type_items            shift and go to state 151
    _19_0x2c_type_item             shift and go to state 152

state 119

    (170) exprs -> exprs , _48_NEWLINE_optional . expr _49_NEWLINE_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 154
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 120

    (171) _48_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 171 (_48_NEWLINE_optional -> NEWLINE .)


state 121

    (162) variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .
    NEWLINE         reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    (               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    INT_DIV         reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    EQUAL           reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    NOT_EQUAL       reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    |               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    >               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    %               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    <               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    *               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    /               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    -               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    +               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    CONCAT          reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    $end            reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    )               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    OF              reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    THEN            reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    END             reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    ELIF            reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    ELSE            reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    ,               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)
    ]               reduce using rule 162 (variant_call -> type_identifier ( _45_NEWLINE_optional _46_exprs_optional ) .)


state 122

    (124) case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional . END
    END             shift and go to state 155


state 123

    (127) _33_cases_optional -> cases .
    (132) cases -> cases . pattern do _35_NEWLINE_optional
    (135) pattern -> . match_variant
    (136) pattern -> . match_as
    (138) match_variant -> . type_identifier
    (139) match_variant -> . type_identifier ( _36_NEWLINE_optional _37_patterns_optional )
    (137) match_as -> . identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    END             reduce using rule 127 (_33_cases_optional -> cases .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 24

    pattern                        shift and go to state 156
    match_variant                  shift and go to state 125
    match_as                       shift and go to state 126
    type_identifier                shift and go to state 127
    identifier                     shift and go to state 128

state 124

    (129) cases -> pattern . do _34_NEWLINE_optional
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    DO              shift and go to state 30

    do                             shift and go to state 157

state 125

    (135) pattern -> match_variant .
    DO              reduce using rule 135 (pattern -> match_variant .)
    NEWLINE         reduce using rule 135 (pattern -> match_variant .)
    ,               reduce using rule 135 (pattern -> match_variant .)
    )               reduce using rule 135 (pattern -> match_variant .)


state 126

    (136) pattern -> match_as .
    DO              reduce using rule 136 (pattern -> match_as .)
    NEWLINE         reduce using rule 136 (pattern -> match_as .)
    ,               reduce using rule 136 (pattern -> match_as .)
    )               reduce using rule 136 (pattern -> match_as .)


state 127

    (138) match_variant -> type_identifier .
    (139) match_variant -> type_identifier . ( _36_NEWLINE_optional _37_patterns_optional )
    DO              reduce using rule 138 (match_variant -> type_identifier .)
    NEWLINE         reduce using rule 138 (match_variant -> type_identifier .)
    ,               reduce using rule 138 (match_variant -> type_identifier .)
    )               reduce using rule 138 (match_variant -> type_identifier .)
    (               shift and go to state 158


state 128

    (137) match_as -> identifier .
    DO              reduce using rule 137 (match_as -> identifier .)
    NEWLINE         reduce using rule 137 (match_as -> identifier .)
    ,               reduce using rule 137 (match_as -> identifier .)
    )               reduce using rule 137 (match_as -> identifier .)


state 129

    (115) if_expr -> IF expr THEN _29_0x3a_type_optional block_statement . _30_or_else_optional END
    (118) _30_or_else_optional -> . or_else
    (119) _30_or_else_optional -> .
    (120) or_else -> . ELIF expr THEN block_statement _31_or_else_optional
    (123) or_else -> . ELSE block_statement
    END             reduce using rule 119 (_30_or_else_optional -> .)
    ELIF            shift and go to state 161
    ELSE            shift and go to state 162

    _30_or_else_optional           shift and go to state 159
    or_else                        shift and go to state 160

state 130

    (45) block_statement -> _7_NEWLINE_optional . _8_do_exprs_optional
    (48) _8_do_exprs_optional -> . do_exprs
    (49) _8_do_exprs_optional -> .
    (6) do_exprs -> . expr _3_NEWLINE_optional
    (9) do_exprs -> . expr NEWLINE do_exprs
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 49 (_8_do_exprs_optional -> .)
    ELSE            reduce using rule 49 (_8_do_exprs_optional -> .)
    END             reduce using rule 49 (_8_do_exprs_optional -> .)
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _8_do_exprs_optional           shift and go to state 163
    do_exprs                       shift and go to state 164
    expr                           shift and go to state 6
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 131

    (46) _7_NEWLINE_optional -> NEWLINE .
    -               reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    (               reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    [               reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    CASE            reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    IF              reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    DEF             reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    STRING          reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    NUMBER          reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    DO              reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    EXTERNAL        reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    ENUM            reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    TYPE_IDENTIFIER reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    ELIF            reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    ELSE            reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 46 (_7_NEWLINE_optional -> NEWLINE .)


state 132

    (116) _29_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    ELIF            reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    ELSE            reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    END             reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    -               reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    (               reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    [               reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    CASE            reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    IF              reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    DEF             reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    STRING          reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    NUMBER          reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    DO              reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 116 (_29_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 116 (_29_0x3a_type_optional -> : type .)


state 133

    (112) param -> identifier . _28_0x3a_type_optional
    (113) _28_0x3a_type_optional -> . : type
    (114) _28_0x3a_type_optional -> .
    :               shift and go to state 166
    NEWLINE         reduce using rule 114 (_28_0x3a_type_optional -> .)
    ,               reduce using rule 114 (_28_0x3a_type_optional -> .)
    )               reduce using rule 114 (_28_0x3a_type_optional -> .)

    _28_0x3a_type_optional         shift and go to state 165

state 134

    (50) def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional . ) _11_0x3a_type_optional do
    )               shift and go to state 167


state 135

    (53) _10_params_optional -> params .
    (72) params -> params . , _17_NEWLINE_optional param _18_NEWLINE_optional
    )               reduce using rule 53 (_10_params_optional -> params .)
    ,               shift and go to state 168


state 136

    (69) params -> param . _16_NEWLINE_optional
    (70) _16_NEWLINE_optional -> . NEWLINE
    (71) _16_NEWLINE_optional -> .
    NEWLINE         shift and go to state 170
    ,               reduce using rule 71 (_16_NEWLINE_optional -> .)
    )               reduce using rule 71 (_16_NEWLINE_optional -> .)

    _16_NEWLINE_optional           shift and go to state 169

state 137

    (57) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat . > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    >               shift and go to state 171


state 138

    (58) _12_0x2c_type_identifier_repeat -> _12_0x2c_type_identifier_items .
    (60) _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items . _12_0x2c_type_identifier_item
    (62) _12_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 58 (_12_0x2c_type_identifier_repeat -> _12_0x2c_type_identifier_items .)
    ,               shift and go to state 140

    _12_0x2c_type_identifier_item  shift and go to state 172

state 139

    (61) _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_item .
    ,               reduce using rule 61 (_12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_item .)
    >               reduce using rule 61 (_12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_item .)


state 140

    (62) _12_0x2c_type_identifier_item -> , . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 173

state 141

    (38) do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .
    NEWLINE         reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    (               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    INT_DIV         reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    EQUAL           reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    NOT_EQUAL       reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    |               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    >               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    %               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    <               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    *               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    /               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    -               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    +               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    CONCAT          reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    $end            reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    )               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    OF              reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    THEN            reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    END             reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    ELIF            reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    ELSE            reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    ,               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    ]               reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    TYPE_IDENTIFIER reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)
    IDENTIFIER      reduce using rule 38 (do -> DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END .)


state 142

    (105) variant -> type_identifier .
    (106) variant -> type_identifier . ( type _27_0x2c_type_repeat )
    NEWLINE         reduce using rule 105 (variant -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 105 (variant -> type_identifier .)
    }               reduce using rule 105 (variant -> type_identifier .)
    (               shift and go to state 174


state 143

    (84) enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional . }
    }               shift and go to state 175


state 144

    (87) _21_variants_optional -> variants .
    (102) variants -> variants . variant _26_NEWLINE_optional
    (105) variant -> . type_identifier
    (106) variant -> . type_identifier ( type _27_0x2c_type_repeat )
    (176) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 87 (_21_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 33

    variant                        shift and go to state 176
    type_identifier                shift and go to state 142

state 145

    (99) variants -> variant . _25_NEWLINE_optional
    (100) _25_NEWLINE_optional -> . NEWLINE
    (101) _25_NEWLINE_optional -> .
    NEWLINE         shift and go to state 178
    TYPE_IDENTIFIER reduce using rule 101 (_25_NEWLINE_optional -> .)
    }               reduce using rule 101 (_25_NEWLINE_optional -> .)

    _25_NEWLINE_optional           shift and go to state 177

state 146

    (89) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat . > { _23_NEWLINE_optional _24_variants_optional }
    >               shift and go to state 179


state 147

    (90) _22_0x2c_type_identifier_repeat -> _22_0x2c_type_identifier_items .
    (92) _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items . _22_0x2c_type_identifier_item
    (94) _22_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 90 (_22_0x2c_type_identifier_repeat -> _22_0x2c_type_identifier_items .)
    ,               shift and go to state 149

    _22_0x2c_type_identifier_item  shift and go to state 180

state 148

    (93) _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_item .
    ,               reduce using rule 93 (_22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_item .)
    >               reduce using rule 93 (_22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_item .)


state 149

    (94) _22_0x2c_type_identifier_item -> , . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 181

state 150

    (77) type -> type_identifier < type _19_0x2c_type_repeat . >
    >               shift and go to state 182


state 151

    (78) _19_0x2c_type_repeat -> _19_0x2c_type_items .
    (80) _19_0x2c_type_items -> _19_0x2c_type_items . _19_0x2c_type_item
    (82) _19_0x2c_type_item -> . , type
    >               reduce using rule 78 (_19_0x2c_type_repeat -> _19_0x2c_type_items .)
    ,               shift and go to state 153

    _19_0x2c_type_item             shift and go to state 183

state 152

    (81) _19_0x2c_type_items -> _19_0x2c_type_item .
    ,               reduce using rule 81 (_19_0x2c_type_items -> _19_0x2c_type_item .)
    >               reduce using rule 81 (_19_0x2c_type_items -> _19_0x2c_type_item .)


state 153

    (82) _19_0x2c_type_item -> , . type
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 184
    type_identifier                shift and go to state 80

state 154

    (170) exprs -> exprs , _48_NEWLINE_optional expr . _49_NEWLINE_optional
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    (173) _49_NEWLINE_optional -> . NEWLINE
    (174) _49_NEWLINE_optional -> .
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48
    NEWLINE         shift and go to state 186
    ,               reduce using rule 174 (_49_NEWLINE_optional -> .)
    ]               reduce using rule 174 (_49_NEWLINE_optional -> .)
    )               reduce using rule 174 (_49_NEWLINE_optional -> .)

    _49_NEWLINE_optional           shift and go to state 185

state 155

    (124) case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .
    NEWLINE         reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    (               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    INT_DIV         reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    EQUAL           reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    NOT_EQUAL       reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    |               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    >               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    %               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    <               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    *               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    /               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    -               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    +               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    CONCAT          reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    $end            reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    )               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    OF              reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    THEN            reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    END             reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    ELIF            reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    ELSE            reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    ,               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)
    ]               reduce using rule 124 (case_of -> CASE expr OF _32_NEWLINE_optional _33_cases_optional END .)


state 156

    (132) cases -> cases pattern . do _35_NEWLINE_optional
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    DO              shift and go to state 30

    do                             shift and go to state 187

state 157

    (129) cases -> pattern do . _34_NEWLINE_optional
    (130) _34_NEWLINE_optional -> . NEWLINE
    (131) _34_NEWLINE_optional -> .
    NEWLINE         shift and go to state 189
    TYPE_IDENTIFIER reduce using rule 131 (_34_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 131 (_34_NEWLINE_optional -> .)
    END             reduce using rule 131 (_34_NEWLINE_optional -> .)

    _34_NEWLINE_optional           shift and go to state 188

state 158

    (139) match_variant -> type_identifier ( . _36_NEWLINE_optional _37_patterns_optional )
    (140) _36_NEWLINE_optional -> . NEWLINE
    (141) _36_NEWLINE_optional -> .
    NEWLINE         shift and go to state 191
    TYPE_IDENTIFIER reduce using rule 141 (_36_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 141 (_36_NEWLINE_optional -> .)
    )               reduce using rule 141 (_36_NEWLINE_optional -> .)

    _36_NEWLINE_optional           shift and go to state 190

state 159

    (115) if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional . END
    END             shift and go to state 192


state 160

    (118) _30_or_else_optional -> or_else .
    END             reduce using rule 118 (_30_or_else_optional -> or_else .)


state 161

    (120) or_else -> ELIF . expr THEN block_statement _31_or_else_optional
    (10) expr -> . - expr
    (11) expr -> . ( expr )
    (12) expr -> . array
    (13) expr -> . variant_call
    (14) expr -> . identifier
    (15) expr -> . let
    (16) expr -> . call
    (17) expr -> . case_of
    (18) expr -> . binary_expr
    (19) expr -> . if_expr
    (20) expr -> . def_expr
    (21) expr -> . literal
    (22) expr -> . do
    (23) expr -> . external
    (24) expr -> . enum
    (152) array -> . [ _41_NEWLINE_optional _42_exprs_optional ]
    (162) variant_call -> . type_identifier ( _45_NEWLINE_optional _46_exprs_optional )
    (175) identifier -> . IDENTIFIER
    (177) let -> . identifier _50_0x3a_type_optional = expr
    (157) call -> . expr ( _43_NEWLINE_optional _44_exprs_optional )
    (124) case_of -> . CASE expr OF _32_NEWLINE_optional _33_cases_optional END
    (26) binary_expr -> . expr INT_DIV expr
    (27) binary_expr -> . expr EQUAL expr
    (28) binary_expr -> . expr NOT_EQUAL expr
    (29) binary_expr -> . expr | expr
    (30) binary_expr -> . expr > expr
    (31) binary_expr -> . expr % expr
    (32) binary_expr -> . expr < expr
    (33) binary_expr -> . expr * expr
    (34) binary_expr -> . expr / expr
    (35) binary_expr -> . expr - expr
    (36) binary_expr -> . expr + expr
    (37) binary_expr -> . expr CONCAT expr
    (115) if_expr -> . IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END
    (50) def_expr -> . DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do
    (57) def_expr -> . DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (180) literal -> . STRING
    (181) literal -> . NUMBER
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    (25) external -> . EXTERNAL
    (84) enum -> . ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional }
    (89) enum -> . ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional }
    (176) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 7
    (               shift and go to state 8
    [               shift and go to state 22
    IDENTIFIER      shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 193
    array                          shift and go to state 9
    variant_call                   shift and go to state 10
    identifier                     shift and go to state 11
    let                            shift and go to state 12
    call                           shift and go to state 13
    case_of                        shift and go to state 14
    binary_expr                    shift and go to state 15
    if_expr                        shift and go to state 16
    def_expr                       shift and go to state 17
    literal                        shift and go to state 18
    do                             shift and go to state 19
    external                       shift and go to state 20
    enum                           shift and go to state 21
    type_identifier                shift and go to state 23

state 162

    (123) or_else -> ELSE . block_statement
    (45) block_statement -> . _7_NEWLINE_optional _8_do_exprs_optional
    (46) _7_NEWLINE_optional -> . NEWLINE
    (47) _7_NEWLINE_optional -> .
    NEWLINE         shift and go to state 131
    -               reduce using rule 47 (_7_NEWLINE_optional -> .)
    (               reduce using rule 47 (_7_NEWLINE_optional -> .)
    [               reduce using rule 47 (_7_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 47 (_7_NEWLINE_optional -> .)
    CASE            reduce using rule 47 (_7_NEWLINE_optional -> .)
    IF              reduce using rule 47 (_7_NEWLINE_optional -> .)
    DEF             reduce using rule 47 (_7_NEWLINE_optional -> .)
    STRING          reduce using rule 47 (_7_NEWLINE_optional -> .)
    NUMBER          reduce using rule 47 (_7_NEWLINE_optional -> .)
    DO              reduce using rule 47 (_7_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 47 (_7_NEWLINE_optional -> .)
    ENUM            reduce using rule 47 (_7_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 47 (_7_NEWLINE_optional -> .)
    END             reduce using rule 47 (_7_NEWLINE_optional -> .)

    block_statement                shift and go to state 194
    _7_NEWLINE_optional            shift and go to state 130

state 163

    (45) block_statement -> _7_NEWLINE_optional _8_do_exprs_optional .
    ELIF            reduce using rule 45 (block_statement -> _7_NEWLINE_optional _8_do_exprs_optional .)
    ELSE            reduce using rule 45 (block_statement -> _7_NEWLINE_optional _8_do_exprs_optional .)
    END             reduce using rule 45 (block_statement -> _7_NEWLINE_optional _8_do_exprs_optional .)


state 164

    (48) _8_do_exprs_optional -> do_exprs .
    ELIF            reduce using rule 48 (_8_do_exprs_optional -> do_exprs .)
    ELSE            reduce using rule 48 (_8_do_exprs_optional -> do_exprs .)
    END             reduce using rule 48 (_8_do_exprs_optional -> do_exprs .)


state 165

    (112) param -> identifier _28_0x3a_type_optional .
    NEWLINE         reduce using rule 112 (param -> identifier _28_0x3a_type_optional .)
    ,               reduce using rule 112 (param -> identifier _28_0x3a_type_optional .)
    )               reduce using rule 112 (param -> identifier _28_0x3a_type_optional .)


state 166

    (113) _28_0x3a_type_optional -> : . type
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 195
    type_identifier                shift and go to state 80

state 167

    (50) def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) . _11_0x3a_type_optional do
    (55) _11_0x3a_type_optional -> . : type
    (56) _11_0x3a_type_optional -> .
    :               shift and go to state 197
    DO              reduce using rule 56 (_11_0x3a_type_optional -> .)

    _11_0x3a_type_optional         shift and go to state 196

state 168

    (72) params -> params , . _17_NEWLINE_optional param _18_NEWLINE_optional
    (73) _17_NEWLINE_optional -> . NEWLINE
    (74) _17_NEWLINE_optional -> .
    NEWLINE         shift and go to state 199
    IDENTIFIER      reduce using rule 74 (_17_NEWLINE_optional -> .)

    _17_NEWLINE_optional           shift and go to state 198

state 169

    (69) params -> param _16_NEWLINE_optional .
    ,               reduce using rule 69 (params -> param _16_NEWLINE_optional .)
    )               reduce using rule 69 (params -> param _16_NEWLINE_optional .)


state 170

    (70) _16_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 70 (_16_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 70 (_16_NEWLINE_optional -> NEWLINE .)


state 171

    (57) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > . ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (               shift and go to state 200


state 172

    (60) _12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item .
    ,               reduce using rule 60 (_12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item .)
    >               reduce using rule 60 (_12_0x2c_type_identifier_items -> _12_0x2c_type_identifier_items _12_0x2c_type_identifier_item .)


state 173

    (62) _12_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 62 (_12_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 62 (_12_0x2c_type_identifier_item -> , type_identifier .)


state 174

    (106) variant -> type_identifier ( . type _27_0x2c_type_repeat )
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 80
    type                           shift and go to state 201

state 175

    (84) enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .
    NEWLINE         reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    (               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    INT_DIV         reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    EQUAL           reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    NOT_EQUAL       reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    |               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    >               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    %               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    <               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    *               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    /               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    -               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    +               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    CONCAT          reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    $end            reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    )               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    OF              reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    THEN            reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    END             reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    ELIF            reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    ELSE            reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    ,               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)
    ]               reduce using rule 84 (enum -> ENUM type_identifier { _20_NEWLINE_optional _21_variants_optional } .)


state 176

    (102) variants -> variants variant . _26_NEWLINE_optional
    (103) _26_NEWLINE_optional -> . NEWLINE
    (104) _26_NEWLINE_optional -> .
    NEWLINE         shift and go to state 203
    TYPE_IDENTIFIER reduce using rule 104 (_26_NEWLINE_optional -> .)
    }               reduce using rule 104 (_26_NEWLINE_optional -> .)

    _26_NEWLINE_optional           shift and go to state 202

state 177

    (99) variants -> variant _25_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 99 (variants -> variant _25_NEWLINE_optional .)
    }               reduce using rule 99 (variants -> variant _25_NEWLINE_optional .)


state 178

    (100) _25_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 100 (_25_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 100 (_25_NEWLINE_optional -> NEWLINE .)


state 179

    (89) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > . { _23_NEWLINE_optional _24_variants_optional }
    {               shift and go to state 204


state 180

    (92) _22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item .
    ,               reduce using rule 92 (_22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item .)
    >               reduce using rule 92 (_22_0x2c_type_identifier_items -> _22_0x2c_type_identifier_items _22_0x2c_type_identifier_item .)


state 181

    (94) _22_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 94 (_22_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 94 (_22_0x2c_type_identifier_item -> , type_identifier .)


state 182

    (77) type -> type_identifier < type _19_0x2c_type_repeat > .
    =               reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    NEWLINE         reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    -               reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    (               reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    [               reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    IDENTIFIER      reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    CASE            reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    IF              reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    DEF             reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    STRING          reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    NUMBER          reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    DO              reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    EXTERNAL        reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    ENUM            reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    TYPE_IDENTIFIER reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    END             reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    ,               reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    >               reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    ELIF            reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    ELSE            reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)
    )               reduce using rule 77 (type -> type_identifier < type _19_0x2c_type_repeat > .)


state 183

    (80) _19_0x2c_type_items -> _19_0x2c_type_items _19_0x2c_type_item .
    ,               reduce using rule 80 (_19_0x2c_type_items -> _19_0x2c_type_items _19_0x2c_type_item .)
    >               reduce using rule 80 (_19_0x2c_type_items -> _19_0x2c_type_items _19_0x2c_type_item .)


state 184

    (82) _19_0x2c_type_item -> , type .
    ,               reduce using rule 82 (_19_0x2c_type_item -> , type .)
    >               reduce using rule 82 (_19_0x2c_type_item -> , type .)


state 185

    (170) exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional .
    ,               reduce using rule 170 (exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional .)
    ]               reduce using rule 170 (exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional .)
    )               reduce using rule 170 (exprs -> exprs , _48_NEWLINE_optional expr _49_NEWLINE_optional .)


state 186

    (173) _49_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 173 (_49_NEWLINE_optional -> NEWLINE .)
    ]               reduce using rule 173 (_49_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 173 (_49_NEWLINE_optional -> NEWLINE .)


state 187

    (132) cases -> cases pattern do . _35_NEWLINE_optional
    (133) _35_NEWLINE_optional -> . NEWLINE
    (134) _35_NEWLINE_optional -> .
    NEWLINE         shift and go to state 206
    TYPE_IDENTIFIER reduce using rule 134 (_35_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 134 (_35_NEWLINE_optional -> .)
    END             reduce using rule 134 (_35_NEWLINE_optional -> .)

    _35_NEWLINE_optional           shift and go to state 205

state 188

    (129) cases -> pattern do _34_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 129 (cases -> pattern do _34_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 129 (cases -> pattern do _34_NEWLINE_optional .)
    END             reduce using rule 129 (cases -> pattern do _34_NEWLINE_optional .)


state 189

    (130) _34_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 130 (_34_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 130 (_34_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 130 (_34_NEWLINE_optional -> NEWLINE .)


state 190

    (139) match_variant -> type_identifier ( _36_NEWLINE_optional . _37_patterns_optional )
    (142) _37_patterns_optional -> . patterns
    (143) _37_patterns_optional -> .
    (144) patterns -> . pattern _38_NEWLINE_optional
    (147) patterns -> . patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional
    (135) pattern -> . match_variant
    (136) pattern -> . match_as
    (138) match_variant -> . type_identifier
    (139) match_variant -> . type_identifier ( _36_NEWLINE_optional _37_patterns_optional )
    (137) match_as -> . identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    )               reduce using rule 143 (_37_patterns_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 24

    type_identifier                shift and go to state 127
    _37_patterns_optional          shift and go to state 207
    patterns                       shift and go to state 208
    pattern                        shift and go to state 209
    match_variant                  shift and go to state 125
    match_as                       shift and go to state 126
    identifier                     shift and go to state 128

state 191

    (140) _36_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 140 (_36_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 140 (_36_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 140 (_36_NEWLINE_optional -> NEWLINE .)


state 192

    (115) if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .
    NEWLINE         reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    (               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    INT_DIV         reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    EQUAL           reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    NOT_EQUAL       reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    |               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    >               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    %               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    <               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    *               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    /               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    -               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    +               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    CONCAT          reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    $end            reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    )               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    OF              reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    THEN            reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    END             reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    ELIF            reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    ELSE            reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    ,               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)
    ]               reduce using rule 115 (if_expr -> IF expr THEN _29_0x3a_type_optional block_statement _30_or_else_optional END .)


state 193

    (120) or_else -> ELIF expr . THEN block_statement _31_or_else_optional
    (157) call -> expr . ( _43_NEWLINE_optional _44_exprs_optional )
    (26) binary_expr -> expr . INT_DIV expr
    (27) binary_expr -> expr . EQUAL expr
    (28) binary_expr -> expr . NOT_EQUAL expr
    (29) binary_expr -> expr . | expr
    (30) binary_expr -> expr . > expr
    (31) binary_expr -> expr . % expr
    (32) binary_expr -> expr . < expr
    (33) binary_expr -> expr . * expr
    (34) binary_expr -> expr . / expr
    (35) binary_expr -> expr . - expr
    (36) binary_expr -> expr . + expr
    (37) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 210
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    EQUAL           shift and go to state 38
    NOT_EQUAL       shift and go to state 39
    |               shift and go to state 40
    >               shift and go to state 41
    %               shift and go to state 42
    <               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    -               shift and go to state 46
    +               shift and go to state 47
    CONCAT          shift and go to state 48


state 194

    (123) or_else -> ELSE block_statement .
    END             reduce using rule 123 (or_else -> ELSE block_statement .)


state 195

    (113) _28_0x3a_type_optional -> : type .
    NEWLINE         reduce using rule 113 (_28_0x3a_type_optional -> : type .)
    ,               reduce using rule 113 (_28_0x3a_type_optional -> : type .)
    )               reduce using rule 113 (_28_0x3a_type_optional -> : type .)


state 196

    (50) def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional . do
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    DO              shift and go to state 30

    do                             shift and go to state 211

state 197

    (55) _11_0x3a_type_optional -> : . type
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 212
    type_identifier                shift and go to state 80

state 198

    (72) params -> params , _17_NEWLINE_optional . param _18_NEWLINE_optional
    (112) param -> . identifier _28_0x3a_type_optional
    (175) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 24

    param                          shift and go to state 213
    identifier                     shift and go to state 133

state 199

    (73) _17_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 73 (_17_NEWLINE_optional -> NEWLINE .)


state 200

    (57) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( . _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do
    (63) _13_NEWLINE_optional -> . NEWLINE
    (64) _13_NEWLINE_optional -> .
    NEWLINE         shift and go to state 215
    IDENTIFIER      reduce using rule 64 (_13_NEWLINE_optional -> .)
    )               reduce using rule 64 (_13_NEWLINE_optional -> .)

    _13_NEWLINE_optional           shift and go to state 214

state 201

    (106) variant -> type_identifier ( type . _27_0x2c_type_repeat )
    (107) _27_0x2c_type_repeat -> . _27_0x2c_type_items
    (108) _27_0x2c_type_repeat -> .
    (109) _27_0x2c_type_items -> . _27_0x2c_type_items _27_0x2c_type_item
    (110) _27_0x2c_type_items -> . _27_0x2c_type_item
    (111) _27_0x2c_type_item -> . , type
    )               reduce using rule 108 (_27_0x2c_type_repeat -> .)
    ,               shift and go to state 219

    _27_0x2c_type_repeat           shift and go to state 216
    _27_0x2c_type_items            shift and go to state 217
    _27_0x2c_type_item             shift and go to state 218

state 202

    (102) variants -> variants variant _26_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 102 (variants -> variants variant _26_NEWLINE_optional .)
    }               reduce using rule 102 (variants -> variants variant _26_NEWLINE_optional .)


state 203

    (103) _26_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 103 (_26_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 103 (_26_NEWLINE_optional -> NEWLINE .)


state 204

    (89) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { . _23_NEWLINE_optional _24_variants_optional }
    (95) _23_NEWLINE_optional -> . NEWLINE
    (96) _23_NEWLINE_optional -> .
    NEWLINE         shift and go to state 221
    TYPE_IDENTIFIER reduce using rule 96 (_23_NEWLINE_optional -> .)
    }               reduce using rule 96 (_23_NEWLINE_optional -> .)

    _23_NEWLINE_optional           shift and go to state 220

state 205

    (132) cases -> cases pattern do _35_NEWLINE_optional .
    TYPE_IDENTIFIER reduce using rule 132 (cases -> cases pattern do _35_NEWLINE_optional .)
    IDENTIFIER      reduce using rule 132 (cases -> cases pattern do _35_NEWLINE_optional .)
    END             reduce using rule 132 (cases -> cases pattern do _35_NEWLINE_optional .)


state 206

    (133) _35_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 133 (_35_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 133 (_35_NEWLINE_optional -> NEWLINE .)
    END             reduce using rule 133 (_35_NEWLINE_optional -> NEWLINE .)


state 207

    (139) match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional . )
    )               shift and go to state 222


state 208

    (142) _37_patterns_optional -> patterns .
    (147) patterns -> patterns . , _39_NEWLINE_optional pattern _40_NEWLINE_optional
    )               reduce using rule 142 (_37_patterns_optional -> patterns .)
    ,               shift and go to state 223


state 209

    (144) patterns -> pattern . _38_NEWLINE_optional
    (145) _38_NEWLINE_optional -> . NEWLINE
    (146) _38_NEWLINE_optional -> .
    NEWLINE         shift and go to state 225
    ,               reduce using rule 146 (_38_NEWLINE_optional -> .)
    )               reduce using rule 146 (_38_NEWLINE_optional -> .)

    _38_NEWLINE_optional           shift and go to state 224

state 210

    (120) or_else -> ELIF expr THEN . block_statement _31_or_else_optional
    (45) block_statement -> . _7_NEWLINE_optional _8_do_exprs_optional
    (46) _7_NEWLINE_optional -> . NEWLINE
    (47) _7_NEWLINE_optional -> .
    NEWLINE         shift and go to state 131
    -               reduce using rule 47 (_7_NEWLINE_optional -> .)
    (               reduce using rule 47 (_7_NEWLINE_optional -> .)
    [               reduce using rule 47 (_7_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 47 (_7_NEWLINE_optional -> .)
    CASE            reduce using rule 47 (_7_NEWLINE_optional -> .)
    IF              reduce using rule 47 (_7_NEWLINE_optional -> .)
    DEF             reduce using rule 47 (_7_NEWLINE_optional -> .)
    STRING          reduce using rule 47 (_7_NEWLINE_optional -> .)
    NUMBER          reduce using rule 47 (_7_NEWLINE_optional -> .)
    DO              reduce using rule 47 (_7_NEWLINE_optional -> .)
    EXTERNAL        reduce using rule 47 (_7_NEWLINE_optional -> .)
    ENUM            reduce using rule 47 (_7_NEWLINE_optional -> .)
    TYPE_IDENTIFIER reduce using rule 47 (_7_NEWLINE_optional -> .)
    ELIF            reduce using rule 47 (_7_NEWLINE_optional -> .)
    ELSE            reduce using rule 47 (_7_NEWLINE_optional -> .)
    END             reduce using rule 47 (_7_NEWLINE_optional -> .)

    block_statement                shift and go to state 226
    _7_NEWLINE_optional            shift and go to state 130

state 211

    (50) def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .
    NEWLINE         reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    (               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    INT_DIV         reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    EQUAL           reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    |               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    >               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    %               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    <               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    *               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    /               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    -               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    +               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    CONCAT          reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    $end            reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    )               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    OF              reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    THEN            reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    END             reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    ELIF            reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    ELSE            reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    ,               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)
    ]               reduce using rule 50 (def_expr -> DEF identifier ( _9_NEWLINE_optional _10_params_optional ) _11_0x3a_type_optional do .)


state 212

    (55) _11_0x3a_type_optional -> : type .
    DO              reduce using rule 55 (_11_0x3a_type_optional -> : type .)


state 213

    (72) params -> params , _17_NEWLINE_optional param . _18_NEWLINE_optional
    (75) _18_NEWLINE_optional -> . NEWLINE
    (76) _18_NEWLINE_optional -> .
    NEWLINE         shift and go to state 228
    ,               reduce using rule 76 (_18_NEWLINE_optional -> .)
    )               reduce using rule 76 (_18_NEWLINE_optional -> .)

    _18_NEWLINE_optional           shift and go to state 227

state 214

    (57) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional . _14_params_optional ) _15_0x3a_type_optional do
    (65) _14_params_optional -> . params
    (66) _14_params_optional -> .
    (69) params -> . param _16_NEWLINE_optional
    (72) params -> . params , _17_NEWLINE_optional param _18_NEWLINE_optional
    (112) param -> . identifier _28_0x3a_type_optional
    (175) identifier -> . IDENTIFIER
    )               reduce using rule 66 (_14_params_optional -> .)
    IDENTIFIER      shift and go to state 24

    identifier                     shift and go to state 133
    _14_params_optional            shift and go to state 229
    params                         shift and go to state 230
    param                          shift and go to state 136

state 215

    (63) _13_NEWLINE_optional -> NEWLINE .
    IDENTIFIER      reduce using rule 63 (_13_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 63 (_13_NEWLINE_optional -> NEWLINE .)


state 216

    (106) variant -> type_identifier ( type _27_0x2c_type_repeat . )
    )               shift and go to state 231


state 217

    (107) _27_0x2c_type_repeat -> _27_0x2c_type_items .
    (109) _27_0x2c_type_items -> _27_0x2c_type_items . _27_0x2c_type_item
    (111) _27_0x2c_type_item -> . , type
    )               reduce using rule 107 (_27_0x2c_type_repeat -> _27_0x2c_type_items .)
    ,               shift and go to state 219

    _27_0x2c_type_item             shift and go to state 232

state 218

    (110) _27_0x2c_type_items -> _27_0x2c_type_item .
    ,               reduce using rule 110 (_27_0x2c_type_items -> _27_0x2c_type_item .)
    )               reduce using rule 110 (_27_0x2c_type_items -> _27_0x2c_type_item .)


state 219

    (111) _27_0x2c_type_item -> , . type
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 233
    type_identifier                shift and go to state 80

state 220

    (89) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional . _24_variants_optional }
    (97) _24_variants_optional -> . variants
    (98) _24_variants_optional -> .
    (99) variants -> . variant _25_NEWLINE_optional
    (102) variants -> . variants variant _26_NEWLINE_optional
    (105) variant -> . type_identifier
    (106) variant -> . type_identifier ( type _27_0x2c_type_repeat )
    (176) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 98 (_24_variants_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 142
    _24_variants_optional          shift and go to state 234
    variants                       shift and go to state 235
    variant                        shift and go to state 145

state 221

    (95) _23_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 95 (_23_NEWLINE_optional -> NEWLINE .)
    }               reduce using rule 95 (_23_NEWLINE_optional -> NEWLINE .)


state 222

    (139) match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .
    DO              reduce using rule 139 (match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .)
    NEWLINE         reduce using rule 139 (match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .)
    ,               reduce using rule 139 (match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .)
    )               reduce using rule 139 (match_variant -> type_identifier ( _36_NEWLINE_optional _37_patterns_optional ) .)


state 223

    (147) patterns -> patterns , . _39_NEWLINE_optional pattern _40_NEWLINE_optional
    (148) _39_NEWLINE_optional -> . NEWLINE
    (149) _39_NEWLINE_optional -> .
    NEWLINE         shift and go to state 237
    TYPE_IDENTIFIER reduce using rule 149 (_39_NEWLINE_optional -> .)
    IDENTIFIER      reduce using rule 149 (_39_NEWLINE_optional -> .)

    _39_NEWLINE_optional           shift and go to state 236

state 224

    (144) patterns -> pattern _38_NEWLINE_optional .
    ,               reduce using rule 144 (patterns -> pattern _38_NEWLINE_optional .)
    )               reduce using rule 144 (patterns -> pattern _38_NEWLINE_optional .)


state 225

    (145) _38_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 145 (_38_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 145 (_38_NEWLINE_optional -> NEWLINE .)


state 226

    (120) or_else -> ELIF expr THEN block_statement . _31_or_else_optional
    (121) _31_or_else_optional -> . or_else
    (122) _31_or_else_optional -> .
    (120) or_else -> . ELIF expr THEN block_statement _31_or_else_optional
    (123) or_else -> . ELSE block_statement
    END             reduce using rule 122 (_31_or_else_optional -> .)
    ELIF            shift and go to state 161
    ELSE            shift and go to state 162

    _31_or_else_optional           shift and go to state 238
    or_else                        shift and go to state 239

state 227

    (72) params -> params , _17_NEWLINE_optional param _18_NEWLINE_optional .
    ,               reduce using rule 72 (params -> params , _17_NEWLINE_optional param _18_NEWLINE_optional .)
    )               reduce using rule 72 (params -> params , _17_NEWLINE_optional param _18_NEWLINE_optional .)


state 228

    (75) _18_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 75 (_18_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 75 (_18_NEWLINE_optional -> NEWLINE .)


state 229

    (57) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional . ) _15_0x3a_type_optional do
    )               shift and go to state 240


state 230

    (65) _14_params_optional -> params .
    (72) params -> params . , _17_NEWLINE_optional param _18_NEWLINE_optional
    )               reduce using rule 65 (_14_params_optional -> params .)
    ,               shift and go to state 168


state 231

    (106) variant -> type_identifier ( type _27_0x2c_type_repeat ) .
    NEWLINE         reduce using rule 106 (variant -> type_identifier ( type _27_0x2c_type_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 106 (variant -> type_identifier ( type _27_0x2c_type_repeat ) .)
    }               reduce using rule 106 (variant -> type_identifier ( type _27_0x2c_type_repeat ) .)


state 232

    (109) _27_0x2c_type_items -> _27_0x2c_type_items _27_0x2c_type_item .
    ,               reduce using rule 109 (_27_0x2c_type_items -> _27_0x2c_type_items _27_0x2c_type_item .)
    )               reduce using rule 109 (_27_0x2c_type_items -> _27_0x2c_type_items _27_0x2c_type_item .)


state 233

    (111) _27_0x2c_type_item -> , type .
    ,               reduce using rule 111 (_27_0x2c_type_item -> , type .)
    )               reduce using rule 111 (_27_0x2c_type_item -> , type .)


state 234

    (89) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional . }
    }               shift and go to state 241


state 235

    (97) _24_variants_optional -> variants .
    (102) variants -> variants . variant _26_NEWLINE_optional
    (105) variant -> . type_identifier
    (106) variant -> . type_identifier ( type _27_0x2c_type_repeat )
    (176) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 97 (_24_variants_optional -> variants .)
    TYPE_IDENTIFIER shift and go to state 33

    variant                        shift and go to state 176
    type_identifier                shift and go to state 142

state 236

    (147) patterns -> patterns , _39_NEWLINE_optional . pattern _40_NEWLINE_optional
    (135) pattern -> . match_variant
    (136) pattern -> . match_as
    (138) match_variant -> . type_identifier
    (139) match_variant -> . type_identifier ( _36_NEWLINE_optional _37_patterns_optional )
    (137) match_as -> . identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    (175) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 24

    pattern                        shift and go to state 242
    match_variant                  shift and go to state 125
    match_as                       shift and go to state 126
    type_identifier                shift and go to state 127
    identifier                     shift and go to state 128

state 237

    (148) _39_NEWLINE_optional -> NEWLINE .
    TYPE_IDENTIFIER reduce using rule 148 (_39_NEWLINE_optional -> NEWLINE .)
    IDENTIFIER      reduce using rule 148 (_39_NEWLINE_optional -> NEWLINE .)


state 238

    (120) or_else -> ELIF expr THEN block_statement _31_or_else_optional .
    END             reduce using rule 120 (or_else -> ELIF expr THEN block_statement _31_or_else_optional .)


state 239

    (121) _31_or_else_optional -> or_else .
    END             reduce using rule 121 (_31_or_else_optional -> or_else .)


state 240

    (57) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) . _15_0x3a_type_optional do
    (67) _15_0x3a_type_optional -> . : type
    (68) _15_0x3a_type_optional -> .
    :               shift and go to state 244
    DO              reduce using rule 68 (_15_0x3a_type_optional -> .)

    _15_0x3a_type_optional         shift and go to state 243

state 241

    (89) enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .
    NEWLINE         reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    (               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    INT_DIV         reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    EQUAL           reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    NOT_EQUAL       reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    |               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    >               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    %               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    <               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    *               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    /               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    -               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    +               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    CONCAT          reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    $end            reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    )               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    OF              reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    THEN            reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    END             reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    ELIF            reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    ELSE            reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    ,               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)
    ]               reduce using rule 89 (enum -> ENUM type_identifier < type_identifier _22_0x2c_type_identifier_repeat > { _23_NEWLINE_optional _24_variants_optional } .)


state 242

    (147) patterns -> patterns , _39_NEWLINE_optional pattern . _40_NEWLINE_optional
    (150) _40_NEWLINE_optional -> . NEWLINE
    (151) _40_NEWLINE_optional -> .
    NEWLINE         shift and go to state 246
    ,               reduce using rule 151 (_40_NEWLINE_optional -> .)
    )               reduce using rule 151 (_40_NEWLINE_optional -> .)

    _40_NEWLINE_optional           shift and go to state 245

state 243

    (57) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional . do
    (38) do -> . DO _4_0x3a_type_optional _5_NEWLINE_optional _6_do_exprs_optional END
    DO              shift and go to state 30

    do                             shift and go to state 247

state 244

    (67) _15_0x3a_type_optional -> : . type
    (77) type -> . type_identifier < type _19_0x2c_type_repeat >
    (83) type -> . type_identifier
    (176) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 248
    type_identifier                shift and go to state 80

state 245

    (147) patterns -> patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional .
    ,               reduce using rule 147 (patterns -> patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional .)
    )               reduce using rule 147 (patterns -> patterns , _39_NEWLINE_optional pattern _40_NEWLINE_optional .)


state 246

    (150) _40_NEWLINE_optional -> NEWLINE .
    ,               reduce using rule 150 (_40_NEWLINE_optional -> NEWLINE .)
    )               reduce using rule 150 (_40_NEWLINE_optional -> NEWLINE .)


state 247

    (57) def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .
    NEWLINE         reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    (               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    INT_DIV         reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    EQUAL           reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    NOT_EQUAL       reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    |               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    >               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    %               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    <               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    *               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    /               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    -               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    +               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    CONCAT          reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    $end            reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    )               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    OF              reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    THEN            reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    END             reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    ELIF            reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    ELSE            reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    ,               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)
    ]               reduce using rule 57 (def_expr -> DEF identifier < type_identifier _12_0x2c_type_identifier_repeat > ( _13_NEWLINE_optional _14_params_optional ) _15_0x3a_type_optional do .)


state 248

    (67) _15_0x3a_type_optional -> : type .
    DO              reduce using rule 67 (_15_0x3a_type_optional -> : type .)
