Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_expr_repeat
Rule 2     _1_expr_repeat -> _1_expr_items
Rule 3     _1_expr_repeat -> <empty>
Rule 4     _1_expr_items -> _1_expr_items _1_expr_item
Rule 5     _1_expr_items -> _1_expr_item
Rule 6     _1_expr_item -> expr
Rule 7     expr -> - expr  [precedence=right, level=6]
Rule 8     expr -> ( expr )  [precedence=left, level=7]
Rule 9     expr -> array
Rule 10    expr -> variant_call
Rule 11    expr -> identifier
Rule 12    expr -> variable_declaration
Rule 13    expr -> call
Rule 14    expr -> case_of
Rule 15    expr -> binary_expr
Rule 16    expr -> if_expr
Rule 17    expr -> def_expr
Rule 18    expr -> literal
Rule 19    expr -> do
Rule 20    expr -> external
Rule 21    expr -> enum
Rule 22    external -> EXTERNAL
Rule 23    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 24    binary_expr -> expr NUM_NOT_EQUAL expr  [precedence=left, level=2]
Rule 25    binary_expr -> expr | expr  [precedence=left, level=4]
Rule 26    binary_expr -> expr > expr  [precedence=left, level=3]
Rule 27    binary_expr -> expr % expr  [precedence=left, level=5]
Rule 28    binary_expr -> expr < expr  [precedence=left, level=3]
Rule 29    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 30    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 31    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 32    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 33    binary_expr -> expr CONCAT expr  [precedence=left, level=4]
Rule 34    do -> DO _2_0x3a_type_optional _3_expr_repeat END
Rule 35    _2_0x3a_type_optional -> : type
Rule 36    _2_0x3a_type_optional -> <empty>
Rule 37    _3_expr_repeat -> _3_expr_items
Rule 38    _3_expr_repeat -> <empty>
Rule 39    _3_expr_items -> _3_expr_items _3_expr_item
Rule 40    _3_expr_items -> _3_expr_item
Rule 41    _3_expr_item -> expr
Rule 42    block_statement -> _4_expr_repeat
Rule 43    _4_expr_repeat -> _4_expr_items
Rule 44    _4_expr_repeat -> <empty>
Rule 45    _4_expr_items -> _4_expr_items _4_expr_item
Rule 46    _4_expr_items -> _4_expr_item
Rule 47    _4_expr_item -> expr
Rule 48    def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do  [precedence=left, level=7]
Rule 49    _5_param_optional -> param
Rule 50    _5_param_optional -> <empty>
Rule 51    _6_0x2c_param_repeat -> _6_0x2c_param_items
Rule 52    _6_0x2c_param_repeat -> <empty>
Rule 53    _6_0x2c_param_items -> _6_0x2c_param_items _6_0x2c_param_item
Rule 54    _6_0x2c_param_items -> _6_0x2c_param_item
Rule 55    _6_0x2c_param_item -> , param
Rule 56    _7_0x3a_type_optional -> : type
Rule 57    _7_0x3a_type_optional -> <empty>
Rule 58    def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do  [precedence=left, level=7]
Rule 59    _8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items
Rule 60    _8_0x2c_type_identifier_repeat -> <empty>
Rule 61    _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item
Rule 62    _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item
Rule 63    _8_0x2c_type_identifier_item -> , type_identifier
Rule 64    _9_param_optional -> param
Rule 65    _9_param_optional -> <empty>
Rule 66    _10_0x2c_param_repeat -> _10_0x2c_param_items
Rule 67    _10_0x2c_param_repeat -> <empty>
Rule 68    _10_0x2c_param_items -> _10_0x2c_param_items _10_0x2c_param_item
Rule 69    _10_0x2c_param_items -> _10_0x2c_param_item
Rule 70    _10_0x2c_param_item -> , param
Rule 71    _11_0x3a_type_optional -> : type
Rule 72    _11_0x3a_type_optional -> <empty>
Rule 73    type -> type_identifier < type _12_0x2c_type_repeat >  [precedence=left, level=3]
Rule 74    _12_0x2c_type_repeat -> _12_0x2c_type_items
Rule 75    _12_0x2c_type_repeat -> <empty>
Rule 76    _12_0x2c_type_items -> _12_0x2c_type_items _12_0x2c_type_item
Rule 77    _12_0x2c_type_items -> _12_0x2c_type_item
Rule 78    _12_0x2c_type_item -> , type
Rule 79    type -> type_identifier
Rule 80    enum -> ENUM type_identifier { _13_variant_repeat }
Rule 81    _13_variant_repeat -> _13_variant_items
Rule 82    _13_variant_repeat -> <empty>
Rule 83    _13_variant_items -> _13_variant_items _13_variant_item
Rule 84    _13_variant_items -> _13_variant_item
Rule 85    _13_variant_item -> variant
Rule 86    enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
Rule 87    _14_0x2c_type_identifier_repeat -> _14_0x2c_type_identifier_items
Rule 88    _14_0x2c_type_identifier_repeat -> <empty>
Rule 89    _14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_items _14_0x2c_type_identifier_item
Rule 90    _14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_item
Rule 91    _14_0x2c_type_identifier_item -> , type_identifier
Rule 92    _15_variant_repeat -> _15_variant_items
Rule 93    _15_variant_repeat -> <empty>
Rule 94    _15_variant_items -> _15_variant_items _15_variant_item
Rule 95    _15_variant_items -> _15_variant_item
Rule 96    _15_variant_item -> variant
Rule 97    variant -> type_identifier
Rule 98    variant -> type_identifier ( type _16_0x2c_type_repeat )  [precedence=left, level=7]
Rule 99    _16_0x2c_type_repeat -> _16_0x2c_type_items
Rule 100   _16_0x2c_type_repeat -> <empty>
Rule 101   _16_0x2c_type_items -> _16_0x2c_type_items _16_0x2c_type_item
Rule 102   _16_0x2c_type_items -> _16_0x2c_type_item
Rule 103   _16_0x2c_type_item -> , type
Rule 104   param -> identifier _17_0x3a_type_optional
Rule 105   _17_0x3a_type_optional -> : type
Rule 106   _17_0x3a_type_optional -> <empty>
Rule 107   if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
Rule 108   _18_0x3a_type_optional -> : type
Rule 109   _18_0x3a_type_optional -> <empty>
Rule 110   _19_or_else_optional -> or_else
Rule 111   _19_or_else_optional -> <empty>
Rule 112   or_else -> ELIF expr THEN block_statement _20_or_else_optional
Rule 113   _20_or_else_optional -> or_else
Rule 114   _20_or_else_optional -> <empty>
Rule 115   or_else -> ELSE block_statement
Rule 116   case_of -> CASE expr OF _21_pattern_do_repeat END
Rule 117   _21_pattern_do_repeat -> _21_pattern_do_items
Rule 118   _21_pattern_do_repeat -> <empty>
Rule 119   _21_pattern_do_items -> _21_pattern_do_items _21_pattern_do_item
Rule 120   _21_pattern_do_items -> _21_pattern_do_item
Rule 121   _21_pattern_do_item -> pattern do
Rule 122   pattern -> match_variant
Rule 123   pattern -> match_as
Rule 124   match_as -> identifier
Rule 125   match_variant -> type_identifier
Rule 126   match_variant -> type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat )  [precedence=left, level=7]
Rule 127   _22_pattern_optional -> pattern
Rule 128   _22_pattern_optional -> <empty>
Rule 129   _23_0x2c_pattern_repeat -> _23_0x2c_pattern_items
Rule 130   _23_0x2c_pattern_repeat -> <empty>
Rule 131   _23_0x2c_pattern_items -> _23_0x2c_pattern_items _23_0x2c_pattern_item
Rule 132   _23_0x2c_pattern_items -> _23_0x2c_pattern_item
Rule 133   _23_0x2c_pattern_item -> , pattern
Rule 134   array -> [ _24_expr_optional _25_0x2c_expr_repeat ]
Rule 135   _24_expr_optional -> expr
Rule 136   _24_expr_optional -> <empty>
Rule 137   _25_0x2c_expr_repeat -> _25_0x2c_expr_items
Rule 138   _25_0x2c_expr_repeat -> <empty>
Rule 139   _25_0x2c_expr_items -> _25_0x2c_expr_items _25_0x2c_expr_item
Rule 140   _25_0x2c_expr_items -> _25_0x2c_expr_item
Rule 141   _25_0x2c_expr_item -> , expr
Rule 142   call -> expr ( _26_expr_optional _27_0x2c_expr_repeat )  [precedence=left, level=7]
Rule 143   _26_expr_optional -> expr
Rule 144   _26_expr_optional -> <empty>
Rule 145   _27_0x2c_expr_repeat -> _27_0x2c_expr_items
Rule 146   _27_0x2c_expr_repeat -> <empty>
Rule 147   _27_0x2c_expr_items -> _27_0x2c_expr_items _27_0x2c_expr_item
Rule 148   _27_0x2c_expr_items -> _27_0x2c_expr_item
Rule 149   _27_0x2c_expr_item -> , expr
Rule 150   variant_call -> type_identifier
Rule 151   variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )  [precedence=left, level=7]
Rule 152   _28_expr_optional -> expr
Rule 153   _28_expr_optional -> <empty>
Rule 154   _29_0x2c_expr_repeat -> _29_0x2c_expr_items
Rule 155   _29_0x2c_expr_repeat -> <empty>
Rule 156   _29_0x2c_expr_items -> _29_0x2c_expr_items _29_0x2c_expr_item
Rule 157   _29_0x2c_expr_items -> _29_0x2c_expr_item
Rule 158   _29_0x2c_expr_item -> , expr
Rule 159   identifier -> IDENTIFIER
Rule 160   type_identifier -> TYPE_IDENTIFIER
Rule 161   variable_declaration -> LET identifier _30_0x3a_type_optional = expr  [precedence=left, level=1]
Rule 162   _30_0x3a_type_optional -> : type
Rule 163   _30_0x3a_type_optional -> <empty>
Rule 164   literal -> STRING
Rule 165   literal -> NUMBER

Terminals, with rules where they appear:

%                    : 27
(                    : 8 48 58 98 126 142 151
)                    : 8 48 58 98 126 142 151
*                    : 29
+                    : 32
,                    : 55 63 70 78 91 103 133 141 149 158
-                    : 7 31
/                    : 30
:                    : 35 56 71 105 108 162
<                    : 28 58 73 86
=                    : 161
>                    : 26 58 73 86
CASE                 : 116
CONCAT               : 33
DEF                  : 48 58
DO                   : 34
ELIF                 : 112
ELSE                 : 115
END                  : 34 107 116
ENUM                 : 80 86
EXTERNAL             : 22
IDENTIFIER           : 159
IF                   : 107
INT_DIV              : 23
LET                  : 161
NUMBER               : 165
NUM_NOT_EQUAL        : 24
OF                   : 116
STRING               : 164
THEN                 : 107 112
TYPE_IDENTIFIER      : 160
[                    : 134
]                    : 134
error                : 
{                    : 80 86
|                    : 25
}                    : 80 86

Nonterminals, with rules where they appear:

_10_0x2c_param_item  : 68 69
_10_0x2c_param_items : 66 68
_10_0x2c_param_repeat : 58
_11_0x3a_type_optional : 58
_12_0x2c_type_item   : 76 77
_12_0x2c_type_items  : 74 76
_12_0x2c_type_repeat : 73
_13_variant_item     : 83 84
_13_variant_items    : 81 83
_13_variant_repeat   : 80
_14_0x2c_type_identifier_item : 89 90
_14_0x2c_type_identifier_items : 87 89
_14_0x2c_type_identifier_repeat : 86
_15_variant_item     : 94 95
_15_variant_items    : 92 94
_15_variant_repeat   : 86
_16_0x2c_type_item   : 101 102
_16_0x2c_type_items  : 99 101
_16_0x2c_type_repeat : 98
_17_0x3a_type_optional : 104
_18_0x3a_type_optional : 107
_19_or_else_optional : 107
_1_expr_item         : 4 5
_1_expr_items        : 2 4
_1_expr_repeat       : 1
_20_or_else_optional : 112
_21_pattern_do_item  : 119 120
_21_pattern_do_items : 117 119
_21_pattern_do_repeat : 116
_22_pattern_optional : 126
_23_0x2c_pattern_item : 131 132
_23_0x2c_pattern_items : 129 131
_23_0x2c_pattern_repeat : 126
_24_expr_optional    : 134
_25_0x2c_expr_item   : 139 140
_25_0x2c_expr_items  : 137 139
_25_0x2c_expr_repeat : 134
_26_expr_optional    : 142
_27_0x2c_expr_item   : 147 148
_27_0x2c_expr_items  : 145 147
_27_0x2c_expr_repeat : 142
_28_expr_optional    : 151
_29_0x2c_expr_item   : 156 157
_29_0x2c_expr_items  : 154 156
_29_0x2c_expr_repeat : 151
_2_0x3a_type_optional : 34
_30_0x3a_type_optional : 161
_3_expr_item         : 39 40
_3_expr_items        : 37 39
_3_expr_repeat       : 34
_4_expr_item         : 45 46
_4_expr_items        : 43 45
_4_expr_repeat       : 42
_5_param_optional    : 48
_6_0x2c_param_item   : 53 54
_6_0x2c_param_items  : 51 53
_6_0x2c_param_repeat : 48
_7_0x3a_type_optional : 48
_8_0x2c_type_identifier_item : 61 62
_8_0x2c_type_identifier_items : 59 61
_8_0x2c_type_identifier_repeat : 58
_9_param_optional    : 58
array                : 9
binary_expr          : 15
block_statement      : 107 112 115
call                 : 13
case_of              : 14
def_expr             : 17
do                   : 19 48 58 121
enum                 : 21
expr                 : 6 7 8 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 41 47 107 112 116 135 141 142 143 149 152 158 161
external             : 20
identifier           : 11 48 58 104 124 161
if_expr              : 16
literal              : 18
match_as             : 123
match_variant        : 122
or_else              : 110 113
param                : 49 55 64 70
pattern              : 121 127 133
program              : 0
type                 : 35 56 71 73 78 98 103 105 108 162
type_identifier      : 58 63 73 79 80 86 86 91 97 98 125 126 150 151
variable_declaration : 12
variant              : 85 96
variant_call         : 10


state 0

    (0) S' -> . program
    (1) program -> . _1_expr_repeat
    (2) _1_expr_repeat -> . _1_expr_items
    (3) _1_expr_repeat -> .
    (4) _1_expr_items -> . _1_expr_items _1_expr_item
    (5) _1_expr_items -> . _1_expr_item
    (6) _1_expr_item -> . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 3 (_1_expr_repeat -> .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    program                        shift and go to state 1
    _1_expr_repeat                 shift and go to state 2
    _1_expr_items                  shift and go to state 3
    _1_expr_item                   shift and go to state 4
    expr                           shift and go to state 5
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_expr_repeat .
    $end            reduce using rule 1 (program -> _1_expr_repeat .)


state 3

    (2) _1_expr_repeat -> _1_expr_items .
    (4) _1_expr_items -> _1_expr_items . _1_expr_item
    (6) _1_expr_item -> . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 2 (_1_expr_repeat -> _1_expr_items .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _1_expr_item                   shift and go to state 34
    expr                           shift and go to state 5
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 4

    (5) _1_expr_items -> _1_expr_item .
    -               reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    (               reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    [               reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    IDENTIFIER      reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    LET             reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    CASE            reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    IF              reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    DEF             reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    STRING          reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    NUMBER          reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    DO              reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    EXTERNAL        reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    ENUM            reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    TYPE_IDENTIFIER reduce using rule 5 (_1_expr_items -> _1_expr_item .)
    $end            reduce using rule 5 (_1_expr_items -> _1_expr_item .)


state 5

    (6) _1_expr_item -> expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    [               reduce using rule 6 (_1_expr_item -> expr .)
    IDENTIFIER      reduce using rule 6 (_1_expr_item -> expr .)
    LET             reduce using rule 6 (_1_expr_item -> expr .)
    CASE            reduce using rule 6 (_1_expr_item -> expr .)
    IF              reduce using rule 6 (_1_expr_item -> expr .)
    DEF             reduce using rule 6 (_1_expr_item -> expr .)
    STRING          reduce using rule 6 (_1_expr_item -> expr .)
    NUMBER          reduce using rule 6 (_1_expr_item -> expr .)
    DO              reduce using rule 6 (_1_expr_item -> expr .)
    EXTERNAL        reduce using rule 6 (_1_expr_item -> expr .)
    ENUM            reduce using rule 6 (_1_expr_item -> expr .)
    TYPE_IDENTIFIER reduce using rule 6 (_1_expr_item -> expr .)
    $end            reduce using rule 6 (_1_expr_item -> expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 6

    (7) expr -> - . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 47
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 7

    (8) expr -> ( . expr )
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 48
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 8

    (9) expr -> array .
    (               reduce using rule 9 (expr -> array .)
    INT_DIV         reduce using rule 9 (expr -> array .)
    NUM_NOT_EQUAL   reduce using rule 9 (expr -> array .)
    |               reduce using rule 9 (expr -> array .)
    >               reduce using rule 9 (expr -> array .)
    %               reduce using rule 9 (expr -> array .)
    <               reduce using rule 9 (expr -> array .)
    *               reduce using rule 9 (expr -> array .)
    /               reduce using rule 9 (expr -> array .)
    -               reduce using rule 9 (expr -> array .)
    +               reduce using rule 9 (expr -> array .)
    CONCAT          reduce using rule 9 (expr -> array .)
    [               reduce using rule 9 (expr -> array .)
    IDENTIFIER      reduce using rule 9 (expr -> array .)
    LET             reduce using rule 9 (expr -> array .)
    CASE            reduce using rule 9 (expr -> array .)
    IF              reduce using rule 9 (expr -> array .)
    DEF             reduce using rule 9 (expr -> array .)
    STRING          reduce using rule 9 (expr -> array .)
    NUMBER          reduce using rule 9 (expr -> array .)
    DO              reduce using rule 9 (expr -> array .)
    EXTERNAL        reduce using rule 9 (expr -> array .)
    ENUM            reduce using rule 9 (expr -> array .)
    TYPE_IDENTIFIER reduce using rule 9 (expr -> array .)
    $end            reduce using rule 9 (expr -> array .)
    )               reduce using rule 9 (expr -> array .)
    ,               reduce using rule 9 (expr -> array .)
    ]               reduce using rule 9 (expr -> array .)
    OF              reduce using rule 9 (expr -> array .)
    THEN            reduce using rule 9 (expr -> array .)
    END             reduce using rule 9 (expr -> array .)
    ELIF            reduce using rule 9 (expr -> array .)
    ELSE            reduce using rule 9 (expr -> array .)


state 9

    (10) expr -> variant_call .
    (               reduce using rule 10 (expr -> variant_call .)
    INT_DIV         reduce using rule 10 (expr -> variant_call .)
    NUM_NOT_EQUAL   reduce using rule 10 (expr -> variant_call .)
    |               reduce using rule 10 (expr -> variant_call .)
    >               reduce using rule 10 (expr -> variant_call .)
    %               reduce using rule 10 (expr -> variant_call .)
    <               reduce using rule 10 (expr -> variant_call .)
    *               reduce using rule 10 (expr -> variant_call .)
    /               reduce using rule 10 (expr -> variant_call .)
    -               reduce using rule 10 (expr -> variant_call .)
    +               reduce using rule 10 (expr -> variant_call .)
    CONCAT          reduce using rule 10 (expr -> variant_call .)
    [               reduce using rule 10 (expr -> variant_call .)
    IDENTIFIER      reduce using rule 10 (expr -> variant_call .)
    LET             reduce using rule 10 (expr -> variant_call .)
    CASE            reduce using rule 10 (expr -> variant_call .)
    IF              reduce using rule 10 (expr -> variant_call .)
    DEF             reduce using rule 10 (expr -> variant_call .)
    STRING          reduce using rule 10 (expr -> variant_call .)
    NUMBER          reduce using rule 10 (expr -> variant_call .)
    DO              reduce using rule 10 (expr -> variant_call .)
    EXTERNAL        reduce using rule 10 (expr -> variant_call .)
    ENUM            reduce using rule 10 (expr -> variant_call .)
    TYPE_IDENTIFIER reduce using rule 10 (expr -> variant_call .)
    $end            reduce using rule 10 (expr -> variant_call .)
    )               reduce using rule 10 (expr -> variant_call .)
    ,               reduce using rule 10 (expr -> variant_call .)
    ]               reduce using rule 10 (expr -> variant_call .)
    OF              reduce using rule 10 (expr -> variant_call .)
    THEN            reduce using rule 10 (expr -> variant_call .)
    END             reduce using rule 10 (expr -> variant_call .)
    ELIF            reduce using rule 10 (expr -> variant_call .)
    ELSE            reduce using rule 10 (expr -> variant_call .)


state 10

    (11) expr -> identifier .
    (               reduce using rule 11 (expr -> identifier .)
    INT_DIV         reduce using rule 11 (expr -> identifier .)
    NUM_NOT_EQUAL   reduce using rule 11 (expr -> identifier .)
    |               reduce using rule 11 (expr -> identifier .)
    >               reduce using rule 11 (expr -> identifier .)
    %               reduce using rule 11 (expr -> identifier .)
    <               reduce using rule 11 (expr -> identifier .)
    *               reduce using rule 11 (expr -> identifier .)
    /               reduce using rule 11 (expr -> identifier .)
    -               reduce using rule 11 (expr -> identifier .)
    +               reduce using rule 11 (expr -> identifier .)
    CONCAT          reduce using rule 11 (expr -> identifier .)
    [               reduce using rule 11 (expr -> identifier .)
    IDENTIFIER      reduce using rule 11 (expr -> identifier .)
    LET             reduce using rule 11 (expr -> identifier .)
    CASE            reduce using rule 11 (expr -> identifier .)
    IF              reduce using rule 11 (expr -> identifier .)
    DEF             reduce using rule 11 (expr -> identifier .)
    STRING          reduce using rule 11 (expr -> identifier .)
    NUMBER          reduce using rule 11 (expr -> identifier .)
    DO              reduce using rule 11 (expr -> identifier .)
    EXTERNAL        reduce using rule 11 (expr -> identifier .)
    ENUM            reduce using rule 11 (expr -> identifier .)
    TYPE_IDENTIFIER reduce using rule 11 (expr -> identifier .)
    $end            reduce using rule 11 (expr -> identifier .)
    )               reduce using rule 11 (expr -> identifier .)
    ,               reduce using rule 11 (expr -> identifier .)
    ]               reduce using rule 11 (expr -> identifier .)
    OF              reduce using rule 11 (expr -> identifier .)
    THEN            reduce using rule 11 (expr -> identifier .)
    END             reduce using rule 11 (expr -> identifier .)
    ELIF            reduce using rule 11 (expr -> identifier .)
    ELSE            reduce using rule 11 (expr -> identifier .)


state 11

    (12) expr -> variable_declaration .
    (               reduce using rule 12 (expr -> variable_declaration .)
    INT_DIV         reduce using rule 12 (expr -> variable_declaration .)
    NUM_NOT_EQUAL   reduce using rule 12 (expr -> variable_declaration .)
    |               reduce using rule 12 (expr -> variable_declaration .)
    >               reduce using rule 12 (expr -> variable_declaration .)
    %               reduce using rule 12 (expr -> variable_declaration .)
    <               reduce using rule 12 (expr -> variable_declaration .)
    *               reduce using rule 12 (expr -> variable_declaration .)
    /               reduce using rule 12 (expr -> variable_declaration .)
    -               reduce using rule 12 (expr -> variable_declaration .)
    +               reduce using rule 12 (expr -> variable_declaration .)
    CONCAT          reduce using rule 12 (expr -> variable_declaration .)
    [               reduce using rule 12 (expr -> variable_declaration .)
    IDENTIFIER      reduce using rule 12 (expr -> variable_declaration .)
    LET             reduce using rule 12 (expr -> variable_declaration .)
    CASE            reduce using rule 12 (expr -> variable_declaration .)
    IF              reduce using rule 12 (expr -> variable_declaration .)
    DEF             reduce using rule 12 (expr -> variable_declaration .)
    STRING          reduce using rule 12 (expr -> variable_declaration .)
    NUMBER          reduce using rule 12 (expr -> variable_declaration .)
    DO              reduce using rule 12 (expr -> variable_declaration .)
    EXTERNAL        reduce using rule 12 (expr -> variable_declaration .)
    ENUM            reduce using rule 12 (expr -> variable_declaration .)
    TYPE_IDENTIFIER reduce using rule 12 (expr -> variable_declaration .)
    $end            reduce using rule 12 (expr -> variable_declaration .)
    )               reduce using rule 12 (expr -> variable_declaration .)
    ,               reduce using rule 12 (expr -> variable_declaration .)
    ]               reduce using rule 12 (expr -> variable_declaration .)
    OF              reduce using rule 12 (expr -> variable_declaration .)
    THEN            reduce using rule 12 (expr -> variable_declaration .)
    END             reduce using rule 12 (expr -> variable_declaration .)
    ELIF            reduce using rule 12 (expr -> variable_declaration .)
    ELSE            reduce using rule 12 (expr -> variable_declaration .)


state 12

    (13) expr -> call .
    (               reduce using rule 13 (expr -> call .)
    INT_DIV         reduce using rule 13 (expr -> call .)
    NUM_NOT_EQUAL   reduce using rule 13 (expr -> call .)
    |               reduce using rule 13 (expr -> call .)
    >               reduce using rule 13 (expr -> call .)
    %               reduce using rule 13 (expr -> call .)
    <               reduce using rule 13 (expr -> call .)
    *               reduce using rule 13 (expr -> call .)
    /               reduce using rule 13 (expr -> call .)
    -               reduce using rule 13 (expr -> call .)
    +               reduce using rule 13 (expr -> call .)
    CONCAT          reduce using rule 13 (expr -> call .)
    [               reduce using rule 13 (expr -> call .)
    IDENTIFIER      reduce using rule 13 (expr -> call .)
    LET             reduce using rule 13 (expr -> call .)
    CASE            reduce using rule 13 (expr -> call .)
    IF              reduce using rule 13 (expr -> call .)
    DEF             reduce using rule 13 (expr -> call .)
    STRING          reduce using rule 13 (expr -> call .)
    NUMBER          reduce using rule 13 (expr -> call .)
    DO              reduce using rule 13 (expr -> call .)
    EXTERNAL        reduce using rule 13 (expr -> call .)
    ENUM            reduce using rule 13 (expr -> call .)
    TYPE_IDENTIFIER reduce using rule 13 (expr -> call .)
    $end            reduce using rule 13 (expr -> call .)
    )               reduce using rule 13 (expr -> call .)
    ,               reduce using rule 13 (expr -> call .)
    ]               reduce using rule 13 (expr -> call .)
    OF              reduce using rule 13 (expr -> call .)
    THEN            reduce using rule 13 (expr -> call .)
    END             reduce using rule 13 (expr -> call .)
    ELIF            reduce using rule 13 (expr -> call .)
    ELSE            reduce using rule 13 (expr -> call .)


state 13

    (14) expr -> case_of .
    (               reduce using rule 14 (expr -> case_of .)
    INT_DIV         reduce using rule 14 (expr -> case_of .)
    NUM_NOT_EQUAL   reduce using rule 14 (expr -> case_of .)
    |               reduce using rule 14 (expr -> case_of .)
    >               reduce using rule 14 (expr -> case_of .)
    %               reduce using rule 14 (expr -> case_of .)
    <               reduce using rule 14 (expr -> case_of .)
    *               reduce using rule 14 (expr -> case_of .)
    /               reduce using rule 14 (expr -> case_of .)
    -               reduce using rule 14 (expr -> case_of .)
    +               reduce using rule 14 (expr -> case_of .)
    CONCAT          reduce using rule 14 (expr -> case_of .)
    [               reduce using rule 14 (expr -> case_of .)
    IDENTIFIER      reduce using rule 14 (expr -> case_of .)
    LET             reduce using rule 14 (expr -> case_of .)
    CASE            reduce using rule 14 (expr -> case_of .)
    IF              reduce using rule 14 (expr -> case_of .)
    DEF             reduce using rule 14 (expr -> case_of .)
    STRING          reduce using rule 14 (expr -> case_of .)
    NUMBER          reduce using rule 14 (expr -> case_of .)
    DO              reduce using rule 14 (expr -> case_of .)
    EXTERNAL        reduce using rule 14 (expr -> case_of .)
    ENUM            reduce using rule 14 (expr -> case_of .)
    TYPE_IDENTIFIER reduce using rule 14 (expr -> case_of .)
    $end            reduce using rule 14 (expr -> case_of .)
    )               reduce using rule 14 (expr -> case_of .)
    ,               reduce using rule 14 (expr -> case_of .)
    ]               reduce using rule 14 (expr -> case_of .)
    OF              reduce using rule 14 (expr -> case_of .)
    THEN            reduce using rule 14 (expr -> case_of .)
    END             reduce using rule 14 (expr -> case_of .)
    ELIF            reduce using rule 14 (expr -> case_of .)
    ELSE            reduce using rule 14 (expr -> case_of .)


state 14

    (15) expr -> binary_expr .
    (               reduce using rule 15 (expr -> binary_expr .)
    INT_DIV         reduce using rule 15 (expr -> binary_expr .)
    NUM_NOT_EQUAL   reduce using rule 15 (expr -> binary_expr .)
    |               reduce using rule 15 (expr -> binary_expr .)
    >               reduce using rule 15 (expr -> binary_expr .)
    %               reduce using rule 15 (expr -> binary_expr .)
    <               reduce using rule 15 (expr -> binary_expr .)
    *               reduce using rule 15 (expr -> binary_expr .)
    /               reduce using rule 15 (expr -> binary_expr .)
    -               reduce using rule 15 (expr -> binary_expr .)
    +               reduce using rule 15 (expr -> binary_expr .)
    CONCAT          reduce using rule 15 (expr -> binary_expr .)
    [               reduce using rule 15 (expr -> binary_expr .)
    IDENTIFIER      reduce using rule 15 (expr -> binary_expr .)
    LET             reduce using rule 15 (expr -> binary_expr .)
    CASE            reduce using rule 15 (expr -> binary_expr .)
    IF              reduce using rule 15 (expr -> binary_expr .)
    DEF             reduce using rule 15 (expr -> binary_expr .)
    STRING          reduce using rule 15 (expr -> binary_expr .)
    NUMBER          reduce using rule 15 (expr -> binary_expr .)
    DO              reduce using rule 15 (expr -> binary_expr .)
    EXTERNAL        reduce using rule 15 (expr -> binary_expr .)
    ENUM            reduce using rule 15 (expr -> binary_expr .)
    TYPE_IDENTIFIER reduce using rule 15 (expr -> binary_expr .)
    $end            reduce using rule 15 (expr -> binary_expr .)
    )               reduce using rule 15 (expr -> binary_expr .)
    ,               reduce using rule 15 (expr -> binary_expr .)
    ]               reduce using rule 15 (expr -> binary_expr .)
    OF              reduce using rule 15 (expr -> binary_expr .)
    THEN            reduce using rule 15 (expr -> binary_expr .)
    END             reduce using rule 15 (expr -> binary_expr .)
    ELIF            reduce using rule 15 (expr -> binary_expr .)
    ELSE            reduce using rule 15 (expr -> binary_expr .)


state 15

    (16) expr -> if_expr .
    (               reduce using rule 16 (expr -> if_expr .)
    INT_DIV         reduce using rule 16 (expr -> if_expr .)
    NUM_NOT_EQUAL   reduce using rule 16 (expr -> if_expr .)
    |               reduce using rule 16 (expr -> if_expr .)
    >               reduce using rule 16 (expr -> if_expr .)
    %               reduce using rule 16 (expr -> if_expr .)
    <               reduce using rule 16 (expr -> if_expr .)
    *               reduce using rule 16 (expr -> if_expr .)
    /               reduce using rule 16 (expr -> if_expr .)
    -               reduce using rule 16 (expr -> if_expr .)
    +               reduce using rule 16 (expr -> if_expr .)
    CONCAT          reduce using rule 16 (expr -> if_expr .)
    [               reduce using rule 16 (expr -> if_expr .)
    IDENTIFIER      reduce using rule 16 (expr -> if_expr .)
    LET             reduce using rule 16 (expr -> if_expr .)
    CASE            reduce using rule 16 (expr -> if_expr .)
    IF              reduce using rule 16 (expr -> if_expr .)
    DEF             reduce using rule 16 (expr -> if_expr .)
    STRING          reduce using rule 16 (expr -> if_expr .)
    NUMBER          reduce using rule 16 (expr -> if_expr .)
    DO              reduce using rule 16 (expr -> if_expr .)
    EXTERNAL        reduce using rule 16 (expr -> if_expr .)
    ENUM            reduce using rule 16 (expr -> if_expr .)
    TYPE_IDENTIFIER reduce using rule 16 (expr -> if_expr .)
    $end            reduce using rule 16 (expr -> if_expr .)
    )               reduce using rule 16 (expr -> if_expr .)
    ,               reduce using rule 16 (expr -> if_expr .)
    ]               reduce using rule 16 (expr -> if_expr .)
    OF              reduce using rule 16 (expr -> if_expr .)
    THEN            reduce using rule 16 (expr -> if_expr .)
    END             reduce using rule 16 (expr -> if_expr .)
    ELIF            reduce using rule 16 (expr -> if_expr .)
    ELSE            reduce using rule 16 (expr -> if_expr .)


state 16

    (17) expr -> def_expr .
    (               reduce using rule 17 (expr -> def_expr .)
    INT_DIV         reduce using rule 17 (expr -> def_expr .)
    NUM_NOT_EQUAL   reduce using rule 17 (expr -> def_expr .)
    |               reduce using rule 17 (expr -> def_expr .)
    >               reduce using rule 17 (expr -> def_expr .)
    %               reduce using rule 17 (expr -> def_expr .)
    <               reduce using rule 17 (expr -> def_expr .)
    *               reduce using rule 17 (expr -> def_expr .)
    /               reduce using rule 17 (expr -> def_expr .)
    -               reduce using rule 17 (expr -> def_expr .)
    +               reduce using rule 17 (expr -> def_expr .)
    CONCAT          reduce using rule 17 (expr -> def_expr .)
    [               reduce using rule 17 (expr -> def_expr .)
    IDENTIFIER      reduce using rule 17 (expr -> def_expr .)
    LET             reduce using rule 17 (expr -> def_expr .)
    CASE            reduce using rule 17 (expr -> def_expr .)
    IF              reduce using rule 17 (expr -> def_expr .)
    DEF             reduce using rule 17 (expr -> def_expr .)
    STRING          reduce using rule 17 (expr -> def_expr .)
    NUMBER          reduce using rule 17 (expr -> def_expr .)
    DO              reduce using rule 17 (expr -> def_expr .)
    EXTERNAL        reduce using rule 17 (expr -> def_expr .)
    ENUM            reduce using rule 17 (expr -> def_expr .)
    TYPE_IDENTIFIER reduce using rule 17 (expr -> def_expr .)
    $end            reduce using rule 17 (expr -> def_expr .)
    )               reduce using rule 17 (expr -> def_expr .)
    ,               reduce using rule 17 (expr -> def_expr .)
    ]               reduce using rule 17 (expr -> def_expr .)
    OF              reduce using rule 17 (expr -> def_expr .)
    THEN            reduce using rule 17 (expr -> def_expr .)
    END             reduce using rule 17 (expr -> def_expr .)
    ELIF            reduce using rule 17 (expr -> def_expr .)
    ELSE            reduce using rule 17 (expr -> def_expr .)


state 17

    (18) expr -> literal .
    (               reduce using rule 18 (expr -> literal .)
    INT_DIV         reduce using rule 18 (expr -> literal .)
    NUM_NOT_EQUAL   reduce using rule 18 (expr -> literal .)
    |               reduce using rule 18 (expr -> literal .)
    >               reduce using rule 18 (expr -> literal .)
    %               reduce using rule 18 (expr -> literal .)
    <               reduce using rule 18 (expr -> literal .)
    *               reduce using rule 18 (expr -> literal .)
    /               reduce using rule 18 (expr -> literal .)
    -               reduce using rule 18 (expr -> literal .)
    +               reduce using rule 18 (expr -> literal .)
    CONCAT          reduce using rule 18 (expr -> literal .)
    [               reduce using rule 18 (expr -> literal .)
    IDENTIFIER      reduce using rule 18 (expr -> literal .)
    LET             reduce using rule 18 (expr -> literal .)
    CASE            reduce using rule 18 (expr -> literal .)
    IF              reduce using rule 18 (expr -> literal .)
    DEF             reduce using rule 18 (expr -> literal .)
    STRING          reduce using rule 18 (expr -> literal .)
    NUMBER          reduce using rule 18 (expr -> literal .)
    DO              reduce using rule 18 (expr -> literal .)
    EXTERNAL        reduce using rule 18 (expr -> literal .)
    ENUM            reduce using rule 18 (expr -> literal .)
    TYPE_IDENTIFIER reduce using rule 18 (expr -> literal .)
    $end            reduce using rule 18 (expr -> literal .)
    )               reduce using rule 18 (expr -> literal .)
    ,               reduce using rule 18 (expr -> literal .)
    ]               reduce using rule 18 (expr -> literal .)
    OF              reduce using rule 18 (expr -> literal .)
    THEN            reduce using rule 18 (expr -> literal .)
    END             reduce using rule 18 (expr -> literal .)
    ELIF            reduce using rule 18 (expr -> literal .)
    ELSE            reduce using rule 18 (expr -> literal .)


state 18

    (19) expr -> do .
    (               reduce using rule 19 (expr -> do .)
    INT_DIV         reduce using rule 19 (expr -> do .)
    NUM_NOT_EQUAL   reduce using rule 19 (expr -> do .)
    |               reduce using rule 19 (expr -> do .)
    >               reduce using rule 19 (expr -> do .)
    %               reduce using rule 19 (expr -> do .)
    <               reduce using rule 19 (expr -> do .)
    *               reduce using rule 19 (expr -> do .)
    /               reduce using rule 19 (expr -> do .)
    -               reduce using rule 19 (expr -> do .)
    +               reduce using rule 19 (expr -> do .)
    CONCAT          reduce using rule 19 (expr -> do .)
    [               reduce using rule 19 (expr -> do .)
    IDENTIFIER      reduce using rule 19 (expr -> do .)
    LET             reduce using rule 19 (expr -> do .)
    CASE            reduce using rule 19 (expr -> do .)
    IF              reduce using rule 19 (expr -> do .)
    DEF             reduce using rule 19 (expr -> do .)
    STRING          reduce using rule 19 (expr -> do .)
    NUMBER          reduce using rule 19 (expr -> do .)
    DO              reduce using rule 19 (expr -> do .)
    EXTERNAL        reduce using rule 19 (expr -> do .)
    ENUM            reduce using rule 19 (expr -> do .)
    TYPE_IDENTIFIER reduce using rule 19 (expr -> do .)
    $end            reduce using rule 19 (expr -> do .)
    )               reduce using rule 19 (expr -> do .)
    ,               reduce using rule 19 (expr -> do .)
    ]               reduce using rule 19 (expr -> do .)
    OF              reduce using rule 19 (expr -> do .)
    THEN            reduce using rule 19 (expr -> do .)
    END             reduce using rule 19 (expr -> do .)
    ELIF            reduce using rule 19 (expr -> do .)
    ELSE            reduce using rule 19 (expr -> do .)


state 19

    (20) expr -> external .
    (               reduce using rule 20 (expr -> external .)
    INT_DIV         reduce using rule 20 (expr -> external .)
    NUM_NOT_EQUAL   reduce using rule 20 (expr -> external .)
    |               reduce using rule 20 (expr -> external .)
    >               reduce using rule 20 (expr -> external .)
    %               reduce using rule 20 (expr -> external .)
    <               reduce using rule 20 (expr -> external .)
    *               reduce using rule 20 (expr -> external .)
    /               reduce using rule 20 (expr -> external .)
    -               reduce using rule 20 (expr -> external .)
    +               reduce using rule 20 (expr -> external .)
    CONCAT          reduce using rule 20 (expr -> external .)
    [               reduce using rule 20 (expr -> external .)
    IDENTIFIER      reduce using rule 20 (expr -> external .)
    LET             reduce using rule 20 (expr -> external .)
    CASE            reduce using rule 20 (expr -> external .)
    IF              reduce using rule 20 (expr -> external .)
    DEF             reduce using rule 20 (expr -> external .)
    STRING          reduce using rule 20 (expr -> external .)
    NUMBER          reduce using rule 20 (expr -> external .)
    DO              reduce using rule 20 (expr -> external .)
    EXTERNAL        reduce using rule 20 (expr -> external .)
    ENUM            reduce using rule 20 (expr -> external .)
    TYPE_IDENTIFIER reduce using rule 20 (expr -> external .)
    $end            reduce using rule 20 (expr -> external .)
    )               reduce using rule 20 (expr -> external .)
    ,               reduce using rule 20 (expr -> external .)
    ]               reduce using rule 20 (expr -> external .)
    OF              reduce using rule 20 (expr -> external .)
    THEN            reduce using rule 20 (expr -> external .)
    END             reduce using rule 20 (expr -> external .)
    ELIF            reduce using rule 20 (expr -> external .)
    ELSE            reduce using rule 20 (expr -> external .)


state 20

    (21) expr -> enum .
    (               reduce using rule 21 (expr -> enum .)
    INT_DIV         reduce using rule 21 (expr -> enum .)
    NUM_NOT_EQUAL   reduce using rule 21 (expr -> enum .)
    |               reduce using rule 21 (expr -> enum .)
    >               reduce using rule 21 (expr -> enum .)
    %               reduce using rule 21 (expr -> enum .)
    <               reduce using rule 21 (expr -> enum .)
    *               reduce using rule 21 (expr -> enum .)
    /               reduce using rule 21 (expr -> enum .)
    -               reduce using rule 21 (expr -> enum .)
    +               reduce using rule 21 (expr -> enum .)
    CONCAT          reduce using rule 21 (expr -> enum .)
    [               reduce using rule 21 (expr -> enum .)
    IDENTIFIER      reduce using rule 21 (expr -> enum .)
    LET             reduce using rule 21 (expr -> enum .)
    CASE            reduce using rule 21 (expr -> enum .)
    IF              reduce using rule 21 (expr -> enum .)
    DEF             reduce using rule 21 (expr -> enum .)
    STRING          reduce using rule 21 (expr -> enum .)
    NUMBER          reduce using rule 21 (expr -> enum .)
    DO              reduce using rule 21 (expr -> enum .)
    EXTERNAL        reduce using rule 21 (expr -> enum .)
    ENUM            reduce using rule 21 (expr -> enum .)
    TYPE_IDENTIFIER reduce using rule 21 (expr -> enum .)
    $end            reduce using rule 21 (expr -> enum .)
    )               reduce using rule 21 (expr -> enum .)
    ,               reduce using rule 21 (expr -> enum .)
    ]               reduce using rule 21 (expr -> enum .)
    OF              reduce using rule 21 (expr -> enum .)
    THEN            reduce using rule 21 (expr -> enum .)
    END             reduce using rule 21 (expr -> enum .)
    ELIF            reduce using rule 21 (expr -> enum .)
    ELSE            reduce using rule 21 (expr -> enum .)


state 21

    (134) array -> [ . _24_expr_optional _25_0x2c_expr_repeat ]
    (135) _24_expr_optional -> . expr
    (136) _24_expr_optional -> .
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 136 (_24_expr_optional -> .)
    ]               reduce using rule 136 (_24_expr_optional -> .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _24_expr_optional              shift and go to state 49
    expr                           shift and go to state 50
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 22

    (150) variant_call -> type_identifier .
    (151) variant_call -> type_identifier . ( _28_expr_optional _29_0x2c_expr_repeat )
  ! shift/reduce conflict for ( resolved as shift
    INT_DIV         reduce using rule 150 (variant_call -> type_identifier .)
    NUM_NOT_EQUAL   reduce using rule 150 (variant_call -> type_identifier .)
    |               reduce using rule 150 (variant_call -> type_identifier .)
    >               reduce using rule 150 (variant_call -> type_identifier .)
    %               reduce using rule 150 (variant_call -> type_identifier .)
    <               reduce using rule 150 (variant_call -> type_identifier .)
    *               reduce using rule 150 (variant_call -> type_identifier .)
    /               reduce using rule 150 (variant_call -> type_identifier .)
    -               reduce using rule 150 (variant_call -> type_identifier .)
    +               reduce using rule 150 (variant_call -> type_identifier .)
    CONCAT          reduce using rule 150 (variant_call -> type_identifier .)
    [               reduce using rule 150 (variant_call -> type_identifier .)
    IDENTIFIER      reduce using rule 150 (variant_call -> type_identifier .)
    LET             reduce using rule 150 (variant_call -> type_identifier .)
    CASE            reduce using rule 150 (variant_call -> type_identifier .)
    IF              reduce using rule 150 (variant_call -> type_identifier .)
    DEF             reduce using rule 150 (variant_call -> type_identifier .)
    STRING          reduce using rule 150 (variant_call -> type_identifier .)
    NUMBER          reduce using rule 150 (variant_call -> type_identifier .)
    DO              reduce using rule 150 (variant_call -> type_identifier .)
    EXTERNAL        reduce using rule 150 (variant_call -> type_identifier .)
    ENUM            reduce using rule 150 (variant_call -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 150 (variant_call -> type_identifier .)
    $end            reduce using rule 150 (variant_call -> type_identifier .)
    )               reduce using rule 150 (variant_call -> type_identifier .)
    ,               reduce using rule 150 (variant_call -> type_identifier .)
    ]               reduce using rule 150 (variant_call -> type_identifier .)
    OF              reduce using rule 150 (variant_call -> type_identifier .)
    THEN            reduce using rule 150 (variant_call -> type_identifier .)
    END             reduce using rule 150 (variant_call -> type_identifier .)
    ELIF            reduce using rule 150 (variant_call -> type_identifier .)
    ELSE            reduce using rule 150 (variant_call -> type_identifier .)
    (               shift and go to state 51


state 23

    (159) identifier -> IDENTIFIER .
    (               reduce using rule 159 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 159 (identifier -> IDENTIFIER .)
    NUM_NOT_EQUAL   reduce using rule 159 (identifier -> IDENTIFIER .)
    |               reduce using rule 159 (identifier -> IDENTIFIER .)
    >               reduce using rule 159 (identifier -> IDENTIFIER .)
    %               reduce using rule 159 (identifier -> IDENTIFIER .)
    <               reduce using rule 159 (identifier -> IDENTIFIER .)
    *               reduce using rule 159 (identifier -> IDENTIFIER .)
    /               reduce using rule 159 (identifier -> IDENTIFIER .)
    -               reduce using rule 159 (identifier -> IDENTIFIER .)
    +               reduce using rule 159 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 159 (identifier -> IDENTIFIER .)
    [               reduce using rule 159 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 159 (identifier -> IDENTIFIER .)
    LET             reduce using rule 159 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 159 (identifier -> IDENTIFIER .)
    IF              reduce using rule 159 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 159 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 159 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 159 (identifier -> IDENTIFIER .)
    DO              reduce using rule 159 (identifier -> IDENTIFIER .)
    EXTERNAL        reduce using rule 159 (identifier -> IDENTIFIER .)
    ENUM            reduce using rule 159 (identifier -> IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 159 (identifier -> IDENTIFIER .)
    $end            reduce using rule 159 (identifier -> IDENTIFIER .)
    )               reduce using rule 159 (identifier -> IDENTIFIER .)
    ,               reduce using rule 159 (identifier -> IDENTIFIER .)
    ]               reduce using rule 159 (identifier -> IDENTIFIER .)
    OF              reduce using rule 159 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 159 (identifier -> IDENTIFIER .)
    END             reduce using rule 159 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 159 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 159 (identifier -> IDENTIFIER .)
    :               reduce using rule 159 (identifier -> IDENTIFIER .)
    =               reduce using rule 159 (identifier -> IDENTIFIER .)


state 24

    (161) variable_declaration -> LET . identifier _30_0x3a_type_optional = expr
    (159) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 23

    identifier                     shift and go to state 52

state 25

    (116) case_of -> CASE . expr OF _21_pattern_do_repeat END
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 53
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 26

    (107) if_expr -> IF . expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 54
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 27

    (48) def_expr -> DEF . identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> DEF . identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (159) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 23

    identifier                     shift and go to state 55

state 28

    (164) literal -> STRING .
    (               reduce using rule 164 (literal -> STRING .)
    INT_DIV         reduce using rule 164 (literal -> STRING .)
    NUM_NOT_EQUAL   reduce using rule 164 (literal -> STRING .)
    |               reduce using rule 164 (literal -> STRING .)
    >               reduce using rule 164 (literal -> STRING .)
    %               reduce using rule 164 (literal -> STRING .)
    <               reduce using rule 164 (literal -> STRING .)
    *               reduce using rule 164 (literal -> STRING .)
    /               reduce using rule 164 (literal -> STRING .)
    -               reduce using rule 164 (literal -> STRING .)
    +               reduce using rule 164 (literal -> STRING .)
    CONCAT          reduce using rule 164 (literal -> STRING .)
    [               reduce using rule 164 (literal -> STRING .)
    IDENTIFIER      reduce using rule 164 (literal -> STRING .)
    LET             reduce using rule 164 (literal -> STRING .)
    CASE            reduce using rule 164 (literal -> STRING .)
    IF              reduce using rule 164 (literal -> STRING .)
    DEF             reduce using rule 164 (literal -> STRING .)
    STRING          reduce using rule 164 (literal -> STRING .)
    NUMBER          reduce using rule 164 (literal -> STRING .)
    DO              reduce using rule 164 (literal -> STRING .)
    EXTERNAL        reduce using rule 164 (literal -> STRING .)
    ENUM            reduce using rule 164 (literal -> STRING .)
    TYPE_IDENTIFIER reduce using rule 164 (literal -> STRING .)
    $end            reduce using rule 164 (literal -> STRING .)
    )               reduce using rule 164 (literal -> STRING .)
    ,               reduce using rule 164 (literal -> STRING .)
    ]               reduce using rule 164 (literal -> STRING .)
    OF              reduce using rule 164 (literal -> STRING .)
    THEN            reduce using rule 164 (literal -> STRING .)
    END             reduce using rule 164 (literal -> STRING .)
    ELIF            reduce using rule 164 (literal -> STRING .)
    ELSE            reduce using rule 164 (literal -> STRING .)


state 29

    (165) literal -> NUMBER .
    (               reduce using rule 165 (literal -> NUMBER .)
    INT_DIV         reduce using rule 165 (literal -> NUMBER .)
    NUM_NOT_EQUAL   reduce using rule 165 (literal -> NUMBER .)
    |               reduce using rule 165 (literal -> NUMBER .)
    >               reduce using rule 165 (literal -> NUMBER .)
    %               reduce using rule 165 (literal -> NUMBER .)
    <               reduce using rule 165 (literal -> NUMBER .)
    *               reduce using rule 165 (literal -> NUMBER .)
    /               reduce using rule 165 (literal -> NUMBER .)
    -               reduce using rule 165 (literal -> NUMBER .)
    +               reduce using rule 165 (literal -> NUMBER .)
    CONCAT          reduce using rule 165 (literal -> NUMBER .)
    [               reduce using rule 165 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 165 (literal -> NUMBER .)
    LET             reduce using rule 165 (literal -> NUMBER .)
    CASE            reduce using rule 165 (literal -> NUMBER .)
    IF              reduce using rule 165 (literal -> NUMBER .)
    DEF             reduce using rule 165 (literal -> NUMBER .)
    STRING          reduce using rule 165 (literal -> NUMBER .)
    NUMBER          reduce using rule 165 (literal -> NUMBER .)
    DO              reduce using rule 165 (literal -> NUMBER .)
    EXTERNAL        reduce using rule 165 (literal -> NUMBER .)
    ENUM            reduce using rule 165 (literal -> NUMBER .)
    TYPE_IDENTIFIER reduce using rule 165 (literal -> NUMBER .)
    $end            reduce using rule 165 (literal -> NUMBER .)
    )               reduce using rule 165 (literal -> NUMBER .)
    ,               reduce using rule 165 (literal -> NUMBER .)
    ]               reduce using rule 165 (literal -> NUMBER .)
    OF              reduce using rule 165 (literal -> NUMBER .)
    THEN            reduce using rule 165 (literal -> NUMBER .)
    END             reduce using rule 165 (literal -> NUMBER .)
    ELIF            reduce using rule 165 (literal -> NUMBER .)
    ELSE            reduce using rule 165 (literal -> NUMBER .)


state 30

    (34) do -> DO . _2_0x3a_type_optional _3_expr_repeat END
    (35) _2_0x3a_type_optional -> . : type
    (36) _2_0x3a_type_optional -> .
    :               shift and go to state 57
    -               reduce using rule 36 (_2_0x3a_type_optional -> .)
    (               reduce using rule 36 (_2_0x3a_type_optional -> .)
    [               reduce using rule 36 (_2_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 36 (_2_0x3a_type_optional -> .)
    LET             reduce using rule 36 (_2_0x3a_type_optional -> .)
    CASE            reduce using rule 36 (_2_0x3a_type_optional -> .)
    IF              reduce using rule 36 (_2_0x3a_type_optional -> .)
    DEF             reduce using rule 36 (_2_0x3a_type_optional -> .)
    STRING          reduce using rule 36 (_2_0x3a_type_optional -> .)
    NUMBER          reduce using rule 36 (_2_0x3a_type_optional -> .)
    DO              reduce using rule 36 (_2_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 36 (_2_0x3a_type_optional -> .)
    ENUM            reduce using rule 36 (_2_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 36 (_2_0x3a_type_optional -> .)
    END             reduce using rule 36 (_2_0x3a_type_optional -> .)

    _2_0x3a_type_optional          shift and go to state 56

state 31

    (22) external -> EXTERNAL .
    (               reduce using rule 22 (external -> EXTERNAL .)
    INT_DIV         reduce using rule 22 (external -> EXTERNAL .)
    NUM_NOT_EQUAL   reduce using rule 22 (external -> EXTERNAL .)
    |               reduce using rule 22 (external -> EXTERNAL .)
    >               reduce using rule 22 (external -> EXTERNAL .)
    %               reduce using rule 22 (external -> EXTERNAL .)
    <               reduce using rule 22 (external -> EXTERNAL .)
    *               reduce using rule 22 (external -> EXTERNAL .)
    /               reduce using rule 22 (external -> EXTERNAL .)
    -               reduce using rule 22 (external -> EXTERNAL .)
    +               reduce using rule 22 (external -> EXTERNAL .)
    CONCAT          reduce using rule 22 (external -> EXTERNAL .)
    [               reduce using rule 22 (external -> EXTERNAL .)
    IDENTIFIER      reduce using rule 22 (external -> EXTERNAL .)
    LET             reduce using rule 22 (external -> EXTERNAL .)
    CASE            reduce using rule 22 (external -> EXTERNAL .)
    IF              reduce using rule 22 (external -> EXTERNAL .)
    DEF             reduce using rule 22 (external -> EXTERNAL .)
    STRING          reduce using rule 22 (external -> EXTERNAL .)
    NUMBER          reduce using rule 22 (external -> EXTERNAL .)
    DO              reduce using rule 22 (external -> EXTERNAL .)
    EXTERNAL        reduce using rule 22 (external -> EXTERNAL .)
    ENUM            reduce using rule 22 (external -> EXTERNAL .)
    TYPE_IDENTIFIER reduce using rule 22 (external -> EXTERNAL .)
    $end            reduce using rule 22 (external -> EXTERNAL .)
    )               reduce using rule 22 (external -> EXTERNAL .)
    ,               reduce using rule 22 (external -> EXTERNAL .)
    ]               reduce using rule 22 (external -> EXTERNAL .)
    OF              reduce using rule 22 (external -> EXTERNAL .)
    THEN            reduce using rule 22 (external -> EXTERNAL .)
    END             reduce using rule 22 (external -> EXTERNAL .)
    ELIF            reduce using rule 22 (external -> EXTERNAL .)
    ELSE            reduce using rule 22 (external -> EXTERNAL .)


state 32

    (80) enum -> ENUM . type_identifier { _13_variant_repeat }
    (86) enum -> ENUM . type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 58

state 33

    (160) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    INT_DIV         reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    NUM_NOT_EQUAL   reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    |               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    %               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    *               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    /               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    +               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    CONCAT          reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    LET             reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    $end            reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    ]               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    OF              reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    THEN            reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 160 (type_identifier -> TYPE_IDENTIFIER .)


state 34

    (4) _1_expr_items -> _1_expr_items _1_expr_item .
    -               reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    (               reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    [               reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    IDENTIFIER      reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    LET             reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    CASE            reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    IF              reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    DEF             reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    STRING          reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    NUMBER          reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    DO              reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    EXTERNAL        reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    ENUM            reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    TYPE_IDENTIFIER reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)
    $end            reduce using rule 4 (_1_expr_items -> _1_expr_items _1_expr_item .)


state 35

    (142) call -> expr ( . _26_expr_optional _27_0x2c_expr_repeat )
    (143) _26_expr_optional -> . expr
    (144) _26_expr_optional -> .
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 144 (_26_expr_optional -> .)
    )               reduce using rule 144 (_26_expr_optional -> .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 59
    _26_expr_optional              shift and go to state 60
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 36

    (23) binary_expr -> expr INT_DIV . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 61
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 37

    (24) binary_expr -> expr NUM_NOT_EQUAL . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 62
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 38

    (25) binary_expr -> expr | . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 63
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 39

    (26) binary_expr -> expr > . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 64
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 40

    (27) binary_expr -> expr % . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 65
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 41

    (28) binary_expr -> expr < . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 66
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 42

    (29) binary_expr -> expr * . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 67
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 43

    (30) binary_expr -> expr / . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 68
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 44

    (31) binary_expr -> expr - . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 69
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 45

    (32) binary_expr -> expr + . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 70
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 46

    (33) binary_expr -> expr CONCAT . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 71
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 47

    (7) expr -> - expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 7 (expr -> - expr .)
    NUM_NOT_EQUAL   reduce using rule 7 (expr -> - expr .)
    |               reduce using rule 7 (expr -> - expr .)
    >               reduce using rule 7 (expr -> - expr .)
    %               reduce using rule 7 (expr -> - expr .)
    <               reduce using rule 7 (expr -> - expr .)
    *               reduce using rule 7 (expr -> - expr .)
    /               reduce using rule 7 (expr -> - expr .)
    -               reduce using rule 7 (expr -> - expr .)
    +               reduce using rule 7 (expr -> - expr .)
    CONCAT          reduce using rule 7 (expr -> - expr .)
    [               reduce using rule 7 (expr -> - expr .)
    IDENTIFIER      reduce using rule 7 (expr -> - expr .)
    LET             reduce using rule 7 (expr -> - expr .)
    CASE            reduce using rule 7 (expr -> - expr .)
    IF              reduce using rule 7 (expr -> - expr .)
    DEF             reduce using rule 7 (expr -> - expr .)
    STRING          reduce using rule 7 (expr -> - expr .)
    NUMBER          reduce using rule 7 (expr -> - expr .)
    DO              reduce using rule 7 (expr -> - expr .)
    EXTERNAL        reduce using rule 7 (expr -> - expr .)
    ENUM            reduce using rule 7 (expr -> - expr .)
    TYPE_IDENTIFIER reduce using rule 7 (expr -> - expr .)
    $end            reduce using rule 7 (expr -> - expr .)
    )               reduce using rule 7 (expr -> - expr .)
    ,               reduce using rule 7 (expr -> - expr .)
    ]               reduce using rule 7 (expr -> - expr .)
    OF              reduce using rule 7 (expr -> - expr .)
    THEN            reduce using rule 7 (expr -> - expr .)
    END             reduce using rule 7 (expr -> - expr .)
    ELIF            reduce using rule 7 (expr -> - expr .)
    ELSE            reduce using rule 7 (expr -> - expr .)
    (               shift and go to state 35


state 48

    (8) expr -> ( expr . )
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    )               shift and go to state 72
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 49

    (134) array -> [ _24_expr_optional . _25_0x2c_expr_repeat ]
    (137) _25_0x2c_expr_repeat -> . _25_0x2c_expr_items
    (138) _25_0x2c_expr_repeat -> .
    (139) _25_0x2c_expr_items -> . _25_0x2c_expr_items _25_0x2c_expr_item
    (140) _25_0x2c_expr_items -> . _25_0x2c_expr_item
    (141) _25_0x2c_expr_item -> . , expr
    ]               reduce using rule 138 (_25_0x2c_expr_repeat -> .)
    ,               shift and go to state 76

    _25_0x2c_expr_repeat           shift and go to state 73
    _25_0x2c_expr_items            shift and go to state 74
    _25_0x2c_expr_item             shift and go to state 75

state 50

    (135) _24_expr_optional -> expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 135 (_24_expr_optional -> expr .)
    ]               reduce using rule 135 (_24_expr_optional -> expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 51

    (151) variant_call -> type_identifier ( . _28_expr_optional _29_0x2c_expr_repeat )
    (152) _28_expr_optional -> . expr
    (153) _28_expr_optional -> .
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 153 (_28_expr_optional -> .)
    )               reduce using rule 153 (_28_expr_optional -> .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 22
    _28_expr_optional              shift and go to state 77
    expr                           shift and go to state 78
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20

state 52

    (161) variable_declaration -> LET identifier . _30_0x3a_type_optional = expr
    (162) _30_0x3a_type_optional -> . : type
    (163) _30_0x3a_type_optional -> .
    :               shift and go to state 80
    =               reduce using rule 163 (_30_0x3a_type_optional -> .)

    _30_0x3a_type_optional         shift and go to state 79

state 53

    (116) case_of -> CASE expr . OF _21_pattern_do_repeat END
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 81
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 54

    (107) if_expr -> IF expr . THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 82
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 55

    (48) def_expr -> DEF identifier . ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> DEF identifier . < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (               shift and go to state 83
    <               shift and go to state 84


state 56

    (34) do -> DO _2_0x3a_type_optional . _3_expr_repeat END
    (37) _3_expr_repeat -> . _3_expr_items
    (38) _3_expr_repeat -> .
    (39) _3_expr_items -> . _3_expr_items _3_expr_item
    (40) _3_expr_items -> . _3_expr_item
    (41) _3_expr_item -> . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 38 (_3_expr_repeat -> .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _3_expr_repeat                 shift and go to state 85
    _3_expr_items                  shift and go to state 86
    _3_expr_item                   shift and go to state 87
    expr                           shift and go to state 88
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 57

    (35) _2_0x3a_type_optional -> : . type
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 89
    type_identifier                shift and go to state 90

state 58

    (80) enum -> ENUM type_identifier . { _13_variant_repeat }
    (86) enum -> ENUM type_identifier . < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    {               shift and go to state 91
    <               shift and go to state 92


state 59

    (143) _26_expr_optional -> expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 143 (_26_expr_optional -> expr .)
    )               reduce using rule 143 (_26_expr_optional -> expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 60

    (142) call -> expr ( _26_expr_optional . _27_0x2c_expr_repeat )
    (145) _27_0x2c_expr_repeat -> . _27_0x2c_expr_items
    (146) _27_0x2c_expr_repeat -> .
    (147) _27_0x2c_expr_items -> . _27_0x2c_expr_items _27_0x2c_expr_item
    (148) _27_0x2c_expr_items -> . _27_0x2c_expr_item
    (149) _27_0x2c_expr_item -> . , expr
    )               reduce using rule 146 (_27_0x2c_expr_repeat -> .)
    ,               shift and go to state 96

    _27_0x2c_expr_repeat           shift and go to state 93
    _27_0x2c_expr_items            shift and go to state 94
    _27_0x2c_expr_item             shift and go to state 95

state 61

    (23) binary_expr -> expr INT_DIV expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    NUM_NOT_EQUAL   reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    |               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    %               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    [               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    IDENTIFIER      reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    LET             reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    CASE            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    IF              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    DEF             reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    STRING          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    NUMBER          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    DO              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    EXTERNAL        reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ENUM            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    TYPE_IDENTIFIER reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    (               shift and go to state 35


state 62

    (24) binary_expr -> expr NUM_NOT_EQUAL expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    NUM_NOT_EQUAL   reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    [               reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    IDENTIFIER      reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    LET             reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    CASE            reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    IF              reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    DEF             reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    STRING          reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    NUMBER          reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    DO              reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    EXTERNAL        reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ENUM            reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    TYPE_IDENTIFIER reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    $end            reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    )               reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ,               reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ]               reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    OF              reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    THEN            reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    END             reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ELIF            reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ELSE            reduce using rule 24 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 63

    (25) binary_expr -> expr | expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    NUM_NOT_EQUAL   reduce using rule 25 (binary_expr -> expr | expr .)
    |               reduce using rule 25 (binary_expr -> expr | expr .)
    >               reduce using rule 25 (binary_expr -> expr | expr .)
    <               reduce using rule 25 (binary_expr -> expr | expr .)
    -               reduce using rule 25 (binary_expr -> expr | expr .)
    +               reduce using rule 25 (binary_expr -> expr | expr .)
    CONCAT          reduce using rule 25 (binary_expr -> expr | expr .)
    [               reduce using rule 25 (binary_expr -> expr | expr .)
    IDENTIFIER      reduce using rule 25 (binary_expr -> expr | expr .)
    LET             reduce using rule 25 (binary_expr -> expr | expr .)
    CASE            reduce using rule 25 (binary_expr -> expr | expr .)
    IF              reduce using rule 25 (binary_expr -> expr | expr .)
    DEF             reduce using rule 25 (binary_expr -> expr | expr .)
    STRING          reduce using rule 25 (binary_expr -> expr | expr .)
    NUMBER          reduce using rule 25 (binary_expr -> expr | expr .)
    DO              reduce using rule 25 (binary_expr -> expr | expr .)
    EXTERNAL        reduce using rule 25 (binary_expr -> expr | expr .)
    ENUM            reduce using rule 25 (binary_expr -> expr | expr .)
    TYPE_IDENTIFIER reduce using rule 25 (binary_expr -> expr | expr .)
    $end            reduce using rule 25 (binary_expr -> expr | expr .)
    )               reduce using rule 25 (binary_expr -> expr | expr .)
    ,               reduce using rule 25 (binary_expr -> expr | expr .)
    ]               reduce using rule 25 (binary_expr -> expr | expr .)
    OF              reduce using rule 25 (binary_expr -> expr | expr .)
    THEN            reduce using rule 25 (binary_expr -> expr | expr .)
    END             reduce using rule 25 (binary_expr -> expr | expr .)
    ELIF            reduce using rule 25 (binary_expr -> expr | expr .)
    ELSE            reduce using rule 25 (binary_expr -> expr | expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    %               shift and go to state 40
    *               shift and go to state 42
    /               shift and go to state 43


state 64

    (26) binary_expr -> expr > expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    NUM_NOT_EQUAL   reduce using rule 26 (binary_expr -> expr > expr .)
    >               reduce using rule 26 (binary_expr -> expr > expr .)
    <               reduce using rule 26 (binary_expr -> expr > expr .)
    [               reduce using rule 26 (binary_expr -> expr > expr .)
    IDENTIFIER      reduce using rule 26 (binary_expr -> expr > expr .)
    LET             reduce using rule 26 (binary_expr -> expr > expr .)
    CASE            reduce using rule 26 (binary_expr -> expr > expr .)
    IF              reduce using rule 26 (binary_expr -> expr > expr .)
    DEF             reduce using rule 26 (binary_expr -> expr > expr .)
    STRING          reduce using rule 26 (binary_expr -> expr > expr .)
    NUMBER          reduce using rule 26 (binary_expr -> expr > expr .)
    DO              reduce using rule 26 (binary_expr -> expr > expr .)
    EXTERNAL        reduce using rule 26 (binary_expr -> expr > expr .)
    ENUM            reduce using rule 26 (binary_expr -> expr > expr .)
    TYPE_IDENTIFIER reduce using rule 26 (binary_expr -> expr > expr .)
    $end            reduce using rule 26 (binary_expr -> expr > expr .)
    )               reduce using rule 26 (binary_expr -> expr > expr .)
    ,               reduce using rule 26 (binary_expr -> expr > expr .)
    ]               reduce using rule 26 (binary_expr -> expr > expr .)
    OF              reduce using rule 26 (binary_expr -> expr > expr .)
    THEN            reduce using rule 26 (binary_expr -> expr > expr .)
    END             reduce using rule 26 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr > expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    |               shift and go to state 38
    %               shift and go to state 40
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 65

    (27) binary_expr -> expr % expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 27 (binary_expr -> expr % expr .)
    NUM_NOT_EQUAL   reduce using rule 27 (binary_expr -> expr % expr .)
    |               reduce using rule 27 (binary_expr -> expr % expr .)
    >               reduce using rule 27 (binary_expr -> expr % expr .)
    %               reduce using rule 27 (binary_expr -> expr % expr .)
    <               reduce using rule 27 (binary_expr -> expr % expr .)
    *               reduce using rule 27 (binary_expr -> expr % expr .)
    /               reduce using rule 27 (binary_expr -> expr % expr .)
    -               reduce using rule 27 (binary_expr -> expr % expr .)
    +               reduce using rule 27 (binary_expr -> expr % expr .)
    CONCAT          reduce using rule 27 (binary_expr -> expr % expr .)
    [               reduce using rule 27 (binary_expr -> expr % expr .)
    IDENTIFIER      reduce using rule 27 (binary_expr -> expr % expr .)
    LET             reduce using rule 27 (binary_expr -> expr % expr .)
    CASE            reduce using rule 27 (binary_expr -> expr % expr .)
    IF              reduce using rule 27 (binary_expr -> expr % expr .)
    DEF             reduce using rule 27 (binary_expr -> expr % expr .)
    STRING          reduce using rule 27 (binary_expr -> expr % expr .)
    NUMBER          reduce using rule 27 (binary_expr -> expr % expr .)
    DO              reduce using rule 27 (binary_expr -> expr % expr .)
    EXTERNAL        reduce using rule 27 (binary_expr -> expr % expr .)
    ENUM            reduce using rule 27 (binary_expr -> expr % expr .)
    TYPE_IDENTIFIER reduce using rule 27 (binary_expr -> expr % expr .)
    $end            reduce using rule 27 (binary_expr -> expr % expr .)
    )               reduce using rule 27 (binary_expr -> expr % expr .)
    ,               reduce using rule 27 (binary_expr -> expr % expr .)
    ]               reduce using rule 27 (binary_expr -> expr % expr .)
    OF              reduce using rule 27 (binary_expr -> expr % expr .)
    THEN            reduce using rule 27 (binary_expr -> expr % expr .)
    END             reduce using rule 27 (binary_expr -> expr % expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr % expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr % expr .)
    (               shift and go to state 35


state 66

    (28) binary_expr -> expr < expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    NUM_NOT_EQUAL   reduce using rule 28 (binary_expr -> expr < expr .)
    >               reduce using rule 28 (binary_expr -> expr < expr .)
    <               reduce using rule 28 (binary_expr -> expr < expr .)
    [               reduce using rule 28 (binary_expr -> expr < expr .)
    IDENTIFIER      reduce using rule 28 (binary_expr -> expr < expr .)
    LET             reduce using rule 28 (binary_expr -> expr < expr .)
    CASE            reduce using rule 28 (binary_expr -> expr < expr .)
    IF              reduce using rule 28 (binary_expr -> expr < expr .)
    DEF             reduce using rule 28 (binary_expr -> expr < expr .)
    STRING          reduce using rule 28 (binary_expr -> expr < expr .)
    NUMBER          reduce using rule 28 (binary_expr -> expr < expr .)
    DO              reduce using rule 28 (binary_expr -> expr < expr .)
    EXTERNAL        reduce using rule 28 (binary_expr -> expr < expr .)
    ENUM            reduce using rule 28 (binary_expr -> expr < expr .)
    TYPE_IDENTIFIER reduce using rule 28 (binary_expr -> expr < expr .)
    $end            reduce using rule 28 (binary_expr -> expr < expr .)
    )               reduce using rule 28 (binary_expr -> expr < expr .)
    ,               reduce using rule 28 (binary_expr -> expr < expr .)
    ]               reduce using rule 28 (binary_expr -> expr < expr .)
    OF              reduce using rule 28 (binary_expr -> expr < expr .)
    THEN            reduce using rule 28 (binary_expr -> expr < expr .)
    END             reduce using rule 28 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr < expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    |               shift and go to state 38
    %               shift and go to state 40
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 67

    (29) binary_expr -> expr * expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 29 (binary_expr -> expr * expr .)
    NUM_NOT_EQUAL   reduce using rule 29 (binary_expr -> expr * expr .)
    |               reduce using rule 29 (binary_expr -> expr * expr .)
    >               reduce using rule 29 (binary_expr -> expr * expr .)
    %               reduce using rule 29 (binary_expr -> expr * expr .)
    <               reduce using rule 29 (binary_expr -> expr * expr .)
    *               reduce using rule 29 (binary_expr -> expr * expr .)
    /               reduce using rule 29 (binary_expr -> expr * expr .)
    -               reduce using rule 29 (binary_expr -> expr * expr .)
    +               reduce using rule 29 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 29 (binary_expr -> expr * expr .)
    [               reduce using rule 29 (binary_expr -> expr * expr .)
    IDENTIFIER      reduce using rule 29 (binary_expr -> expr * expr .)
    LET             reduce using rule 29 (binary_expr -> expr * expr .)
    CASE            reduce using rule 29 (binary_expr -> expr * expr .)
    IF              reduce using rule 29 (binary_expr -> expr * expr .)
    DEF             reduce using rule 29 (binary_expr -> expr * expr .)
    STRING          reduce using rule 29 (binary_expr -> expr * expr .)
    NUMBER          reduce using rule 29 (binary_expr -> expr * expr .)
    DO              reduce using rule 29 (binary_expr -> expr * expr .)
    EXTERNAL        reduce using rule 29 (binary_expr -> expr * expr .)
    ENUM            reduce using rule 29 (binary_expr -> expr * expr .)
    TYPE_IDENTIFIER reduce using rule 29 (binary_expr -> expr * expr .)
    $end            reduce using rule 29 (binary_expr -> expr * expr .)
    )               reduce using rule 29 (binary_expr -> expr * expr .)
    ,               reduce using rule 29 (binary_expr -> expr * expr .)
    ]               reduce using rule 29 (binary_expr -> expr * expr .)
    OF              reduce using rule 29 (binary_expr -> expr * expr .)
    THEN            reduce using rule 29 (binary_expr -> expr * expr .)
    END             reduce using rule 29 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr * expr .)
    (               shift and go to state 35


state 68

    (30) binary_expr -> expr / expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 30 (binary_expr -> expr / expr .)
    NUM_NOT_EQUAL   reduce using rule 30 (binary_expr -> expr / expr .)
    |               reduce using rule 30 (binary_expr -> expr / expr .)
    >               reduce using rule 30 (binary_expr -> expr / expr .)
    %               reduce using rule 30 (binary_expr -> expr / expr .)
    <               reduce using rule 30 (binary_expr -> expr / expr .)
    *               reduce using rule 30 (binary_expr -> expr / expr .)
    /               reduce using rule 30 (binary_expr -> expr / expr .)
    -               reduce using rule 30 (binary_expr -> expr / expr .)
    +               reduce using rule 30 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 30 (binary_expr -> expr / expr .)
    [               reduce using rule 30 (binary_expr -> expr / expr .)
    IDENTIFIER      reduce using rule 30 (binary_expr -> expr / expr .)
    LET             reduce using rule 30 (binary_expr -> expr / expr .)
    CASE            reduce using rule 30 (binary_expr -> expr / expr .)
    IF              reduce using rule 30 (binary_expr -> expr / expr .)
    DEF             reduce using rule 30 (binary_expr -> expr / expr .)
    STRING          reduce using rule 30 (binary_expr -> expr / expr .)
    NUMBER          reduce using rule 30 (binary_expr -> expr / expr .)
    DO              reduce using rule 30 (binary_expr -> expr / expr .)
    EXTERNAL        reduce using rule 30 (binary_expr -> expr / expr .)
    ENUM            reduce using rule 30 (binary_expr -> expr / expr .)
    TYPE_IDENTIFIER reduce using rule 30 (binary_expr -> expr / expr .)
    $end            reduce using rule 30 (binary_expr -> expr / expr .)
    )               reduce using rule 30 (binary_expr -> expr / expr .)
    ,               reduce using rule 30 (binary_expr -> expr / expr .)
    ]               reduce using rule 30 (binary_expr -> expr / expr .)
    OF              reduce using rule 30 (binary_expr -> expr / expr .)
    THEN            reduce using rule 30 (binary_expr -> expr / expr .)
    END             reduce using rule 30 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr / expr .)
    (               shift and go to state 35


state 69

    (31) binary_expr -> expr - expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    NUM_NOT_EQUAL   reduce using rule 31 (binary_expr -> expr - expr .)
    |               reduce using rule 31 (binary_expr -> expr - expr .)
    >               reduce using rule 31 (binary_expr -> expr - expr .)
    <               reduce using rule 31 (binary_expr -> expr - expr .)
    -               reduce using rule 31 (binary_expr -> expr - expr .)
    +               reduce using rule 31 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 31 (binary_expr -> expr - expr .)
    [               reduce using rule 31 (binary_expr -> expr - expr .)
    IDENTIFIER      reduce using rule 31 (binary_expr -> expr - expr .)
    LET             reduce using rule 31 (binary_expr -> expr - expr .)
    CASE            reduce using rule 31 (binary_expr -> expr - expr .)
    IF              reduce using rule 31 (binary_expr -> expr - expr .)
    DEF             reduce using rule 31 (binary_expr -> expr - expr .)
    STRING          reduce using rule 31 (binary_expr -> expr - expr .)
    NUMBER          reduce using rule 31 (binary_expr -> expr - expr .)
    DO              reduce using rule 31 (binary_expr -> expr - expr .)
    EXTERNAL        reduce using rule 31 (binary_expr -> expr - expr .)
    ENUM            reduce using rule 31 (binary_expr -> expr - expr .)
    TYPE_IDENTIFIER reduce using rule 31 (binary_expr -> expr - expr .)
    $end            reduce using rule 31 (binary_expr -> expr - expr .)
    )               reduce using rule 31 (binary_expr -> expr - expr .)
    ,               reduce using rule 31 (binary_expr -> expr - expr .)
    ]               reduce using rule 31 (binary_expr -> expr - expr .)
    OF              reduce using rule 31 (binary_expr -> expr - expr .)
    THEN            reduce using rule 31 (binary_expr -> expr - expr .)
    END             reduce using rule 31 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr - expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    %               shift and go to state 40
    *               shift and go to state 42
    /               shift and go to state 43


state 70

    (32) binary_expr -> expr + expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    NUM_NOT_EQUAL   reduce using rule 32 (binary_expr -> expr + expr .)
    |               reduce using rule 32 (binary_expr -> expr + expr .)
    >               reduce using rule 32 (binary_expr -> expr + expr .)
    <               reduce using rule 32 (binary_expr -> expr + expr .)
    -               reduce using rule 32 (binary_expr -> expr + expr .)
    +               reduce using rule 32 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 32 (binary_expr -> expr + expr .)
    [               reduce using rule 32 (binary_expr -> expr + expr .)
    IDENTIFIER      reduce using rule 32 (binary_expr -> expr + expr .)
    LET             reduce using rule 32 (binary_expr -> expr + expr .)
    CASE            reduce using rule 32 (binary_expr -> expr + expr .)
    IF              reduce using rule 32 (binary_expr -> expr + expr .)
    DEF             reduce using rule 32 (binary_expr -> expr + expr .)
    STRING          reduce using rule 32 (binary_expr -> expr + expr .)
    NUMBER          reduce using rule 32 (binary_expr -> expr + expr .)
    DO              reduce using rule 32 (binary_expr -> expr + expr .)
    EXTERNAL        reduce using rule 32 (binary_expr -> expr + expr .)
    ENUM            reduce using rule 32 (binary_expr -> expr + expr .)
    TYPE_IDENTIFIER reduce using rule 32 (binary_expr -> expr + expr .)
    $end            reduce using rule 32 (binary_expr -> expr + expr .)
    )               reduce using rule 32 (binary_expr -> expr + expr .)
    ,               reduce using rule 32 (binary_expr -> expr + expr .)
    ]               reduce using rule 32 (binary_expr -> expr + expr .)
    OF              reduce using rule 32 (binary_expr -> expr + expr .)
    THEN            reduce using rule 32 (binary_expr -> expr + expr .)
    END             reduce using rule 32 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr + expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    %               shift and go to state 40
    *               shift and go to state 42
    /               shift and go to state 43


state 71

    (33) binary_expr -> expr CONCAT expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    NUM_NOT_EQUAL   reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    |               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    -               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    +               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    [               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    IDENTIFIER      reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    LET             reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    CASE            reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    IF              reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    DEF             reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    STRING          reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    NUMBER          reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    DO              reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    EXTERNAL        reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    ENUM            reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    TYPE_IDENTIFIER reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    %               shift and go to state 40
    *               shift and go to state 42
    /               shift and go to state 43


state 72

    (8) expr -> ( expr ) .
    (               reduce using rule 8 (expr -> ( expr ) .)
    INT_DIV         reduce using rule 8 (expr -> ( expr ) .)
    NUM_NOT_EQUAL   reduce using rule 8 (expr -> ( expr ) .)
    |               reduce using rule 8 (expr -> ( expr ) .)
    >               reduce using rule 8 (expr -> ( expr ) .)
    %               reduce using rule 8 (expr -> ( expr ) .)
    <               reduce using rule 8 (expr -> ( expr ) .)
    *               reduce using rule 8 (expr -> ( expr ) .)
    /               reduce using rule 8 (expr -> ( expr ) .)
    -               reduce using rule 8 (expr -> ( expr ) .)
    +               reduce using rule 8 (expr -> ( expr ) .)
    CONCAT          reduce using rule 8 (expr -> ( expr ) .)
    [               reduce using rule 8 (expr -> ( expr ) .)
    IDENTIFIER      reduce using rule 8 (expr -> ( expr ) .)
    LET             reduce using rule 8 (expr -> ( expr ) .)
    CASE            reduce using rule 8 (expr -> ( expr ) .)
    IF              reduce using rule 8 (expr -> ( expr ) .)
    DEF             reduce using rule 8 (expr -> ( expr ) .)
    STRING          reduce using rule 8 (expr -> ( expr ) .)
    NUMBER          reduce using rule 8 (expr -> ( expr ) .)
    DO              reduce using rule 8 (expr -> ( expr ) .)
    EXTERNAL        reduce using rule 8 (expr -> ( expr ) .)
    ENUM            reduce using rule 8 (expr -> ( expr ) .)
    TYPE_IDENTIFIER reduce using rule 8 (expr -> ( expr ) .)
    $end            reduce using rule 8 (expr -> ( expr ) .)
    )               reduce using rule 8 (expr -> ( expr ) .)
    ,               reduce using rule 8 (expr -> ( expr ) .)
    ]               reduce using rule 8 (expr -> ( expr ) .)
    OF              reduce using rule 8 (expr -> ( expr ) .)
    THEN            reduce using rule 8 (expr -> ( expr ) .)
    END             reduce using rule 8 (expr -> ( expr ) .)
    ELIF            reduce using rule 8 (expr -> ( expr ) .)
    ELSE            reduce using rule 8 (expr -> ( expr ) .)


state 73

    (134) array -> [ _24_expr_optional _25_0x2c_expr_repeat . ]
    ]               shift and go to state 97


state 74

    (137) _25_0x2c_expr_repeat -> _25_0x2c_expr_items .
    (139) _25_0x2c_expr_items -> _25_0x2c_expr_items . _25_0x2c_expr_item
    (141) _25_0x2c_expr_item -> . , expr
    ]               reduce using rule 137 (_25_0x2c_expr_repeat -> _25_0x2c_expr_items .)
    ,               shift and go to state 76

    _25_0x2c_expr_item             shift and go to state 98

state 75

    (140) _25_0x2c_expr_items -> _25_0x2c_expr_item .
    ,               reduce using rule 140 (_25_0x2c_expr_items -> _25_0x2c_expr_item .)
    ]               reduce using rule 140 (_25_0x2c_expr_items -> _25_0x2c_expr_item .)


state 76

    (141) _25_0x2c_expr_item -> , . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 99
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 77

    (151) variant_call -> type_identifier ( _28_expr_optional . _29_0x2c_expr_repeat )
    (154) _29_0x2c_expr_repeat -> . _29_0x2c_expr_items
    (155) _29_0x2c_expr_repeat -> .
    (156) _29_0x2c_expr_items -> . _29_0x2c_expr_items _29_0x2c_expr_item
    (157) _29_0x2c_expr_items -> . _29_0x2c_expr_item
    (158) _29_0x2c_expr_item -> . , expr
    )               reduce using rule 155 (_29_0x2c_expr_repeat -> .)
    ,               shift and go to state 103

    _29_0x2c_expr_repeat           shift and go to state 100
    _29_0x2c_expr_items            shift and go to state 101
    _29_0x2c_expr_item             shift and go to state 102

state 78

    (152) _28_expr_optional -> expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 152 (_28_expr_optional -> expr .)
    )               reduce using rule 152 (_28_expr_optional -> expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 79

    (161) variable_declaration -> LET identifier _30_0x3a_type_optional . = expr
    =               shift and go to state 104


state 80

    (162) _30_0x3a_type_optional -> : . type
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 105
    type_identifier                shift and go to state 90

state 81

    (116) case_of -> CASE expr OF . _21_pattern_do_repeat END
    (117) _21_pattern_do_repeat -> . _21_pattern_do_items
    (118) _21_pattern_do_repeat -> .
    (119) _21_pattern_do_items -> . _21_pattern_do_items _21_pattern_do_item
    (120) _21_pattern_do_items -> . _21_pattern_do_item
    (121) _21_pattern_do_item -> . pattern do
    (122) pattern -> . match_variant
    (123) pattern -> . match_as
    (125) match_variant -> . type_identifier
    (126) match_variant -> . type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat )
    (124) match_as -> . identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    (159) identifier -> . IDENTIFIER
    END             reduce using rule 118 (_21_pattern_do_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 23

    _21_pattern_do_repeat          shift and go to state 106
    _21_pattern_do_items           shift and go to state 107
    _21_pattern_do_item            shift and go to state 108
    pattern                        shift and go to state 109
    match_variant                  shift and go to state 110
    match_as                       shift and go to state 111
    type_identifier                shift and go to state 112
    identifier                     shift and go to state 113

state 82

    (107) if_expr -> IF expr THEN . _18_0x3a_type_optional block_statement _19_or_else_optional END
    (108) _18_0x3a_type_optional -> . : type
    (109) _18_0x3a_type_optional -> .
    :               shift and go to state 115
    -               reduce using rule 109 (_18_0x3a_type_optional -> .)
    (               reduce using rule 109 (_18_0x3a_type_optional -> .)
    [               reduce using rule 109 (_18_0x3a_type_optional -> .)
    IDENTIFIER      reduce using rule 109 (_18_0x3a_type_optional -> .)
    LET             reduce using rule 109 (_18_0x3a_type_optional -> .)
    CASE            reduce using rule 109 (_18_0x3a_type_optional -> .)
    IF              reduce using rule 109 (_18_0x3a_type_optional -> .)
    DEF             reduce using rule 109 (_18_0x3a_type_optional -> .)
    STRING          reduce using rule 109 (_18_0x3a_type_optional -> .)
    NUMBER          reduce using rule 109 (_18_0x3a_type_optional -> .)
    DO              reduce using rule 109 (_18_0x3a_type_optional -> .)
    EXTERNAL        reduce using rule 109 (_18_0x3a_type_optional -> .)
    ENUM            reduce using rule 109 (_18_0x3a_type_optional -> .)
    TYPE_IDENTIFIER reduce using rule 109 (_18_0x3a_type_optional -> .)
    ELIF            reduce using rule 109 (_18_0x3a_type_optional -> .)
    ELSE            reduce using rule 109 (_18_0x3a_type_optional -> .)
    END             reduce using rule 109 (_18_0x3a_type_optional -> .)

    _18_0x3a_type_optional         shift and go to state 114

state 83

    (48) def_expr -> DEF identifier ( . _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (49) _5_param_optional -> . param
    (50) _5_param_optional -> .
    (104) param -> . identifier _17_0x3a_type_optional
    (159) identifier -> . IDENTIFIER
    ,               reduce using rule 50 (_5_param_optional -> .)
    )               reduce using rule 50 (_5_param_optional -> .)
    IDENTIFIER      shift and go to state 23

    identifier                     shift and go to state 116
    _5_param_optional              shift and go to state 117
    param                          shift and go to state 118

state 84

    (58) def_expr -> DEF identifier < . type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 119

state 85

    (34) do -> DO _2_0x3a_type_optional _3_expr_repeat . END
    END             shift and go to state 120


state 86

    (37) _3_expr_repeat -> _3_expr_items .
    (39) _3_expr_items -> _3_expr_items . _3_expr_item
    (41) _3_expr_item -> . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 37 (_3_expr_repeat -> _3_expr_items .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _3_expr_item                   shift and go to state 121
    expr                           shift and go to state 88
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 87

    (40) _3_expr_items -> _3_expr_item .
    -               reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    (               reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    [               reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    IDENTIFIER      reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    LET             reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    CASE            reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    IF              reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    DEF             reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    STRING          reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    NUMBER          reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    DO              reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    EXTERNAL        reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    ENUM            reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    TYPE_IDENTIFIER reduce using rule 40 (_3_expr_items -> _3_expr_item .)
    END             reduce using rule 40 (_3_expr_items -> _3_expr_item .)


state 88

    (41) _3_expr_item -> expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    [               reduce using rule 41 (_3_expr_item -> expr .)
    IDENTIFIER      reduce using rule 41 (_3_expr_item -> expr .)
    LET             reduce using rule 41 (_3_expr_item -> expr .)
    CASE            reduce using rule 41 (_3_expr_item -> expr .)
    IF              reduce using rule 41 (_3_expr_item -> expr .)
    DEF             reduce using rule 41 (_3_expr_item -> expr .)
    STRING          reduce using rule 41 (_3_expr_item -> expr .)
    NUMBER          reduce using rule 41 (_3_expr_item -> expr .)
    DO              reduce using rule 41 (_3_expr_item -> expr .)
    EXTERNAL        reduce using rule 41 (_3_expr_item -> expr .)
    ENUM            reduce using rule 41 (_3_expr_item -> expr .)
    TYPE_IDENTIFIER reduce using rule 41 (_3_expr_item -> expr .)
    END             reduce using rule 41 (_3_expr_item -> expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 89

    (35) _2_0x3a_type_optional -> : type .
    -               reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    (               reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    [               reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    LET             reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    CASE            reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    IF              reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    DEF             reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    STRING          reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    NUMBER          reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    DO              reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 35 (_2_0x3a_type_optional -> : type .)
    END             reduce using rule 35 (_2_0x3a_type_optional -> : type .)


state 90

    (73) type -> type_identifier . < type _12_0x2c_type_repeat >
    (79) type -> type_identifier .
    <               shift and go to state 122
    -               reduce using rule 79 (type -> type_identifier .)
    (               reduce using rule 79 (type -> type_identifier .)
    [               reduce using rule 79 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 79 (type -> type_identifier .)
    LET             reduce using rule 79 (type -> type_identifier .)
    CASE            reduce using rule 79 (type -> type_identifier .)
    IF              reduce using rule 79 (type -> type_identifier .)
    DEF             reduce using rule 79 (type -> type_identifier .)
    STRING          reduce using rule 79 (type -> type_identifier .)
    NUMBER          reduce using rule 79 (type -> type_identifier .)
    DO              reduce using rule 79 (type -> type_identifier .)
    EXTERNAL        reduce using rule 79 (type -> type_identifier .)
    ENUM            reduce using rule 79 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 79 (type -> type_identifier .)
    END             reduce using rule 79 (type -> type_identifier .)
    =               reduce using rule 79 (type -> type_identifier .)
    ELIF            reduce using rule 79 (type -> type_identifier .)
    ELSE            reduce using rule 79 (type -> type_identifier .)
    ,               reduce using rule 79 (type -> type_identifier .)
    >               reduce using rule 79 (type -> type_identifier .)
    )               reduce using rule 79 (type -> type_identifier .)


state 91

    (80) enum -> ENUM type_identifier { . _13_variant_repeat }
    (81) _13_variant_repeat -> . _13_variant_items
    (82) _13_variant_repeat -> .
    (83) _13_variant_items -> . _13_variant_items _13_variant_item
    (84) _13_variant_items -> . _13_variant_item
    (85) _13_variant_item -> . variant
    (97) variant -> . type_identifier
    (98) variant -> . type_identifier ( type _16_0x2c_type_repeat )
    (160) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 82 (_13_variant_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 123
    _13_variant_repeat             shift and go to state 124
    _13_variant_items              shift and go to state 125
    _13_variant_item               shift and go to state 126
    variant                        shift and go to state 127

state 92

    (86) enum -> ENUM type_identifier < . type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 128

state 93

    (142) call -> expr ( _26_expr_optional _27_0x2c_expr_repeat . )
    )               shift and go to state 129


state 94

    (145) _27_0x2c_expr_repeat -> _27_0x2c_expr_items .
    (147) _27_0x2c_expr_items -> _27_0x2c_expr_items . _27_0x2c_expr_item
    (149) _27_0x2c_expr_item -> . , expr
    )               reduce using rule 145 (_27_0x2c_expr_repeat -> _27_0x2c_expr_items .)
    ,               shift and go to state 96

    _27_0x2c_expr_item             shift and go to state 130

state 95

    (148) _27_0x2c_expr_items -> _27_0x2c_expr_item .
    ,               reduce using rule 148 (_27_0x2c_expr_items -> _27_0x2c_expr_item .)
    )               reduce using rule 148 (_27_0x2c_expr_items -> _27_0x2c_expr_item .)


state 96

    (149) _27_0x2c_expr_item -> , . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 131
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 97

    (134) array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .
    (               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    INT_DIV         reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    NUM_NOT_EQUAL   reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    |               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    >               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    %               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    <               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    *               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    /               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    -               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    +               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    CONCAT          reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    [               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    IDENTIFIER      reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    LET             reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    CASE            reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    IF              reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    DEF             reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    STRING          reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    NUMBER          reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    DO              reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    EXTERNAL        reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    ENUM            reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    TYPE_IDENTIFIER reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    $end            reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    )               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    ,               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    ]               reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    OF              reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    THEN            reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    END             reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    ELIF            reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)
    ELSE            reduce using rule 134 (array -> [ _24_expr_optional _25_0x2c_expr_repeat ] .)


state 98

    (139) _25_0x2c_expr_items -> _25_0x2c_expr_items _25_0x2c_expr_item .
    ,               reduce using rule 139 (_25_0x2c_expr_items -> _25_0x2c_expr_items _25_0x2c_expr_item .)
    ]               reduce using rule 139 (_25_0x2c_expr_items -> _25_0x2c_expr_items _25_0x2c_expr_item .)


state 99

    (141) _25_0x2c_expr_item -> , expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 141 (_25_0x2c_expr_item -> , expr .)
    ]               reduce using rule 141 (_25_0x2c_expr_item -> , expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 100

    (151) variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat . )
    )               shift and go to state 132


state 101

    (154) _29_0x2c_expr_repeat -> _29_0x2c_expr_items .
    (156) _29_0x2c_expr_items -> _29_0x2c_expr_items . _29_0x2c_expr_item
    (158) _29_0x2c_expr_item -> . , expr
    )               reduce using rule 154 (_29_0x2c_expr_repeat -> _29_0x2c_expr_items .)
    ,               shift and go to state 103

    _29_0x2c_expr_item             shift and go to state 133

state 102

    (157) _29_0x2c_expr_items -> _29_0x2c_expr_item .
    ,               reduce using rule 157 (_29_0x2c_expr_items -> _29_0x2c_expr_item .)
    )               reduce using rule 157 (_29_0x2c_expr_items -> _29_0x2c_expr_item .)


state 103

    (158) _29_0x2c_expr_item -> , . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 134
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 104

    (161) variable_declaration -> LET identifier _30_0x3a_type_optional = . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    identifier                     shift and go to state 10
    expr                           shift and go to state 135
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 105

    (162) _30_0x3a_type_optional -> : type .
    =               reduce using rule 162 (_30_0x3a_type_optional -> : type .)


state 106

    (116) case_of -> CASE expr OF _21_pattern_do_repeat . END
    END             shift and go to state 136


state 107

    (117) _21_pattern_do_repeat -> _21_pattern_do_items .
    (119) _21_pattern_do_items -> _21_pattern_do_items . _21_pattern_do_item
    (121) _21_pattern_do_item -> . pattern do
    (122) pattern -> . match_variant
    (123) pattern -> . match_as
    (125) match_variant -> . type_identifier
    (126) match_variant -> . type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat )
    (124) match_as -> . identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    (159) identifier -> . IDENTIFIER
    END             reduce using rule 117 (_21_pattern_do_repeat -> _21_pattern_do_items .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 23

    _21_pattern_do_item            shift and go to state 137
    pattern                        shift and go to state 109
    match_variant                  shift and go to state 110
    match_as                       shift and go to state 111
    type_identifier                shift and go to state 112
    identifier                     shift and go to state 113

state 108

    (120) _21_pattern_do_items -> _21_pattern_do_item .
    TYPE_IDENTIFIER reduce using rule 120 (_21_pattern_do_items -> _21_pattern_do_item .)
    IDENTIFIER      reduce using rule 120 (_21_pattern_do_items -> _21_pattern_do_item .)
    END             reduce using rule 120 (_21_pattern_do_items -> _21_pattern_do_item .)


state 109

    (121) _21_pattern_do_item -> pattern . do
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    DO              shift and go to state 30

    do                             shift and go to state 138

state 110

    (122) pattern -> match_variant .
    DO              reduce using rule 122 (pattern -> match_variant .)
    ,               reduce using rule 122 (pattern -> match_variant .)
    )               reduce using rule 122 (pattern -> match_variant .)


state 111

    (123) pattern -> match_as .
    DO              reduce using rule 123 (pattern -> match_as .)
    ,               reduce using rule 123 (pattern -> match_as .)
    )               reduce using rule 123 (pattern -> match_as .)


state 112

    (125) match_variant -> type_identifier .
    (126) match_variant -> type_identifier . ( _22_pattern_optional _23_0x2c_pattern_repeat )
    DO              reduce using rule 125 (match_variant -> type_identifier .)
    ,               reduce using rule 125 (match_variant -> type_identifier .)
    )               reduce using rule 125 (match_variant -> type_identifier .)
    (               shift and go to state 139


state 113

    (124) match_as -> identifier .
    DO              reduce using rule 124 (match_as -> identifier .)
    ,               reduce using rule 124 (match_as -> identifier .)
    )               reduce using rule 124 (match_as -> identifier .)


state 114

    (107) if_expr -> IF expr THEN _18_0x3a_type_optional . block_statement _19_or_else_optional END
    (42) block_statement -> . _4_expr_repeat
    (43) _4_expr_repeat -> . _4_expr_items
    (44) _4_expr_repeat -> .
    (45) _4_expr_items -> . _4_expr_items _4_expr_item
    (46) _4_expr_items -> . _4_expr_item
    (47) _4_expr_item -> . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 44 (_4_expr_repeat -> .)
    ELSE            reduce using rule 44 (_4_expr_repeat -> .)
    END             reduce using rule 44 (_4_expr_repeat -> .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 140
    block_statement                shift and go to state 141
    _4_expr_repeat                 shift and go to state 142
    _4_expr_items                  shift and go to state 143
    _4_expr_item                   shift and go to state 144
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 115

    (108) _18_0x3a_type_optional -> : . type
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 145
    type_identifier                shift and go to state 90

state 116

    (104) param -> identifier . _17_0x3a_type_optional
    (105) _17_0x3a_type_optional -> . : type
    (106) _17_0x3a_type_optional -> .
    :               shift and go to state 147
    ,               reduce using rule 106 (_17_0x3a_type_optional -> .)
    )               reduce using rule 106 (_17_0x3a_type_optional -> .)

    _17_0x3a_type_optional         shift and go to state 146

state 117

    (48) def_expr -> DEF identifier ( _5_param_optional . _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (51) _6_0x2c_param_repeat -> . _6_0x2c_param_items
    (52) _6_0x2c_param_repeat -> .
    (53) _6_0x2c_param_items -> . _6_0x2c_param_items _6_0x2c_param_item
    (54) _6_0x2c_param_items -> . _6_0x2c_param_item
    (55) _6_0x2c_param_item -> . , param
    )               reduce using rule 52 (_6_0x2c_param_repeat -> .)
    ,               shift and go to state 151

    _6_0x2c_param_repeat           shift and go to state 148
    _6_0x2c_param_items            shift and go to state 149
    _6_0x2c_param_item             shift and go to state 150

state 118

    (49) _5_param_optional -> param .
    ,               reduce using rule 49 (_5_param_optional -> param .)
    )               reduce using rule 49 (_5_param_optional -> param .)


state 119

    (58) def_expr -> DEF identifier < type_identifier . _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (59) _8_0x2c_type_identifier_repeat -> . _8_0x2c_type_identifier_items
    (60) _8_0x2c_type_identifier_repeat -> .
    (61) _8_0x2c_type_identifier_items -> . _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item
    (62) _8_0x2c_type_identifier_items -> . _8_0x2c_type_identifier_item
    (63) _8_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 60 (_8_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 155

    _8_0x2c_type_identifier_repeat shift and go to state 152
    _8_0x2c_type_identifier_items  shift and go to state 153
    _8_0x2c_type_identifier_item   shift and go to state 154

state 120

    (34) do -> DO _2_0x3a_type_optional _3_expr_repeat END .
    (               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    INT_DIV         reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    NUM_NOT_EQUAL   reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    |               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    >               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    %               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    <               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    *               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    /               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    -               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    +               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    CONCAT          reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    [               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    IDENTIFIER      reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    LET             reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    CASE            reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    IF              reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    DEF             reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    STRING          reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    NUMBER          reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    DO              reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    EXTERNAL        reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    ENUM            reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    TYPE_IDENTIFIER reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    $end            reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    )               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    ,               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    ]               reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    OF              reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    THEN            reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    END             reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    ELIF            reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)
    ELSE            reduce using rule 34 (do -> DO _2_0x3a_type_optional _3_expr_repeat END .)


state 121

    (39) _3_expr_items -> _3_expr_items _3_expr_item .
    -               reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    (               reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    [               reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    IDENTIFIER      reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    LET             reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    CASE            reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    IF              reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    DEF             reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    STRING          reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    NUMBER          reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    DO              reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    EXTERNAL        reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    ENUM            reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    TYPE_IDENTIFIER reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)
    END             reduce using rule 39 (_3_expr_items -> _3_expr_items _3_expr_item .)


state 122

    (73) type -> type_identifier < . type _12_0x2c_type_repeat >
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 90
    type                           shift and go to state 156

state 123

    (97) variant -> type_identifier .
    (98) variant -> type_identifier . ( type _16_0x2c_type_repeat )
    TYPE_IDENTIFIER reduce using rule 97 (variant -> type_identifier .)
    }               reduce using rule 97 (variant -> type_identifier .)
    (               shift and go to state 157


state 124

    (80) enum -> ENUM type_identifier { _13_variant_repeat . }
    }               shift and go to state 158


state 125

    (81) _13_variant_repeat -> _13_variant_items .
    (83) _13_variant_items -> _13_variant_items . _13_variant_item
    (85) _13_variant_item -> . variant
    (97) variant -> . type_identifier
    (98) variant -> . type_identifier ( type _16_0x2c_type_repeat )
    (160) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 81 (_13_variant_repeat -> _13_variant_items .)
    TYPE_IDENTIFIER shift and go to state 33

    _13_variant_item               shift and go to state 159
    variant                        shift and go to state 127
    type_identifier                shift and go to state 123

state 126

    (84) _13_variant_items -> _13_variant_item .
    TYPE_IDENTIFIER reduce using rule 84 (_13_variant_items -> _13_variant_item .)
    }               reduce using rule 84 (_13_variant_items -> _13_variant_item .)


state 127

    (85) _13_variant_item -> variant .
    TYPE_IDENTIFIER reduce using rule 85 (_13_variant_item -> variant .)
    }               reduce using rule 85 (_13_variant_item -> variant .)


state 128

    (86) enum -> ENUM type_identifier < type_identifier . _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (87) _14_0x2c_type_identifier_repeat -> . _14_0x2c_type_identifier_items
    (88) _14_0x2c_type_identifier_repeat -> .
    (89) _14_0x2c_type_identifier_items -> . _14_0x2c_type_identifier_items _14_0x2c_type_identifier_item
    (90) _14_0x2c_type_identifier_items -> . _14_0x2c_type_identifier_item
    (91) _14_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 88 (_14_0x2c_type_identifier_repeat -> .)
    ,               shift and go to state 163

    _14_0x2c_type_identifier_repeat shift and go to state 160
    _14_0x2c_type_identifier_items shift and go to state 161
    _14_0x2c_type_identifier_item  shift and go to state 162

state 129

    (142) call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .
    (               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    INT_DIV         reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    NUM_NOT_EQUAL   reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    |               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    >               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    %               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    <               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    *               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    /               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    -               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    +               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    CONCAT          reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    [               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    IDENTIFIER      reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    LET             reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    CASE            reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    IF              reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    DEF             reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    STRING          reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    NUMBER          reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    DO              reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    EXTERNAL        reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    ENUM            reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    $end            reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    )               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    ,               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    ]               reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    OF              reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    THEN            reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    END             reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    ELIF            reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)
    ELSE            reduce using rule 142 (call -> expr ( _26_expr_optional _27_0x2c_expr_repeat ) .)


state 130

    (147) _27_0x2c_expr_items -> _27_0x2c_expr_items _27_0x2c_expr_item .
    ,               reduce using rule 147 (_27_0x2c_expr_items -> _27_0x2c_expr_items _27_0x2c_expr_item .)
    )               reduce using rule 147 (_27_0x2c_expr_items -> _27_0x2c_expr_items _27_0x2c_expr_item .)


state 131

    (149) _27_0x2c_expr_item -> , expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 149 (_27_0x2c_expr_item -> , expr .)
    )               reduce using rule 149 (_27_0x2c_expr_item -> , expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 132

    (151) variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .
    (               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    INT_DIV         reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    NUM_NOT_EQUAL   reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    |               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    >               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    %               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    <               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    *               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    /               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    -               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    +               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    CONCAT          reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    [               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    IDENTIFIER      reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    LET             reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    CASE            reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    IF              reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    DEF             reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    STRING          reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    NUMBER          reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    DO              reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    EXTERNAL        reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    ENUM            reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    $end            reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    )               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    ,               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    ]               reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    OF              reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    THEN            reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    END             reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    ELIF            reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)
    ELSE            reduce using rule 151 (variant_call -> type_identifier ( _28_expr_optional _29_0x2c_expr_repeat ) .)


state 133

    (156) _29_0x2c_expr_items -> _29_0x2c_expr_items _29_0x2c_expr_item .
    ,               reduce using rule 156 (_29_0x2c_expr_items -> _29_0x2c_expr_items _29_0x2c_expr_item .)
    )               reduce using rule 156 (_29_0x2c_expr_items -> _29_0x2c_expr_items _29_0x2c_expr_item .)


state 134

    (158) _29_0x2c_expr_item -> , expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 158 (_29_0x2c_expr_item -> , expr .)
    )               reduce using rule 158 (_29_0x2c_expr_item -> , expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 135

    (161) variable_declaration -> LET identifier _30_0x3a_type_optional = expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    [               reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    IDENTIFIER      reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    LET             reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    CASE            reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    IF              reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    DEF             reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    STRING          reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    NUMBER          reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    DO              reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    EXTERNAL        reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    ENUM            reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    TYPE_IDENTIFIER reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    $end            reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    )               reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    ,               reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    ]               reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    OF              reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    THEN            reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    END             reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    ELIF            reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    ELSE            reduce using rule 161 (variable_declaration -> LET identifier _30_0x3a_type_optional = expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 136

    (116) case_of -> CASE expr OF _21_pattern_do_repeat END .
    (               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    INT_DIV         reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    NUM_NOT_EQUAL   reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    |               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    >               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    %               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    <               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    *               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    /               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    -               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    +               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    CONCAT          reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    [               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    IDENTIFIER      reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    LET             reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    CASE            reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    IF              reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    DEF             reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    STRING          reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    NUMBER          reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    DO              reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    EXTERNAL        reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    ENUM            reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    TYPE_IDENTIFIER reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    $end            reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    )               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    ,               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    ]               reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    OF              reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    THEN            reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    END             reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    ELIF            reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)
    ELSE            reduce using rule 116 (case_of -> CASE expr OF _21_pattern_do_repeat END .)


state 137

    (119) _21_pattern_do_items -> _21_pattern_do_items _21_pattern_do_item .
    TYPE_IDENTIFIER reduce using rule 119 (_21_pattern_do_items -> _21_pattern_do_items _21_pattern_do_item .)
    IDENTIFIER      reduce using rule 119 (_21_pattern_do_items -> _21_pattern_do_items _21_pattern_do_item .)
    END             reduce using rule 119 (_21_pattern_do_items -> _21_pattern_do_items _21_pattern_do_item .)


state 138

    (121) _21_pattern_do_item -> pattern do .
    TYPE_IDENTIFIER reduce using rule 121 (_21_pattern_do_item -> pattern do .)
    IDENTIFIER      reduce using rule 121 (_21_pattern_do_item -> pattern do .)
    END             reduce using rule 121 (_21_pattern_do_item -> pattern do .)


state 139

    (126) match_variant -> type_identifier ( . _22_pattern_optional _23_0x2c_pattern_repeat )
    (127) _22_pattern_optional -> . pattern
    (128) _22_pattern_optional -> .
    (122) pattern -> . match_variant
    (123) pattern -> . match_as
    (125) match_variant -> . type_identifier
    (126) match_variant -> . type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat )
    (124) match_as -> . identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    (159) identifier -> . IDENTIFIER
    ,               reduce using rule 128 (_22_pattern_optional -> .)
    )               reduce using rule 128 (_22_pattern_optional -> .)
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 23

    type_identifier                shift and go to state 112
    _22_pattern_optional           shift and go to state 164
    pattern                        shift and go to state 165
    match_variant                  shift and go to state 110
    match_as                       shift and go to state 111
    identifier                     shift and go to state 113

state 140

    (47) _4_expr_item -> expr .
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    [               reduce using rule 47 (_4_expr_item -> expr .)
    IDENTIFIER      reduce using rule 47 (_4_expr_item -> expr .)
    LET             reduce using rule 47 (_4_expr_item -> expr .)
    CASE            reduce using rule 47 (_4_expr_item -> expr .)
    IF              reduce using rule 47 (_4_expr_item -> expr .)
    DEF             reduce using rule 47 (_4_expr_item -> expr .)
    STRING          reduce using rule 47 (_4_expr_item -> expr .)
    NUMBER          reduce using rule 47 (_4_expr_item -> expr .)
    DO              reduce using rule 47 (_4_expr_item -> expr .)
    EXTERNAL        reduce using rule 47 (_4_expr_item -> expr .)
    ENUM            reduce using rule 47 (_4_expr_item -> expr .)
    TYPE_IDENTIFIER reduce using rule 47 (_4_expr_item -> expr .)
    ELIF            reduce using rule 47 (_4_expr_item -> expr .)
    ELSE            reduce using rule 47 (_4_expr_item -> expr .)
    END             reduce using rule 47 (_4_expr_item -> expr .)
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 141

    (107) if_expr -> IF expr THEN _18_0x3a_type_optional block_statement . _19_or_else_optional END
    (110) _19_or_else_optional -> . or_else
    (111) _19_or_else_optional -> .
    (112) or_else -> . ELIF expr THEN block_statement _20_or_else_optional
    (115) or_else -> . ELSE block_statement
    END             reduce using rule 111 (_19_or_else_optional -> .)
    ELIF            shift and go to state 168
    ELSE            shift and go to state 169

    _19_or_else_optional           shift and go to state 166
    or_else                        shift and go to state 167

state 142

    (42) block_statement -> _4_expr_repeat .
    ELIF            reduce using rule 42 (block_statement -> _4_expr_repeat .)
    ELSE            reduce using rule 42 (block_statement -> _4_expr_repeat .)
    END             reduce using rule 42 (block_statement -> _4_expr_repeat .)


state 143

    (43) _4_expr_repeat -> _4_expr_items .
    (45) _4_expr_items -> _4_expr_items . _4_expr_item
    (47) _4_expr_item -> . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 43 (_4_expr_repeat -> _4_expr_items .)
    ELSE            reduce using rule 43 (_4_expr_repeat -> _4_expr_items .)
    END             reduce using rule 43 (_4_expr_repeat -> _4_expr_items .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    _4_expr_item                   shift and go to state 170
    expr                           shift and go to state 140
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 144

    (46) _4_expr_items -> _4_expr_item .
    -               reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    (               reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    [               reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    IDENTIFIER      reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    LET             reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    CASE            reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    IF              reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    DEF             reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    STRING          reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    NUMBER          reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    DO              reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    EXTERNAL        reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    ENUM            reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    TYPE_IDENTIFIER reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    ELIF            reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    ELSE            reduce using rule 46 (_4_expr_items -> _4_expr_item .)
    END             reduce using rule 46 (_4_expr_items -> _4_expr_item .)


state 145

    (108) _18_0x3a_type_optional -> : type .
    -               reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    (               reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    [               reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    IDENTIFIER      reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    LET             reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    CASE            reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    IF              reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    DEF             reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    STRING          reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    NUMBER          reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    DO              reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    EXTERNAL        reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    ENUM            reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    ELIF            reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    ELSE            reduce using rule 108 (_18_0x3a_type_optional -> : type .)
    END             reduce using rule 108 (_18_0x3a_type_optional -> : type .)


state 146

    (104) param -> identifier _17_0x3a_type_optional .
    ,               reduce using rule 104 (param -> identifier _17_0x3a_type_optional .)
    )               reduce using rule 104 (param -> identifier _17_0x3a_type_optional .)


state 147

    (105) _17_0x3a_type_optional -> : . type
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 171
    type_identifier                shift and go to state 90

state 148

    (48) def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat . ) _7_0x3a_type_optional do
    )               shift and go to state 172


state 149

    (51) _6_0x2c_param_repeat -> _6_0x2c_param_items .
    (53) _6_0x2c_param_items -> _6_0x2c_param_items . _6_0x2c_param_item
    (55) _6_0x2c_param_item -> . , param
    )               reduce using rule 51 (_6_0x2c_param_repeat -> _6_0x2c_param_items .)
    ,               shift and go to state 151

    _6_0x2c_param_item             shift and go to state 173

state 150

    (54) _6_0x2c_param_items -> _6_0x2c_param_item .
    ,               reduce using rule 54 (_6_0x2c_param_items -> _6_0x2c_param_item .)
    )               reduce using rule 54 (_6_0x2c_param_items -> _6_0x2c_param_item .)


state 151

    (55) _6_0x2c_param_item -> , . param
    (104) param -> . identifier _17_0x3a_type_optional
    (159) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 23

    param                          shift and go to state 174
    identifier                     shift and go to state 116

state 152

    (58) def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat . > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    >               shift and go to state 175


state 153

    (59) _8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items .
    (61) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items . _8_0x2c_type_identifier_item
    (63) _8_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 59 (_8_0x2c_type_identifier_repeat -> _8_0x2c_type_identifier_items .)
    ,               shift and go to state 155

    _8_0x2c_type_identifier_item   shift and go to state 176

state 154

    (62) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .
    ,               reduce using rule 62 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .)
    >               reduce using rule 62 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_item .)


state 155

    (63) _8_0x2c_type_identifier_item -> , . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 177

state 156

    (73) type -> type_identifier < type . _12_0x2c_type_repeat >
    (74) _12_0x2c_type_repeat -> . _12_0x2c_type_items
    (75) _12_0x2c_type_repeat -> .
    (76) _12_0x2c_type_items -> . _12_0x2c_type_items _12_0x2c_type_item
    (77) _12_0x2c_type_items -> . _12_0x2c_type_item
    (78) _12_0x2c_type_item -> . , type
    >               reduce using rule 75 (_12_0x2c_type_repeat -> .)
    ,               shift and go to state 181

    _12_0x2c_type_repeat           shift and go to state 178
    _12_0x2c_type_items            shift and go to state 179
    _12_0x2c_type_item             shift and go to state 180

state 157

    (98) variant -> type_identifier ( . type _16_0x2c_type_repeat )
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 90
    type                           shift and go to state 182

state 158

    (80) enum -> ENUM type_identifier { _13_variant_repeat } .
    (               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    INT_DIV         reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    NUM_NOT_EQUAL   reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    |               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    >               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    %               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    <               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    *               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    /               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    -               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    +               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    CONCAT          reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    [               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    IDENTIFIER      reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    LET             reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    CASE            reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    IF              reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    DEF             reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    STRING          reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    NUMBER          reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    DO              reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    EXTERNAL        reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    ENUM            reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    TYPE_IDENTIFIER reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    $end            reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    )               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    ,               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    ]               reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    OF              reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    THEN            reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    END             reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    ELIF            reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)
    ELSE            reduce using rule 80 (enum -> ENUM type_identifier { _13_variant_repeat } .)


state 159

    (83) _13_variant_items -> _13_variant_items _13_variant_item .
    TYPE_IDENTIFIER reduce using rule 83 (_13_variant_items -> _13_variant_items _13_variant_item .)
    }               reduce using rule 83 (_13_variant_items -> _13_variant_items _13_variant_item .)


state 160

    (86) enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat . > { _15_variant_repeat }
    >               shift and go to state 183


state 161

    (87) _14_0x2c_type_identifier_repeat -> _14_0x2c_type_identifier_items .
    (89) _14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_items . _14_0x2c_type_identifier_item
    (91) _14_0x2c_type_identifier_item -> . , type_identifier
    >               reduce using rule 87 (_14_0x2c_type_identifier_repeat -> _14_0x2c_type_identifier_items .)
    ,               shift and go to state 163

    _14_0x2c_type_identifier_item  shift and go to state 184

state 162

    (90) _14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_item .
    ,               reduce using rule 90 (_14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_item .)
    >               reduce using rule 90 (_14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_item .)


state 163

    (91) _14_0x2c_type_identifier_item -> , . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 185

state 164

    (126) match_variant -> type_identifier ( _22_pattern_optional . _23_0x2c_pattern_repeat )
    (129) _23_0x2c_pattern_repeat -> . _23_0x2c_pattern_items
    (130) _23_0x2c_pattern_repeat -> .
    (131) _23_0x2c_pattern_items -> . _23_0x2c_pattern_items _23_0x2c_pattern_item
    (132) _23_0x2c_pattern_items -> . _23_0x2c_pattern_item
    (133) _23_0x2c_pattern_item -> . , pattern
    )               reduce using rule 130 (_23_0x2c_pattern_repeat -> .)
    ,               shift and go to state 189

    _23_0x2c_pattern_repeat        shift and go to state 186
    _23_0x2c_pattern_items         shift and go to state 187
    _23_0x2c_pattern_item          shift and go to state 188

state 165

    (127) _22_pattern_optional -> pattern .
    ,               reduce using rule 127 (_22_pattern_optional -> pattern .)
    )               reduce using rule 127 (_22_pattern_optional -> pattern .)


state 166

    (107) if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional . END
    END             shift and go to state 190


state 167

    (110) _19_or_else_optional -> or_else .
    END             reduce using rule 110 (_19_or_else_optional -> or_else .)


state 168

    (112) or_else -> ELIF . expr THEN block_statement _20_or_else_optional
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 191
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 169

    (115) or_else -> ELSE . block_statement
    (42) block_statement -> . _4_expr_repeat
    (43) _4_expr_repeat -> . _4_expr_items
    (44) _4_expr_repeat -> .
    (45) _4_expr_items -> . _4_expr_items _4_expr_item
    (46) _4_expr_items -> . _4_expr_item
    (47) _4_expr_item -> . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 44 (_4_expr_repeat -> .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    block_statement                shift and go to state 192
    _4_expr_repeat                 shift and go to state 142
    _4_expr_items                  shift and go to state 143
    _4_expr_item                   shift and go to state 144
    expr                           shift and go to state 140
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 170

    (45) _4_expr_items -> _4_expr_items _4_expr_item .
    -               reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    (               reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    [               reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    IDENTIFIER      reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    LET             reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    CASE            reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    IF              reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    DEF             reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    STRING          reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    NUMBER          reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    DO              reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    EXTERNAL        reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    ENUM            reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    TYPE_IDENTIFIER reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    ELIF            reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    ELSE            reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)
    END             reduce using rule 45 (_4_expr_items -> _4_expr_items _4_expr_item .)


state 171

    (105) _17_0x3a_type_optional -> : type .
    ,               reduce using rule 105 (_17_0x3a_type_optional -> : type .)
    )               reduce using rule 105 (_17_0x3a_type_optional -> : type .)


state 172

    (48) def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) . _7_0x3a_type_optional do
    (56) _7_0x3a_type_optional -> . : type
    (57) _7_0x3a_type_optional -> .
    :               shift and go to state 194
    DO              reduce using rule 57 (_7_0x3a_type_optional -> .)

    _7_0x3a_type_optional          shift and go to state 193

state 173

    (53) _6_0x2c_param_items -> _6_0x2c_param_items _6_0x2c_param_item .
    ,               reduce using rule 53 (_6_0x2c_param_items -> _6_0x2c_param_items _6_0x2c_param_item .)
    )               reduce using rule 53 (_6_0x2c_param_items -> _6_0x2c_param_items _6_0x2c_param_item .)


state 174

    (55) _6_0x2c_param_item -> , param .
    ,               reduce using rule 55 (_6_0x2c_param_item -> , param .)
    )               reduce using rule 55 (_6_0x2c_param_item -> , param .)


state 175

    (58) def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > . ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (               shift and go to state 195


state 176

    (61) _8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .
    ,               reduce using rule 61 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .)
    >               reduce using rule 61 (_8_0x2c_type_identifier_items -> _8_0x2c_type_identifier_items _8_0x2c_type_identifier_item .)


state 177

    (63) _8_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 63 (_8_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 63 (_8_0x2c_type_identifier_item -> , type_identifier .)


state 178

    (73) type -> type_identifier < type _12_0x2c_type_repeat . >
    >               shift and go to state 196


state 179

    (74) _12_0x2c_type_repeat -> _12_0x2c_type_items .
    (76) _12_0x2c_type_items -> _12_0x2c_type_items . _12_0x2c_type_item
    (78) _12_0x2c_type_item -> . , type
    >               reduce using rule 74 (_12_0x2c_type_repeat -> _12_0x2c_type_items .)
    ,               shift and go to state 181

    _12_0x2c_type_item             shift and go to state 197

state 180

    (77) _12_0x2c_type_items -> _12_0x2c_type_item .
    ,               reduce using rule 77 (_12_0x2c_type_items -> _12_0x2c_type_item .)
    >               reduce using rule 77 (_12_0x2c_type_items -> _12_0x2c_type_item .)


state 181

    (78) _12_0x2c_type_item -> , . type
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 198
    type_identifier                shift and go to state 90

state 182

    (98) variant -> type_identifier ( type . _16_0x2c_type_repeat )
    (99) _16_0x2c_type_repeat -> . _16_0x2c_type_items
    (100) _16_0x2c_type_repeat -> .
    (101) _16_0x2c_type_items -> . _16_0x2c_type_items _16_0x2c_type_item
    (102) _16_0x2c_type_items -> . _16_0x2c_type_item
    (103) _16_0x2c_type_item -> . , type
    )               reduce using rule 100 (_16_0x2c_type_repeat -> .)
    ,               shift and go to state 202

    _16_0x2c_type_repeat           shift and go to state 199
    _16_0x2c_type_items            shift and go to state 200
    _16_0x2c_type_item             shift and go to state 201

state 183

    (86) enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > . { _15_variant_repeat }
    {               shift and go to state 203


state 184

    (89) _14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_items _14_0x2c_type_identifier_item .
    ,               reduce using rule 89 (_14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_items _14_0x2c_type_identifier_item .)
    >               reduce using rule 89 (_14_0x2c_type_identifier_items -> _14_0x2c_type_identifier_items _14_0x2c_type_identifier_item .)


state 185

    (91) _14_0x2c_type_identifier_item -> , type_identifier .
    ,               reduce using rule 91 (_14_0x2c_type_identifier_item -> , type_identifier .)
    >               reduce using rule 91 (_14_0x2c_type_identifier_item -> , type_identifier .)


state 186

    (126) match_variant -> type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat . )
    )               shift and go to state 204


state 187

    (129) _23_0x2c_pattern_repeat -> _23_0x2c_pattern_items .
    (131) _23_0x2c_pattern_items -> _23_0x2c_pattern_items . _23_0x2c_pattern_item
    (133) _23_0x2c_pattern_item -> . , pattern
    )               reduce using rule 129 (_23_0x2c_pattern_repeat -> _23_0x2c_pattern_items .)
    ,               shift and go to state 189

    _23_0x2c_pattern_item          shift and go to state 205

state 188

    (132) _23_0x2c_pattern_items -> _23_0x2c_pattern_item .
    ,               reduce using rule 132 (_23_0x2c_pattern_items -> _23_0x2c_pattern_item .)
    )               reduce using rule 132 (_23_0x2c_pattern_items -> _23_0x2c_pattern_item .)


state 189

    (133) _23_0x2c_pattern_item -> , . pattern
    (122) pattern -> . match_variant
    (123) pattern -> . match_as
    (125) match_variant -> . type_identifier
    (126) match_variant -> . type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat )
    (124) match_as -> . identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    (159) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33
    IDENTIFIER      shift and go to state 23

    pattern                        shift and go to state 206
    match_variant                  shift and go to state 110
    match_as                       shift and go to state 111
    type_identifier                shift and go to state 112
    identifier                     shift and go to state 113

state 190

    (107) if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .
    (               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    INT_DIV         reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    NUM_NOT_EQUAL   reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    |               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    >               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    %               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    <               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    *               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    /               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    -               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    +               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    CONCAT          reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    [               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    IDENTIFIER      reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    LET             reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    CASE            reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    IF              reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    DEF             reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    STRING          reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    NUMBER          reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    DO              reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    EXTERNAL        reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    ENUM            reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    TYPE_IDENTIFIER reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    $end            reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    )               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    ,               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    ]               reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    OF              reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    THEN            reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    END             reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    ELIF            reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)
    ELSE            reduce using rule 107 (if_expr -> IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END .)


state 191

    (112) or_else -> ELIF expr . THEN block_statement _20_or_else_optional
    (142) call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . NUM_NOT_EQUAL expr
    (25) binary_expr -> expr . | expr
    (26) binary_expr -> expr . > expr
    (27) binary_expr -> expr . % expr
    (28) binary_expr -> expr . < expr
    (29) binary_expr -> expr . * expr
    (30) binary_expr -> expr . / expr
    (31) binary_expr -> expr . - expr
    (32) binary_expr -> expr . + expr
    (33) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 207
    (               shift and go to state 35
    INT_DIV         shift and go to state 36
    NUM_NOT_EQUAL   shift and go to state 37
    |               shift and go to state 38
    >               shift and go to state 39
    %               shift and go to state 40
    <               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    CONCAT          shift and go to state 46


state 192

    (115) or_else -> ELSE block_statement .
    END             reduce using rule 115 (or_else -> ELSE block_statement .)


state 193

    (48) def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional . do
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    DO              shift and go to state 30

    do                             shift and go to state 208

state 194

    (56) _7_0x3a_type_optional -> : . type
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 209
    type_identifier                shift and go to state 90

state 195

    (58) def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( . _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (64) _9_param_optional -> . param
    (65) _9_param_optional -> .
    (104) param -> . identifier _17_0x3a_type_optional
    (159) identifier -> . IDENTIFIER
    ,               reduce using rule 65 (_9_param_optional -> .)
    )               reduce using rule 65 (_9_param_optional -> .)
    IDENTIFIER      shift and go to state 23

    identifier                     shift and go to state 116
    _9_param_optional              shift and go to state 210
    param                          shift and go to state 211

state 196

    (73) type -> type_identifier < type _12_0x2c_type_repeat > .
    -               reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    (               reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    [               reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    IDENTIFIER      reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    LET             reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    CASE            reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    IF              reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    DEF             reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    STRING          reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    NUMBER          reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    DO              reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    EXTERNAL        reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    ENUM            reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    TYPE_IDENTIFIER reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    END             reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    =               reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    ELIF            reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    ELSE            reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    ,               reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    >               reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)
    )               reduce using rule 73 (type -> type_identifier < type _12_0x2c_type_repeat > .)


state 197

    (76) _12_0x2c_type_items -> _12_0x2c_type_items _12_0x2c_type_item .
    ,               reduce using rule 76 (_12_0x2c_type_items -> _12_0x2c_type_items _12_0x2c_type_item .)
    >               reduce using rule 76 (_12_0x2c_type_items -> _12_0x2c_type_items _12_0x2c_type_item .)


state 198

    (78) _12_0x2c_type_item -> , type .
    ,               reduce using rule 78 (_12_0x2c_type_item -> , type .)
    >               reduce using rule 78 (_12_0x2c_type_item -> , type .)


state 199

    (98) variant -> type_identifier ( type _16_0x2c_type_repeat . )
    )               shift and go to state 212


state 200

    (99) _16_0x2c_type_repeat -> _16_0x2c_type_items .
    (101) _16_0x2c_type_items -> _16_0x2c_type_items . _16_0x2c_type_item
    (103) _16_0x2c_type_item -> . , type
    )               reduce using rule 99 (_16_0x2c_type_repeat -> _16_0x2c_type_items .)
    ,               shift and go to state 202

    _16_0x2c_type_item             shift and go to state 213

state 201

    (102) _16_0x2c_type_items -> _16_0x2c_type_item .
    ,               reduce using rule 102 (_16_0x2c_type_items -> _16_0x2c_type_item .)
    )               reduce using rule 102 (_16_0x2c_type_items -> _16_0x2c_type_item .)


state 202

    (103) _16_0x2c_type_item -> , . type
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 214
    type_identifier                shift and go to state 90

state 203

    (86) enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { . _15_variant_repeat }
    (92) _15_variant_repeat -> . _15_variant_items
    (93) _15_variant_repeat -> .
    (94) _15_variant_items -> . _15_variant_items _15_variant_item
    (95) _15_variant_items -> . _15_variant_item
    (96) _15_variant_item -> . variant
    (97) variant -> . type_identifier
    (98) variant -> . type_identifier ( type _16_0x2c_type_repeat )
    (160) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 93 (_15_variant_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 33

    type_identifier                shift and go to state 123
    _15_variant_repeat             shift and go to state 215
    _15_variant_items              shift and go to state 216
    _15_variant_item               shift and go to state 217
    variant                        shift and go to state 218

state 204

    (126) match_variant -> type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat ) .
    DO              reduce using rule 126 (match_variant -> type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat ) .)
    ,               reduce using rule 126 (match_variant -> type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat ) .)
    )               reduce using rule 126 (match_variant -> type_identifier ( _22_pattern_optional _23_0x2c_pattern_repeat ) .)


state 205

    (131) _23_0x2c_pattern_items -> _23_0x2c_pattern_items _23_0x2c_pattern_item .
    ,               reduce using rule 131 (_23_0x2c_pattern_items -> _23_0x2c_pattern_items _23_0x2c_pattern_item .)
    )               reduce using rule 131 (_23_0x2c_pattern_items -> _23_0x2c_pattern_items _23_0x2c_pattern_item .)


state 206

    (133) _23_0x2c_pattern_item -> , pattern .
    ,               reduce using rule 133 (_23_0x2c_pattern_item -> , pattern .)
    )               reduce using rule 133 (_23_0x2c_pattern_item -> , pattern .)


state 207

    (112) or_else -> ELIF expr THEN . block_statement _20_or_else_optional
    (42) block_statement -> . _4_expr_repeat
    (43) _4_expr_repeat -> . _4_expr_items
    (44) _4_expr_repeat -> .
    (45) _4_expr_items -> . _4_expr_items _4_expr_item
    (46) _4_expr_items -> . _4_expr_item
    (47) _4_expr_item -> . expr
    (7) expr -> . - expr
    (8) expr -> . ( expr )
    (9) expr -> . array
    (10) expr -> . variant_call
    (11) expr -> . identifier
    (12) expr -> . variable_declaration
    (13) expr -> . call
    (14) expr -> . case_of
    (15) expr -> . binary_expr
    (16) expr -> . if_expr
    (17) expr -> . def_expr
    (18) expr -> . literal
    (19) expr -> . do
    (20) expr -> . external
    (21) expr -> . enum
    (134) array -> . [ _24_expr_optional _25_0x2c_expr_repeat ]
    (150) variant_call -> . type_identifier
    (151) variant_call -> . type_identifier ( _28_expr_optional _29_0x2c_expr_repeat )
    (159) identifier -> . IDENTIFIER
    (161) variable_declaration -> . LET identifier _30_0x3a_type_optional = expr
    (142) call -> . expr ( _26_expr_optional _27_0x2c_expr_repeat )
    (116) case_of -> . CASE expr OF _21_pattern_do_repeat END
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr NUM_NOT_EQUAL expr
    (25) binary_expr -> . expr | expr
    (26) binary_expr -> . expr > expr
    (27) binary_expr -> . expr % expr
    (28) binary_expr -> . expr < expr
    (29) binary_expr -> . expr * expr
    (30) binary_expr -> . expr / expr
    (31) binary_expr -> . expr - expr
    (32) binary_expr -> . expr + expr
    (33) binary_expr -> . expr CONCAT expr
    (107) if_expr -> . IF expr THEN _18_0x3a_type_optional block_statement _19_or_else_optional END
    (48) def_expr -> . DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do
    (58) def_expr -> . DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (164) literal -> . STRING
    (165) literal -> . NUMBER
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    (22) external -> . EXTERNAL
    (80) enum -> . ENUM type_identifier { _13_variant_repeat }
    (86) enum -> . ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat }
    (160) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 44 (_4_expr_repeat -> .)
    ELSE            reduce using rule 44 (_4_expr_repeat -> .)
    END             reduce using rule 44 (_4_expr_repeat -> .)
    -               shift and go to state 6
    (               shift and go to state 7
    [               shift and go to state 21
    IDENTIFIER      shift and go to state 23
    LET             shift and go to state 24
    CASE            shift and go to state 25
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    DO              shift and go to state 30
    EXTERNAL        shift and go to state 31
    ENUM            shift and go to state 32
    TYPE_IDENTIFIER shift and go to state 33

    expr                           shift and go to state 140
    block_statement                shift and go to state 219
    _4_expr_repeat                 shift and go to state 142
    _4_expr_items                  shift and go to state 143
    _4_expr_item                   shift and go to state 144
    array                          shift and go to state 8
    variant_call                   shift and go to state 9
    identifier                     shift and go to state 10
    variable_declaration           shift and go to state 11
    call                           shift and go to state 12
    case_of                        shift and go to state 13
    binary_expr                    shift and go to state 14
    if_expr                        shift and go to state 15
    def_expr                       shift and go to state 16
    literal                        shift and go to state 17
    do                             shift and go to state 18
    external                       shift and go to state 19
    enum                           shift and go to state 20
    type_identifier                shift and go to state 22

state 208

    (48) def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .
    (               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    INT_DIV         reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    NUM_NOT_EQUAL   reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    |               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    >               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    %               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    <               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    *               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    /               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    -               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    +               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    CONCAT          reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    [               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    IDENTIFIER      reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    LET             reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    CASE            reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    IF              reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    DEF             reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    STRING          reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    NUMBER          reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    DO              reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    EXTERNAL        reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    ENUM            reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    TYPE_IDENTIFIER reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    $end            reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    )               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    ,               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    ]               reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    OF              reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    THEN            reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    END             reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    ELIF            reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)
    ELSE            reduce using rule 48 (def_expr -> DEF identifier ( _5_param_optional _6_0x2c_param_repeat ) _7_0x3a_type_optional do .)


state 209

    (56) _7_0x3a_type_optional -> : type .
    DO              reduce using rule 56 (_7_0x3a_type_optional -> : type .)


state 210

    (58) def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional . _10_0x2c_param_repeat ) _11_0x3a_type_optional do
    (66) _10_0x2c_param_repeat -> . _10_0x2c_param_items
    (67) _10_0x2c_param_repeat -> .
    (68) _10_0x2c_param_items -> . _10_0x2c_param_items _10_0x2c_param_item
    (69) _10_0x2c_param_items -> . _10_0x2c_param_item
    (70) _10_0x2c_param_item -> . , param
    )               reduce using rule 67 (_10_0x2c_param_repeat -> .)
    ,               shift and go to state 223

    _10_0x2c_param_repeat          shift and go to state 220
    _10_0x2c_param_items           shift and go to state 221
    _10_0x2c_param_item            shift and go to state 222

state 211

    (64) _9_param_optional -> param .
    ,               reduce using rule 64 (_9_param_optional -> param .)
    )               reduce using rule 64 (_9_param_optional -> param .)


state 212

    (98) variant -> type_identifier ( type _16_0x2c_type_repeat ) .
    TYPE_IDENTIFIER reduce using rule 98 (variant -> type_identifier ( type _16_0x2c_type_repeat ) .)
    }               reduce using rule 98 (variant -> type_identifier ( type _16_0x2c_type_repeat ) .)


state 213

    (101) _16_0x2c_type_items -> _16_0x2c_type_items _16_0x2c_type_item .
    ,               reduce using rule 101 (_16_0x2c_type_items -> _16_0x2c_type_items _16_0x2c_type_item .)
    )               reduce using rule 101 (_16_0x2c_type_items -> _16_0x2c_type_items _16_0x2c_type_item .)


state 214

    (103) _16_0x2c_type_item -> , type .
    ,               reduce using rule 103 (_16_0x2c_type_item -> , type .)
    )               reduce using rule 103 (_16_0x2c_type_item -> , type .)


state 215

    (86) enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat . }
    }               shift and go to state 224


state 216

    (92) _15_variant_repeat -> _15_variant_items .
    (94) _15_variant_items -> _15_variant_items . _15_variant_item
    (96) _15_variant_item -> . variant
    (97) variant -> . type_identifier
    (98) variant -> . type_identifier ( type _16_0x2c_type_repeat )
    (160) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 92 (_15_variant_repeat -> _15_variant_items .)
    TYPE_IDENTIFIER shift and go to state 33

    _15_variant_item               shift and go to state 225
    variant                        shift and go to state 218
    type_identifier                shift and go to state 123

state 217

    (95) _15_variant_items -> _15_variant_item .
    TYPE_IDENTIFIER reduce using rule 95 (_15_variant_items -> _15_variant_item .)
    }               reduce using rule 95 (_15_variant_items -> _15_variant_item .)


state 218

    (96) _15_variant_item -> variant .
    TYPE_IDENTIFIER reduce using rule 96 (_15_variant_item -> variant .)
    }               reduce using rule 96 (_15_variant_item -> variant .)


state 219

    (112) or_else -> ELIF expr THEN block_statement . _20_or_else_optional
    (113) _20_or_else_optional -> . or_else
    (114) _20_or_else_optional -> .
    (112) or_else -> . ELIF expr THEN block_statement _20_or_else_optional
    (115) or_else -> . ELSE block_statement
    END             reduce using rule 114 (_20_or_else_optional -> .)
    ELIF            shift and go to state 168
    ELSE            shift and go to state 169

    _20_or_else_optional           shift and go to state 226
    or_else                        shift and go to state 227

state 220

    (58) def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat . ) _11_0x3a_type_optional do
    )               shift and go to state 228


state 221

    (66) _10_0x2c_param_repeat -> _10_0x2c_param_items .
    (68) _10_0x2c_param_items -> _10_0x2c_param_items . _10_0x2c_param_item
    (70) _10_0x2c_param_item -> . , param
    )               reduce using rule 66 (_10_0x2c_param_repeat -> _10_0x2c_param_items .)
    ,               shift and go to state 223

    _10_0x2c_param_item            shift and go to state 229

state 222

    (69) _10_0x2c_param_items -> _10_0x2c_param_item .
    ,               reduce using rule 69 (_10_0x2c_param_items -> _10_0x2c_param_item .)
    )               reduce using rule 69 (_10_0x2c_param_items -> _10_0x2c_param_item .)


state 223

    (70) _10_0x2c_param_item -> , . param
    (104) param -> . identifier _17_0x3a_type_optional
    (159) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 23

    param                          shift and go to state 230
    identifier                     shift and go to state 116

state 224

    (86) enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .
    (               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    INT_DIV         reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    NUM_NOT_EQUAL   reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    |               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    >               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    %               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    <               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    *               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    /               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    -               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    +               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    CONCAT          reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    [               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    IDENTIFIER      reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    LET             reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    CASE            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    IF              reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    DEF             reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    STRING          reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    NUMBER          reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    DO              reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    EXTERNAL        reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    ENUM            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    TYPE_IDENTIFIER reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    $end            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    )               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    ,               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    ]               reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    OF              reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    THEN            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    END             reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    ELIF            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)
    ELSE            reduce using rule 86 (enum -> ENUM type_identifier < type_identifier _14_0x2c_type_identifier_repeat > { _15_variant_repeat } .)


state 225

    (94) _15_variant_items -> _15_variant_items _15_variant_item .
    TYPE_IDENTIFIER reduce using rule 94 (_15_variant_items -> _15_variant_items _15_variant_item .)
    }               reduce using rule 94 (_15_variant_items -> _15_variant_items _15_variant_item .)


state 226

    (112) or_else -> ELIF expr THEN block_statement _20_or_else_optional .
    END             reduce using rule 112 (or_else -> ELIF expr THEN block_statement _20_or_else_optional .)


state 227

    (113) _20_or_else_optional -> or_else .
    END             reduce using rule 113 (_20_or_else_optional -> or_else .)


state 228

    (58) def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) . _11_0x3a_type_optional do
    (71) _11_0x3a_type_optional -> . : type
    (72) _11_0x3a_type_optional -> .
    :               shift and go to state 232
    DO              reduce using rule 72 (_11_0x3a_type_optional -> .)

    _11_0x3a_type_optional         shift and go to state 231

state 229

    (68) _10_0x2c_param_items -> _10_0x2c_param_items _10_0x2c_param_item .
    ,               reduce using rule 68 (_10_0x2c_param_items -> _10_0x2c_param_items _10_0x2c_param_item .)
    )               reduce using rule 68 (_10_0x2c_param_items -> _10_0x2c_param_items _10_0x2c_param_item .)


state 230

    (70) _10_0x2c_param_item -> , param .
    ,               reduce using rule 70 (_10_0x2c_param_item -> , param .)
    )               reduce using rule 70 (_10_0x2c_param_item -> , param .)


state 231

    (58) def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional . do
    (34) do -> . DO _2_0x3a_type_optional _3_expr_repeat END
    DO              shift and go to state 30

    do                             shift and go to state 233

state 232

    (71) _11_0x3a_type_optional -> : . type
    (73) type -> . type_identifier < type _12_0x2c_type_repeat >
    (79) type -> . type_identifier
    (160) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 33

    type                           shift and go to state 234
    type_identifier                shift and go to state 90

state 233

    (58) def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .
    (               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    INT_DIV         reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    NUM_NOT_EQUAL   reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    |               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    >               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    %               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    <               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    *               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    /               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    -               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    +               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    CONCAT          reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    [               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    IDENTIFIER      reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    LET             reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    CASE            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    IF              reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    DEF             reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    STRING          reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    NUMBER          reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    DO              reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    EXTERNAL        reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    ENUM            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    TYPE_IDENTIFIER reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    $end            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    )               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    ,               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    ]               reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    OF              reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    THEN            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    END             reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    ELIF            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)
    ELSE            reduce using rule 58 (def_expr -> DEF identifier < type_identifier _8_0x2c_type_identifier_repeat > ( _9_param_optional _10_0x2c_param_repeat ) _11_0x3a_type_optional do .)


state 234

    (71) _11_0x3a_type_optional -> : type .
    DO              reduce using rule 71 (_11_0x3a_type_optional -> : type .)


Conflicts:

shift/reduce conflict for ( in state 5 resolved as shift
   shift using rule call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
   ╭╴
   │ expr ♦ ( _26_expr_optional _27_0x2c_expr_repeat )
   │ ╰call───────────────────────────────────────────╯
   ╰╴

   reduce using rule _1_expr_item -> expr .
   ╭╴
   │ expr ♦          ( expr )
   │ ╰_1_expr_item╯  ╰expr──╯
   │ ╰_1_expr_items╯ ╰_1_expr_item╯
   │ ╰_1_expr_items───────────────╯
   ╰╴

shift/reduce conflict for - in state 5 resolved as shift
   shift using rule binary_expr -> expr . - expr
   ╭╴
   │ expr ♦ - expr
   │ ╰binary_expr╯
   ╰╴

   reduce using rule _1_expr_item -> expr .
   ╭╴
   │ expr ♦          - expr
   │ ╰_1_expr_item╯  ╰expr╯
   │ ╰_1_expr_items╯ ╰_1_expr_item╯
   │ ╰_1_expr_items───────────────╯
   ╰╴

shift/reduce conflict for ( in state 22 resolved as shift
   shift using rule variant_call -> type_identifier . ( _28_expr_optional _29_0x2c_expr_repeat )
   ╭╴
   │ type_identifier ♦ ( _28_expr_optional _29_0x2c_expr_repeat )
   │ ╰variant_call──────────────────────────────────────────────╯
   ╰╴

   reduce using rule variant_call -> type_identifier .
   ╭╴
   │ type_identifier ♦ ( _26_expr_optional _27_0x2c_expr_repeat )
   │ ╰variant_call───╯
   │ ╰expr───────────╯
   │ ╰call──────────────────────────────────────────────────────╯
   ├╴
   │ type_identifier ♦ ( expr )
   │ ╰variant_call───╯ ╰expr──╯
   │ ╰expr───────────╯ ╰_1_expr_item╯
   │ ╰_1_expr_item───╯
   │ ╰_1_expr_items──╯
   │ ╰_1_expr_items─────────────────╯
   ├╴
   │ type_identifier ♦ ( expr )
   │ ╰variant_call───╯ ╰expr──╯
   │ ╰expr───────────╯ ╰_3_expr_item╯
   │ ╰_3_expr_item───╯
   │ ╰_3_expr_items──╯
   │ ╰_3_expr_items─────────────────╯
   ├╴
   │ type_identifier ♦ ( expr )
   │ ╰variant_call───╯ ╰expr──╯
   │ ╰expr───────────╯ ╰_4_expr_item╯
   │ ╰_4_expr_item───╯
   │ ╰_4_expr_items──╯
   │ ╰_4_expr_items─────────────────╯
   ╰╴

shift/reduce conflict for ( in state 88 resolved as shift
   shift using rule call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
   ╭╴
   │ expr ♦ ( _26_expr_optional _27_0x2c_expr_repeat )
   │ ╰call───────────────────────────────────────────╯
   ╰╴

   reduce using rule _3_expr_item -> expr .
   ╭╴
   │ expr ♦          ( expr )
   │ ╰_3_expr_item╯  ╰expr──╯
   │ ╰_3_expr_items╯ ╰_3_expr_item╯
   │ ╰_3_expr_items───────────────╯
   ╰╴

shift/reduce conflict for - in state 88 resolved as shift
   shift using rule binary_expr -> expr . - expr
   ╭╴
   │ expr ♦ - expr
   │ ╰binary_expr╯
   ╰╴

   reduce using rule _3_expr_item -> expr .
   ╭╴
   │ expr ♦          - expr
   │ ╰_3_expr_item╯  ╰expr╯
   │ ╰_3_expr_items╯ ╰_3_expr_item╯
   │ ╰_3_expr_items───────────────╯
   ╰╴

shift/reduce conflict for ( in state 140 resolved as shift
   shift using rule call -> expr . ( _26_expr_optional _27_0x2c_expr_repeat )
   ╭╴
   │ expr ♦ ( _26_expr_optional _27_0x2c_expr_repeat )
   │ ╰call───────────────────────────────────────────╯
   ╰╴

   reduce using rule _4_expr_item -> expr .
   ╭╴
   │ expr ♦          ( expr )
   │ ╰_4_expr_item╯  ╰expr──╯
   │ ╰_4_expr_items╯ ╰_4_expr_item╯
   │ ╰_4_expr_items───────────────╯
   ╰╴

shift/reduce conflict for - in state 140 resolved as shift
   shift using rule binary_expr -> expr . - expr
   ╭╴
   │ expr ♦ - expr
   │ ╰binary_expr╯
   ╰╴

   reduce using rule _4_expr_item -> expr .
   ╭╴
   │ expr ♦          - expr
   │ ╰_4_expr_item╯  ╰expr╯
   │ ╰_4_expr_items╯ ╰_4_expr_item╯
   │ ╰_4_expr_items───────────────╯
   ╰╴
