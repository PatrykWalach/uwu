Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_optional _2_repeat
Rule 2     _1_optional -> stmt
Rule 3     _1_optional -> <empty>
Rule 4     _2_repeat -> _2_items
Rule 5     _2_repeat -> <empty>
Rule 6     _2_items -> _2_items _2_item
Rule 7     _2_items -> _2_item
Rule 8     _2_item -> NEWLINE stmt
Rule 9     stmt -> enum
Rule 10    stmt -> struct
Rule 11    stmt -> expr
Rule 12    expr -> ( expr )
Rule 13    expr -> - expr  [precedence=right, level=5]
Rule 14    expr -> tuple
Rule 15    expr -> array
Rule 16    expr -> binary_expr
Rule 17    expr -> variable_declaration
Rule 18    expr -> case_of
Rule 19    expr -> call
Rule 20    expr -> if_expr
Rule 21    expr -> def_expr
Rule 22    expr -> literal
Rule 23    expr -> identifier
Rule 24    expr -> do
Rule 25    binary_expr -> expr INT_DIV expr  [precedence=left, level=4]
Rule 26    binary_expr -> expr * expr  [precedence=left, level=4]
Rule 27    binary_expr -> expr / expr  [precedence=left, level=4]
Rule 28    binary_expr -> expr - expr  [precedence=left, level=3]
Rule 29    binary_expr -> expr + expr  [precedence=left, level=3]
Rule 30    binary_expr -> expr CONCAT expr  [precedence=left, level=2]
Rule 31    do -> DO _3_optional _4_optional _5_repeat END
Rule 32    _3_optional -> : type
Rule 33    _3_optional -> <empty>
Rule 34    _4_optional -> expr
Rule 35    _4_optional -> <empty>
Rule 36    _5_repeat -> _5_items
Rule 37    _5_repeat -> <empty>
Rule 38    _5_items -> _5_items _5_item
Rule 39    _5_items -> _5_item
Rule 40    _5_item -> NEWLINE expr
Rule 41    def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do
Rule 42    _6_optional -> param
Rule 43    _6_optional -> <empty>
Rule 44    _7_repeat -> _7_items
Rule 45    _7_repeat -> <empty>
Rule 46    _7_items -> _7_items _7_item
Rule 47    _7_items -> _7_item
Rule 48    _7_item -> , param
Rule 49    _8_optional -> type
Rule 50    _8_optional -> <empty>
Rule 51    type -> identifier _9_optional
Rule 52    _9_optional -> < type _10_repeat >
Rule 53    _10_repeat -> _10_items
Rule 54    _10_repeat -> <empty>
Rule 55    _10_items -> _10_items _10_item
Rule 56    _10_items -> _10_item
Rule 57    _10_item -> , type
Rule 58    _9_optional -> <empty>
Rule 59    struct -> STRUCT identifier _11_optional { _13_repeat }
Rule 60    _11_optional -> < identifier _12_repeat >
Rule 61    _12_repeat -> _12_items
Rule 62    _12_repeat -> <empty>
Rule 63    _12_items -> _12_items _12_item
Rule 64    _12_items -> _12_item
Rule 65    _12_item -> , identifier
Rule 66    _11_optional -> <empty>
Rule 67    _13_repeat -> _13_items
Rule 68    _13_repeat -> <empty>
Rule 69    _13_items -> _13_items _13_item
Rule 70    _13_items -> _13_item
Rule 71    _13_item -> identifier type
Rule 72    enum -> ENUM identifier _14_optional { _16_repeat }
Rule 73    _14_optional -> < identifier _15_repeat >
Rule 74    _15_repeat -> _15_items
Rule 75    _15_repeat -> <empty>
Rule 76    _15_items -> _15_items _15_item
Rule 77    _15_items -> _15_item
Rule 78    _15_item -> , identifier
Rule 79    _14_optional -> <empty>
Rule 80    _16_repeat -> _16_items
Rule 81    _16_repeat -> <empty>
Rule 82    _16_items -> _16_items _16_item
Rule 83    _16_items -> _16_item
Rule 84    _16_item -> enum_key
Rule 85    enum_key -> identifier _17_optional
Rule 86    _17_optional -> ( identifier _18_repeat )
Rule 87    _18_repeat -> _18_items
Rule 88    _18_repeat -> <empty>
Rule 89    _18_items -> _18_items _18_item
Rule 90    _18_items -> _18_item
Rule 91    _18_item -> , identifier
Rule 92    _17_optional -> <empty>
Rule 93    param -> identifier _19_optional
Rule 94    _19_optional -> : type
Rule 95    _19_optional -> <empty>
Rule 96    if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
Rule 97    _20_optional -> : type
Rule 98    _20_optional -> <empty>
Rule 99    _21_optional -> expr
Rule 100   _21_optional -> <empty>
Rule 101   _22_repeat -> _22_items
Rule 102   _22_repeat -> <empty>
Rule 103   _22_items -> _22_items _22_item
Rule 104   _22_items -> _22_item
Rule 105   _22_item -> NEWLINE expr
Rule 106   _23_repeat -> _23_items
Rule 107   _23_repeat -> <empty>
Rule 108   _23_items -> _23_items _23_item
Rule 109   _23_items -> _23_item
Rule 110   _23_item -> elif_expr
Rule 111   _24_optional -> else_expr
Rule 112   _24_optional -> <empty>
Rule 113   else_expr -> ELSE _25_optional _26_repeat
Rule 114   _25_optional -> expr
Rule 115   _25_optional -> <empty>
Rule 116   _26_repeat -> _26_items
Rule 117   _26_repeat -> <empty>
Rule 118   _26_items -> _26_items _26_item
Rule 119   _26_items -> _26_item
Rule 120   _26_item -> NEWLINE expr
Rule 121   elif_expr -> ELIF expr THEN _27_optional _28_optional _29_repeat
Rule 122   _27_optional -> : type
Rule 123   _27_optional -> <empty>
Rule 124   _28_optional -> expr
Rule 125   _28_optional -> <empty>
Rule 126   _29_repeat -> _29_items
Rule 127   _29_repeat -> <empty>
Rule 128   _29_items -> _29_items _29_item
Rule 129   _29_items -> _29_item
Rule 130   _29_item -> NEWLINE expr
Rule 131   case_of -> CASE expr OF case _30_repeat END
Rule 132   _30_repeat -> _30_items
Rule 133   _30_repeat -> <empty>
Rule 134   _30_items -> _30_items _30_item
Rule 135   _30_items -> _30_item
Rule 136   _30_item -> case
Rule 137   case -> pattern do
Rule 138   pattern -> enum_pattern
Rule 139   enum_pattern -> identifier _31_optional
Rule 140   _31_optional -> ( pattern _32_repeat )
Rule 141   _32_repeat -> _32_items
Rule 142   _32_repeat -> <empty>
Rule 143   _32_items -> _32_items _32_item
Rule 144   _32_items -> _32_item
Rule 145   _32_item -> , pattern
Rule 146   _31_optional -> <empty>
Rule 147   array -> [ _33_optional _34_repeat ]
Rule 148   _33_optional -> expr
Rule 149   _33_optional -> <empty>
Rule 150   _34_repeat -> _34_items
Rule 151   _34_repeat -> <empty>
Rule 152   _34_items -> _34_items _34_item
Rule 153   _34_items -> _34_item
Rule 154   _34_item -> , expr
Rule 155   tuple -> { _35_optional _36_repeat }
Rule 156   _35_optional -> expr
Rule 157   _35_optional -> <empty>
Rule 158   _36_repeat -> _36_items
Rule 159   _36_repeat -> <empty>
Rule 160   _36_items -> _36_items _36_item
Rule 161   _36_items -> _36_item
Rule 162   _36_item -> , expr
Rule 163   call -> callee ( _37_optional _38_repeat )
Rule 164   _37_optional -> expr
Rule 165   _37_optional -> <empty>
Rule 166   _38_repeat -> _38_items
Rule 167   _38_repeat -> <empty>
Rule 168   _38_items -> _38_items _38_item
Rule 169   _38_items -> _38_item
Rule 170   _38_item -> , expr
Rule 171   callee -> identifier
Rule 172   identifier -> IDENTIFIER
Rule 173   variable_declaration -> identifier _39_optional = expr  [precedence=left, level=1]
Rule 174   _39_optional -> : type
Rule 175   _39_optional -> <empty>
Rule 176   literal -> STRING
Rule 177   literal -> NUMBER

Unused terminals:

    SPREAD

Terminals, with rules where they appear:

(                    : 12 41 86 140 163
)                    : 12 41 86 140 163
*                    : 26
+                    : 29
,                    : 48 57 65 78 91 145 154 162 170
-                    : 13 28
/                    : 27
:                    : 32 94 97 122 174
<                    : 52 60 73
=                    : 173
>                    : 52 60 73
CASE                 : 131
CONCAT               : 30
DEF                  : 41
DO                   : 31
ELIF                 : 121
ELSE                 : 113
END                  : 31 96 131
ENUM                 : 72
IDENTIFIER           : 172
IF                   : 96
INT_DIV              : 25
NEWLINE              : 8 40 105 120 130
NUMBER               : 177
OF                   : 131
SPREAD               : 
STRING               : 176
STRUCT               : 59
THEN                 : 96 121
[                    : 147
]                    : 147
error                : 
{                    : 59 72 155
}                    : 59 72 155

Nonterminals, with rules where they appear:

_10_item             : 55 56
_10_items            : 53 55
_10_repeat           : 52
_11_optional         : 59
_12_item             : 63 64
_12_items            : 61 63
_12_repeat           : 60
_13_item             : 69 70
_13_items            : 67 69
_13_repeat           : 59
_14_optional         : 72
_15_item             : 76 77
_15_items            : 74 76
_15_repeat           : 73
_16_item             : 82 83
_16_items            : 80 82
_16_repeat           : 72
_17_optional         : 85
_18_item             : 89 90
_18_items            : 87 89
_18_repeat           : 86
_19_optional         : 93
_1_optional          : 1
_20_optional         : 96
_21_optional         : 96
_22_item             : 103 104
_22_items            : 101 103
_22_repeat           : 96
_23_item             : 108 109
_23_items            : 106 108
_23_repeat           : 96
_24_optional         : 96
_25_optional         : 113
_26_item             : 118 119
_26_items            : 116 118
_26_repeat           : 113
_27_optional         : 121
_28_optional         : 121
_29_item             : 128 129
_29_items            : 126 128
_29_repeat           : 121
_2_item              : 6 7
_2_items             : 4 6
_2_repeat            : 1
_30_item             : 134 135
_30_items            : 132 134
_30_repeat           : 131
_31_optional         : 139
_32_item             : 143 144
_32_items            : 141 143
_32_repeat           : 140
_33_optional         : 147
_34_item             : 152 153
_34_items            : 150 152
_34_repeat           : 147
_35_optional         : 155
_36_item             : 160 161
_36_items            : 158 160
_36_repeat           : 155
_37_optional         : 163
_38_item             : 168 169
_38_items            : 166 168
_38_repeat           : 163
_39_optional         : 173
_3_optional          : 31
_4_optional          : 31
_5_item              : 38 39
_5_items             : 36 38
_5_repeat            : 31
_6_optional          : 41
_7_item              : 46 47
_7_items             : 44 46
_7_repeat            : 41
_8_optional          : 41
_9_optional          : 51
array                : 15
binary_expr          : 16
call                 : 19
callee               : 163
case                 : 131 136
case_of              : 18
def_expr             : 21
do                   : 24 41 137
elif_expr            : 110
else_expr            : 111
enum                 : 9
enum_key             : 84
enum_pattern         : 138
expr                 : 11 12 13 25 25 26 26 27 27 28 28 29 29 30 30 34 40 96 99 105 114 120 121 124 130 131 148 154 156 162 164 170 173
identifier           : 23 41 51 59 60 65 71 72 73 78 85 86 91 93 139 171 173
if_expr              : 20
literal              : 22
param                : 42 48
pattern              : 137 140 145
program              : 0
stmt                 : 2 8
struct               : 10
tuple                : 14
type                 : 32 49 52 57 71 94 97 122 174
variable_declaration : 17


state 0

    (0) S' -> . program
    (1) program -> . _1_optional _2_repeat
    (2) _1_optional -> . stmt
    (3) _1_optional -> .
    (9) stmt -> . enum
    (10) stmt -> . struct
    (11) stmt -> . expr
    (72) enum -> . ENUM identifier _14_optional { _16_repeat }
    (59) struct -> . STRUCT identifier _11_optional { _13_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    NEWLINE         reduce using rule 3 (_1_optional -> .)
    $end            reduce using rule 3 (_1_optional -> .)
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    program                        shift and go to state 1
    _1_optional                    shift and go to state 2
    stmt                           shift and go to state 3
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    identifier                     shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_optional . _2_repeat
    (4) _2_repeat -> . _2_items
    (5) _2_repeat -> .
    (6) _2_items -> . _2_items _2_item
    (7) _2_items -> . _2_item
    (8) _2_item -> . NEWLINE stmt
    $end            reduce using rule 5 (_2_repeat -> .)
    NEWLINE         shift and go to state 35

    _2_repeat                      shift and go to state 32
    _2_items                       shift and go to state 33
    _2_item                        shift and go to state 34

state 3

    (2) _1_optional -> stmt .
    NEWLINE         reduce using rule 2 (_1_optional -> stmt .)
    $end            reduce using rule 2 (_1_optional -> stmt .)


state 4

    (9) stmt -> enum .
    NEWLINE         reduce using rule 9 (stmt -> enum .)
    $end            reduce using rule 9 (stmt -> enum .)


state 5

    (10) stmt -> struct .
    NEWLINE         reduce using rule 10 (stmt -> struct .)
    $end            reduce using rule 10 (stmt -> struct .)


state 6

    (11) stmt -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 11 (stmt -> expr .)
    $end            reduce using rule 11 (stmt -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 7

    (72) enum -> ENUM . identifier _14_optional { _16_repeat }
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 42

state 8

    (23) expr -> identifier .
    (173) variable_declaration -> identifier . _39_optional = expr
    (171) callee -> identifier .
    (174) _39_optional -> . : type
    (175) _39_optional -> .
    INT_DIV         reduce using rule 23 (expr -> identifier .)
    *               reduce using rule 23 (expr -> identifier .)
    /               reduce using rule 23 (expr -> identifier .)
    -               reduce using rule 23 (expr -> identifier .)
    +               reduce using rule 23 (expr -> identifier .)
    CONCAT          reduce using rule 23 (expr -> identifier .)
    NEWLINE         reduce using rule 23 (expr -> identifier .)
    $end            reduce using rule 23 (expr -> identifier .)
    ,               reduce using rule 23 (expr -> identifier .)
    }               reduce using rule 23 (expr -> identifier .)
    )               reduce using rule 23 (expr -> identifier .)
    ]               reduce using rule 23 (expr -> identifier .)
    OF              reduce using rule 23 (expr -> identifier .)
    THEN            reduce using rule 23 (expr -> identifier .)
    END             reduce using rule 23 (expr -> identifier .)
    ELIF            reduce using rule 23 (expr -> identifier .)
    ELSE            reduce using rule 23 (expr -> identifier .)
    (               reduce using rule 171 (callee -> identifier .)
    :               shift and go to state 44
    =               reduce using rule 175 (_39_optional -> .)

    _39_optional                   shift and go to state 43

state 9

    (155) tuple -> { . _35_optional _36_repeat }
    (156) _35_optional -> . expr
    (157) _35_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    ,               reduce using rule 157 (_35_optional -> .)
    }               reduce using rule 157 (_35_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    _35_optional                   shift and go to state 45
    expr                           shift and go to state 46
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 10

    (59) struct -> STRUCT . identifier _11_optional { _13_repeat }
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 47

state 11

    (12) expr -> ( . expr )
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 48
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 12

    (13) expr -> - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 49
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 13

    (14) expr -> tuple .
    INT_DIV         reduce using rule 14 (expr -> tuple .)
    *               reduce using rule 14 (expr -> tuple .)
    /               reduce using rule 14 (expr -> tuple .)
    -               reduce using rule 14 (expr -> tuple .)
    +               reduce using rule 14 (expr -> tuple .)
    CONCAT          reduce using rule 14 (expr -> tuple .)
    NEWLINE         reduce using rule 14 (expr -> tuple .)
    $end            reduce using rule 14 (expr -> tuple .)
    ,               reduce using rule 14 (expr -> tuple .)
    }               reduce using rule 14 (expr -> tuple .)
    )               reduce using rule 14 (expr -> tuple .)
    ]               reduce using rule 14 (expr -> tuple .)
    OF              reduce using rule 14 (expr -> tuple .)
    THEN            reduce using rule 14 (expr -> tuple .)
    END             reduce using rule 14 (expr -> tuple .)
    ELIF            reduce using rule 14 (expr -> tuple .)
    ELSE            reduce using rule 14 (expr -> tuple .)


state 14

    (15) expr -> array .
    INT_DIV         reduce using rule 15 (expr -> array .)
    *               reduce using rule 15 (expr -> array .)
    /               reduce using rule 15 (expr -> array .)
    -               reduce using rule 15 (expr -> array .)
    +               reduce using rule 15 (expr -> array .)
    CONCAT          reduce using rule 15 (expr -> array .)
    NEWLINE         reduce using rule 15 (expr -> array .)
    $end            reduce using rule 15 (expr -> array .)
    ,               reduce using rule 15 (expr -> array .)
    }               reduce using rule 15 (expr -> array .)
    )               reduce using rule 15 (expr -> array .)
    ]               reduce using rule 15 (expr -> array .)
    OF              reduce using rule 15 (expr -> array .)
    THEN            reduce using rule 15 (expr -> array .)
    END             reduce using rule 15 (expr -> array .)
    ELIF            reduce using rule 15 (expr -> array .)
    ELSE            reduce using rule 15 (expr -> array .)


state 15

    (16) expr -> binary_expr .
    INT_DIV         reduce using rule 16 (expr -> binary_expr .)
    *               reduce using rule 16 (expr -> binary_expr .)
    /               reduce using rule 16 (expr -> binary_expr .)
    -               reduce using rule 16 (expr -> binary_expr .)
    +               reduce using rule 16 (expr -> binary_expr .)
    CONCAT          reduce using rule 16 (expr -> binary_expr .)
    NEWLINE         reduce using rule 16 (expr -> binary_expr .)
    $end            reduce using rule 16 (expr -> binary_expr .)
    ,               reduce using rule 16 (expr -> binary_expr .)
    }               reduce using rule 16 (expr -> binary_expr .)
    )               reduce using rule 16 (expr -> binary_expr .)
    ]               reduce using rule 16 (expr -> binary_expr .)
    OF              reduce using rule 16 (expr -> binary_expr .)
    THEN            reduce using rule 16 (expr -> binary_expr .)
    END             reduce using rule 16 (expr -> binary_expr .)
    ELIF            reduce using rule 16 (expr -> binary_expr .)
    ELSE            reduce using rule 16 (expr -> binary_expr .)


state 16

    (17) expr -> variable_declaration .
    INT_DIV         reduce using rule 17 (expr -> variable_declaration .)
    *               reduce using rule 17 (expr -> variable_declaration .)
    /               reduce using rule 17 (expr -> variable_declaration .)
    -               reduce using rule 17 (expr -> variable_declaration .)
    +               reduce using rule 17 (expr -> variable_declaration .)
    CONCAT          reduce using rule 17 (expr -> variable_declaration .)
    NEWLINE         reduce using rule 17 (expr -> variable_declaration .)
    $end            reduce using rule 17 (expr -> variable_declaration .)
    ,               reduce using rule 17 (expr -> variable_declaration .)
    }               reduce using rule 17 (expr -> variable_declaration .)
    )               reduce using rule 17 (expr -> variable_declaration .)
    ]               reduce using rule 17 (expr -> variable_declaration .)
    OF              reduce using rule 17 (expr -> variable_declaration .)
    THEN            reduce using rule 17 (expr -> variable_declaration .)
    END             reduce using rule 17 (expr -> variable_declaration .)
    ELIF            reduce using rule 17 (expr -> variable_declaration .)
    ELSE            reduce using rule 17 (expr -> variable_declaration .)


state 17

    (18) expr -> case_of .
    INT_DIV         reduce using rule 18 (expr -> case_of .)
    *               reduce using rule 18 (expr -> case_of .)
    /               reduce using rule 18 (expr -> case_of .)
    -               reduce using rule 18 (expr -> case_of .)
    +               reduce using rule 18 (expr -> case_of .)
    CONCAT          reduce using rule 18 (expr -> case_of .)
    NEWLINE         reduce using rule 18 (expr -> case_of .)
    $end            reduce using rule 18 (expr -> case_of .)
    ,               reduce using rule 18 (expr -> case_of .)
    }               reduce using rule 18 (expr -> case_of .)
    )               reduce using rule 18 (expr -> case_of .)
    ]               reduce using rule 18 (expr -> case_of .)
    OF              reduce using rule 18 (expr -> case_of .)
    THEN            reduce using rule 18 (expr -> case_of .)
    END             reduce using rule 18 (expr -> case_of .)
    ELIF            reduce using rule 18 (expr -> case_of .)
    ELSE            reduce using rule 18 (expr -> case_of .)


state 18

    (19) expr -> call .
    INT_DIV         reduce using rule 19 (expr -> call .)
    *               reduce using rule 19 (expr -> call .)
    /               reduce using rule 19 (expr -> call .)
    -               reduce using rule 19 (expr -> call .)
    +               reduce using rule 19 (expr -> call .)
    CONCAT          reduce using rule 19 (expr -> call .)
    NEWLINE         reduce using rule 19 (expr -> call .)
    $end            reduce using rule 19 (expr -> call .)
    ,               reduce using rule 19 (expr -> call .)
    }               reduce using rule 19 (expr -> call .)
    )               reduce using rule 19 (expr -> call .)
    ]               reduce using rule 19 (expr -> call .)
    OF              reduce using rule 19 (expr -> call .)
    THEN            reduce using rule 19 (expr -> call .)
    END             reduce using rule 19 (expr -> call .)
    ELIF            reduce using rule 19 (expr -> call .)
    ELSE            reduce using rule 19 (expr -> call .)


state 19

    (20) expr -> if_expr .
    INT_DIV         reduce using rule 20 (expr -> if_expr .)
    *               reduce using rule 20 (expr -> if_expr .)
    /               reduce using rule 20 (expr -> if_expr .)
    -               reduce using rule 20 (expr -> if_expr .)
    +               reduce using rule 20 (expr -> if_expr .)
    CONCAT          reduce using rule 20 (expr -> if_expr .)
    NEWLINE         reduce using rule 20 (expr -> if_expr .)
    $end            reduce using rule 20 (expr -> if_expr .)
    ,               reduce using rule 20 (expr -> if_expr .)
    }               reduce using rule 20 (expr -> if_expr .)
    )               reduce using rule 20 (expr -> if_expr .)
    ]               reduce using rule 20 (expr -> if_expr .)
    OF              reduce using rule 20 (expr -> if_expr .)
    THEN            reduce using rule 20 (expr -> if_expr .)
    END             reduce using rule 20 (expr -> if_expr .)
    ELIF            reduce using rule 20 (expr -> if_expr .)
    ELSE            reduce using rule 20 (expr -> if_expr .)


state 20

    (21) expr -> def_expr .
    INT_DIV         reduce using rule 21 (expr -> def_expr .)
    *               reduce using rule 21 (expr -> def_expr .)
    /               reduce using rule 21 (expr -> def_expr .)
    -               reduce using rule 21 (expr -> def_expr .)
    +               reduce using rule 21 (expr -> def_expr .)
    CONCAT          reduce using rule 21 (expr -> def_expr .)
    NEWLINE         reduce using rule 21 (expr -> def_expr .)
    $end            reduce using rule 21 (expr -> def_expr .)
    ,               reduce using rule 21 (expr -> def_expr .)
    }               reduce using rule 21 (expr -> def_expr .)
    )               reduce using rule 21 (expr -> def_expr .)
    ]               reduce using rule 21 (expr -> def_expr .)
    OF              reduce using rule 21 (expr -> def_expr .)
    THEN            reduce using rule 21 (expr -> def_expr .)
    END             reduce using rule 21 (expr -> def_expr .)
    ELIF            reduce using rule 21 (expr -> def_expr .)
    ELSE            reduce using rule 21 (expr -> def_expr .)


state 21

    (22) expr -> literal .
    INT_DIV         reduce using rule 22 (expr -> literal .)
    *               reduce using rule 22 (expr -> literal .)
    /               reduce using rule 22 (expr -> literal .)
    -               reduce using rule 22 (expr -> literal .)
    +               reduce using rule 22 (expr -> literal .)
    CONCAT          reduce using rule 22 (expr -> literal .)
    NEWLINE         reduce using rule 22 (expr -> literal .)
    $end            reduce using rule 22 (expr -> literal .)
    ,               reduce using rule 22 (expr -> literal .)
    }               reduce using rule 22 (expr -> literal .)
    )               reduce using rule 22 (expr -> literal .)
    ]               reduce using rule 22 (expr -> literal .)
    OF              reduce using rule 22 (expr -> literal .)
    THEN            reduce using rule 22 (expr -> literal .)
    END             reduce using rule 22 (expr -> literal .)
    ELIF            reduce using rule 22 (expr -> literal .)
    ELSE            reduce using rule 22 (expr -> literal .)


state 22

    (24) expr -> do .
    INT_DIV         reduce using rule 24 (expr -> do .)
    *               reduce using rule 24 (expr -> do .)
    /               reduce using rule 24 (expr -> do .)
    -               reduce using rule 24 (expr -> do .)
    +               reduce using rule 24 (expr -> do .)
    CONCAT          reduce using rule 24 (expr -> do .)
    NEWLINE         reduce using rule 24 (expr -> do .)
    $end            reduce using rule 24 (expr -> do .)
    ,               reduce using rule 24 (expr -> do .)
    }               reduce using rule 24 (expr -> do .)
    )               reduce using rule 24 (expr -> do .)
    ]               reduce using rule 24 (expr -> do .)
    OF              reduce using rule 24 (expr -> do .)
    THEN            reduce using rule 24 (expr -> do .)
    END             reduce using rule 24 (expr -> do .)
    ELIF            reduce using rule 24 (expr -> do .)
    ELSE            reduce using rule 24 (expr -> do .)


state 23

    (147) array -> [ . _33_optional _34_repeat ]
    (148) _33_optional -> . expr
    (149) _33_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    ,               reduce using rule 149 (_33_optional -> .)
    ]               reduce using rule 149 (_33_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    _33_optional                   shift and go to state 50
    expr                           shift and go to state 51
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 24

    (131) case_of -> CASE . expr OF case _30_repeat END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 52
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 25

    (163) call -> callee . ( _37_optional _38_repeat )
    (               shift and go to state 53


state 26

    (96) if_expr -> IF . expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 54
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 27

    (41) def_expr -> DEF . identifier ( _6_optional _7_repeat ) _8_optional do
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 55

state 28

    (176) literal -> STRING .
    INT_DIV         reduce using rule 176 (literal -> STRING .)
    *               reduce using rule 176 (literal -> STRING .)
    /               reduce using rule 176 (literal -> STRING .)
    -               reduce using rule 176 (literal -> STRING .)
    +               reduce using rule 176 (literal -> STRING .)
    CONCAT          reduce using rule 176 (literal -> STRING .)
    NEWLINE         reduce using rule 176 (literal -> STRING .)
    $end            reduce using rule 176 (literal -> STRING .)
    ,               reduce using rule 176 (literal -> STRING .)
    }               reduce using rule 176 (literal -> STRING .)
    )               reduce using rule 176 (literal -> STRING .)
    ]               reduce using rule 176 (literal -> STRING .)
    OF              reduce using rule 176 (literal -> STRING .)
    THEN            reduce using rule 176 (literal -> STRING .)
    END             reduce using rule 176 (literal -> STRING .)
    ELIF            reduce using rule 176 (literal -> STRING .)
    ELSE            reduce using rule 176 (literal -> STRING .)


state 29

    (177) literal -> NUMBER .
    INT_DIV         reduce using rule 177 (literal -> NUMBER .)
    *               reduce using rule 177 (literal -> NUMBER .)
    /               reduce using rule 177 (literal -> NUMBER .)
    -               reduce using rule 177 (literal -> NUMBER .)
    +               reduce using rule 177 (literal -> NUMBER .)
    CONCAT          reduce using rule 177 (literal -> NUMBER .)
    NEWLINE         reduce using rule 177 (literal -> NUMBER .)
    $end            reduce using rule 177 (literal -> NUMBER .)
    ,               reduce using rule 177 (literal -> NUMBER .)
    }               reduce using rule 177 (literal -> NUMBER .)
    )               reduce using rule 177 (literal -> NUMBER .)
    ]               reduce using rule 177 (literal -> NUMBER .)
    OF              reduce using rule 177 (literal -> NUMBER .)
    THEN            reduce using rule 177 (literal -> NUMBER .)
    END             reduce using rule 177 (literal -> NUMBER .)
    ELIF            reduce using rule 177 (literal -> NUMBER .)
    ELSE            reduce using rule 177 (literal -> NUMBER .)


state 30

    (172) identifier -> IDENTIFIER .
    :               reduce using rule 172 (identifier -> IDENTIFIER .)
    =               reduce using rule 172 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 172 (identifier -> IDENTIFIER .)
    *               reduce using rule 172 (identifier -> IDENTIFIER .)
    /               reduce using rule 172 (identifier -> IDENTIFIER .)
    -               reduce using rule 172 (identifier -> IDENTIFIER .)
    +               reduce using rule 172 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 172 (identifier -> IDENTIFIER .)
    NEWLINE         reduce using rule 172 (identifier -> IDENTIFIER .)
    $end            reduce using rule 172 (identifier -> IDENTIFIER .)
    (               reduce using rule 172 (identifier -> IDENTIFIER .)
    <               reduce using rule 172 (identifier -> IDENTIFIER .)
    {               reduce using rule 172 (identifier -> IDENTIFIER .)
    ,               reduce using rule 172 (identifier -> IDENTIFIER .)
    }               reduce using rule 172 (identifier -> IDENTIFIER .)
    )               reduce using rule 172 (identifier -> IDENTIFIER .)
    ]               reduce using rule 172 (identifier -> IDENTIFIER .)
    OF              reduce using rule 172 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 172 (identifier -> IDENTIFIER .)
    END             reduce using rule 172 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 172 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 172 (identifier -> IDENTIFIER .)
    [               reduce using rule 172 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 172 (identifier -> IDENTIFIER .)
    IF              reduce using rule 172 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 172 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 172 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 172 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 172 (identifier -> IDENTIFIER .)
    DO              reduce using rule 172 (identifier -> IDENTIFIER .)
    >               reduce using rule 172 (identifier -> IDENTIFIER .)


state 31

    (31) do -> DO . _3_optional _4_optional _5_repeat END
    (32) _3_optional -> . : type
    (33) _3_optional -> .
    :               shift and go to state 57
    (               reduce using rule 33 (_3_optional -> .)
    -               reduce using rule 33 (_3_optional -> .)
    {               reduce using rule 33 (_3_optional -> .)
    [               reduce using rule 33 (_3_optional -> .)
    CASE            reduce using rule 33 (_3_optional -> .)
    IF              reduce using rule 33 (_3_optional -> .)
    DEF             reduce using rule 33 (_3_optional -> .)
    STRING          reduce using rule 33 (_3_optional -> .)
    NUMBER          reduce using rule 33 (_3_optional -> .)
    IDENTIFIER      reduce using rule 33 (_3_optional -> .)
    DO              reduce using rule 33 (_3_optional -> .)
    NEWLINE         reduce using rule 33 (_3_optional -> .)
    END             reduce using rule 33 (_3_optional -> .)

    _3_optional                    shift and go to state 56

state 32

    (1) program -> _1_optional _2_repeat .
    $end            reduce using rule 1 (program -> _1_optional _2_repeat .)


state 33

    (4) _2_repeat -> _2_items .
    (6) _2_items -> _2_items . _2_item
    (8) _2_item -> . NEWLINE stmt
    $end            reduce using rule 4 (_2_repeat -> _2_items .)
    NEWLINE         shift and go to state 35

    _2_item                        shift and go to state 58

state 34

    (7) _2_items -> _2_item .
    NEWLINE         reduce using rule 7 (_2_items -> _2_item .)
    $end            reduce using rule 7 (_2_items -> _2_item .)


state 35

    (8) _2_item -> NEWLINE . stmt
    (9) stmt -> . enum
    (10) stmt -> . struct
    (11) stmt -> . expr
    (72) enum -> . ENUM identifier _14_optional { _16_repeat }
    (59) struct -> . STRUCT identifier _11_optional { _13_repeat }
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    ENUM            shift and go to state 7
    STRUCT          shift and go to state 10
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    stmt                           shift and go to state 59
    enum                           shift and go to state 4
    struct                         shift and go to state 5
    expr                           shift and go to state 6
    identifier                     shift and go to state 8
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 36

    (25) binary_expr -> expr INT_DIV . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 60
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 37

    (26) binary_expr -> expr * . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 61
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 38

    (27) binary_expr -> expr / . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 62
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 39

    (28) binary_expr -> expr - . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 63
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 40

    (29) binary_expr -> expr + . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 64
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 41

    (30) binary_expr -> expr CONCAT . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 65
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 42

    (72) enum -> ENUM identifier . _14_optional { _16_repeat }
    (73) _14_optional -> . < identifier _15_repeat >
    (79) _14_optional -> .
    <               shift and go to state 67
    {               reduce using rule 79 (_14_optional -> .)

    _14_optional                   shift and go to state 66

state 43

    (173) variable_declaration -> identifier _39_optional . = expr
    =               shift and go to state 68


state 44

    (174) _39_optional -> : . type
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    type                           shift and go to state 69
    identifier                     shift and go to state 70

state 45

    (155) tuple -> { _35_optional . _36_repeat }
    (158) _36_repeat -> . _36_items
    (159) _36_repeat -> .
    (160) _36_items -> . _36_items _36_item
    (161) _36_items -> . _36_item
    (162) _36_item -> . , expr
    }               reduce using rule 159 (_36_repeat -> .)
    ,               shift and go to state 74

    _36_repeat                     shift and go to state 71
    _36_items                      shift and go to state 72
    _36_item                       shift and go to state 73

state 46

    (156) _35_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 156 (_35_optional -> expr .)
    }               reduce using rule 156 (_35_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 47

    (59) struct -> STRUCT identifier . _11_optional { _13_repeat }
    (60) _11_optional -> . < identifier _12_repeat >
    (66) _11_optional -> .
    <               shift and go to state 76
    {               reduce using rule 66 (_11_optional -> .)

    _11_optional                   shift and go to state 75

state 48

    (12) expr -> ( expr . )
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    )               shift and go to state 77
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 49

    (13) expr -> - expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 13 (expr -> - expr .)
    *               reduce using rule 13 (expr -> - expr .)
    /               reduce using rule 13 (expr -> - expr .)
    -               reduce using rule 13 (expr -> - expr .)
    +               reduce using rule 13 (expr -> - expr .)
    CONCAT          reduce using rule 13 (expr -> - expr .)
    NEWLINE         reduce using rule 13 (expr -> - expr .)
    $end            reduce using rule 13 (expr -> - expr .)
    ,               reduce using rule 13 (expr -> - expr .)
    }               reduce using rule 13 (expr -> - expr .)
    )               reduce using rule 13 (expr -> - expr .)
    ]               reduce using rule 13 (expr -> - expr .)
    OF              reduce using rule 13 (expr -> - expr .)
    THEN            reduce using rule 13 (expr -> - expr .)
    END             reduce using rule 13 (expr -> - expr .)
    ELIF            reduce using rule 13 (expr -> - expr .)
    ELSE            reduce using rule 13 (expr -> - expr .)


state 50

    (147) array -> [ _33_optional . _34_repeat ]
    (150) _34_repeat -> . _34_items
    (151) _34_repeat -> .
    (152) _34_items -> . _34_items _34_item
    (153) _34_items -> . _34_item
    (154) _34_item -> . , expr
    ]               reduce using rule 151 (_34_repeat -> .)
    ,               shift and go to state 81

    _34_repeat                     shift and go to state 78
    _34_items                      shift and go to state 79
    _34_item                       shift and go to state 80

state 51

    (148) _33_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 148 (_33_optional -> expr .)
    ]               reduce using rule 148 (_33_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 52

    (131) case_of -> CASE expr . OF case _30_repeat END
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 82
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 53

    (163) call -> callee ( . _37_optional _38_repeat )
    (164) _37_optional -> . expr
    (165) _37_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    ,               reduce using rule 165 (_37_optional -> .)
    )               reduce using rule 165 (_37_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    callee                         shift and go to state 25
    _37_optional                   shift and go to state 83
    expr                           shift and go to state 84
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22

state 54

    (96) if_expr -> IF expr . THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 85
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 55

    (41) def_expr -> DEF identifier . ( _6_optional _7_repeat ) _8_optional do
    (               shift and go to state 86


state 56

    (31) do -> DO _3_optional . _4_optional _5_repeat END
    (34) _4_optional -> . expr
    (35) _4_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    NEWLINE         reduce using rule 35 (_4_optional -> .)
    END             reduce using rule 35 (_4_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    _4_optional                    shift and go to state 87
    expr                           shift and go to state 88
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 57

    (32) _3_optional -> : . type
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    type                           shift and go to state 89
    identifier                     shift and go to state 70

state 58

    (6) _2_items -> _2_items _2_item .
    NEWLINE         reduce using rule 6 (_2_items -> _2_items _2_item .)
    $end            reduce using rule 6 (_2_items -> _2_items _2_item .)


state 59

    (8) _2_item -> NEWLINE stmt .
    NEWLINE         reduce using rule 8 (_2_item -> NEWLINE stmt .)
    $end            reduce using rule 8 (_2_item -> NEWLINE stmt .)


state 60

    (25) binary_expr -> expr INT_DIV expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    NEWLINE         reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    }               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 25 (binary_expr -> expr INT_DIV expr .)


state 61

    (26) binary_expr -> expr * expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 26 (binary_expr -> expr * expr .)
    *               reduce using rule 26 (binary_expr -> expr * expr .)
    /               reduce using rule 26 (binary_expr -> expr * expr .)
    -               reduce using rule 26 (binary_expr -> expr * expr .)
    +               reduce using rule 26 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr * expr .)
    NEWLINE         reduce using rule 26 (binary_expr -> expr * expr .)
    $end            reduce using rule 26 (binary_expr -> expr * expr .)
    ,               reduce using rule 26 (binary_expr -> expr * expr .)
    }               reduce using rule 26 (binary_expr -> expr * expr .)
    )               reduce using rule 26 (binary_expr -> expr * expr .)
    ]               reduce using rule 26 (binary_expr -> expr * expr .)
    OF              reduce using rule 26 (binary_expr -> expr * expr .)
    THEN            reduce using rule 26 (binary_expr -> expr * expr .)
    END             reduce using rule 26 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr * expr .)


state 62

    (27) binary_expr -> expr / expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 27 (binary_expr -> expr / expr .)
    *               reduce using rule 27 (binary_expr -> expr / expr .)
    /               reduce using rule 27 (binary_expr -> expr / expr .)
    -               reduce using rule 27 (binary_expr -> expr / expr .)
    +               reduce using rule 27 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 27 (binary_expr -> expr / expr .)
    NEWLINE         reduce using rule 27 (binary_expr -> expr / expr .)
    $end            reduce using rule 27 (binary_expr -> expr / expr .)
    ,               reduce using rule 27 (binary_expr -> expr / expr .)
    }               reduce using rule 27 (binary_expr -> expr / expr .)
    )               reduce using rule 27 (binary_expr -> expr / expr .)
    ]               reduce using rule 27 (binary_expr -> expr / expr .)
    OF              reduce using rule 27 (binary_expr -> expr / expr .)
    THEN            reduce using rule 27 (binary_expr -> expr / expr .)
    END             reduce using rule 27 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr / expr .)


state 63

    (28) binary_expr -> expr - expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    -               reduce using rule 28 (binary_expr -> expr - expr .)
    +               reduce using rule 28 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 28 (binary_expr -> expr - expr .)
    NEWLINE         reduce using rule 28 (binary_expr -> expr - expr .)
    $end            reduce using rule 28 (binary_expr -> expr - expr .)
    ,               reduce using rule 28 (binary_expr -> expr - expr .)
    }               reduce using rule 28 (binary_expr -> expr - expr .)
    )               reduce using rule 28 (binary_expr -> expr - expr .)
    ]               reduce using rule 28 (binary_expr -> expr - expr .)
    OF              reduce using rule 28 (binary_expr -> expr - expr .)
    THEN            reduce using rule 28 (binary_expr -> expr - expr .)
    END             reduce using rule 28 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr - expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38


state 64

    (29) binary_expr -> expr + expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    -               reduce using rule 29 (binary_expr -> expr + expr .)
    +               reduce using rule 29 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 29 (binary_expr -> expr + expr .)
    NEWLINE         reduce using rule 29 (binary_expr -> expr + expr .)
    $end            reduce using rule 29 (binary_expr -> expr + expr .)
    ,               reduce using rule 29 (binary_expr -> expr + expr .)
    }               reduce using rule 29 (binary_expr -> expr + expr .)
    )               reduce using rule 29 (binary_expr -> expr + expr .)
    ]               reduce using rule 29 (binary_expr -> expr + expr .)
    OF              reduce using rule 29 (binary_expr -> expr + expr .)
    THEN            reduce using rule 29 (binary_expr -> expr + expr .)
    END             reduce using rule 29 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr + expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38


state 65

    (30) binary_expr -> expr CONCAT expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    CONCAT          reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    NEWLINE         reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    }               reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr CONCAT expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40


state 66

    (72) enum -> ENUM identifier _14_optional . { _16_repeat }
    {               shift and go to state 90


state 67

    (73) _14_optional -> < . identifier _15_repeat >
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 91

state 68

    (173) variable_declaration -> identifier _39_optional = . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    identifier                     shift and go to state 8
    expr                           shift and go to state 92
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 69

    (174) _39_optional -> : type .
    =               reduce using rule 174 (_39_optional -> : type .)


state 70

    (51) type -> identifier . _9_optional
    (52) _9_optional -> . < type _10_repeat >
    (58) _9_optional -> .
    <               shift and go to state 94
    =               reduce using rule 58 (_9_optional -> .)
    (               reduce using rule 58 (_9_optional -> .)
    -               reduce using rule 58 (_9_optional -> .)
    {               reduce using rule 58 (_9_optional -> .)
    [               reduce using rule 58 (_9_optional -> .)
    CASE            reduce using rule 58 (_9_optional -> .)
    IF              reduce using rule 58 (_9_optional -> .)
    DEF             reduce using rule 58 (_9_optional -> .)
    STRING          reduce using rule 58 (_9_optional -> .)
    NUMBER          reduce using rule 58 (_9_optional -> .)
    IDENTIFIER      reduce using rule 58 (_9_optional -> .)
    DO              reduce using rule 58 (_9_optional -> .)
    NEWLINE         reduce using rule 58 (_9_optional -> .)
    END             reduce using rule 58 (_9_optional -> .)
    ,               reduce using rule 58 (_9_optional -> .)
    >               reduce using rule 58 (_9_optional -> .)
    ELIF            reduce using rule 58 (_9_optional -> .)
    ELSE            reduce using rule 58 (_9_optional -> .)
    }               reduce using rule 58 (_9_optional -> .)
    )               reduce using rule 58 (_9_optional -> .)

    _9_optional                    shift and go to state 93

state 71

    (155) tuple -> { _35_optional _36_repeat . }
    }               shift and go to state 95


state 72

    (158) _36_repeat -> _36_items .
    (160) _36_items -> _36_items . _36_item
    (162) _36_item -> . , expr
    }               reduce using rule 158 (_36_repeat -> _36_items .)
    ,               shift and go to state 74

    _36_item                       shift and go to state 96

state 73

    (161) _36_items -> _36_item .
    ,               reduce using rule 161 (_36_items -> _36_item .)
    }               reduce using rule 161 (_36_items -> _36_item .)


state 74

    (162) _36_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 97
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 75

    (59) struct -> STRUCT identifier _11_optional . { _13_repeat }
    {               shift and go to state 98


state 76

    (60) _11_optional -> < . identifier _12_repeat >
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 99

state 77

    (12) expr -> ( expr ) .
    INT_DIV         reduce using rule 12 (expr -> ( expr ) .)
    *               reduce using rule 12 (expr -> ( expr ) .)
    /               reduce using rule 12 (expr -> ( expr ) .)
    -               reduce using rule 12 (expr -> ( expr ) .)
    +               reduce using rule 12 (expr -> ( expr ) .)
    CONCAT          reduce using rule 12 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 12 (expr -> ( expr ) .)
    $end            reduce using rule 12 (expr -> ( expr ) .)
    ,               reduce using rule 12 (expr -> ( expr ) .)
    }               reduce using rule 12 (expr -> ( expr ) .)
    )               reduce using rule 12 (expr -> ( expr ) .)
    ]               reduce using rule 12 (expr -> ( expr ) .)
    OF              reduce using rule 12 (expr -> ( expr ) .)
    THEN            reduce using rule 12 (expr -> ( expr ) .)
    END             reduce using rule 12 (expr -> ( expr ) .)
    ELIF            reduce using rule 12 (expr -> ( expr ) .)
    ELSE            reduce using rule 12 (expr -> ( expr ) .)


state 78

    (147) array -> [ _33_optional _34_repeat . ]
    ]               shift and go to state 100


state 79

    (150) _34_repeat -> _34_items .
    (152) _34_items -> _34_items . _34_item
    (154) _34_item -> . , expr
    ]               reduce using rule 150 (_34_repeat -> _34_items .)
    ,               shift and go to state 81

    _34_item                       shift and go to state 101

state 80

    (153) _34_items -> _34_item .
    ,               reduce using rule 153 (_34_items -> _34_item .)
    ]               reduce using rule 153 (_34_items -> _34_item .)


state 81

    (154) _34_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 102
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 82

    (131) case_of -> CASE expr OF . case _30_repeat END
    (137) case -> . pattern do
    (138) pattern -> . enum_pattern
    (139) enum_pattern -> . identifier _31_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    case                           shift and go to state 103
    pattern                        shift and go to state 104
    enum_pattern                   shift and go to state 105
    identifier                     shift and go to state 106

state 83

    (163) call -> callee ( _37_optional . _38_repeat )
    (166) _38_repeat -> . _38_items
    (167) _38_repeat -> .
    (168) _38_items -> . _38_items _38_item
    (169) _38_items -> . _38_item
    (170) _38_item -> . , expr
    )               reduce using rule 167 (_38_repeat -> .)
    ,               shift and go to state 110

    _38_repeat                     shift and go to state 107
    _38_items                      shift and go to state 108
    _38_item                       shift and go to state 109

state 84

    (164) _37_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 164 (_37_optional -> expr .)
    )               reduce using rule 164 (_37_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 85

    (96) if_expr -> IF expr THEN . _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (97) _20_optional -> . : type
    (98) _20_optional -> .
    :               shift and go to state 112
    (               reduce using rule 98 (_20_optional -> .)
    -               reduce using rule 98 (_20_optional -> .)
    {               reduce using rule 98 (_20_optional -> .)
    [               reduce using rule 98 (_20_optional -> .)
    CASE            reduce using rule 98 (_20_optional -> .)
    IF              reduce using rule 98 (_20_optional -> .)
    DEF             reduce using rule 98 (_20_optional -> .)
    STRING          reduce using rule 98 (_20_optional -> .)
    NUMBER          reduce using rule 98 (_20_optional -> .)
    IDENTIFIER      reduce using rule 98 (_20_optional -> .)
    DO              reduce using rule 98 (_20_optional -> .)
    NEWLINE         reduce using rule 98 (_20_optional -> .)
    ELIF            reduce using rule 98 (_20_optional -> .)
    ELSE            reduce using rule 98 (_20_optional -> .)
    END             reduce using rule 98 (_20_optional -> .)

    _20_optional                   shift and go to state 111

state 86

    (41) def_expr -> DEF identifier ( . _6_optional _7_repeat ) _8_optional do
    (42) _6_optional -> . param
    (43) _6_optional -> .
    (93) param -> . identifier _19_optional
    (172) identifier -> . IDENTIFIER
    ,               reduce using rule 43 (_6_optional -> .)
    )               reduce using rule 43 (_6_optional -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 113
    _6_optional                    shift and go to state 114
    param                          shift and go to state 115

state 87

    (31) do -> DO _3_optional _4_optional . _5_repeat END
    (36) _5_repeat -> . _5_items
    (37) _5_repeat -> .
    (38) _5_items -> . _5_items _5_item
    (39) _5_items -> . _5_item
    (40) _5_item -> . NEWLINE expr
    END             reduce using rule 37 (_5_repeat -> .)
    NEWLINE         shift and go to state 119

    _5_repeat                      shift and go to state 116
    _5_items                       shift and go to state 117
    _5_item                        shift and go to state 118

state 88

    (34) _4_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 34 (_4_optional -> expr .)
    END             reduce using rule 34 (_4_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 89

    (32) _3_optional -> : type .
    (               reduce using rule 32 (_3_optional -> : type .)
    -               reduce using rule 32 (_3_optional -> : type .)
    {               reduce using rule 32 (_3_optional -> : type .)
    [               reduce using rule 32 (_3_optional -> : type .)
    CASE            reduce using rule 32 (_3_optional -> : type .)
    IF              reduce using rule 32 (_3_optional -> : type .)
    DEF             reduce using rule 32 (_3_optional -> : type .)
    STRING          reduce using rule 32 (_3_optional -> : type .)
    NUMBER          reduce using rule 32 (_3_optional -> : type .)
    IDENTIFIER      reduce using rule 32 (_3_optional -> : type .)
    DO              reduce using rule 32 (_3_optional -> : type .)
    NEWLINE         reduce using rule 32 (_3_optional -> : type .)
    END             reduce using rule 32 (_3_optional -> : type .)


state 90

    (72) enum -> ENUM identifier _14_optional { . _16_repeat }
    (80) _16_repeat -> . _16_items
    (81) _16_repeat -> .
    (82) _16_items -> . _16_items _16_item
    (83) _16_items -> . _16_item
    (84) _16_item -> . enum_key
    (85) enum_key -> . identifier _17_optional
    (172) identifier -> . IDENTIFIER
    }               reduce using rule 81 (_16_repeat -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 120
    _16_repeat                     shift and go to state 121
    _16_items                      shift and go to state 122
    _16_item                       shift and go to state 123
    enum_key                       shift and go to state 124

state 91

    (73) _14_optional -> < identifier . _15_repeat >
    (74) _15_repeat -> . _15_items
    (75) _15_repeat -> .
    (76) _15_items -> . _15_items _15_item
    (77) _15_items -> . _15_item
    (78) _15_item -> . , identifier
    >               reduce using rule 75 (_15_repeat -> .)
    ,               shift and go to state 128

    _15_repeat                     shift and go to state 125
    _15_items                      shift and go to state 126
    _15_item                       shift and go to state 127

state 92

    (173) variable_declaration -> identifier _39_optional = expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    $end            reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    ,               reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    }               reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    )               reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    ]               reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    OF              reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    THEN            reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    END             reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    ELIF            reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    ELSE            reduce using rule 173 (variable_declaration -> identifier _39_optional = expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 93

    (51) type -> identifier _9_optional .
    =               reduce using rule 51 (type -> identifier _9_optional .)
    (               reduce using rule 51 (type -> identifier _9_optional .)
    -               reduce using rule 51 (type -> identifier _9_optional .)
    {               reduce using rule 51 (type -> identifier _9_optional .)
    [               reduce using rule 51 (type -> identifier _9_optional .)
    CASE            reduce using rule 51 (type -> identifier _9_optional .)
    IF              reduce using rule 51 (type -> identifier _9_optional .)
    DEF             reduce using rule 51 (type -> identifier _9_optional .)
    STRING          reduce using rule 51 (type -> identifier _9_optional .)
    NUMBER          reduce using rule 51 (type -> identifier _9_optional .)
    IDENTIFIER      reduce using rule 51 (type -> identifier _9_optional .)
    DO              reduce using rule 51 (type -> identifier _9_optional .)
    NEWLINE         reduce using rule 51 (type -> identifier _9_optional .)
    END             reduce using rule 51 (type -> identifier _9_optional .)
    ,               reduce using rule 51 (type -> identifier _9_optional .)
    >               reduce using rule 51 (type -> identifier _9_optional .)
    ELIF            reduce using rule 51 (type -> identifier _9_optional .)
    ELSE            reduce using rule 51 (type -> identifier _9_optional .)
    }               reduce using rule 51 (type -> identifier _9_optional .)
    )               reduce using rule 51 (type -> identifier _9_optional .)


state 94

    (52) _9_optional -> < . type _10_repeat >
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    type                           shift and go to state 129
    identifier                     shift and go to state 70

state 95

    (155) tuple -> { _35_optional _36_repeat } .
    INT_DIV         reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    *               reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    /               reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    -               reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    +               reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    CONCAT          reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    NEWLINE         reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    $end            reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    ,               reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    }               reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    )               reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    ]               reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    OF              reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    THEN            reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    END             reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    ELIF            reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)
    ELSE            reduce using rule 155 (tuple -> { _35_optional _36_repeat } .)


state 96

    (160) _36_items -> _36_items _36_item .
    ,               reduce using rule 160 (_36_items -> _36_items _36_item .)
    }               reduce using rule 160 (_36_items -> _36_items _36_item .)


state 97

    (162) _36_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 162 (_36_item -> , expr .)
    }               reduce using rule 162 (_36_item -> , expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 98

    (59) struct -> STRUCT identifier _11_optional { . _13_repeat }
    (67) _13_repeat -> . _13_items
    (68) _13_repeat -> .
    (69) _13_items -> . _13_items _13_item
    (70) _13_items -> . _13_item
    (71) _13_item -> . identifier type
    (172) identifier -> . IDENTIFIER
    }               reduce using rule 68 (_13_repeat -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 130
    _13_repeat                     shift and go to state 131
    _13_items                      shift and go to state 132
    _13_item                       shift and go to state 133

state 99

    (60) _11_optional -> < identifier . _12_repeat >
    (61) _12_repeat -> . _12_items
    (62) _12_repeat -> .
    (63) _12_items -> . _12_items _12_item
    (64) _12_items -> . _12_item
    (65) _12_item -> . , identifier
    >               reduce using rule 62 (_12_repeat -> .)
    ,               shift and go to state 137

    _12_repeat                     shift and go to state 134
    _12_items                      shift and go to state 135
    _12_item                       shift and go to state 136

state 100

    (147) array -> [ _33_optional _34_repeat ] .
    INT_DIV         reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    *               reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    /               reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    -               reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    +               reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    CONCAT          reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    NEWLINE         reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    $end            reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    ,               reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    }               reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    )               reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    ]               reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    OF              reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    THEN            reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    END             reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    ELIF            reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)
    ELSE            reduce using rule 147 (array -> [ _33_optional _34_repeat ] .)


state 101

    (152) _34_items -> _34_items _34_item .
    ,               reduce using rule 152 (_34_items -> _34_items _34_item .)
    ]               reduce using rule 152 (_34_items -> _34_items _34_item .)


state 102

    (154) _34_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 154 (_34_item -> , expr .)
    ]               reduce using rule 154 (_34_item -> , expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 103

    (131) case_of -> CASE expr OF case . _30_repeat END
    (132) _30_repeat -> . _30_items
    (133) _30_repeat -> .
    (134) _30_items -> . _30_items _30_item
    (135) _30_items -> . _30_item
    (136) _30_item -> . case
    (137) case -> . pattern do
    (138) pattern -> . enum_pattern
    (139) enum_pattern -> . identifier _31_optional
    (172) identifier -> . IDENTIFIER
    END             reduce using rule 133 (_30_repeat -> .)
    IDENTIFIER      shift and go to state 30

    case                           shift and go to state 138
    _30_repeat                     shift and go to state 139
    _30_items                      shift and go to state 140
    _30_item                       shift and go to state 141
    pattern                        shift and go to state 104
    enum_pattern                   shift and go to state 105
    identifier                     shift and go to state 106

state 104

    (137) case -> pattern . do
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    DO              shift and go to state 31

    do                             shift and go to state 142

state 105

    (138) pattern -> enum_pattern .
    DO              reduce using rule 138 (pattern -> enum_pattern .)
    ,               reduce using rule 138 (pattern -> enum_pattern .)
    )               reduce using rule 138 (pattern -> enum_pattern .)


state 106

    (139) enum_pattern -> identifier . _31_optional
    (140) _31_optional -> . ( pattern _32_repeat )
    (146) _31_optional -> .
    (               shift and go to state 144
    DO              reduce using rule 146 (_31_optional -> .)
    ,               reduce using rule 146 (_31_optional -> .)
    )               reduce using rule 146 (_31_optional -> .)

    _31_optional                   shift and go to state 143

state 107

    (163) call -> callee ( _37_optional _38_repeat . )
    )               shift and go to state 145


state 108

    (166) _38_repeat -> _38_items .
    (168) _38_items -> _38_items . _38_item
    (170) _38_item -> . , expr
    )               reduce using rule 166 (_38_repeat -> _38_items .)
    ,               shift and go to state 110

    _38_item                       shift and go to state 146

state 109

    (169) _38_items -> _38_item .
    ,               reduce using rule 169 (_38_items -> _38_item .)
    )               reduce using rule 169 (_38_items -> _38_item .)


state 110

    (170) _38_item -> , . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 147
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 111

    (96) if_expr -> IF expr THEN _20_optional . _21_optional _22_repeat _23_repeat _24_optional END
    (99) _21_optional -> . expr
    (100) _21_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    NEWLINE         reduce using rule 100 (_21_optional -> .)
    ELIF            reduce using rule 100 (_21_optional -> .)
    ELSE            reduce using rule 100 (_21_optional -> .)
    END             reduce using rule 100 (_21_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 148
    _21_optional                   shift and go to state 149
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 112

    (97) _20_optional -> : . type
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    type                           shift and go to state 150
    identifier                     shift and go to state 70

state 113

    (93) param -> identifier . _19_optional
    (94) _19_optional -> . : type
    (95) _19_optional -> .
    :               shift and go to state 152
    ,               reduce using rule 95 (_19_optional -> .)
    )               reduce using rule 95 (_19_optional -> .)

    _19_optional                   shift and go to state 151

state 114

    (41) def_expr -> DEF identifier ( _6_optional . _7_repeat ) _8_optional do
    (44) _7_repeat -> . _7_items
    (45) _7_repeat -> .
    (46) _7_items -> . _7_items _7_item
    (47) _7_items -> . _7_item
    (48) _7_item -> . , param
    )               reduce using rule 45 (_7_repeat -> .)
    ,               shift and go to state 156

    _7_repeat                      shift and go to state 153
    _7_items                       shift and go to state 154
    _7_item                        shift and go to state 155

state 115

    (42) _6_optional -> param .
    ,               reduce using rule 42 (_6_optional -> param .)
    )               reduce using rule 42 (_6_optional -> param .)


state 116

    (31) do -> DO _3_optional _4_optional _5_repeat . END
    END             shift and go to state 157


state 117

    (36) _5_repeat -> _5_items .
    (38) _5_items -> _5_items . _5_item
    (40) _5_item -> . NEWLINE expr
    END             reduce using rule 36 (_5_repeat -> _5_items .)
    NEWLINE         shift and go to state 119

    _5_item                        shift and go to state 158

state 118

    (39) _5_items -> _5_item .
    NEWLINE         reduce using rule 39 (_5_items -> _5_item .)
    END             reduce using rule 39 (_5_items -> _5_item .)


state 119

    (40) _5_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 159
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 120

    (85) enum_key -> identifier . _17_optional
    (86) _17_optional -> . ( identifier _18_repeat )
    (92) _17_optional -> .
    (               shift and go to state 161
    IDENTIFIER      reduce using rule 92 (_17_optional -> .)
    }               reduce using rule 92 (_17_optional -> .)

    _17_optional                   shift and go to state 160

state 121

    (72) enum -> ENUM identifier _14_optional { _16_repeat . }
    }               shift and go to state 162


state 122

    (80) _16_repeat -> _16_items .
    (82) _16_items -> _16_items . _16_item
    (84) _16_item -> . enum_key
    (85) enum_key -> . identifier _17_optional
    (172) identifier -> . IDENTIFIER
    }               reduce using rule 80 (_16_repeat -> _16_items .)
    IDENTIFIER      shift and go to state 30

    _16_item                       shift and go to state 163
    enum_key                       shift and go to state 124
    identifier                     shift and go to state 120

state 123

    (83) _16_items -> _16_item .
    IDENTIFIER      reduce using rule 83 (_16_items -> _16_item .)
    }               reduce using rule 83 (_16_items -> _16_item .)


state 124

    (84) _16_item -> enum_key .
    IDENTIFIER      reduce using rule 84 (_16_item -> enum_key .)
    }               reduce using rule 84 (_16_item -> enum_key .)


state 125

    (73) _14_optional -> < identifier _15_repeat . >
    >               shift and go to state 164


state 126

    (74) _15_repeat -> _15_items .
    (76) _15_items -> _15_items . _15_item
    (78) _15_item -> . , identifier
    >               reduce using rule 74 (_15_repeat -> _15_items .)
    ,               shift and go to state 128

    _15_item                       shift and go to state 165

state 127

    (77) _15_items -> _15_item .
    ,               reduce using rule 77 (_15_items -> _15_item .)
    >               reduce using rule 77 (_15_items -> _15_item .)


state 128

    (78) _15_item -> , . identifier
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 166

state 129

    (52) _9_optional -> < type . _10_repeat >
    (53) _10_repeat -> . _10_items
    (54) _10_repeat -> .
    (55) _10_items -> . _10_items _10_item
    (56) _10_items -> . _10_item
    (57) _10_item -> . , type
    >               reduce using rule 54 (_10_repeat -> .)
    ,               shift and go to state 170

    _10_repeat                     shift and go to state 167
    _10_items                      shift and go to state 168
    _10_item                       shift and go to state 169

state 130

    (71) _13_item -> identifier . type
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 70
    type                           shift and go to state 171

state 131

    (59) struct -> STRUCT identifier _11_optional { _13_repeat . }
    }               shift and go to state 172


state 132

    (67) _13_repeat -> _13_items .
    (69) _13_items -> _13_items . _13_item
    (71) _13_item -> . identifier type
    (172) identifier -> . IDENTIFIER
    }               reduce using rule 67 (_13_repeat -> _13_items .)
    IDENTIFIER      shift and go to state 30

    _13_item                       shift and go to state 173
    identifier                     shift and go to state 130

state 133

    (70) _13_items -> _13_item .
    IDENTIFIER      reduce using rule 70 (_13_items -> _13_item .)
    }               reduce using rule 70 (_13_items -> _13_item .)


state 134

    (60) _11_optional -> < identifier _12_repeat . >
    >               shift and go to state 174


state 135

    (61) _12_repeat -> _12_items .
    (63) _12_items -> _12_items . _12_item
    (65) _12_item -> . , identifier
    >               reduce using rule 61 (_12_repeat -> _12_items .)
    ,               shift and go to state 137

    _12_item                       shift and go to state 175

state 136

    (64) _12_items -> _12_item .
    ,               reduce using rule 64 (_12_items -> _12_item .)
    >               reduce using rule 64 (_12_items -> _12_item .)


state 137

    (65) _12_item -> , . identifier
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 176

state 138

    (136) _30_item -> case .
    IDENTIFIER      reduce using rule 136 (_30_item -> case .)
    END             reduce using rule 136 (_30_item -> case .)


state 139

    (131) case_of -> CASE expr OF case _30_repeat . END
    END             shift and go to state 177


state 140

    (132) _30_repeat -> _30_items .
    (134) _30_items -> _30_items . _30_item
    (136) _30_item -> . case
    (137) case -> . pattern do
    (138) pattern -> . enum_pattern
    (139) enum_pattern -> . identifier _31_optional
    (172) identifier -> . IDENTIFIER
    END             reduce using rule 132 (_30_repeat -> _30_items .)
    IDENTIFIER      shift and go to state 30

    _30_item                       shift and go to state 178
    case                           shift and go to state 138
    pattern                        shift and go to state 104
    enum_pattern                   shift and go to state 105
    identifier                     shift and go to state 106

state 141

    (135) _30_items -> _30_item .
    IDENTIFIER      reduce using rule 135 (_30_items -> _30_item .)
    END             reduce using rule 135 (_30_items -> _30_item .)


state 142

    (137) case -> pattern do .
    IDENTIFIER      reduce using rule 137 (case -> pattern do .)
    END             reduce using rule 137 (case -> pattern do .)


state 143

    (139) enum_pattern -> identifier _31_optional .
    DO              reduce using rule 139 (enum_pattern -> identifier _31_optional .)
    ,               reduce using rule 139 (enum_pattern -> identifier _31_optional .)
    )               reduce using rule 139 (enum_pattern -> identifier _31_optional .)


state 144

    (140) _31_optional -> ( . pattern _32_repeat )
    (138) pattern -> . enum_pattern
    (139) enum_pattern -> . identifier _31_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 179
    enum_pattern                   shift and go to state 105
    identifier                     shift and go to state 106

state 145

    (163) call -> callee ( _37_optional _38_repeat ) .
    INT_DIV         reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    *               reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    /               reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    -               reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    +               reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    CONCAT          reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    NEWLINE         reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    $end            reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    ,               reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    }               reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    )               reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    ]               reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    OF              reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    THEN            reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    END             reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    ELIF            reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)
    ELSE            reduce using rule 163 (call -> callee ( _37_optional _38_repeat ) .)


state 146

    (168) _38_items -> _38_items _38_item .
    ,               reduce using rule 168 (_38_items -> _38_items _38_item .)
    )               reduce using rule 168 (_38_items -> _38_items _38_item .)


state 147

    (170) _38_item -> , expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 170 (_38_item -> , expr .)
    )               reduce using rule 170 (_38_item -> , expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 148

    (99) _21_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 99 (_21_optional -> expr .)
    ELIF            reduce using rule 99 (_21_optional -> expr .)
    ELSE            reduce using rule 99 (_21_optional -> expr .)
    END             reduce using rule 99 (_21_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 149

    (96) if_expr -> IF expr THEN _20_optional _21_optional . _22_repeat _23_repeat _24_optional END
    (101) _22_repeat -> . _22_items
    (102) _22_repeat -> .
    (103) _22_items -> . _22_items _22_item
    (104) _22_items -> . _22_item
    (105) _22_item -> . NEWLINE expr
    ELIF            reduce using rule 102 (_22_repeat -> .)
    ELSE            reduce using rule 102 (_22_repeat -> .)
    END             reduce using rule 102 (_22_repeat -> .)
    NEWLINE         shift and go to state 183

    _22_repeat                     shift and go to state 180
    _22_items                      shift and go to state 181
    _22_item                       shift and go to state 182

state 150

    (97) _20_optional -> : type .
    (               reduce using rule 97 (_20_optional -> : type .)
    -               reduce using rule 97 (_20_optional -> : type .)
    {               reduce using rule 97 (_20_optional -> : type .)
    [               reduce using rule 97 (_20_optional -> : type .)
    CASE            reduce using rule 97 (_20_optional -> : type .)
    IF              reduce using rule 97 (_20_optional -> : type .)
    DEF             reduce using rule 97 (_20_optional -> : type .)
    STRING          reduce using rule 97 (_20_optional -> : type .)
    NUMBER          reduce using rule 97 (_20_optional -> : type .)
    IDENTIFIER      reduce using rule 97 (_20_optional -> : type .)
    DO              reduce using rule 97 (_20_optional -> : type .)
    NEWLINE         reduce using rule 97 (_20_optional -> : type .)
    ELIF            reduce using rule 97 (_20_optional -> : type .)
    ELSE            reduce using rule 97 (_20_optional -> : type .)
    END             reduce using rule 97 (_20_optional -> : type .)


state 151

    (93) param -> identifier _19_optional .
    ,               reduce using rule 93 (param -> identifier _19_optional .)
    )               reduce using rule 93 (param -> identifier _19_optional .)


state 152

    (94) _19_optional -> : . type
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    type                           shift and go to state 184
    identifier                     shift and go to state 70

state 153

    (41) def_expr -> DEF identifier ( _6_optional _7_repeat . ) _8_optional do
    )               shift and go to state 185


state 154

    (44) _7_repeat -> _7_items .
    (46) _7_items -> _7_items . _7_item
    (48) _7_item -> . , param
    )               reduce using rule 44 (_7_repeat -> _7_items .)
    ,               shift and go to state 156

    _7_item                        shift and go to state 186

state 155

    (47) _7_items -> _7_item .
    ,               reduce using rule 47 (_7_items -> _7_item .)
    )               reduce using rule 47 (_7_items -> _7_item .)


state 156

    (48) _7_item -> , . param
    (93) param -> . identifier _19_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    param                          shift and go to state 187
    identifier                     shift and go to state 113

state 157

    (31) do -> DO _3_optional _4_optional _5_repeat END .
    INT_DIV         reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    *               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    /               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    -               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    +               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    CONCAT          reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    NEWLINE         reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    $end            reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    ,               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    }               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    )               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    ]               reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    OF              reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    THEN            reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    END             reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    ELIF            reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    ELSE            reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)
    IDENTIFIER      reduce using rule 31 (do -> DO _3_optional _4_optional _5_repeat END .)


state 158

    (38) _5_items -> _5_items _5_item .
    NEWLINE         reduce using rule 38 (_5_items -> _5_items _5_item .)
    END             reduce using rule 38 (_5_items -> _5_items _5_item .)


state 159

    (40) _5_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 40 (_5_item -> NEWLINE expr .)
    END             reduce using rule 40 (_5_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 160

    (85) enum_key -> identifier _17_optional .
    IDENTIFIER      reduce using rule 85 (enum_key -> identifier _17_optional .)
    }               reduce using rule 85 (enum_key -> identifier _17_optional .)


state 161

    (86) _17_optional -> ( . identifier _18_repeat )
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 188

state 162

    (72) enum -> ENUM identifier _14_optional { _16_repeat } .
    NEWLINE         reduce using rule 72 (enum -> ENUM identifier _14_optional { _16_repeat } .)
    $end            reduce using rule 72 (enum -> ENUM identifier _14_optional { _16_repeat } .)


state 163

    (82) _16_items -> _16_items _16_item .
    IDENTIFIER      reduce using rule 82 (_16_items -> _16_items _16_item .)
    }               reduce using rule 82 (_16_items -> _16_items _16_item .)


state 164

    (73) _14_optional -> < identifier _15_repeat > .
    {               reduce using rule 73 (_14_optional -> < identifier _15_repeat > .)


state 165

    (76) _15_items -> _15_items _15_item .
    ,               reduce using rule 76 (_15_items -> _15_items _15_item .)
    >               reduce using rule 76 (_15_items -> _15_items _15_item .)


state 166

    (78) _15_item -> , identifier .
    ,               reduce using rule 78 (_15_item -> , identifier .)
    >               reduce using rule 78 (_15_item -> , identifier .)


state 167

    (52) _9_optional -> < type _10_repeat . >
    >               shift and go to state 189


state 168

    (53) _10_repeat -> _10_items .
    (55) _10_items -> _10_items . _10_item
    (57) _10_item -> . , type
    >               reduce using rule 53 (_10_repeat -> _10_items .)
    ,               shift and go to state 170

    _10_item                       shift and go to state 190

state 169

    (56) _10_items -> _10_item .
    ,               reduce using rule 56 (_10_items -> _10_item .)
    >               reduce using rule 56 (_10_items -> _10_item .)


state 170

    (57) _10_item -> , . type
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    type                           shift and go to state 191
    identifier                     shift and go to state 70

state 171

    (71) _13_item -> identifier type .
    IDENTIFIER      reduce using rule 71 (_13_item -> identifier type .)
    }               reduce using rule 71 (_13_item -> identifier type .)


state 172

    (59) struct -> STRUCT identifier _11_optional { _13_repeat } .
    NEWLINE         reduce using rule 59 (struct -> STRUCT identifier _11_optional { _13_repeat } .)
    $end            reduce using rule 59 (struct -> STRUCT identifier _11_optional { _13_repeat } .)


state 173

    (69) _13_items -> _13_items _13_item .
    IDENTIFIER      reduce using rule 69 (_13_items -> _13_items _13_item .)
    }               reduce using rule 69 (_13_items -> _13_items _13_item .)


state 174

    (60) _11_optional -> < identifier _12_repeat > .
    {               reduce using rule 60 (_11_optional -> < identifier _12_repeat > .)


state 175

    (63) _12_items -> _12_items _12_item .
    ,               reduce using rule 63 (_12_items -> _12_items _12_item .)
    >               reduce using rule 63 (_12_items -> _12_items _12_item .)


state 176

    (65) _12_item -> , identifier .
    ,               reduce using rule 65 (_12_item -> , identifier .)
    >               reduce using rule 65 (_12_item -> , identifier .)


state 177

    (131) case_of -> CASE expr OF case _30_repeat END .
    INT_DIV         reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    *               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    /               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    -               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    +               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    CONCAT          reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    NEWLINE         reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    $end            reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    ,               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    }               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    )               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    ]               reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    OF              reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    THEN            reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    END             reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    ELIF            reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)
    ELSE            reduce using rule 131 (case_of -> CASE expr OF case _30_repeat END .)


state 178

    (134) _30_items -> _30_items _30_item .
    IDENTIFIER      reduce using rule 134 (_30_items -> _30_items _30_item .)
    END             reduce using rule 134 (_30_items -> _30_items _30_item .)


state 179

    (140) _31_optional -> ( pattern . _32_repeat )
    (141) _32_repeat -> . _32_items
    (142) _32_repeat -> .
    (143) _32_items -> . _32_items _32_item
    (144) _32_items -> . _32_item
    (145) _32_item -> . , pattern
    )               reduce using rule 142 (_32_repeat -> .)
    ,               shift and go to state 195

    _32_repeat                     shift and go to state 192
    _32_items                      shift and go to state 193
    _32_item                       shift and go to state 194

state 180

    (96) if_expr -> IF expr THEN _20_optional _21_optional _22_repeat . _23_repeat _24_optional END
    (106) _23_repeat -> . _23_items
    (107) _23_repeat -> .
    (108) _23_items -> . _23_items _23_item
    (109) _23_items -> . _23_item
    (110) _23_item -> . elif_expr
    (121) elif_expr -> . ELIF expr THEN _27_optional _28_optional _29_repeat
    ELSE            reduce using rule 107 (_23_repeat -> .)
    END             reduce using rule 107 (_23_repeat -> .)
    ELIF            shift and go to state 200

    _23_repeat                     shift and go to state 196
    _23_items                      shift and go to state 197
    _23_item                       shift and go to state 198
    elif_expr                      shift and go to state 199

state 181

    (101) _22_repeat -> _22_items .
    (103) _22_items -> _22_items . _22_item
    (105) _22_item -> . NEWLINE expr
    ELIF            reduce using rule 101 (_22_repeat -> _22_items .)
    ELSE            reduce using rule 101 (_22_repeat -> _22_items .)
    END             reduce using rule 101 (_22_repeat -> _22_items .)
    NEWLINE         shift and go to state 183

    _22_item                       shift and go to state 201

state 182

    (104) _22_items -> _22_item .
    NEWLINE         reduce using rule 104 (_22_items -> _22_item .)
    ELIF            reduce using rule 104 (_22_items -> _22_item .)
    ELSE            reduce using rule 104 (_22_items -> _22_item .)
    END             reduce using rule 104 (_22_items -> _22_item .)


state 183

    (105) _22_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 202
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 184

    (94) _19_optional -> : type .
    ,               reduce using rule 94 (_19_optional -> : type .)
    )               reduce using rule 94 (_19_optional -> : type .)


state 185

    (41) def_expr -> DEF identifier ( _6_optional _7_repeat ) . _8_optional do
    (49) _8_optional -> . type
    (50) _8_optional -> .
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    DO              reduce using rule 50 (_8_optional -> .)
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 70
    _8_optional                    shift and go to state 203
    type                           shift and go to state 204

state 186

    (46) _7_items -> _7_items _7_item .
    ,               reduce using rule 46 (_7_items -> _7_items _7_item .)
    )               reduce using rule 46 (_7_items -> _7_items _7_item .)


state 187

    (48) _7_item -> , param .
    ,               reduce using rule 48 (_7_item -> , param .)
    )               reduce using rule 48 (_7_item -> , param .)


state 188

    (86) _17_optional -> ( identifier . _18_repeat )
    (87) _18_repeat -> . _18_items
    (88) _18_repeat -> .
    (89) _18_items -> . _18_items _18_item
    (90) _18_items -> . _18_item
    (91) _18_item -> . , identifier
    )               reduce using rule 88 (_18_repeat -> .)
    ,               shift and go to state 208

    _18_repeat                     shift and go to state 205
    _18_items                      shift and go to state 206
    _18_item                       shift and go to state 207

state 189

    (52) _9_optional -> < type _10_repeat > .
    =               reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    (               reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    -               reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    {               reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    [               reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    CASE            reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    IF              reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    DEF             reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    STRING          reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    NUMBER          reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    IDENTIFIER      reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    DO              reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    NEWLINE         reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    END             reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    ,               reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    >               reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    ELIF            reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    ELSE            reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    }               reduce using rule 52 (_9_optional -> < type _10_repeat > .)
    )               reduce using rule 52 (_9_optional -> < type _10_repeat > .)


state 190

    (55) _10_items -> _10_items _10_item .
    ,               reduce using rule 55 (_10_items -> _10_items _10_item .)
    >               reduce using rule 55 (_10_items -> _10_items _10_item .)


state 191

    (57) _10_item -> , type .
    ,               reduce using rule 57 (_10_item -> , type .)
    >               reduce using rule 57 (_10_item -> , type .)


state 192

    (140) _31_optional -> ( pattern _32_repeat . )
    )               shift and go to state 209


state 193

    (141) _32_repeat -> _32_items .
    (143) _32_items -> _32_items . _32_item
    (145) _32_item -> . , pattern
    )               reduce using rule 141 (_32_repeat -> _32_items .)
    ,               shift and go to state 195

    _32_item                       shift and go to state 210

state 194

    (144) _32_items -> _32_item .
    ,               reduce using rule 144 (_32_items -> _32_item .)
    )               reduce using rule 144 (_32_items -> _32_item .)


state 195

    (145) _32_item -> , . pattern
    (138) pattern -> . enum_pattern
    (139) enum_pattern -> . identifier _31_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    pattern                        shift and go to state 211
    enum_pattern                   shift and go to state 105
    identifier                     shift and go to state 106

state 196

    (96) if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat . _24_optional END
    (111) _24_optional -> . else_expr
    (112) _24_optional -> .
    (113) else_expr -> . ELSE _25_optional _26_repeat
    END             reduce using rule 112 (_24_optional -> .)
    ELSE            shift and go to state 214

    _24_optional                   shift and go to state 212
    else_expr                      shift and go to state 213

state 197

    (106) _23_repeat -> _23_items .
    (108) _23_items -> _23_items . _23_item
    (110) _23_item -> . elif_expr
    (121) elif_expr -> . ELIF expr THEN _27_optional _28_optional _29_repeat
    ELSE            reduce using rule 106 (_23_repeat -> _23_items .)
    END             reduce using rule 106 (_23_repeat -> _23_items .)
    ELIF            shift and go to state 200

    _23_item                       shift and go to state 215
    elif_expr                      shift and go to state 199

state 198

    (109) _23_items -> _23_item .
    ELIF            reduce using rule 109 (_23_items -> _23_item .)
    ELSE            reduce using rule 109 (_23_items -> _23_item .)
    END             reduce using rule 109 (_23_items -> _23_item .)


state 199

    (110) _23_item -> elif_expr .
    ELIF            reduce using rule 110 (_23_item -> elif_expr .)
    ELSE            reduce using rule 110 (_23_item -> elif_expr .)
    END             reduce using rule 110 (_23_item -> elif_expr .)


state 200

    (121) elif_expr -> ELIF . expr THEN _27_optional _28_optional _29_repeat
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 216
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 201

    (103) _22_items -> _22_items _22_item .
    NEWLINE         reduce using rule 103 (_22_items -> _22_items _22_item .)
    ELIF            reduce using rule 103 (_22_items -> _22_items _22_item .)
    ELSE            reduce using rule 103 (_22_items -> _22_items _22_item .)
    END             reduce using rule 103 (_22_items -> _22_items _22_item .)


state 202

    (105) _22_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 105 (_22_item -> NEWLINE expr .)
    ELIF            reduce using rule 105 (_22_item -> NEWLINE expr .)
    ELSE            reduce using rule 105 (_22_item -> NEWLINE expr .)
    END             reduce using rule 105 (_22_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 203

    (41) def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional . do
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    DO              shift and go to state 31

    do                             shift and go to state 217

state 204

    (49) _8_optional -> type .
    DO              reduce using rule 49 (_8_optional -> type .)


state 205

    (86) _17_optional -> ( identifier _18_repeat . )
    )               shift and go to state 218


state 206

    (87) _18_repeat -> _18_items .
    (89) _18_items -> _18_items . _18_item
    (91) _18_item -> . , identifier
    )               reduce using rule 87 (_18_repeat -> _18_items .)
    ,               shift and go to state 208

    _18_item                       shift and go to state 219

state 207

    (90) _18_items -> _18_item .
    ,               reduce using rule 90 (_18_items -> _18_item .)
    )               reduce using rule 90 (_18_items -> _18_item .)


state 208

    (91) _18_item -> , . identifier
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    identifier                     shift and go to state 220

state 209

    (140) _31_optional -> ( pattern _32_repeat ) .
    DO              reduce using rule 140 (_31_optional -> ( pattern _32_repeat ) .)
    ,               reduce using rule 140 (_31_optional -> ( pattern _32_repeat ) .)
    )               reduce using rule 140 (_31_optional -> ( pattern _32_repeat ) .)


state 210

    (143) _32_items -> _32_items _32_item .
    ,               reduce using rule 143 (_32_items -> _32_items _32_item .)
    )               reduce using rule 143 (_32_items -> _32_items _32_item .)


state 211

    (145) _32_item -> , pattern .
    ,               reduce using rule 145 (_32_item -> , pattern .)
    )               reduce using rule 145 (_32_item -> , pattern .)


state 212

    (96) if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional . END
    END             shift and go to state 221


state 213

    (111) _24_optional -> else_expr .
    END             reduce using rule 111 (_24_optional -> else_expr .)


state 214

    (113) else_expr -> ELSE . _25_optional _26_repeat
    (114) _25_optional -> . expr
    (115) _25_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    NEWLINE         reduce using rule 115 (_25_optional -> .)
    END             reduce using rule 115 (_25_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    _25_optional                   shift and go to state 222
    expr                           shift and go to state 223
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 215

    (108) _23_items -> _23_items _23_item .
    ELIF            reduce using rule 108 (_23_items -> _23_items _23_item .)
    ELSE            reduce using rule 108 (_23_items -> _23_items _23_item .)
    END             reduce using rule 108 (_23_items -> _23_items _23_item .)


state 216

    (121) elif_expr -> ELIF expr . THEN _27_optional _28_optional _29_repeat
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 224
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 217

    (41) def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .
    INT_DIV         reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    *               reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    /               reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    -               reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    +               reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    CONCAT          reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    NEWLINE         reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    $end            reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    ,               reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    }               reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    )               reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    ]               reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    OF              reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    THEN            reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    END             reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    ELIF            reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)
    ELSE            reduce using rule 41 (def_expr -> DEF identifier ( _6_optional _7_repeat ) _8_optional do .)


state 218

    (86) _17_optional -> ( identifier _18_repeat ) .
    IDENTIFIER      reduce using rule 86 (_17_optional -> ( identifier _18_repeat ) .)
    }               reduce using rule 86 (_17_optional -> ( identifier _18_repeat ) .)


state 219

    (89) _18_items -> _18_items _18_item .
    ,               reduce using rule 89 (_18_items -> _18_items _18_item .)
    )               reduce using rule 89 (_18_items -> _18_items _18_item .)


state 220

    (91) _18_item -> , identifier .
    ,               reduce using rule 91 (_18_item -> , identifier .)
    )               reduce using rule 91 (_18_item -> , identifier .)


state 221

    (96) if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .
    INT_DIV         reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    *               reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    /               reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    -               reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    +               reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    CONCAT          reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    NEWLINE         reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    $end            reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    ,               reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    }               reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    )               reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    ]               reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    OF              reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    THEN            reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    END             reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    ELIF            reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)
    ELSE            reduce using rule 96 (if_expr -> IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END .)


state 222

    (113) else_expr -> ELSE _25_optional . _26_repeat
    (116) _26_repeat -> . _26_items
    (117) _26_repeat -> .
    (118) _26_items -> . _26_items _26_item
    (119) _26_items -> . _26_item
    (120) _26_item -> . NEWLINE expr
    END             reduce using rule 117 (_26_repeat -> .)
    NEWLINE         shift and go to state 228

    _26_repeat                     shift and go to state 225
    _26_items                      shift and go to state 226
    _26_item                       shift and go to state 227

state 223

    (114) _25_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 114 (_25_optional -> expr .)
    END             reduce using rule 114 (_25_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 224

    (121) elif_expr -> ELIF expr THEN . _27_optional _28_optional _29_repeat
    (122) _27_optional -> . : type
    (123) _27_optional -> .
    :               shift and go to state 230
    (               reduce using rule 123 (_27_optional -> .)
    -               reduce using rule 123 (_27_optional -> .)
    {               reduce using rule 123 (_27_optional -> .)
    [               reduce using rule 123 (_27_optional -> .)
    CASE            reduce using rule 123 (_27_optional -> .)
    IF              reduce using rule 123 (_27_optional -> .)
    DEF             reduce using rule 123 (_27_optional -> .)
    STRING          reduce using rule 123 (_27_optional -> .)
    NUMBER          reduce using rule 123 (_27_optional -> .)
    IDENTIFIER      reduce using rule 123 (_27_optional -> .)
    DO              reduce using rule 123 (_27_optional -> .)
    NEWLINE         reduce using rule 123 (_27_optional -> .)
    ELIF            reduce using rule 123 (_27_optional -> .)
    ELSE            reduce using rule 123 (_27_optional -> .)
    END             reduce using rule 123 (_27_optional -> .)

    _27_optional                   shift and go to state 229

state 225

    (113) else_expr -> ELSE _25_optional _26_repeat .
    END             reduce using rule 113 (else_expr -> ELSE _25_optional _26_repeat .)


state 226

    (116) _26_repeat -> _26_items .
    (118) _26_items -> _26_items . _26_item
    (120) _26_item -> . NEWLINE expr
    END             reduce using rule 116 (_26_repeat -> _26_items .)
    NEWLINE         shift and go to state 228

    _26_item                       shift and go to state 231

state 227

    (119) _26_items -> _26_item .
    NEWLINE         reduce using rule 119 (_26_items -> _26_item .)
    END             reduce using rule 119 (_26_items -> _26_item .)


state 228

    (120) _26_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 232
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 229

    (121) elif_expr -> ELIF expr THEN _27_optional . _28_optional _29_repeat
    (124) _28_optional -> . expr
    (125) _28_optional -> .
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    NEWLINE         reduce using rule 125 (_28_optional -> .)
    ELIF            reduce using rule 125 (_28_optional -> .)
    ELSE            reduce using rule 125 (_28_optional -> .)
    END             reduce using rule 125 (_28_optional -> .)
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 233
    _28_optional                   shift and go to state 234
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 230

    (122) _27_optional -> : . type
    (51) type -> . identifier _9_optional
    (172) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 30

    type                           shift and go to state 235
    identifier                     shift and go to state 70

state 231

    (118) _26_items -> _26_items _26_item .
    NEWLINE         reduce using rule 118 (_26_items -> _26_items _26_item .)
    END             reduce using rule 118 (_26_items -> _26_items _26_item .)


state 232

    (120) _26_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 120 (_26_item -> NEWLINE expr .)
    END             reduce using rule 120 (_26_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 233

    (124) _28_optional -> expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 124 (_28_optional -> expr .)
    ELIF            reduce using rule 124 (_28_optional -> expr .)
    ELSE            reduce using rule 124 (_28_optional -> expr .)
    END             reduce using rule 124 (_28_optional -> expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41


state 234

    (121) elif_expr -> ELIF expr THEN _27_optional _28_optional . _29_repeat
    (126) _29_repeat -> . _29_items
    (127) _29_repeat -> .
    (128) _29_items -> . _29_items _29_item
    (129) _29_items -> . _29_item
    (130) _29_item -> . NEWLINE expr
    ELIF            reduce using rule 127 (_29_repeat -> .)
    ELSE            reduce using rule 127 (_29_repeat -> .)
    END             reduce using rule 127 (_29_repeat -> .)
    NEWLINE         shift and go to state 239

    _29_repeat                     shift and go to state 236
    _29_items                      shift and go to state 237
    _29_item                       shift and go to state 238

state 235

    (122) _27_optional -> : type .
    (               reduce using rule 122 (_27_optional -> : type .)
    -               reduce using rule 122 (_27_optional -> : type .)
    {               reduce using rule 122 (_27_optional -> : type .)
    [               reduce using rule 122 (_27_optional -> : type .)
    CASE            reduce using rule 122 (_27_optional -> : type .)
    IF              reduce using rule 122 (_27_optional -> : type .)
    DEF             reduce using rule 122 (_27_optional -> : type .)
    STRING          reduce using rule 122 (_27_optional -> : type .)
    NUMBER          reduce using rule 122 (_27_optional -> : type .)
    IDENTIFIER      reduce using rule 122 (_27_optional -> : type .)
    DO              reduce using rule 122 (_27_optional -> : type .)
    NEWLINE         reduce using rule 122 (_27_optional -> : type .)
    ELIF            reduce using rule 122 (_27_optional -> : type .)
    ELSE            reduce using rule 122 (_27_optional -> : type .)
    END             reduce using rule 122 (_27_optional -> : type .)


state 236

    (121) elif_expr -> ELIF expr THEN _27_optional _28_optional _29_repeat .
    ELIF            reduce using rule 121 (elif_expr -> ELIF expr THEN _27_optional _28_optional _29_repeat .)
    ELSE            reduce using rule 121 (elif_expr -> ELIF expr THEN _27_optional _28_optional _29_repeat .)
    END             reduce using rule 121 (elif_expr -> ELIF expr THEN _27_optional _28_optional _29_repeat .)


state 237

    (126) _29_repeat -> _29_items .
    (128) _29_items -> _29_items . _29_item
    (130) _29_item -> . NEWLINE expr
    ELIF            reduce using rule 126 (_29_repeat -> _29_items .)
    ELSE            reduce using rule 126 (_29_repeat -> _29_items .)
    END             reduce using rule 126 (_29_repeat -> _29_items .)
    NEWLINE         shift and go to state 239

    _29_item                       shift and go to state 240

state 238

    (129) _29_items -> _29_item .
    NEWLINE         reduce using rule 129 (_29_items -> _29_item .)
    ELIF            reduce using rule 129 (_29_items -> _29_item .)
    ELSE            reduce using rule 129 (_29_items -> _29_item .)
    END             reduce using rule 129 (_29_items -> _29_item .)


state 239

    (130) _29_item -> NEWLINE . expr
    (12) expr -> . ( expr )
    (13) expr -> . - expr
    (14) expr -> . tuple
    (15) expr -> . array
    (16) expr -> . binary_expr
    (17) expr -> . variable_declaration
    (18) expr -> . case_of
    (19) expr -> . call
    (20) expr -> . if_expr
    (21) expr -> . def_expr
    (22) expr -> . literal
    (23) expr -> . identifier
    (24) expr -> . do
    (155) tuple -> . { _35_optional _36_repeat }
    (147) array -> . [ _33_optional _34_repeat ]
    (25) binary_expr -> . expr INT_DIV expr
    (26) binary_expr -> . expr * expr
    (27) binary_expr -> . expr / expr
    (28) binary_expr -> . expr - expr
    (29) binary_expr -> . expr + expr
    (30) binary_expr -> . expr CONCAT expr
    (173) variable_declaration -> . identifier _39_optional = expr
    (131) case_of -> . CASE expr OF case _30_repeat END
    (163) call -> . callee ( _37_optional _38_repeat )
    (96) if_expr -> . IF expr THEN _20_optional _21_optional _22_repeat _23_repeat _24_optional END
    (41) def_expr -> . DEF identifier ( _6_optional _7_repeat ) _8_optional do
    (176) literal -> . STRING
    (177) literal -> . NUMBER
    (172) identifier -> . IDENTIFIER
    (31) do -> . DO _3_optional _4_optional _5_repeat END
    (171) callee -> . identifier
    (               shift and go to state 11
    -               shift and go to state 12
    {               shift and go to state 9
    [               shift and go to state 23
    CASE            shift and go to state 24
    IF              shift and go to state 26
    DEF             shift and go to state 27
    STRING          shift and go to state 28
    NUMBER          shift and go to state 29
    IDENTIFIER      shift and go to state 30
    DO              shift and go to state 31

    expr                           shift and go to state 241
    tuple                          shift and go to state 13
    array                          shift and go to state 14
    binary_expr                    shift and go to state 15
    variable_declaration           shift and go to state 16
    case_of                        shift and go to state 17
    call                           shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    identifier                     shift and go to state 8
    do                             shift and go to state 22
    callee                         shift and go to state 25

state 240

    (128) _29_items -> _29_items _29_item .
    NEWLINE         reduce using rule 128 (_29_items -> _29_items _29_item .)
    ELIF            reduce using rule 128 (_29_items -> _29_items _29_item .)
    ELSE            reduce using rule 128 (_29_items -> _29_items _29_item .)
    END             reduce using rule 128 (_29_items -> _29_items _29_item .)


state 241

    (130) _29_item -> NEWLINE expr .
    (25) binary_expr -> expr . INT_DIV expr
    (26) binary_expr -> expr . * expr
    (27) binary_expr -> expr . / expr
    (28) binary_expr -> expr . - expr
    (29) binary_expr -> expr . + expr
    (30) binary_expr -> expr . CONCAT expr
    NEWLINE         reduce using rule 130 (_29_item -> NEWLINE expr .)
    ELIF            reduce using rule 130 (_29_item -> NEWLINE expr .)
    ELSE            reduce using rule 130 (_29_item -> NEWLINE expr .)
    END             reduce using rule 130 (_29_item -> NEWLINE expr .)
    INT_DIV         shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    -               shift and go to state 39
    +               shift and go to state 40
    CONCAT          shift and go to state 41
