Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_repeat
Rule 2     _1_repeat -> _1_items
Rule 3     _1_repeat -> <empty>
Rule 4     _1_items -> _1_items _1_item
Rule 5     _1_items -> _1_item
Rule 6     _1_item -> stmt
Rule 7     stmt -> enum
Rule 8     stmt -> expr
Rule 9     expr -> ( expr )  [precedence=left, level=6]
Rule 10    expr -> - expr  [precedence=right, level=7]
Rule 11    expr -> array
Rule 12    expr -> variant_call
Rule 13    expr -> identifier
Rule 14    expr -> variable_declaration
Rule 15    expr -> call
Rule 16    expr -> case_of
Rule 17    expr -> binary_expr
Rule 18    expr -> if_expr
Rule 19    expr -> def_expr
Rule 20    expr -> literal
Rule 21    expr -> do
Rule 22    expr -> external
Rule 23    external -> EXTERNAL
Rule 24    binary_expr -> expr INT_DIV expr  [precedence=left, level=5]
Rule 25    binary_expr -> expr NOT_MORE expr  [precedence=left, level=1]
Rule 26    binary_expr -> expr NUM_NOT_EQUAL expr  [precedence=left, level=1]
Rule 27    binary_expr -> expr > expr  [precedence=left, level=1]
Rule 28    binary_expr -> expr % expr  [precedence=left, level=3]
Rule 29    binary_expr -> expr < expr  [precedence=left, level=1]
Rule 30    binary_expr -> expr * expr  [precedence=left, level=5]
Rule 31    binary_expr -> expr / expr  [precedence=left, level=5]
Rule 32    binary_expr -> expr - expr  [precedence=left, level=4]
Rule 33    binary_expr -> expr + expr  [precedence=left, level=4]
Rule 34    binary_expr -> expr CONCAT expr  [precedence=left, level=2]
Rule 35    do -> DO _2_optional _3_repeat END
Rule 36    _2_optional -> : type
Rule 37    _2_optional -> <empty>
Rule 38    _3_repeat -> _3_items
Rule 39    _3_repeat -> <empty>
Rule 40    _3_items -> _3_items _3_item
Rule 41    _3_items -> _3_item
Rule 42    _3_item -> expr
Rule 43    block_statement -> _4_repeat
Rule 44    _4_repeat -> _4_items
Rule 45    _4_repeat -> <empty>
Rule 46    _4_items -> _4_items _4_item
Rule 47    _4_items -> _4_item
Rule 48    _4_item -> expr
Rule 49    def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do  [precedence=left, level=6]
Rule 50    _5_optional -> param
Rule 51    _5_optional -> <empty>
Rule 52    _6_repeat -> _6_items
Rule 53    _6_repeat -> <empty>
Rule 54    _6_items -> _6_items _6_item
Rule 55    _6_items -> _6_item
Rule 56    _6_item -> , param
Rule 57    _7_optional -> : type
Rule 58    _7_optional -> <empty>
Rule 59    type -> GENERIC_IDENTIFIER
Rule 60    type -> type_identifier < type _8_repeat >  [precedence=left, level=1]
Rule 61    _8_repeat -> _8_items
Rule 62    _8_repeat -> <empty>
Rule 63    _8_items -> _8_items _8_item
Rule 64    _8_items -> _8_item
Rule 65    _8_item -> , type
Rule 66    type -> type_identifier
Rule 67    enum -> ENUM type_identifier { _9_repeat }
Rule 68    _9_repeat -> _9_items
Rule 69    _9_repeat -> <empty>
Rule 70    _9_items -> _9_items _9_item
Rule 71    _9_items -> _9_item
Rule 72    _9_item -> variant
Rule 73    enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat }
Rule 74    _10_repeat -> _10_items
Rule 75    _10_repeat -> <empty>
Rule 76    _10_items -> _10_items _10_item
Rule 77    _10_items -> _10_item
Rule 78    _10_item -> , type_identifier
Rule 79    _11_repeat -> _11_items
Rule 80    _11_repeat -> <empty>
Rule 81    _11_items -> _11_items _11_item
Rule 82    _11_items -> _11_item
Rule 83    _11_item -> variant
Rule 84    variant -> type_identifier
Rule 85    variant -> type_identifier ( type _12_repeat )  [precedence=left, level=6]
Rule 86    _12_repeat -> _12_items
Rule 87    _12_repeat -> <empty>
Rule 88    _12_items -> _12_items _12_item
Rule 89    _12_items -> _12_item
Rule 90    _12_item -> , type
Rule 91    param -> identifier _13_optional
Rule 92    _13_optional -> : type
Rule 93    _13_optional -> <empty>
Rule 94    if_expr -> IF expr THEN _14_optional block_statement _15_optional END
Rule 95    _14_optional -> : type
Rule 96    _14_optional -> <empty>
Rule 97    _15_optional -> or_else
Rule 98    _15_optional -> <empty>
Rule 99    or_else -> ELIF expr THEN block_statement _16_optional
Rule 100   _16_optional -> or_else
Rule 101   _16_optional -> <empty>
Rule 102   or_else -> ELSE block_statement
Rule 103   case_of -> CASE expr OF _17_repeat END
Rule 104   _17_repeat -> _17_items
Rule 105   _17_repeat -> <empty>
Rule 106   _17_items -> _17_items _17_item
Rule 107   _17_items -> _17_item
Rule 108   _17_item -> pattern do
Rule 109   pattern -> match_variant
Rule 110   pattern -> match_as
Rule 111   match_as -> identifier
Rule 112   match_variant -> type_identifier
Rule 113   match_variant -> type_identifier ( _18_optional _19_repeat )  [precedence=left, level=6]
Rule 114   _18_optional -> pattern
Rule 115   _18_optional -> <empty>
Rule 116   _19_repeat -> _19_items
Rule 117   _19_repeat -> <empty>
Rule 118   _19_items -> _19_items _19_item
Rule 119   _19_items -> _19_item
Rule 120   _19_item -> , pattern
Rule 121   array -> [ _20_optional _21_repeat ]
Rule 122   _20_optional -> expr
Rule 123   _20_optional -> <empty>
Rule 124   _21_repeat -> _21_items
Rule 125   _21_repeat -> <empty>
Rule 126   _21_items -> _21_items _21_item
Rule 127   _21_items -> _21_item
Rule 128   _21_item -> , expr
Rule 129   call -> expr ( _22_optional _23_repeat )  [precedence=left, level=6]
Rule 130   _22_optional -> expr
Rule 131   _22_optional -> <empty>
Rule 132   _23_repeat -> _23_items
Rule 133   _23_repeat -> <empty>
Rule 134   _23_items -> _23_items _23_item
Rule 135   _23_items -> _23_item
Rule 136   _23_item -> , expr
Rule 137   variant_call -> type_identifier
Rule 138   variant_call -> type_identifier ( _24_optional _25_repeat )  [precedence=left, level=6]
Rule 139   _24_optional -> expr
Rule 140   _24_optional -> <empty>
Rule 141   _25_repeat -> _25_items
Rule 142   _25_repeat -> <empty>
Rule 143   _25_items -> _25_items _25_item
Rule 144   _25_items -> _25_item
Rule 145   _25_item -> , expr
Rule 146   identifier -> IDENTIFIER
Rule 147   type_identifier -> TYPE_IDENTIFIER
Rule 148   variable_declaration -> LET identifier _26_optional = expr  [precedence=left, level=1]
Rule 149   _26_optional -> : type
Rule 150   _26_optional -> <empty>
Rule 151   literal -> STRING
Rule 152   literal -> NUMBER

Terminals, with rules where they appear:

%                    : 28
(                    : 9 49 85 113 129 138
)                    : 9 49 85 113 129 138
*                    : 30
+                    : 33
,                    : 56 65 78 90 120 128 136 145
-                    : 10 32
/                    : 31
:                    : 36 57 92 95 149
<                    : 29 60 73
=                    : 148
>                    : 27 60 73
CASE                 : 103
CONCAT               : 34
DEF                  : 49
DO                   : 35
ELIF                 : 99
ELSE                 : 102
END                  : 35 94 103
ENUM                 : 67 73
EXTERNAL             : 23
GENERIC_IDENTIFIER   : 59
IDENTIFIER           : 146
IF                   : 94
INT_DIV              : 24
LET                  : 148
NOT_MORE             : 25
NUMBER               : 152
NUM_NOT_EQUAL        : 26
OF                   : 103
STRING               : 151
THEN                 : 94 99
TYPE_IDENTIFIER      : 147
[                    : 121
]                    : 121
error                : 
{                    : 67 73
}                    : 67 73

Nonterminals, with rules where they appear:

_10_item             : 76 77
_10_items            : 74 76
_10_repeat           : 73
_11_item             : 81 82
_11_items            : 79 81
_11_repeat           : 73
_12_item             : 88 89
_12_items            : 86 88
_12_repeat           : 85
_13_optional         : 91
_14_optional         : 94
_15_optional         : 94
_16_optional         : 99
_17_item             : 106 107
_17_items            : 104 106
_17_repeat           : 103
_18_optional         : 113
_19_item             : 118 119
_19_items            : 116 118
_19_repeat           : 113
_1_item              : 4 5
_1_items             : 2 4
_1_repeat            : 1
_20_optional         : 121
_21_item             : 126 127
_21_items            : 124 126
_21_repeat           : 121
_22_optional         : 129
_23_item             : 134 135
_23_items            : 132 134
_23_repeat           : 129
_24_optional         : 138
_25_item             : 143 144
_25_items            : 141 143
_25_repeat           : 138
_26_optional         : 148
_2_optional          : 35
_3_item              : 40 41
_3_items             : 38 40
_3_repeat            : 35
_4_item              : 46 47
_4_items             : 44 46
_4_repeat            : 43
_5_optional          : 49
_6_item              : 54 55
_6_items             : 52 54
_6_repeat            : 49
_7_optional          : 49
_8_item              : 63 64
_8_items             : 61 63
_8_repeat            : 60
_9_item              : 70 71
_9_items             : 68 70
_9_repeat            : 67
array                : 11
binary_expr          : 17
block_statement      : 94 99 102
call                 : 15
case_of              : 16
def_expr             : 19
do                   : 21 49 108
enum                 : 7
expr                 : 8 9 10 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 42 48 94 99 103 122 128 129 130 136 139 145 148
external             : 22
identifier           : 13 49 91 111 148
if_expr              : 18
literal              : 20
match_as             : 110
match_variant        : 109
or_else              : 97 100
param                : 50 56
pattern              : 108 114 120
program              : 0
stmt                 : 6
type                 : 36 57 60 65 85 90 92 95 149
type_identifier      : 60 66 67 73 73 78 84 85 112 113 137 138
variable_declaration : 14
variant              : 72 83
variant_call         : 12


state 0

    (0) S' -> . program
    (1) program -> . _1_repeat
    (2) _1_repeat -> . _1_items
    (3) _1_repeat -> .
    (4) _1_items -> . _1_items _1_item
    (5) _1_items -> . _1_item
    (6) _1_item -> . stmt
    (7) stmt -> . enum
    (8) stmt -> . expr
    (67) enum -> . ENUM type_identifier { _9_repeat }
    (73) enum -> . ENUM type_identifier < type_identifier _10_repeat > { _11_repeat }
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 3 (_1_repeat -> .)
    ENUM            shift and go to state 8
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    program                        shift and go to state 1
    _1_repeat                      shift and go to state 2
    _1_items                       shift and go to state 3
    _1_item                        shift and go to state 4
    stmt                           shift and go to state 5
    enum                           shift and go to state 6
    expr                           shift and go to state 7
    type_identifier                shift and go to state 9
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_repeat .
    $end            reduce using rule 1 (program -> _1_repeat .)


state 3

    (2) _1_repeat -> _1_items .
    (4) _1_items -> _1_items . _1_item
    (6) _1_item -> . stmt
    (7) stmt -> . enum
    (8) stmt -> . expr
    (67) enum -> . ENUM type_identifier { _9_repeat }
    (73) enum -> . ENUM type_identifier < type_identifier _10_repeat > { _11_repeat }
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    $end            reduce using rule 2 (_1_repeat -> _1_items .)
    ENUM            shift and go to state 8
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _1_item                        shift and go to state 35
    stmt                           shift and go to state 5
    enum                           shift and go to state 6
    expr                           shift and go to state 7
    type_identifier                shift and go to state 9
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23

state 4

    (5) _1_items -> _1_item .
    ENUM            reduce using rule 5 (_1_items -> _1_item .)
    (               reduce using rule 5 (_1_items -> _1_item .)
    -               reduce using rule 5 (_1_items -> _1_item .)
    [               reduce using rule 5 (_1_items -> _1_item .)
    IDENTIFIER      reduce using rule 5 (_1_items -> _1_item .)
    LET             reduce using rule 5 (_1_items -> _1_item .)
    CASE            reduce using rule 5 (_1_items -> _1_item .)
    IF              reduce using rule 5 (_1_items -> _1_item .)
    DEF             reduce using rule 5 (_1_items -> _1_item .)
    STRING          reduce using rule 5 (_1_items -> _1_item .)
    NUMBER          reduce using rule 5 (_1_items -> _1_item .)
    DO              reduce using rule 5 (_1_items -> _1_item .)
    EXTERNAL        reduce using rule 5 (_1_items -> _1_item .)
    TYPE_IDENTIFIER reduce using rule 5 (_1_items -> _1_item .)
    $end            reduce using rule 5 (_1_items -> _1_item .)


state 5

    (6) _1_item -> stmt .
    ENUM            reduce using rule 6 (_1_item -> stmt .)
    (               reduce using rule 6 (_1_item -> stmt .)
    -               reduce using rule 6 (_1_item -> stmt .)
    [               reduce using rule 6 (_1_item -> stmt .)
    IDENTIFIER      reduce using rule 6 (_1_item -> stmt .)
    LET             reduce using rule 6 (_1_item -> stmt .)
    CASE            reduce using rule 6 (_1_item -> stmt .)
    IF              reduce using rule 6 (_1_item -> stmt .)
    DEF             reduce using rule 6 (_1_item -> stmt .)
    STRING          reduce using rule 6 (_1_item -> stmt .)
    NUMBER          reduce using rule 6 (_1_item -> stmt .)
    DO              reduce using rule 6 (_1_item -> stmt .)
    EXTERNAL        reduce using rule 6 (_1_item -> stmt .)
    TYPE_IDENTIFIER reduce using rule 6 (_1_item -> stmt .)
    $end            reduce using rule 6 (_1_item -> stmt .)


state 6

    (7) stmt -> enum .
    ENUM            reduce using rule 7 (stmt -> enum .)
    (               reduce using rule 7 (stmt -> enum .)
    -               reduce using rule 7 (stmt -> enum .)
    [               reduce using rule 7 (stmt -> enum .)
    IDENTIFIER      reduce using rule 7 (stmt -> enum .)
    LET             reduce using rule 7 (stmt -> enum .)
    CASE            reduce using rule 7 (stmt -> enum .)
    IF              reduce using rule 7 (stmt -> enum .)
    DEF             reduce using rule 7 (stmt -> enum .)
    STRING          reduce using rule 7 (stmt -> enum .)
    NUMBER          reduce using rule 7 (stmt -> enum .)
    DO              reduce using rule 7 (stmt -> enum .)
    EXTERNAL        reduce using rule 7 (stmt -> enum .)
    TYPE_IDENTIFIER reduce using rule 7 (stmt -> enum .)
    $end            reduce using rule 7 (stmt -> enum .)


state 7

    (8) stmt -> expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    ENUM            reduce using rule 8 (stmt -> expr .)
    [               reduce using rule 8 (stmt -> expr .)
    IDENTIFIER      reduce using rule 8 (stmt -> expr .)
    LET             reduce using rule 8 (stmt -> expr .)
    CASE            reduce using rule 8 (stmt -> expr .)
    IF              reduce using rule 8 (stmt -> expr .)
    DEF             reduce using rule 8 (stmt -> expr .)
    STRING          reduce using rule 8 (stmt -> expr .)
    NUMBER          reduce using rule 8 (stmt -> expr .)
    DO              reduce using rule 8 (stmt -> expr .)
    EXTERNAL        reduce using rule 8 (stmt -> expr .)
    TYPE_IDENTIFIER reduce using rule 8 (stmt -> expr .)
    $end            reduce using rule 8 (stmt -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 8

    (67) enum -> ENUM . type_identifier { _9_repeat }
    (73) enum -> ENUM . type_identifier < type_identifier _10_repeat > { _11_repeat }
    (147) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 48

state 9

    (137) variant_call -> type_identifier .
    (138) variant_call -> type_identifier . ( _24_optional _25_repeat )
  ! shift/reduce conflict for ( resolved as shift
    INT_DIV         reduce using rule 137 (variant_call -> type_identifier .)
    NOT_MORE        reduce using rule 137 (variant_call -> type_identifier .)
    NUM_NOT_EQUAL   reduce using rule 137 (variant_call -> type_identifier .)
    >               reduce using rule 137 (variant_call -> type_identifier .)
    %               reduce using rule 137 (variant_call -> type_identifier .)
    <               reduce using rule 137 (variant_call -> type_identifier .)
    *               reduce using rule 137 (variant_call -> type_identifier .)
    /               reduce using rule 137 (variant_call -> type_identifier .)
    -               reduce using rule 137 (variant_call -> type_identifier .)
    +               reduce using rule 137 (variant_call -> type_identifier .)
    CONCAT          reduce using rule 137 (variant_call -> type_identifier .)
    ENUM            reduce using rule 137 (variant_call -> type_identifier .)
    [               reduce using rule 137 (variant_call -> type_identifier .)
    IDENTIFIER      reduce using rule 137 (variant_call -> type_identifier .)
    LET             reduce using rule 137 (variant_call -> type_identifier .)
    CASE            reduce using rule 137 (variant_call -> type_identifier .)
    IF              reduce using rule 137 (variant_call -> type_identifier .)
    DEF             reduce using rule 137 (variant_call -> type_identifier .)
    STRING          reduce using rule 137 (variant_call -> type_identifier .)
    NUMBER          reduce using rule 137 (variant_call -> type_identifier .)
    DO              reduce using rule 137 (variant_call -> type_identifier .)
    EXTERNAL        reduce using rule 137 (variant_call -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 137 (variant_call -> type_identifier .)
    $end            reduce using rule 137 (variant_call -> type_identifier .)
    )               reduce using rule 137 (variant_call -> type_identifier .)
    ,               reduce using rule 137 (variant_call -> type_identifier .)
    ]               reduce using rule 137 (variant_call -> type_identifier .)
    OF              reduce using rule 137 (variant_call -> type_identifier .)
    THEN            reduce using rule 137 (variant_call -> type_identifier .)
    END             reduce using rule 137 (variant_call -> type_identifier .)
    ELIF            reduce using rule 137 (variant_call -> type_identifier .)
    ELSE            reduce using rule 137 (variant_call -> type_identifier .)
    (               shift and go to state 49


state 10

    (9) expr -> ( . expr )
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 50
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 11

    (10) expr -> - . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 51
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 12

    (11) expr -> array .
    (               reduce using rule 11 (expr -> array .)
    INT_DIV         reduce using rule 11 (expr -> array .)
    NOT_MORE        reduce using rule 11 (expr -> array .)
    NUM_NOT_EQUAL   reduce using rule 11 (expr -> array .)
    >               reduce using rule 11 (expr -> array .)
    %               reduce using rule 11 (expr -> array .)
    <               reduce using rule 11 (expr -> array .)
    *               reduce using rule 11 (expr -> array .)
    /               reduce using rule 11 (expr -> array .)
    -               reduce using rule 11 (expr -> array .)
    +               reduce using rule 11 (expr -> array .)
    CONCAT          reduce using rule 11 (expr -> array .)
    ENUM            reduce using rule 11 (expr -> array .)
    [               reduce using rule 11 (expr -> array .)
    IDENTIFIER      reduce using rule 11 (expr -> array .)
    LET             reduce using rule 11 (expr -> array .)
    CASE            reduce using rule 11 (expr -> array .)
    IF              reduce using rule 11 (expr -> array .)
    DEF             reduce using rule 11 (expr -> array .)
    STRING          reduce using rule 11 (expr -> array .)
    NUMBER          reduce using rule 11 (expr -> array .)
    DO              reduce using rule 11 (expr -> array .)
    EXTERNAL        reduce using rule 11 (expr -> array .)
    TYPE_IDENTIFIER reduce using rule 11 (expr -> array .)
    $end            reduce using rule 11 (expr -> array .)
    )               reduce using rule 11 (expr -> array .)
    ,               reduce using rule 11 (expr -> array .)
    ]               reduce using rule 11 (expr -> array .)
    OF              reduce using rule 11 (expr -> array .)
    THEN            reduce using rule 11 (expr -> array .)
    END             reduce using rule 11 (expr -> array .)
    ELIF            reduce using rule 11 (expr -> array .)
    ELSE            reduce using rule 11 (expr -> array .)


state 13

    (12) expr -> variant_call .
    (               reduce using rule 12 (expr -> variant_call .)
    INT_DIV         reduce using rule 12 (expr -> variant_call .)
    NOT_MORE        reduce using rule 12 (expr -> variant_call .)
    NUM_NOT_EQUAL   reduce using rule 12 (expr -> variant_call .)
    >               reduce using rule 12 (expr -> variant_call .)
    %               reduce using rule 12 (expr -> variant_call .)
    <               reduce using rule 12 (expr -> variant_call .)
    *               reduce using rule 12 (expr -> variant_call .)
    /               reduce using rule 12 (expr -> variant_call .)
    -               reduce using rule 12 (expr -> variant_call .)
    +               reduce using rule 12 (expr -> variant_call .)
    CONCAT          reduce using rule 12 (expr -> variant_call .)
    ENUM            reduce using rule 12 (expr -> variant_call .)
    [               reduce using rule 12 (expr -> variant_call .)
    IDENTIFIER      reduce using rule 12 (expr -> variant_call .)
    LET             reduce using rule 12 (expr -> variant_call .)
    CASE            reduce using rule 12 (expr -> variant_call .)
    IF              reduce using rule 12 (expr -> variant_call .)
    DEF             reduce using rule 12 (expr -> variant_call .)
    STRING          reduce using rule 12 (expr -> variant_call .)
    NUMBER          reduce using rule 12 (expr -> variant_call .)
    DO              reduce using rule 12 (expr -> variant_call .)
    EXTERNAL        reduce using rule 12 (expr -> variant_call .)
    TYPE_IDENTIFIER reduce using rule 12 (expr -> variant_call .)
    $end            reduce using rule 12 (expr -> variant_call .)
    )               reduce using rule 12 (expr -> variant_call .)
    ,               reduce using rule 12 (expr -> variant_call .)
    ]               reduce using rule 12 (expr -> variant_call .)
    OF              reduce using rule 12 (expr -> variant_call .)
    THEN            reduce using rule 12 (expr -> variant_call .)
    END             reduce using rule 12 (expr -> variant_call .)
    ELIF            reduce using rule 12 (expr -> variant_call .)
    ELSE            reduce using rule 12 (expr -> variant_call .)


state 14

    (13) expr -> identifier .
    (               reduce using rule 13 (expr -> identifier .)
    INT_DIV         reduce using rule 13 (expr -> identifier .)
    NOT_MORE        reduce using rule 13 (expr -> identifier .)
    NUM_NOT_EQUAL   reduce using rule 13 (expr -> identifier .)
    >               reduce using rule 13 (expr -> identifier .)
    %               reduce using rule 13 (expr -> identifier .)
    <               reduce using rule 13 (expr -> identifier .)
    *               reduce using rule 13 (expr -> identifier .)
    /               reduce using rule 13 (expr -> identifier .)
    -               reduce using rule 13 (expr -> identifier .)
    +               reduce using rule 13 (expr -> identifier .)
    CONCAT          reduce using rule 13 (expr -> identifier .)
    ENUM            reduce using rule 13 (expr -> identifier .)
    [               reduce using rule 13 (expr -> identifier .)
    IDENTIFIER      reduce using rule 13 (expr -> identifier .)
    LET             reduce using rule 13 (expr -> identifier .)
    CASE            reduce using rule 13 (expr -> identifier .)
    IF              reduce using rule 13 (expr -> identifier .)
    DEF             reduce using rule 13 (expr -> identifier .)
    STRING          reduce using rule 13 (expr -> identifier .)
    NUMBER          reduce using rule 13 (expr -> identifier .)
    DO              reduce using rule 13 (expr -> identifier .)
    EXTERNAL        reduce using rule 13 (expr -> identifier .)
    TYPE_IDENTIFIER reduce using rule 13 (expr -> identifier .)
    $end            reduce using rule 13 (expr -> identifier .)
    )               reduce using rule 13 (expr -> identifier .)
    ,               reduce using rule 13 (expr -> identifier .)
    ]               reduce using rule 13 (expr -> identifier .)
    OF              reduce using rule 13 (expr -> identifier .)
    THEN            reduce using rule 13 (expr -> identifier .)
    END             reduce using rule 13 (expr -> identifier .)
    ELIF            reduce using rule 13 (expr -> identifier .)
    ELSE            reduce using rule 13 (expr -> identifier .)


state 15

    (14) expr -> variable_declaration .
    (               reduce using rule 14 (expr -> variable_declaration .)
    INT_DIV         reduce using rule 14 (expr -> variable_declaration .)
    NOT_MORE        reduce using rule 14 (expr -> variable_declaration .)
    NUM_NOT_EQUAL   reduce using rule 14 (expr -> variable_declaration .)
    >               reduce using rule 14 (expr -> variable_declaration .)
    %               reduce using rule 14 (expr -> variable_declaration .)
    <               reduce using rule 14 (expr -> variable_declaration .)
    *               reduce using rule 14 (expr -> variable_declaration .)
    /               reduce using rule 14 (expr -> variable_declaration .)
    -               reduce using rule 14 (expr -> variable_declaration .)
    +               reduce using rule 14 (expr -> variable_declaration .)
    CONCAT          reduce using rule 14 (expr -> variable_declaration .)
    ENUM            reduce using rule 14 (expr -> variable_declaration .)
    [               reduce using rule 14 (expr -> variable_declaration .)
    IDENTIFIER      reduce using rule 14 (expr -> variable_declaration .)
    LET             reduce using rule 14 (expr -> variable_declaration .)
    CASE            reduce using rule 14 (expr -> variable_declaration .)
    IF              reduce using rule 14 (expr -> variable_declaration .)
    DEF             reduce using rule 14 (expr -> variable_declaration .)
    STRING          reduce using rule 14 (expr -> variable_declaration .)
    NUMBER          reduce using rule 14 (expr -> variable_declaration .)
    DO              reduce using rule 14 (expr -> variable_declaration .)
    EXTERNAL        reduce using rule 14 (expr -> variable_declaration .)
    TYPE_IDENTIFIER reduce using rule 14 (expr -> variable_declaration .)
    $end            reduce using rule 14 (expr -> variable_declaration .)
    )               reduce using rule 14 (expr -> variable_declaration .)
    ,               reduce using rule 14 (expr -> variable_declaration .)
    ]               reduce using rule 14 (expr -> variable_declaration .)
    OF              reduce using rule 14 (expr -> variable_declaration .)
    THEN            reduce using rule 14 (expr -> variable_declaration .)
    END             reduce using rule 14 (expr -> variable_declaration .)
    ELIF            reduce using rule 14 (expr -> variable_declaration .)
    ELSE            reduce using rule 14 (expr -> variable_declaration .)


state 16

    (15) expr -> call .
    (               reduce using rule 15 (expr -> call .)
    INT_DIV         reduce using rule 15 (expr -> call .)
    NOT_MORE        reduce using rule 15 (expr -> call .)
    NUM_NOT_EQUAL   reduce using rule 15 (expr -> call .)
    >               reduce using rule 15 (expr -> call .)
    %               reduce using rule 15 (expr -> call .)
    <               reduce using rule 15 (expr -> call .)
    *               reduce using rule 15 (expr -> call .)
    /               reduce using rule 15 (expr -> call .)
    -               reduce using rule 15 (expr -> call .)
    +               reduce using rule 15 (expr -> call .)
    CONCAT          reduce using rule 15 (expr -> call .)
    ENUM            reduce using rule 15 (expr -> call .)
    [               reduce using rule 15 (expr -> call .)
    IDENTIFIER      reduce using rule 15 (expr -> call .)
    LET             reduce using rule 15 (expr -> call .)
    CASE            reduce using rule 15 (expr -> call .)
    IF              reduce using rule 15 (expr -> call .)
    DEF             reduce using rule 15 (expr -> call .)
    STRING          reduce using rule 15 (expr -> call .)
    NUMBER          reduce using rule 15 (expr -> call .)
    DO              reduce using rule 15 (expr -> call .)
    EXTERNAL        reduce using rule 15 (expr -> call .)
    TYPE_IDENTIFIER reduce using rule 15 (expr -> call .)
    $end            reduce using rule 15 (expr -> call .)
    )               reduce using rule 15 (expr -> call .)
    ,               reduce using rule 15 (expr -> call .)
    ]               reduce using rule 15 (expr -> call .)
    OF              reduce using rule 15 (expr -> call .)
    THEN            reduce using rule 15 (expr -> call .)
    END             reduce using rule 15 (expr -> call .)
    ELIF            reduce using rule 15 (expr -> call .)
    ELSE            reduce using rule 15 (expr -> call .)


state 17

    (16) expr -> case_of .
    (               reduce using rule 16 (expr -> case_of .)
    INT_DIV         reduce using rule 16 (expr -> case_of .)
    NOT_MORE        reduce using rule 16 (expr -> case_of .)
    NUM_NOT_EQUAL   reduce using rule 16 (expr -> case_of .)
    >               reduce using rule 16 (expr -> case_of .)
    %               reduce using rule 16 (expr -> case_of .)
    <               reduce using rule 16 (expr -> case_of .)
    *               reduce using rule 16 (expr -> case_of .)
    /               reduce using rule 16 (expr -> case_of .)
    -               reduce using rule 16 (expr -> case_of .)
    +               reduce using rule 16 (expr -> case_of .)
    CONCAT          reduce using rule 16 (expr -> case_of .)
    ENUM            reduce using rule 16 (expr -> case_of .)
    [               reduce using rule 16 (expr -> case_of .)
    IDENTIFIER      reduce using rule 16 (expr -> case_of .)
    LET             reduce using rule 16 (expr -> case_of .)
    CASE            reduce using rule 16 (expr -> case_of .)
    IF              reduce using rule 16 (expr -> case_of .)
    DEF             reduce using rule 16 (expr -> case_of .)
    STRING          reduce using rule 16 (expr -> case_of .)
    NUMBER          reduce using rule 16 (expr -> case_of .)
    DO              reduce using rule 16 (expr -> case_of .)
    EXTERNAL        reduce using rule 16 (expr -> case_of .)
    TYPE_IDENTIFIER reduce using rule 16 (expr -> case_of .)
    $end            reduce using rule 16 (expr -> case_of .)
    )               reduce using rule 16 (expr -> case_of .)
    ,               reduce using rule 16 (expr -> case_of .)
    ]               reduce using rule 16 (expr -> case_of .)
    OF              reduce using rule 16 (expr -> case_of .)
    THEN            reduce using rule 16 (expr -> case_of .)
    END             reduce using rule 16 (expr -> case_of .)
    ELIF            reduce using rule 16 (expr -> case_of .)
    ELSE            reduce using rule 16 (expr -> case_of .)


state 18

    (17) expr -> binary_expr .
    (               reduce using rule 17 (expr -> binary_expr .)
    INT_DIV         reduce using rule 17 (expr -> binary_expr .)
    NOT_MORE        reduce using rule 17 (expr -> binary_expr .)
    NUM_NOT_EQUAL   reduce using rule 17 (expr -> binary_expr .)
    >               reduce using rule 17 (expr -> binary_expr .)
    %               reduce using rule 17 (expr -> binary_expr .)
    <               reduce using rule 17 (expr -> binary_expr .)
    *               reduce using rule 17 (expr -> binary_expr .)
    /               reduce using rule 17 (expr -> binary_expr .)
    -               reduce using rule 17 (expr -> binary_expr .)
    +               reduce using rule 17 (expr -> binary_expr .)
    CONCAT          reduce using rule 17 (expr -> binary_expr .)
    ENUM            reduce using rule 17 (expr -> binary_expr .)
    [               reduce using rule 17 (expr -> binary_expr .)
    IDENTIFIER      reduce using rule 17 (expr -> binary_expr .)
    LET             reduce using rule 17 (expr -> binary_expr .)
    CASE            reduce using rule 17 (expr -> binary_expr .)
    IF              reduce using rule 17 (expr -> binary_expr .)
    DEF             reduce using rule 17 (expr -> binary_expr .)
    STRING          reduce using rule 17 (expr -> binary_expr .)
    NUMBER          reduce using rule 17 (expr -> binary_expr .)
    DO              reduce using rule 17 (expr -> binary_expr .)
    EXTERNAL        reduce using rule 17 (expr -> binary_expr .)
    TYPE_IDENTIFIER reduce using rule 17 (expr -> binary_expr .)
    $end            reduce using rule 17 (expr -> binary_expr .)
    )               reduce using rule 17 (expr -> binary_expr .)
    ,               reduce using rule 17 (expr -> binary_expr .)
    ]               reduce using rule 17 (expr -> binary_expr .)
    OF              reduce using rule 17 (expr -> binary_expr .)
    THEN            reduce using rule 17 (expr -> binary_expr .)
    END             reduce using rule 17 (expr -> binary_expr .)
    ELIF            reduce using rule 17 (expr -> binary_expr .)
    ELSE            reduce using rule 17 (expr -> binary_expr .)


state 19

    (18) expr -> if_expr .
    (               reduce using rule 18 (expr -> if_expr .)
    INT_DIV         reduce using rule 18 (expr -> if_expr .)
    NOT_MORE        reduce using rule 18 (expr -> if_expr .)
    NUM_NOT_EQUAL   reduce using rule 18 (expr -> if_expr .)
    >               reduce using rule 18 (expr -> if_expr .)
    %               reduce using rule 18 (expr -> if_expr .)
    <               reduce using rule 18 (expr -> if_expr .)
    *               reduce using rule 18 (expr -> if_expr .)
    /               reduce using rule 18 (expr -> if_expr .)
    -               reduce using rule 18 (expr -> if_expr .)
    +               reduce using rule 18 (expr -> if_expr .)
    CONCAT          reduce using rule 18 (expr -> if_expr .)
    ENUM            reduce using rule 18 (expr -> if_expr .)
    [               reduce using rule 18 (expr -> if_expr .)
    IDENTIFIER      reduce using rule 18 (expr -> if_expr .)
    LET             reduce using rule 18 (expr -> if_expr .)
    CASE            reduce using rule 18 (expr -> if_expr .)
    IF              reduce using rule 18 (expr -> if_expr .)
    DEF             reduce using rule 18 (expr -> if_expr .)
    STRING          reduce using rule 18 (expr -> if_expr .)
    NUMBER          reduce using rule 18 (expr -> if_expr .)
    DO              reduce using rule 18 (expr -> if_expr .)
    EXTERNAL        reduce using rule 18 (expr -> if_expr .)
    TYPE_IDENTIFIER reduce using rule 18 (expr -> if_expr .)
    $end            reduce using rule 18 (expr -> if_expr .)
    )               reduce using rule 18 (expr -> if_expr .)
    ,               reduce using rule 18 (expr -> if_expr .)
    ]               reduce using rule 18 (expr -> if_expr .)
    OF              reduce using rule 18 (expr -> if_expr .)
    THEN            reduce using rule 18 (expr -> if_expr .)
    END             reduce using rule 18 (expr -> if_expr .)
    ELIF            reduce using rule 18 (expr -> if_expr .)
    ELSE            reduce using rule 18 (expr -> if_expr .)


state 20

    (19) expr -> def_expr .
    (               reduce using rule 19 (expr -> def_expr .)
    INT_DIV         reduce using rule 19 (expr -> def_expr .)
    NOT_MORE        reduce using rule 19 (expr -> def_expr .)
    NUM_NOT_EQUAL   reduce using rule 19 (expr -> def_expr .)
    >               reduce using rule 19 (expr -> def_expr .)
    %               reduce using rule 19 (expr -> def_expr .)
    <               reduce using rule 19 (expr -> def_expr .)
    *               reduce using rule 19 (expr -> def_expr .)
    /               reduce using rule 19 (expr -> def_expr .)
    -               reduce using rule 19 (expr -> def_expr .)
    +               reduce using rule 19 (expr -> def_expr .)
    CONCAT          reduce using rule 19 (expr -> def_expr .)
    ENUM            reduce using rule 19 (expr -> def_expr .)
    [               reduce using rule 19 (expr -> def_expr .)
    IDENTIFIER      reduce using rule 19 (expr -> def_expr .)
    LET             reduce using rule 19 (expr -> def_expr .)
    CASE            reduce using rule 19 (expr -> def_expr .)
    IF              reduce using rule 19 (expr -> def_expr .)
    DEF             reduce using rule 19 (expr -> def_expr .)
    STRING          reduce using rule 19 (expr -> def_expr .)
    NUMBER          reduce using rule 19 (expr -> def_expr .)
    DO              reduce using rule 19 (expr -> def_expr .)
    EXTERNAL        reduce using rule 19 (expr -> def_expr .)
    TYPE_IDENTIFIER reduce using rule 19 (expr -> def_expr .)
    $end            reduce using rule 19 (expr -> def_expr .)
    )               reduce using rule 19 (expr -> def_expr .)
    ,               reduce using rule 19 (expr -> def_expr .)
    ]               reduce using rule 19 (expr -> def_expr .)
    OF              reduce using rule 19 (expr -> def_expr .)
    THEN            reduce using rule 19 (expr -> def_expr .)
    END             reduce using rule 19 (expr -> def_expr .)
    ELIF            reduce using rule 19 (expr -> def_expr .)
    ELSE            reduce using rule 19 (expr -> def_expr .)


state 21

    (20) expr -> literal .
    (               reduce using rule 20 (expr -> literal .)
    INT_DIV         reduce using rule 20 (expr -> literal .)
    NOT_MORE        reduce using rule 20 (expr -> literal .)
    NUM_NOT_EQUAL   reduce using rule 20 (expr -> literal .)
    >               reduce using rule 20 (expr -> literal .)
    %               reduce using rule 20 (expr -> literal .)
    <               reduce using rule 20 (expr -> literal .)
    *               reduce using rule 20 (expr -> literal .)
    /               reduce using rule 20 (expr -> literal .)
    -               reduce using rule 20 (expr -> literal .)
    +               reduce using rule 20 (expr -> literal .)
    CONCAT          reduce using rule 20 (expr -> literal .)
    ENUM            reduce using rule 20 (expr -> literal .)
    [               reduce using rule 20 (expr -> literal .)
    IDENTIFIER      reduce using rule 20 (expr -> literal .)
    LET             reduce using rule 20 (expr -> literal .)
    CASE            reduce using rule 20 (expr -> literal .)
    IF              reduce using rule 20 (expr -> literal .)
    DEF             reduce using rule 20 (expr -> literal .)
    STRING          reduce using rule 20 (expr -> literal .)
    NUMBER          reduce using rule 20 (expr -> literal .)
    DO              reduce using rule 20 (expr -> literal .)
    EXTERNAL        reduce using rule 20 (expr -> literal .)
    TYPE_IDENTIFIER reduce using rule 20 (expr -> literal .)
    $end            reduce using rule 20 (expr -> literal .)
    )               reduce using rule 20 (expr -> literal .)
    ,               reduce using rule 20 (expr -> literal .)
    ]               reduce using rule 20 (expr -> literal .)
    OF              reduce using rule 20 (expr -> literal .)
    THEN            reduce using rule 20 (expr -> literal .)
    END             reduce using rule 20 (expr -> literal .)
    ELIF            reduce using rule 20 (expr -> literal .)
    ELSE            reduce using rule 20 (expr -> literal .)


state 22

    (21) expr -> do .
    (               reduce using rule 21 (expr -> do .)
    INT_DIV         reduce using rule 21 (expr -> do .)
    NOT_MORE        reduce using rule 21 (expr -> do .)
    NUM_NOT_EQUAL   reduce using rule 21 (expr -> do .)
    >               reduce using rule 21 (expr -> do .)
    %               reduce using rule 21 (expr -> do .)
    <               reduce using rule 21 (expr -> do .)
    *               reduce using rule 21 (expr -> do .)
    /               reduce using rule 21 (expr -> do .)
    -               reduce using rule 21 (expr -> do .)
    +               reduce using rule 21 (expr -> do .)
    CONCAT          reduce using rule 21 (expr -> do .)
    ENUM            reduce using rule 21 (expr -> do .)
    [               reduce using rule 21 (expr -> do .)
    IDENTIFIER      reduce using rule 21 (expr -> do .)
    LET             reduce using rule 21 (expr -> do .)
    CASE            reduce using rule 21 (expr -> do .)
    IF              reduce using rule 21 (expr -> do .)
    DEF             reduce using rule 21 (expr -> do .)
    STRING          reduce using rule 21 (expr -> do .)
    NUMBER          reduce using rule 21 (expr -> do .)
    DO              reduce using rule 21 (expr -> do .)
    EXTERNAL        reduce using rule 21 (expr -> do .)
    TYPE_IDENTIFIER reduce using rule 21 (expr -> do .)
    $end            reduce using rule 21 (expr -> do .)
    )               reduce using rule 21 (expr -> do .)
    ,               reduce using rule 21 (expr -> do .)
    ]               reduce using rule 21 (expr -> do .)
    OF              reduce using rule 21 (expr -> do .)
    THEN            reduce using rule 21 (expr -> do .)
    END             reduce using rule 21 (expr -> do .)
    ELIF            reduce using rule 21 (expr -> do .)
    ELSE            reduce using rule 21 (expr -> do .)


state 23

    (22) expr -> external .
    (               reduce using rule 22 (expr -> external .)
    INT_DIV         reduce using rule 22 (expr -> external .)
    NOT_MORE        reduce using rule 22 (expr -> external .)
    NUM_NOT_EQUAL   reduce using rule 22 (expr -> external .)
    >               reduce using rule 22 (expr -> external .)
    %               reduce using rule 22 (expr -> external .)
    <               reduce using rule 22 (expr -> external .)
    *               reduce using rule 22 (expr -> external .)
    /               reduce using rule 22 (expr -> external .)
    -               reduce using rule 22 (expr -> external .)
    +               reduce using rule 22 (expr -> external .)
    CONCAT          reduce using rule 22 (expr -> external .)
    ENUM            reduce using rule 22 (expr -> external .)
    [               reduce using rule 22 (expr -> external .)
    IDENTIFIER      reduce using rule 22 (expr -> external .)
    LET             reduce using rule 22 (expr -> external .)
    CASE            reduce using rule 22 (expr -> external .)
    IF              reduce using rule 22 (expr -> external .)
    DEF             reduce using rule 22 (expr -> external .)
    STRING          reduce using rule 22 (expr -> external .)
    NUMBER          reduce using rule 22 (expr -> external .)
    DO              reduce using rule 22 (expr -> external .)
    EXTERNAL        reduce using rule 22 (expr -> external .)
    TYPE_IDENTIFIER reduce using rule 22 (expr -> external .)
    $end            reduce using rule 22 (expr -> external .)
    )               reduce using rule 22 (expr -> external .)
    ,               reduce using rule 22 (expr -> external .)
    ]               reduce using rule 22 (expr -> external .)
    OF              reduce using rule 22 (expr -> external .)
    THEN            reduce using rule 22 (expr -> external .)
    END             reduce using rule 22 (expr -> external .)
    ELIF            reduce using rule 22 (expr -> external .)
    ELSE            reduce using rule 22 (expr -> external .)


state 24

    (121) array -> [ . _20_optional _21_repeat ]
    (122) _20_optional -> . expr
    (123) _20_optional -> .
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 123 (_20_optional -> .)
    ]               reduce using rule 123 (_20_optional -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _20_optional                   shift and go to state 52
    expr                           shift and go to state 53
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 25

    (146) identifier -> IDENTIFIER .
    (               reduce using rule 146 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 146 (identifier -> IDENTIFIER .)
    NOT_MORE        reduce using rule 146 (identifier -> IDENTIFIER .)
    NUM_NOT_EQUAL   reduce using rule 146 (identifier -> IDENTIFIER .)
    >               reduce using rule 146 (identifier -> IDENTIFIER .)
    %               reduce using rule 146 (identifier -> IDENTIFIER .)
    <               reduce using rule 146 (identifier -> IDENTIFIER .)
    *               reduce using rule 146 (identifier -> IDENTIFIER .)
    /               reduce using rule 146 (identifier -> IDENTIFIER .)
    -               reduce using rule 146 (identifier -> IDENTIFIER .)
    +               reduce using rule 146 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 146 (identifier -> IDENTIFIER .)
    ENUM            reduce using rule 146 (identifier -> IDENTIFIER .)
    [               reduce using rule 146 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 146 (identifier -> IDENTIFIER .)
    LET             reduce using rule 146 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 146 (identifier -> IDENTIFIER .)
    IF              reduce using rule 146 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 146 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 146 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 146 (identifier -> IDENTIFIER .)
    DO              reduce using rule 146 (identifier -> IDENTIFIER .)
    EXTERNAL        reduce using rule 146 (identifier -> IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 146 (identifier -> IDENTIFIER .)
    $end            reduce using rule 146 (identifier -> IDENTIFIER .)
    )               reduce using rule 146 (identifier -> IDENTIFIER .)
    ,               reduce using rule 146 (identifier -> IDENTIFIER .)
    ]               reduce using rule 146 (identifier -> IDENTIFIER .)
    OF              reduce using rule 146 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 146 (identifier -> IDENTIFIER .)
    END             reduce using rule 146 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 146 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 146 (identifier -> IDENTIFIER .)
    :               reduce using rule 146 (identifier -> IDENTIFIER .)
    =               reduce using rule 146 (identifier -> IDENTIFIER .)


state 26

    (148) variable_declaration -> LET . identifier _26_optional = expr
    (146) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 54

state 27

    (103) case_of -> CASE . expr OF _17_repeat END
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 55
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 28

    (94) if_expr -> IF . expr THEN _14_optional block_statement _15_optional END
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 56
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 29

    (49) def_expr -> DEF . identifier ( _5_optional _6_repeat ) _7_optional do
    (146) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 57

state 30

    (151) literal -> STRING .
    (               reduce using rule 151 (literal -> STRING .)
    INT_DIV         reduce using rule 151 (literal -> STRING .)
    NOT_MORE        reduce using rule 151 (literal -> STRING .)
    NUM_NOT_EQUAL   reduce using rule 151 (literal -> STRING .)
    >               reduce using rule 151 (literal -> STRING .)
    %               reduce using rule 151 (literal -> STRING .)
    <               reduce using rule 151 (literal -> STRING .)
    *               reduce using rule 151 (literal -> STRING .)
    /               reduce using rule 151 (literal -> STRING .)
    -               reduce using rule 151 (literal -> STRING .)
    +               reduce using rule 151 (literal -> STRING .)
    CONCAT          reduce using rule 151 (literal -> STRING .)
    ENUM            reduce using rule 151 (literal -> STRING .)
    [               reduce using rule 151 (literal -> STRING .)
    IDENTIFIER      reduce using rule 151 (literal -> STRING .)
    LET             reduce using rule 151 (literal -> STRING .)
    CASE            reduce using rule 151 (literal -> STRING .)
    IF              reduce using rule 151 (literal -> STRING .)
    DEF             reduce using rule 151 (literal -> STRING .)
    STRING          reduce using rule 151 (literal -> STRING .)
    NUMBER          reduce using rule 151 (literal -> STRING .)
    DO              reduce using rule 151 (literal -> STRING .)
    EXTERNAL        reduce using rule 151 (literal -> STRING .)
    TYPE_IDENTIFIER reduce using rule 151 (literal -> STRING .)
    $end            reduce using rule 151 (literal -> STRING .)
    )               reduce using rule 151 (literal -> STRING .)
    ,               reduce using rule 151 (literal -> STRING .)
    ]               reduce using rule 151 (literal -> STRING .)
    OF              reduce using rule 151 (literal -> STRING .)
    THEN            reduce using rule 151 (literal -> STRING .)
    END             reduce using rule 151 (literal -> STRING .)
    ELIF            reduce using rule 151 (literal -> STRING .)
    ELSE            reduce using rule 151 (literal -> STRING .)


state 31

    (152) literal -> NUMBER .
    (               reduce using rule 152 (literal -> NUMBER .)
    INT_DIV         reduce using rule 152 (literal -> NUMBER .)
    NOT_MORE        reduce using rule 152 (literal -> NUMBER .)
    NUM_NOT_EQUAL   reduce using rule 152 (literal -> NUMBER .)
    >               reduce using rule 152 (literal -> NUMBER .)
    %               reduce using rule 152 (literal -> NUMBER .)
    <               reduce using rule 152 (literal -> NUMBER .)
    *               reduce using rule 152 (literal -> NUMBER .)
    /               reduce using rule 152 (literal -> NUMBER .)
    -               reduce using rule 152 (literal -> NUMBER .)
    +               reduce using rule 152 (literal -> NUMBER .)
    CONCAT          reduce using rule 152 (literal -> NUMBER .)
    ENUM            reduce using rule 152 (literal -> NUMBER .)
    [               reduce using rule 152 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 152 (literal -> NUMBER .)
    LET             reduce using rule 152 (literal -> NUMBER .)
    CASE            reduce using rule 152 (literal -> NUMBER .)
    IF              reduce using rule 152 (literal -> NUMBER .)
    DEF             reduce using rule 152 (literal -> NUMBER .)
    STRING          reduce using rule 152 (literal -> NUMBER .)
    NUMBER          reduce using rule 152 (literal -> NUMBER .)
    DO              reduce using rule 152 (literal -> NUMBER .)
    EXTERNAL        reduce using rule 152 (literal -> NUMBER .)
    TYPE_IDENTIFIER reduce using rule 152 (literal -> NUMBER .)
    $end            reduce using rule 152 (literal -> NUMBER .)
    )               reduce using rule 152 (literal -> NUMBER .)
    ,               reduce using rule 152 (literal -> NUMBER .)
    ]               reduce using rule 152 (literal -> NUMBER .)
    OF              reduce using rule 152 (literal -> NUMBER .)
    THEN            reduce using rule 152 (literal -> NUMBER .)
    END             reduce using rule 152 (literal -> NUMBER .)
    ELIF            reduce using rule 152 (literal -> NUMBER .)
    ELSE            reduce using rule 152 (literal -> NUMBER .)


state 32

    (35) do -> DO . _2_optional _3_repeat END
    (36) _2_optional -> . : type
    (37) _2_optional -> .
    :               shift and go to state 59
    (               reduce using rule 37 (_2_optional -> .)
    -               reduce using rule 37 (_2_optional -> .)
    [               reduce using rule 37 (_2_optional -> .)
    IDENTIFIER      reduce using rule 37 (_2_optional -> .)
    LET             reduce using rule 37 (_2_optional -> .)
    CASE            reduce using rule 37 (_2_optional -> .)
    IF              reduce using rule 37 (_2_optional -> .)
    DEF             reduce using rule 37 (_2_optional -> .)
    STRING          reduce using rule 37 (_2_optional -> .)
    NUMBER          reduce using rule 37 (_2_optional -> .)
    DO              reduce using rule 37 (_2_optional -> .)
    EXTERNAL        reduce using rule 37 (_2_optional -> .)
    TYPE_IDENTIFIER reduce using rule 37 (_2_optional -> .)
    END             reduce using rule 37 (_2_optional -> .)

    _2_optional                    shift and go to state 58

state 33

    (23) external -> EXTERNAL .
    (               reduce using rule 23 (external -> EXTERNAL .)
    INT_DIV         reduce using rule 23 (external -> EXTERNAL .)
    NOT_MORE        reduce using rule 23 (external -> EXTERNAL .)
    NUM_NOT_EQUAL   reduce using rule 23 (external -> EXTERNAL .)
    >               reduce using rule 23 (external -> EXTERNAL .)
    %               reduce using rule 23 (external -> EXTERNAL .)
    <               reduce using rule 23 (external -> EXTERNAL .)
    *               reduce using rule 23 (external -> EXTERNAL .)
    /               reduce using rule 23 (external -> EXTERNAL .)
    -               reduce using rule 23 (external -> EXTERNAL .)
    +               reduce using rule 23 (external -> EXTERNAL .)
    CONCAT          reduce using rule 23 (external -> EXTERNAL .)
    ENUM            reduce using rule 23 (external -> EXTERNAL .)
    [               reduce using rule 23 (external -> EXTERNAL .)
    IDENTIFIER      reduce using rule 23 (external -> EXTERNAL .)
    LET             reduce using rule 23 (external -> EXTERNAL .)
    CASE            reduce using rule 23 (external -> EXTERNAL .)
    IF              reduce using rule 23 (external -> EXTERNAL .)
    DEF             reduce using rule 23 (external -> EXTERNAL .)
    STRING          reduce using rule 23 (external -> EXTERNAL .)
    NUMBER          reduce using rule 23 (external -> EXTERNAL .)
    DO              reduce using rule 23 (external -> EXTERNAL .)
    EXTERNAL        reduce using rule 23 (external -> EXTERNAL .)
    TYPE_IDENTIFIER reduce using rule 23 (external -> EXTERNAL .)
    $end            reduce using rule 23 (external -> EXTERNAL .)
    )               reduce using rule 23 (external -> EXTERNAL .)
    ,               reduce using rule 23 (external -> EXTERNAL .)
    ]               reduce using rule 23 (external -> EXTERNAL .)
    OF              reduce using rule 23 (external -> EXTERNAL .)
    THEN            reduce using rule 23 (external -> EXTERNAL .)
    END             reduce using rule 23 (external -> EXTERNAL .)
    ELIF            reduce using rule 23 (external -> EXTERNAL .)
    ELSE            reduce using rule 23 (external -> EXTERNAL .)


state 34

    (147) type_identifier -> TYPE_IDENTIFIER .
    (               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    INT_DIV         reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    NOT_MORE        reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    NUM_NOT_EQUAL   reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    >               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    %               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    <               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    *               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    /               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    +               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    CONCAT          reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    ENUM            reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    LET             reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    EXTERNAL        reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    $end            reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    ]               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    OF              reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    THEN            reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    ELIF            reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    ELSE            reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 147 (type_identifier -> TYPE_IDENTIFIER .)


state 35

    (4) _1_items -> _1_items _1_item .
    ENUM            reduce using rule 4 (_1_items -> _1_items _1_item .)
    (               reduce using rule 4 (_1_items -> _1_items _1_item .)
    -               reduce using rule 4 (_1_items -> _1_items _1_item .)
    [               reduce using rule 4 (_1_items -> _1_items _1_item .)
    IDENTIFIER      reduce using rule 4 (_1_items -> _1_items _1_item .)
    LET             reduce using rule 4 (_1_items -> _1_items _1_item .)
    CASE            reduce using rule 4 (_1_items -> _1_items _1_item .)
    IF              reduce using rule 4 (_1_items -> _1_items _1_item .)
    DEF             reduce using rule 4 (_1_items -> _1_items _1_item .)
    STRING          reduce using rule 4 (_1_items -> _1_items _1_item .)
    NUMBER          reduce using rule 4 (_1_items -> _1_items _1_item .)
    DO              reduce using rule 4 (_1_items -> _1_items _1_item .)
    EXTERNAL        reduce using rule 4 (_1_items -> _1_items _1_item .)
    TYPE_IDENTIFIER reduce using rule 4 (_1_items -> _1_items _1_item .)
    $end            reduce using rule 4 (_1_items -> _1_items _1_item .)


state 36

    (129) call -> expr ( . _22_optional _23_repeat )
    (130) _22_optional -> . expr
    (131) _22_optional -> .
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 131 (_22_optional -> .)
    )               reduce using rule 131 (_22_optional -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 60
    _22_optional                   shift and go to state 61
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 37

    (24) binary_expr -> expr INT_DIV . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 62
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 38

    (25) binary_expr -> expr NOT_MORE . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 63
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 39

    (26) binary_expr -> expr NUM_NOT_EQUAL . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 64
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 40

    (27) binary_expr -> expr > . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 65
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 41

    (28) binary_expr -> expr % . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 66
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 42

    (29) binary_expr -> expr < . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 67
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 43

    (30) binary_expr -> expr * . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 68
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 44

    (31) binary_expr -> expr / . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 69
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 45

    (32) binary_expr -> expr - . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 70
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 46

    (33) binary_expr -> expr + . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 71
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 47

    (34) binary_expr -> expr CONCAT . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 72
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 48

    (67) enum -> ENUM type_identifier . { _9_repeat }
    (73) enum -> ENUM type_identifier . < type_identifier _10_repeat > { _11_repeat }
    {               shift and go to state 73
    <               shift and go to state 74


state 49

    (138) variant_call -> type_identifier ( . _24_optional _25_repeat )
    (139) _24_optional -> . expr
    (140) _24_optional -> .
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    ,               reduce using rule 140 (_24_optional -> .)
    )               reduce using rule 140 (_24_optional -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 9
    _24_optional                   shift and go to state 75
    expr                           shift and go to state 76
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23

state 50

    (9) expr -> ( expr . )
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    )               shift and go to state 77
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 51

    (10) expr -> - expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    (               reduce using rule 10 (expr -> - expr .)
    INT_DIV         reduce using rule 10 (expr -> - expr .)
    NOT_MORE        reduce using rule 10 (expr -> - expr .)
    NUM_NOT_EQUAL   reduce using rule 10 (expr -> - expr .)
    >               reduce using rule 10 (expr -> - expr .)
    %               reduce using rule 10 (expr -> - expr .)
    <               reduce using rule 10 (expr -> - expr .)
    *               reduce using rule 10 (expr -> - expr .)
    /               reduce using rule 10 (expr -> - expr .)
    -               reduce using rule 10 (expr -> - expr .)
    +               reduce using rule 10 (expr -> - expr .)
    CONCAT          reduce using rule 10 (expr -> - expr .)
    ENUM            reduce using rule 10 (expr -> - expr .)
    [               reduce using rule 10 (expr -> - expr .)
    IDENTIFIER      reduce using rule 10 (expr -> - expr .)
    LET             reduce using rule 10 (expr -> - expr .)
    CASE            reduce using rule 10 (expr -> - expr .)
    IF              reduce using rule 10 (expr -> - expr .)
    DEF             reduce using rule 10 (expr -> - expr .)
    STRING          reduce using rule 10 (expr -> - expr .)
    NUMBER          reduce using rule 10 (expr -> - expr .)
    DO              reduce using rule 10 (expr -> - expr .)
    EXTERNAL        reduce using rule 10 (expr -> - expr .)
    TYPE_IDENTIFIER reduce using rule 10 (expr -> - expr .)
    $end            reduce using rule 10 (expr -> - expr .)
    )               reduce using rule 10 (expr -> - expr .)
    ,               reduce using rule 10 (expr -> - expr .)
    ]               reduce using rule 10 (expr -> - expr .)
    OF              reduce using rule 10 (expr -> - expr .)
    THEN            reduce using rule 10 (expr -> - expr .)
    END             reduce using rule 10 (expr -> - expr .)
    ELIF            reduce using rule 10 (expr -> - expr .)
    ELSE            reduce using rule 10 (expr -> - expr .)


state 52

    (121) array -> [ _20_optional . _21_repeat ]
    (124) _21_repeat -> . _21_items
    (125) _21_repeat -> .
    (126) _21_items -> . _21_items _21_item
    (127) _21_items -> . _21_item
    (128) _21_item -> . , expr
    ]               reduce using rule 125 (_21_repeat -> .)
    ,               shift and go to state 81

    _21_repeat                     shift and go to state 78
    _21_items                      shift and go to state 79
    _21_item                       shift and go to state 80

state 53

    (122) _20_optional -> expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 122 (_20_optional -> expr .)
    ]               reduce using rule 122 (_20_optional -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 54

    (148) variable_declaration -> LET identifier . _26_optional = expr
    (149) _26_optional -> . : type
    (150) _26_optional -> .
    :               shift and go to state 83
    =               reduce using rule 150 (_26_optional -> .)

    _26_optional                   shift and go to state 82

state 55

    (103) case_of -> CASE expr . OF _17_repeat END
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 84
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 56

    (94) if_expr -> IF expr . THEN _14_optional block_statement _15_optional END
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 85
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 57

    (49) def_expr -> DEF identifier . ( _5_optional _6_repeat ) _7_optional do
    (               shift and go to state 86


state 58

    (35) do -> DO _2_optional . _3_repeat END
    (38) _3_repeat -> . _3_items
    (39) _3_repeat -> .
    (40) _3_items -> . _3_items _3_item
    (41) _3_items -> . _3_item
    (42) _3_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 39 (_3_repeat -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _3_repeat                      shift and go to state 87
    _3_items                       shift and go to state 88
    _3_item                        shift and go to state 89
    expr                           shift and go to state 90
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 59

    (36) _2_optional -> : . type
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 91
    type_identifier                shift and go to state 93

state 60

    (130) _22_optional -> expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 130 (_22_optional -> expr .)
    )               reduce using rule 130 (_22_optional -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 61

    (129) call -> expr ( _22_optional . _23_repeat )
    (132) _23_repeat -> . _23_items
    (133) _23_repeat -> .
    (134) _23_items -> . _23_items _23_item
    (135) _23_items -> . _23_item
    (136) _23_item -> . , expr
    )               reduce using rule 133 (_23_repeat -> .)
    ,               shift and go to state 97

    _23_repeat                     shift and go to state 94
    _23_items                      shift and go to state 95
    _23_item                       shift and go to state 96

state 62

    (24) binary_expr -> expr INT_DIV expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    NOT_MORE        reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    NUM_NOT_EQUAL   reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    >               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    %               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    <               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ENUM            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    [               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    IDENTIFIER      reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    LET             reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    CASE            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    IF              reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    DEF             reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    STRING          reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    NUMBER          reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    DO              reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    EXTERNAL        reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    TYPE_IDENTIFIER reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    THEN            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 24 (binary_expr -> expr INT_DIV expr .)
    (               shift and go to state 36


state 63

    (25) binary_expr -> expr NOT_MORE expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    NUM_NOT_EQUAL   reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    >               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    <               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ENUM            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    [               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    IDENTIFIER      reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    LET             reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    CASE            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    IF              reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    DEF             reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    STRING          reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    NUMBER          reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    DO              reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    EXTERNAL        reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    TYPE_IDENTIFIER reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    $end            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    )               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ,               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ]               reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    OF              reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    THEN            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    END             reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ELIF            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    ELSE            reduce using rule 25 (binary_expr -> expr NOT_MORE expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 64

    (26) binary_expr -> expr NUM_NOT_EQUAL expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    NUM_NOT_EQUAL   reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    >               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    <               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ENUM            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    [               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    IDENTIFIER      reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    LET             reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    CASE            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    IF              reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    DEF             reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    STRING          reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    NUMBER          reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    DO              reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    EXTERNAL        reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    TYPE_IDENTIFIER reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    $end            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    )               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ,               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ]               reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    OF              reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    THEN            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    END             reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr NUM_NOT_EQUAL expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 65

    (27) binary_expr -> expr > expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 27 (binary_expr -> expr > expr .)
    NUM_NOT_EQUAL   reduce using rule 27 (binary_expr -> expr > expr .)
    >               reduce using rule 27 (binary_expr -> expr > expr .)
    <               reduce using rule 27 (binary_expr -> expr > expr .)
    ENUM            reduce using rule 27 (binary_expr -> expr > expr .)
    [               reduce using rule 27 (binary_expr -> expr > expr .)
    IDENTIFIER      reduce using rule 27 (binary_expr -> expr > expr .)
    LET             reduce using rule 27 (binary_expr -> expr > expr .)
    CASE            reduce using rule 27 (binary_expr -> expr > expr .)
    IF              reduce using rule 27 (binary_expr -> expr > expr .)
    DEF             reduce using rule 27 (binary_expr -> expr > expr .)
    STRING          reduce using rule 27 (binary_expr -> expr > expr .)
    NUMBER          reduce using rule 27 (binary_expr -> expr > expr .)
    DO              reduce using rule 27 (binary_expr -> expr > expr .)
    EXTERNAL        reduce using rule 27 (binary_expr -> expr > expr .)
    TYPE_IDENTIFIER reduce using rule 27 (binary_expr -> expr > expr .)
    $end            reduce using rule 27 (binary_expr -> expr > expr .)
    )               reduce using rule 27 (binary_expr -> expr > expr .)
    ,               reduce using rule 27 (binary_expr -> expr > expr .)
    ]               reduce using rule 27 (binary_expr -> expr > expr .)
    OF              reduce using rule 27 (binary_expr -> expr > expr .)
    THEN            reduce using rule 27 (binary_expr -> expr > expr .)
    END             reduce using rule 27 (binary_expr -> expr > expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr > expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr > expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 66

    (28) binary_expr -> expr % expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 28 (binary_expr -> expr % expr .)
    NUM_NOT_EQUAL   reduce using rule 28 (binary_expr -> expr % expr .)
    >               reduce using rule 28 (binary_expr -> expr % expr .)
    %               reduce using rule 28 (binary_expr -> expr % expr .)
    <               reduce using rule 28 (binary_expr -> expr % expr .)
    CONCAT          reduce using rule 28 (binary_expr -> expr % expr .)
    ENUM            reduce using rule 28 (binary_expr -> expr % expr .)
    [               reduce using rule 28 (binary_expr -> expr % expr .)
    IDENTIFIER      reduce using rule 28 (binary_expr -> expr % expr .)
    LET             reduce using rule 28 (binary_expr -> expr % expr .)
    CASE            reduce using rule 28 (binary_expr -> expr % expr .)
    IF              reduce using rule 28 (binary_expr -> expr % expr .)
    DEF             reduce using rule 28 (binary_expr -> expr % expr .)
    STRING          reduce using rule 28 (binary_expr -> expr % expr .)
    NUMBER          reduce using rule 28 (binary_expr -> expr % expr .)
    DO              reduce using rule 28 (binary_expr -> expr % expr .)
    EXTERNAL        reduce using rule 28 (binary_expr -> expr % expr .)
    TYPE_IDENTIFIER reduce using rule 28 (binary_expr -> expr % expr .)
    $end            reduce using rule 28 (binary_expr -> expr % expr .)
    )               reduce using rule 28 (binary_expr -> expr % expr .)
    ,               reduce using rule 28 (binary_expr -> expr % expr .)
    ]               reduce using rule 28 (binary_expr -> expr % expr .)
    OF              reduce using rule 28 (binary_expr -> expr % expr .)
    THEN            reduce using rule 28 (binary_expr -> expr % expr .)
    END             reduce using rule 28 (binary_expr -> expr % expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr % expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr % expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 67

    (29) binary_expr -> expr < expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 29 (binary_expr -> expr < expr .)
    NUM_NOT_EQUAL   reduce using rule 29 (binary_expr -> expr < expr .)
    >               reduce using rule 29 (binary_expr -> expr < expr .)
    <               reduce using rule 29 (binary_expr -> expr < expr .)
    ENUM            reduce using rule 29 (binary_expr -> expr < expr .)
    [               reduce using rule 29 (binary_expr -> expr < expr .)
    IDENTIFIER      reduce using rule 29 (binary_expr -> expr < expr .)
    LET             reduce using rule 29 (binary_expr -> expr < expr .)
    CASE            reduce using rule 29 (binary_expr -> expr < expr .)
    IF              reduce using rule 29 (binary_expr -> expr < expr .)
    DEF             reduce using rule 29 (binary_expr -> expr < expr .)
    STRING          reduce using rule 29 (binary_expr -> expr < expr .)
    NUMBER          reduce using rule 29 (binary_expr -> expr < expr .)
    DO              reduce using rule 29 (binary_expr -> expr < expr .)
    EXTERNAL        reduce using rule 29 (binary_expr -> expr < expr .)
    TYPE_IDENTIFIER reduce using rule 29 (binary_expr -> expr < expr .)
    $end            reduce using rule 29 (binary_expr -> expr < expr .)
    )               reduce using rule 29 (binary_expr -> expr < expr .)
    ,               reduce using rule 29 (binary_expr -> expr < expr .)
    ]               reduce using rule 29 (binary_expr -> expr < expr .)
    OF              reduce using rule 29 (binary_expr -> expr < expr .)
    THEN            reduce using rule 29 (binary_expr -> expr < expr .)
    END             reduce using rule 29 (binary_expr -> expr < expr .)
    ELIF            reduce using rule 29 (binary_expr -> expr < expr .)
    ELSE            reduce using rule 29 (binary_expr -> expr < expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 68

    (30) binary_expr -> expr * expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 30 (binary_expr -> expr * expr .)
    NOT_MORE        reduce using rule 30 (binary_expr -> expr * expr .)
    NUM_NOT_EQUAL   reduce using rule 30 (binary_expr -> expr * expr .)
    >               reduce using rule 30 (binary_expr -> expr * expr .)
    %               reduce using rule 30 (binary_expr -> expr * expr .)
    <               reduce using rule 30 (binary_expr -> expr * expr .)
    *               reduce using rule 30 (binary_expr -> expr * expr .)
    /               reduce using rule 30 (binary_expr -> expr * expr .)
    -               reduce using rule 30 (binary_expr -> expr * expr .)
    +               reduce using rule 30 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 30 (binary_expr -> expr * expr .)
    ENUM            reduce using rule 30 (binary_expr -> expr * expr .)
    [               reduce using rule 30 (binary_expr -> expr * expr .)
    IDENTIFIER      reduce using rule 30 (binary_expr -> expr * expr .)
    LET             reduce using rule 30 (binary_expr -> expr * expr .)
    CASE            reduce using rule 30 (binary_expr -> expr * expr .)
    IF              reduce using rule 30 (binary_expr -> expr * expr .)
    DEF             reduce using rule 30 (binary_expr -> expr * expr .)
    STRING          reduce using rule 30 (binary_expr -> expr * expr .)
    NUMBER          reduce using rule 30 (binary_expr -> expr * expr .)
    DO              reduce using rule 30 (binary_expr -> expr * expr .)
    EXTERNAL        reduce using rule 30 (binary_expr -> expr * expr .)
    TYPE_IDENTIFIER reduce using rule 30 (binary_expr -> expr * expr .)
    $end            reduce using rule 30 (binary_expr -> expr * expr .)
    )               reduce using rule 30 (binary_expr -> expr * expr .)
    ,               reduce using rule 30 (binary_expr -> expr * expr .)
    ]               reduce using rule 30 (binary_expr -> expr * expr .)
    OF              reduce using rule 30 (binary_expr -> expr * expr .)
    THEN            reduce using rule 30 (binary_expr -> expr * expr .)
    END             reduce using rule 30 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 30 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 30 (binary_expr -> expr * expr .)
    (               shift and go to state 36


state 69

    (31) binary_expr -> expr / expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 31 (binary_expr -> expr / expr .)
    NOT_MORE        reduce using rule 31 (binary_expr -> expr / expr .)
    NUM_NOT_EQUAL   reduce using rule 31 (binary_expr -> expr / expr .)
    >               reduce using rule 31 (binary_expr -> expr / expr .)
    %               reduce using rule 31 (binary_expr -> expr / expr .)
    <               reduce using rule 31 (binary_expr -> expr / expr .)
    *               reduce using rule 31 (binary_expr -> expr / expr .)
    /               reduce using rule 31 (binary_expr -> expr / expr .)
    -               reduce using rule 31 (binary_expr -> expr / expr .)
    +               reduce using rule 31 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 31 (binary_expr -> expr / expr .)
    ENUM            reduce using rule 31 (binary_expr -> expr / expr .)
    [               reduce using rule 31 (binary_expr -> expr / expr .)
    IDENTIFIER      reduce using rule 31 (binary_expr -> expr / expr .)
    LET             reduce using rule 31 (binary_expr -> expr / expr .)
    CASE            reduce using rule 31 (binary_expr -> expr / expr .)
    IF              reduce using rule 31 (binary_expr -> expr / expr .)
    DEF             reduce using rule 31 (binary_expr -> expr / expr .)
    STRING          reduce using rule 31 (binary_expr -> expr / expr .)
    NUMBER          reduce using rule 31 (binary_expr -> expr / expr .)
    DO              reduce using rule 31 (binary_expr -> expr / expr .)
    EXTERNAL        reduce using rule 31 (binary_expr -> expr / expr .)
    TYPE_IDENTIFIER reduce using rule 31 (binary_expr -> expr / expr .)
    $end            reduce using rule 31 (binary_expr -> expr / expr .)
    )               reduce using rule 31 (binary_expr -> expr / expr .)
    ,               reduce using rule 31 (binary_expr -> expr / expr .)
    ]               reduce using rule 31 (binary_expr -> expr / expr .)
    OF              reduce using rule 31 (binary_expr -> expr / expr .)
    THEN            reduce using rule 31 (binary_expr -> expr / expr .)
    END             reduce using rule 31 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 31 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 31 (binary_expr -> expr / expr .)
    (               shift and go to state 36


state 70

    (32) binary_expr -> expr - expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 32 (binary_expr -> expr - expr .)
    NUM_NOT_EQUAL   reduce using rule 32 (binary_expr -> expr - expr .)
    >               reduce using rule 32 (binary_expr -> expr - expr .)
    %               reduce using rule 32 (binary_expr -> expr - expr .)
    <               reduce using rule 32 (binary_expr -> expr - expr .)
    -               reduce using rule 32 (binary_expr -> expr - expr .)
    +               reduce using rule 32 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 32 (binary_expr -> expr - expr .)
    ENUM            reduce using rule 32 (binary_expr -> expr - expr .)
    [               reduce using rule 32 (binary_expr -> expr - expr .)
    IDENTIFIER      reduce using rule 32 (binary_expr -> expr - expr .)
    LET             reduce using rule 32 (binary_expr -> expr - expr .)
    CASE            reduce using rule 32 (binary_expr -> expr - expr .)
    IF              reduce using rule 32 (binary_expr -> expr - expr .)
    DEF             reduce using rule 32 (binary_expr -> expr - expr .)
    STRING          reduce using rule 32 (binary_expr -> expr - expr .)
    NUMBER          reduce using rule 32 (binary_expr -> expr - expr .)
    DO              reduce using rule 32 (binary_expr -> expr - expr .)
    EXTERNAL        reduce using rule 32 (binary_expr -> expr - expr .)
    TYPE_IDENTIFIER reduce using rule 32 (binary_expr -> expr - expr .)
    $end            reduce using rule 32 (binary_expr -> expr - expr .)
    )               reduce using rule 32 (binary_expr -> expr - expr .)
    ,               reduce using rule 32 (binary_expr -> expr - expr .)
    ]               reduce using rule 32 (binary_expr -> expr - expr .)
    OF              reduce using rule 32 (binary_expr -> expr - expr .)
    THEN            reduce using rule 32 (binary_expr -> expr - expr .)
    END             reduce using rule 32 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 32 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 32 (binary_expr -> expr - expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    *               shift and go to state 43
    /               shift and go to state 44


state 71

    (33) binary_expr -> expr + expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 33 (binary_expr -> expr + expr .)
    NUM_NOT_EQUAL   reduce using rule 33 (binary_expr -> expr + expr .)
    >               reduce using rule 33 (binary_expr -> expr + expr .)
    %               reduce using rule 33 (binary_expr -> expr + expr .)
    <               reduce using rule 33 (binary_expr -> expr + expr .)
    -               reduce using rule 33 (binary_expr -> expr + expr .)
    +               reduce using rule 33 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 33 (binary_expr -> expr + expr .)
    ENUM            reduce using rule 33 (binary_expr -> expr + expr .)
    [               reduce using rule 33 (binary_expr -> expr + expr .)
    IDENTIFIER      reduce using rule 33 (binary_expr -> expr + expr .)
    LET             reduce using rule 33 (binary_expr -> expr + expr .)
    CASE            reduce using rule 33 (binary_expr -> expr + expr .)
    IF              reduce using rule 33 (binary_expr -> expr + expr .)
    DEF             reduce using rule 33 (binary_expr -> expr + expr .)
    STRING          reduce using rule 33 (binary_expr -> expr + expr .)
    NUMBER          reduce using rule 33 (binary_expr -> expr + expr .)
    DO              reduce using rule 33 (binary_expr -> expr + expr .)
    EXTERNAL        reduce using rule 33 (binary_expr -> expr + expr .)
    TYPE_IDENTIFIER reduce using rule 33 (binary_expr -> expr + expr .)
    $end            reduce using rule 33 (binary_expr -> expr + expr .)
    )               reduce using rule 33 (binary_expr -> expr + expr .)
    ,               reduce using rule 33 (binary_expr -> expr + expr .)
    ]               reduce using rule 33 (binary_expr -> expr + expr .)
    OF              reduce using rule 33 (binary_expr -> expr + expr .)
    THEN            reduce using rule 33 (binary_expr -> expr + expr .)
    END             reduce using rule 33 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 33 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 33 (binary_expr -> expr + expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    *               shift and go to state 43
    /               shift and go to state 44


state 72

    (34) binary_expr -> expr CONCAT expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    NUM_NOT_EQUAL   reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    >               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    <               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    CONCAT          reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ENUM            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    [               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    IDENTIFIER      reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    LET             reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    CASE            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    IF              reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    DEF             reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    STRING          reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    NUMBER          reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    DO              reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    EXTERNAL        reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    TYPE_IDENTIFIER reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    THEN            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 34 (binary_expr -> expr CONCAT expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46


state 73

    (67) enum -> ENUM type_identifier { . _9_repeat }
    (68) _9_repeat -> . _9_items
    (69) _9_repeat -> .
    (70) _9_items -> . _9_items _9_item
    (71) _9_items -> . _9_item
    (72) _9_item -> . variant
    (84) variant -> . type_identifier
    (85) variant -> . type_identifier ( type _12_repeat )
    (147) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 69 (_9_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 98
    _9_repeat                      shift and go to state 99
    _9_items                       shift and go to state 100
    _9_item                        shift and go to state 101
    variant                        shift and go to state 102

state 74

    (73) enum -> ENUM type_identifier < . type_identifier _10_repeat > { _11_repeat }
    (147) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 103

state 75

    (138) variant_call -> type_identifier ( _24_optional . _25_repeat )
    (141) _25_repeat -> . _25_items
    (142) _25_repeat -> .
    (143) _25_items -> . _25_items _25_item
    (144) _25_items -> . _25_item
    (145) _25_item -> . , expr
    )               reduce using rule 142 (_25_repeat -> .)
    ,               shift and go to state 107

    _25_repeat                     shift and go to state 104
    _25_items                      shift and go to state 105
    _25_item                       shift and go to state 106

state 76

    (139) _24_optional -> expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 139 (_24_optional -> expr .)
    )               reduce using rule 139 (_24_optional -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 77

    (9) expr -> ( expr ) .
    (               reduce using rule 9 (expr -> ( expr ) .)
    INT_DIV         reduce using rule 9 (expr -> ( expr ) .)
    NOT_MORE        reduce using rule 9 (expr -> ( expr ) .)
    NUM_NOT_EQUAL   reduce using rule 9 (expr -> ( expr ) .)
    >               reduce using rule 9 (expr -> ( expr ) .)
    %               reduce using rule 9 (expr -> ( expr ) .)
    <               reduce using rule 9 (expr -> ( expr ) .)
    *               reduce using rule 9 (expr -> ( expr ) .)
    /               reduce using rule 9 (expr -> ( expr ) .)
    -               reduce using rule 9 (expr -> ( expr ) .)
    +               reduce using rule 9 (expr -> ( expr ) .)
    CONCAT          reduce using rule 9 (expr -> ( expr ) .)
    ENUM            reduce using rule 9 (expr -> ( expr ) .)
    [               reduce using rule 9 (expr -> ( expr ) .)
    IDENTIFIER      reduce using rule 9 (expr -> ( expr ) .)
    LET             reduce using rule 9 (expr -> ( expr ) .)
    CASE            reduce using rule 9 (expr -> ( expr ) .)
    IF              reduce using rule 9 (expr -> ( expr ) .)
    DEF             reduce using rule 9 (expr -> ( expr ) .)
    STRING          reduce using rule 9 (expr -> ( expr ) .)
    NUMBER          reduce using rule 9 (expr -> ( expr ) .)
    DO              reduce using rule 9 (expr -> ( expr ) .)
    EXTERNAL        reduce using rule 9 (expr -> ( expr ) .)
    TYPE_IDENTIFIER reduce using rule 9 (expr -> ( expr ) .)
    $end            reduce using rule 9 (expr -> ( expr ) .)
    )               reduce using rule 9 (expr -> ( expr ) .)
    ,               reduce using rule 9 (expr -> ( expr ) .)
    ]               reduce using rule 9 (expr -> ( expr ) .)
    OF              reduce using rule 9 (expr -> ( expr ) .)
    THEN            reduce using rule 9 (expr -> ( expr ) .)
    END             reduce using rule 9 (expr -> ( expr ) .)
    ELIF            reduce using rule 9 (expr -> ( expr ) .)
    ELSE            reduce using rule 9 (expr -> ( expr ) .)


state 78

    (121) array -> [ _20_optional _21_repeat . ]
    ]               shift and go to state 108


state 79

    (124) _21_repeat -> _21_items .
    (126) _21_items -> _21_items . _21_item
    (128) _21_item -> . , expr
    ]               reduce using rule 124 (_21_repeat -> _21_items .)
    ,               shift and go to state 81

    _21_item                       shift and go to state 109

state 80

    (127) _21_items -> _21_item .
    ,               reduce using rule 127 (_21_items -> _21_item .)
    ]               reduce using rule 127 (_21_items -> _21_item .)


state 81

    (128) _21_item -> , . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 110
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 82

    (148) variable_declaration -> LET identifier _26_optional . = expr
    =               shift and go to state 111


state 83

    (149) _26_optional -> : . type
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 112
    type_identifier                shift and go to state 93

state 84

    (103) case_of -> CASE expr OF . _17_repeat END
    (104) _17_repeat -> . _17_items
    (105) _17_repeat -> .
    (106) _17_items -> . _17_items _17_item
    (107) _17_items -> . _17_item
    (108) _17_item -> . pattern do
    (109) pattern -> . match_variant
    (110) pattern -> . match_as
    (112) match_variant -> . type_identifier
    (113) match_variant -> . type_identifier ( _18_optional _19_repeat )
    (111) match_as -> . identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    (146) identifier -> . IDENTIFIER
    END             reduce using rule 105 (_17_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 25

    _17_repeat                     shift and go to state 113
    _17_items                      shift and go to state 114
    _17_item                       shift and go to state 115
    pattern                        shift and go to state 116
    match_variant                  shift and go to state 117
    match_as                       shift and go to state 118
    type_identifier                shift and go to state 119
    identifier                     shift and go to state 120

state 85

    (94) if_expr -> IF expr THEN . _14_optional block_statement _15_optional END
    (95) _14_optional -> . : type
    (96) _14_optional -> .
    :               shift and go to state 122
    (               reduce using rule 96 (_14_optional -> .)
    -               reduce using rule 96 (_14_optional -> .)
    [               reduce using rule 96 (_14_optional -> .)
    IDENTIFIER      reduce using rule 96 (_14_optional -> .)
    LET             reduce using rule 96 (_14_optional -> .)
    CASE            reduce using rule 96 (_14_optional -> .)
    IF              reduce using rule 96 (_14_optional -> .)
    DEF             reduce using rule 96 (_14_optional -> .)
    STRING          reduce using rule 96 (_14_optional -> .)
    NUMBER          reduce using rule 96 (_14_optional -> .)
    DO              reduce using rule 96 (_14_optional -> .)
    EXTERNAL        reduce using rule 96 (_14_optional -> .)
    TYPE_IDENTIFIER reduce using rule 96 (_14_optional -> .)
    ELIF            reduce using rule 96 (_14_optional -> .)
    ELSE            reduce using rule 96 (_14_optional -> .)
    END             reduce using rule 96 (_14_optional -> .)

    _14_optional                   shift and go to state 121

state 86

    (49) def_expr -> DEF identifier ( . _5_optional _6_repeat ) _7_optional do
    (50) _5_optional -> . param
    (51) _5_optional -> .
    (91) param -> . identifier _13_optional
    (146) identifier -> . IDENTIFIER
    ,               reduce using rule 51 (_5_optional -> .)
    )               reduce using rule 51 (_5_optional -> .)
    IDENTIFIER      shift and go to state 25

    identifier                     shift and go to state 123
    _5_optional                    shift and go to state 124
    param                          shift and go to state 125

state 87

    (35) do -> DO _2_optional _3_repeat . END
    END             shift and go to state 126


state 88

    (38) _3_repeat -> _3_items .
    (40) _3_items -> _3_items . _3_item
    (42) _3_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 38 (_3_repeat -> _3_items .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _3_item                        shift and go to state 127
    expr                           shift and go to state 90
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 89

    (41) _3_items -> _3_item .
    (               reduce using rule 41 (_3_items -> _3_item .)
    -               reduce using rule 41 (_3_items -> _3_item .)
    [               reduce using rule 41 (_3_items -> _3_item .)
    IDENTIFIER      reduce using rule 41 (_3_items -> _3_item .)
    LET             reduce using rule 41 (_3_items -> _3_item .)
    CASE            reduce using rule 41 (_3_items -> _3_item .)
    IF              reduce using rule 41 (_3_items -> _3_item .)
    DEF             reduce using rule 41 (_3_items -> _3_item .)
    STRING          reduce using rule 41 (_3_items -> _3_item .)
    NUMBER          reduce using rule 41 (_3_items -> _3_item .)
    DO              reduce using rule 41 (_3_items -> _3_item .)
    EXTERNAL        reduce using rule 41 (_3_items -> _3_item .)
    TYPE_IDENTIFIER reduce using rule 41 (_3_items -> _3_item .)
    END             reduce using rule 41 (_3_items -> _3_item .)


state 90

    (42) _3_item -> expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    [               reduce using rule 42 (_3_item -> expr .)
    IDENTIFIER      reduce using rule 42 (_3_item -> expr .)
    LET             reduce using rule 42 (_3_item -> expr .)
    CASE            reduce using rule 42 (_3_item -> expr .)
    IF              reduce using rule 42 (_3_item -> expr .)
    DEF             reduce using rule 42 (_3_item -> expr .)
    STRING          reduce using rule 42 (_3_item -> expr .)
    NUMBER          reduce using rule 42 (_3_item -> expr .)
    DO              reduce using rule 42 (_3_item -> expr .)
    EXTERNAL        reduce using rule 42 (_3_item -> expr .)
    TYPE_IDENTIFIER reduce using rule 42 (_3_item -> expr .)
    END             reduce using rule 42 (_3_item -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 91

    (36) _2_optional -> : type .
    (               reduce using rule 36 (_2_optional -> : type .)
    -               reduce using rule 36 (_2_optional -> : type .)
    [               reduce using rule 36 (_2_optional -> : type .)
    IDENTIFIER      reduce using rule 36 (_2_optional -> : type .)
    LET             reduce using rule 36 (_2_optional -> : type .)
    CASE            reduce using rule 36 (_2_optional -> : type .)
    IF              reduce using rule 36 (_2_optional -> : type .)
    DEF             reduce using rule 36 (_2_optional -> : type .)
    STRING          reduce using rule 36 (_2_optional -> : type .)
    NUMBER          reduce using rule 36 (_2_optional -> : type .)
    DO              reduce using rule 36 (_2_optional -> : type .)
    EXTERNAL        reduce using rule 36 (_2_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 36 (_2_optional -> : type .)
    END             reduce using rule 36 (_2_optional -> : type .)


state 92

    (59) type -> GENERIC_IDENTIFIER .
    (               reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    -               reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    [               reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    IDENTIFIER      reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    LET             reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    CASE            reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    IF              reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    DEF             reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    STRING          reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    NUMBER          reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    DO              reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    EXTERNAL        reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    TYPE_IDENTIFIER reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    END             reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    =               reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    ELIF            reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    ELSE            reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    ,               reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    >               reduce using rule 59 (type -> GENERIC_IDENTIFIER .)
    )               reduce using rule 59 (type -> GENERIC_IDENTIFIER .)


state 93

    (60) type -> type_identifier . < type _8_repeat >
    (66) type -> type_identifier .
    <               shift and go to state 128
    (               reduce using rule 66 (type -> type_identifier .)
    -               reduce using rule 66 (type -> type_identifier .)
    [               reduce using rule 66 (type -> type_identifier .)
    IDENTIFIER      reduce using rule 66 (type -> type_identifier .)
    LET             reduce using rule 66 (type -> type_identifier .)
    CASE            reduce using rule 66 (type -> type_identifier .)
    IF              reduce using rule 66 (type -> type_identifier .)
    DEF             reduce using rule 66 (type -> type_identifier .)
    STRING          reduce using rule 66 (type -> type_identifier .)
    NUMBER          reduce using rule 66 (type -> type_identifier .)
    DO              reduce using rule 66 (type -> type_identifier .)
    EXTERNAL        reduce using rule 66 (type -> type_identifier .)
    TYPE_IDENTIFIER reduce using rule 66 (type -> type_identifier .)
    END             reduce using rule 66 (type -> type_identifier .)
    =               reduce using rule 66 (type -> type_identifier .)
    ELIF            reduce using rule 66 (type -> type_identifier .)
    ELSE            reduce using rule 66 (type -> type_identifier .)
    ,               reduce using rule 66 (type -> type_identifier .)
    >               reduce using rule 66 (type -> type_identifier .)
    )               reduce using rule 66 (type -> type_identifier .)


state 94

    (129) call -> expr ( _22_optional _23_repeat . )
    )               shift and go to state 129


state 95

    (132) _23_repeat -> _23_items .
    (134) _23_items -> _23_items . _23_item
    (136) _23_item -> . , expr
    )               reduce using rule 132 (_23_repeat -> _23_items .)
    ,               shift and go to state 97

    _23_item                       shift and go to state 130

state 96

    (135) _23_items -> _23_item .
    ,               reduce using rule 135 (_23_items -> _23_item .)
    )               reduce using rule 135 (_23_items -> _23_item .)


state 97

    (136) _23_item -> , . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 131
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 98

    (84) variant -> type_identifier .
    (85) variant -> type_identifier . ( type _12_repeat )
    TYPE_IDENTIFIER reduce using rule 84 (variant -> type_identifier .)
    }               reduce using rule 84 (variant -> type_identifier .)
    (               shift and go to state 132


state 99

    (67) enum -> ENUM type_identifier { _9_repeat . }
    }               shift and go to state 133


state 100

    (68) _9_repeat -> _9_items .
    (70) _9_items -> _9_items . _9_item
    (72) _9_item -> . variant
    (84) variant -> . type_identifier
    (85) variant -> . type_identifier ( type _12_repeat )
    (147) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 68 (_9_repeat -> _9_items .)
    TYPE_IDENTIFIER shift and go to state 34

    _9_item                        shift and go to state 134
    variant                        shift and go to state 102
    type_identifier                shift and go to state 98

state 101

    (71) _9_items -> _9_item .
    TYPE_IDENTIFIER reduce using rule 71 (_9_items -> _9_item .)
    }               reduce using rule 71 (_9_items -> _9_item .)


state 102

    (72) _9_item -> variant .
    TYPE_IDENTIFIER reduce using rule 72 (_9_item -> variant .)
    }               reduce using rule 72 (_9_item -> variant .)


state 103

    (73) enum -> ENUM type_identifier < type_identifier . _10_repeat > { _11_repeat }
    (74) _10_repeat -> . _10_items
    (75) _10_repeat -> .
    (76) _10_items -> . _10_items _10_item
    (77) _10_items -> . _10_item
    (78) _10_item -> . , type_identifier
    >               reduce using rule 75 (_10_repeat -> .)
    ,               shift and go to state 138

    _10_repeat                     shift and go to state 135
    _10_items                      shift and go to state 136
    _10_item                       shift and go to state 137

state 104

    (138) variant_call -> type_identifier ( _24_optional _25_repeat . )
    )               shift and go to state 139


state 105

    (141) _25_repeat -> _25_items .
    (143) _25_items -> _25_items . _25_item
    (145) _25_item -> . , expr
    )               reduce using rule 141 (_25_repeat -> _25_items .)
    ,               shift and go to state 107

    _25_item                       shift and go to state 140

state 106

    (144) _25_items -> _25_item .
    ,               reduce using rule 144 (_25_items -> _25_item .)
    )               reduce using rule 144 (_25_items -> _25_item .)


state 107

    (145) _25_item -> , . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 141
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 108

    (121) array -> [ _20_optional _21_repeat ] .
    (               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    INT_DIV         reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    NOT_MORE        reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    NUM_NOT_EQUAL   reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    >               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    %               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    <               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    *               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    /               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    -               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    +               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    CONCAT          reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    ENUM            reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    [               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    IDENTIFIER      reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    LET             reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    CASE            reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    IF              reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    DEF             reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    STRING          reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    NUMBER          reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    DO              reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    EXTERNAL        reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    TYPE_IDENTIFIER reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    $end            reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    )               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    ,               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    ]               reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    OF              reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    THEN            reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    END             reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    ELIF            reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)
    ELSE            reduce using rule 121 (array -> [ _20_optional _21_repeat ] .)


state 109

    (126) _21_items -> _21_items _21_item .
    ,               reduce using rule 126 (_21_items -> _21_items _21_item .)
    ]               reduce using rule 126 (_21_items -> _21_items _21_item .)


state 110

    (128) _21_item -> , expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 128 (_21_item -> , expr .)
    ]               reduce using rule 128 (_21_item -> , expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 111

    (148) variable_declaration -> LET identifier _26_optional = . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    identifier                     shift and go to state 14
    expr                           shift and go to state 142
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 112

    (149) _26_optional -> : type .
    =               reduce using rule 149 (_26_optional -> : type .)


state 113

    (103) case_of -> CASE expr OF _17_repeat . END
    END             shift and go to state 143


state 114

    (104) _17_repeat -> _17_items .
    (106) _17_items -> _17_items . _17_item
    (108) _17_item -> . pattern do
    (109) pattern -> . match_variant
    (110) pattern -> . match_as
    (112) match_variant -> . type_identifier
    (113) match_variant -> . type_identifier ( _18_optional _19_repeat )
    (111) match_as -> . identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    (146) identifier -> . IDENTIFIER
    END             reduce using rule 104 (_17_repeat -> _17_items .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 25

    _17_item                       shift and go to state 144
    pattern                        shift and go to state 116
    match_variant                  shift and go to state 117
    match_as                       shift and go to state 118
    type_identifier                shift and go to state 119
    identifier                     shift and go to state 120

state 115

    (107) _17_items -> _17_item .
    TYPE_IDENTIFIER reduce using rule 107 (_17_items -> _17_item .)
    IDENTIFIER      reduce using rule 107 (_17_items -> _17_item .)
    END             reduce using rule 107 (_17_items -> _17_item .)


state 116

    (108) _17_item -> pattern . do
    (35) do -> . DO _2_optional _3_repeat END
    DO              shift and go to state 32

    do                             shift and go to state 145

state 117

    (109) pattern -> match_variant .
    DO              reduce using rule 109 (pattern -> match_variant .)
    ,               reduce using rule 109 (pattern -> match_variant .)
    )               reduce using rule 109 (pattern -> match_variant .)


state 118

    (110) pattern -> match_as .
    DO              reduce using rule 110 (pattern -> match_as .)
    ,               reduce using rule 110 (pattern -> match_as .)
    )               reduce using rule 110 (pattern -> match_as .)


state 119

    (112) match_variant -> type_identifier .
    (113) match_variant -> type_identifier . ( _18_optional _19_repeat )
    DO              reduce using rule 112 (match_variant -> type_identifier .)
    ,               reduce using rule 112 (match_variant -> type_identifier .)
    )               reduce using rule 112 (match_variant -> type_identifier .)
    (               shift and go to state 146


state 120

    (111) match_as -> identifier .
    DO              reduce using rule 111 (match_as -> identifier .)
    ,               reduce using rule 111 (match_as -> identifier .)
    )               reduce using rule 111 (match_as -> identifier .)


state 121

    (94) if_expr -> IF expr THEN _14_optional . block_statement _15_optional END
    (43) block_statement -> . _4_repeat
    (44) _4_repeat -> . _4_items
    (45) _4_repeat -> .
    (46) _4_items -> . _4_items _4_item
    (47) _4_items -> . _4_item
    (48) _4_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 45 (_4_repeat -> .)
    ELSE            reduce using rule 45 (_4_repeat -> .)
    END             reduce using rule 45 (_4_repeat -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 147
    block_statement                shift and go to state 148
    _4_repeat                      shift and go to state 149
    _4_items                       shift and go to state 150
    _4_item                        shift and go to state 151
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 122

    (95) _14_optional -> : . type
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 152
    type_identifier                shift and go to state 93

state 123

    (91) param -> identifier . _13_optional
    (92) _13_optional -> . : type
    (93) _13_optional -> .
    :               shift and go to state 154
    ,               reduce using rule 93 (_13_optional -> .)
    )               reduce using rule 93 (_13_optional -> .)

    _13_optional                   shift and go to state 153

state 124

    (49) def_expr -> DEF identifier ( _5_optional . _6_repeat ) _7_optional do
    (52) _6_repeat -> . _6_items
    (53) _6_repeat -> .
    (54) _6_items -> . _6_items _6_item
    (55) _6_items -> . _6_item
    (56) _6_item -> . , param
    )               reduce using rule 53 (_6_repeat -> .)
    ,               shift and go to state 158

    _6_repeat                      shift and go to state 155
    _6_items                       shift and go to state 156
    _6_item                        shift and go to state 157

state 125

    (50) _5_optional -> param .
    ,               reduce using rule 50 (_5_optional -> param .)
    )               reduce using rule 50 (_5_optional -> param .)


state 126

    (35) do -> DO _2_optional _3_repeat END .
    (               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    INT_DIV         reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    NOT_MORE        reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    NUM_NOT_EQUAL   reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    >               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    %               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    <               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    *               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    /               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    -               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    +               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    CONCAT          reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ENUM            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    [               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    IDENTIFIER      reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    LET             reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    CASE            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    IF              reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    DEF             reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    STRING          reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    NUMBER          reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    DO              reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    EXTERNAL        reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    TYPE_IDENTIFIER reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    $end            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    )               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ,               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ]               reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    OF              reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    THEN            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    END             reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ELIF            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)
    ELSE            reduce using rule 35 (do -> DO _2_optional _3_repeat END .)


state 127

    (40) _3_items -> _3_items _3_item .
    (               reduce using rule 40 (_3_items -> _3_items _3_item .)
    -               reduce using rule 40 (_3_items -> _3_items _3_item .)
    [               reduce using rule 40 (_3_items -> _3_items _3_item .)
    IDENTIFIER      reduce using rule 40 (_3_items -> _3_items _3_item .)
    LET             reduce using rule 40 (_3_items -> _3_items _3_item .)
    CASE            reduce using rule 40 (_3_items -> _3_items _3_item .)
    IF              reduce using rule 40 (_3_items -> _3_items _3_item .)
    DEF             reduce using rule 40 (_3_items -> _3_items _3_item .)
    STRING          reduce using rule 40 (_3_items -> _3_items _3_item .)
    NUMBER          reduce using rule 40 (_3_items -> _3_items _3_item .)
    DO              reduce using rule 40 (_3_items -> _3_items _3_item .)
    EXTERNAL        reduce using rule 40 (_3_items -> _3_items _3_item .)
    TYPE_IDENTIFIER reduce using rule 40 (_3_items -> _3_items _3_item .)
    END             reduce using rule 40 (_3_items -> _3_items _3_item .)


state 128

    (60) type -> type_identifier < . type _8_repeat >
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 93
    type                           shift and go to state 159

state 129

    (129) call -> expr ( _22_optional _23_repeat ) .
    (               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    INT_DIV         reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    NOT_MORE        reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    NUM_NOT_EQUAL   reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    >               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    %               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    <               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    *               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    /               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    -               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    +               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    CONCAT          reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    ENUM            reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    [               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    IDENTIFIER      reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    LET             reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    CASE            reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    IF              reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    DEF             reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    STRING          reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    NUMBER          reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    DO              reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    EXTERNAL        reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    $end            reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    )               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    ,               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    ]               reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    OF              reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    THEN            reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    END             reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    ELIF            reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)
    ELSE            reduce using rule 129 (call -> expr ( _22_optional _23_repeat ) .)


state 130

    (134) _23_items -> _23_items _23_item .
    ,               reduce using rule 134 (_23_items -> _23_items _23_item .)
    )               reduce using rule 134 (_23_items -> _23_items _23_item .)


state 131

    (136) _23_item -> , expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 136 (_23_item -> , expr .)
    )               reduce using rule 136 (_23_item -> , expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 132

    (85) variant -> type_identifier ( . type _12_repeat )
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 93
    type                           shift and go to state 160

state 133

    (67) enum -> ENUM type_identifier { _9_repeat } .
    ENUM            reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    (               reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    -               reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    [               reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    IDENTIFIER      reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    LET             reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    CASE            reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    IF              reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    DEF             reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    STRING          reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    NUMBER          reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    DO              reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    EXTERNAL        reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    TYPE_IDENTIFIER reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)
    $end            reduce using rule 67 (enum -> ENUM type_identifier { _9_repeat } .)


state 134

    (70) _9_items -> _9_items _9_item .
    TYPE_IDENTIFIER reduce using rule 70 (_9_items -> _9_items _9_item .)
    }               reduce using rule 70 (_9_items -> _9_items _9_item .)


state 135

    (73) enum -> ENUM type_identifier < type_identifier _10_repeat . > { _11_repeat }
    >               shift and go to state 161


state 136

    (74) _10_repeat -> _10_items .
    (76) _10_items -> _10_items . _10_item
    (78) _10_item -> . , type_identifier
    >               reduce using rule 74 (_10_repeat -> _10_items .)
    ,               shift and go to state 138

    _10_item                       shift and go to state 162

state 137

    (77) _10_items -> _10_item .
    ,               reduce using rule 77 (_10_items -> _10_item .)
    >               reduce using rule 77 (_10_items -> _10_item .)


state 138

    (78) _10_item -> , . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 163

state 139

    (138) variant_call -> type_identifier ( _24_optional _25_repeat ) .
    (               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    INT_DIV         reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    NOT_MORE        reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    NUM_NOT_EQUAL   reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    >               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    %               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    <               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    *               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    /               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    -               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    +               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    CONCAT          reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ENUM            reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    [               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    IDENTIFIER      reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    LET             reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    CASE            reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    IF              reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    DEF             reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    STRING          reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    NUMBER          reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    DO              reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    EXTERNAL        reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    TYPE_IDENTIFIER reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    $end            reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    )               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ,               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ]               reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    OF              reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    THEN            reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    END             reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ELIF            reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)
    ELSE            reduce using rule 138 (variant_call -> type_identifier ( _24_optional _25_repeat ) .)


state 140

    (143) _25_items -> _25_items _25_item .
    ,               reduce using rule 143 (_25_items -> _25_items _25_item .)
    )               reduce using rule 143 (_25_items -> _25_items _25_item .)


state 141

    (145) _25_item -> , expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 145 (_25_item -> , expr .)
    )               reduce using rule 145 (_25_item -> , expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 142

    (148) variable_declaration -> LET identifier _26_optional = expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    NOT_MORE        reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    NUM_NOT_EQUAL   reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    >               reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    <               reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    ENUM            reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    [               reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    IDENTIFIER      reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    LET             reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    CASE            reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    IF              reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    DEF             reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    STRING          reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    NUMBER          reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    DO              reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    EXTERNAL        reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    TYPE_IDENTIFIER reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    $end            reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    )               reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    ,               reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    ]               reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    OF              reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    THEN            reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    END             reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    ELIF            reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    ELSE            reduce using rule 148 (variable_declaration -> LET identifier _26_optional = expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    %               shift and go to state 41
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 143

    (103) case_of -> CASE expr OF _17_repeat END .
    (               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    INT_DIV         reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    NOT_MORE        reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    NUM_NOT_EQUAL   reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    >               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    %               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    <               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    *               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    /               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    -               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    +               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    CONCAT          reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    ENUM            reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    [               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    IDENTIFIER      reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    LET             reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    CASE            reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    IF              reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    DEF             reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    STRING          reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    NUMBER          reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    DO              reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    EXTERNAL        reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    TYPE_IDENTIFIER reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    $end            reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    )               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    ,               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    ]               reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    OF              reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    THEN            reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    END             reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    ELIF            reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)
    ELSE            reduce using rule 103 (case_of -> CASE expr OF _17_repeat END .)


state 144

    (106) _17_items -> _17_items _17_item .
    TYPE_IDENTIFIER reduce using rule 106 (_17_items -> _17_items _17_item .)
    IDENTIFIER      reduce using rule 106 (_17_items -> _17_items _17_item .)
    END             reduce using rule 106 (_17_items -> _17_items _17_item .)


state 145

    (108) _17_item -> pattern do .
    TYPE_IDENTIFIER reduce using rule 108 (_17_item -> pattern do .)
    IDENTIFIER      reduce using rule 108 (_17_item -> pattern do .)
    END             reduce using rule 108 (_17_item -> pattern do .)


state 146

    (113) match_variant -> type_identifier ( . _18_optional _19_repeat )
    (114) _18_optional -> . pattern
    (115) _18_optional -> .
    (109) pattern -> . match_variant
    (110) pattern -> . match_as
    (112) match_variant -> . type_identifier
    (113) match_variant -> . type_identifier ( _18_optional _19_repeat )
    (111) match_as -> . identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    (146) identifier -> . IDENTIFIER
    ,               reduce using rule 115 (_18_optional -> .)
    )               reduce using rule 115 (_18_optional -> .)
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 25

    type_identifier                shift and go to state 119
    _18_optional                   shift and go to state 164
    pattern                        shift and go to state 165
    match_variant                  shift and go to state 117
    match_as                       shift and go to state 118
    identifier                     shift and go to state 120

state 147

    (48) _4_item -> expr .
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
    [               reduce using rule 48 (_4_item -> expr .)
    IDENTIFIER      reduce using rule 48 (_4_item -> expr .)
    LET             reduce using rule 48 (_4_item -> expr .)
    CASE            reduce using rule 48 (_4_item -> expr .)
    IF              reduce using rule 48 (_4_item -> expr .)
    DEF             reduce using rule 48 (_4_item -> expr .)
    STRING          reduce using rule 48 (_4_item -> expr .)
    NUMBER          reduce using rule 48 (_4_item -> expr .)
    DO              reduce using rule 48 (_4_item -> expr .)
    EXTERNAL        reduce using rule 48 (_4_item -> expr .)
    TYPE_IDENTIFIER reduce using rule 48 (_4_item -> expr .)
    ELIF            reduce using rule 48 (_4_item -> expr .)
    ELSE            reduce using rule 48 (_4_item -> expr .)
    END             reduce using rule 48 (_4_item -> expr .)
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 148

    (94) if_expr -> IF expr THEN _14_optional block_statement . _15_optional END
    (97) _15_optional -> . or_else
    (98) _15_optional -> .
    (99) or_else -> . ELIF expr THEN block_statement _16_optional
    (102) or_else -> . ELSE block_statement
    END             reduce using rule 98 (_15_optional -> .)
    ELIF            shift and go to state 168
    ELSE            shift and go to state 169

    _15_optional                   shift and go to state 166
    or_else                        shift and go to state 167

state 149

    (43) block_statement -> _4_repeat .
    ELIF            reduce using rule 43 (block_statement -> _4_repeat .)
    ELSE            reduce using rule 43 (block_statement -> _4_repeat .)
    END             reduce using rule 43 (block_statement -> _4_repeat .)


state 150

    (44) _4_repeat -> _4_items .
    (46) _4_items -> _4_items . _4_item
    (48) _4_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 44 (_4_repeat -> _4_items .)
    ELSE            reduce using rule 44 (_4_repeat -> _4_items .)
    END             reduce using rule 44 (_4_repeat -> _4_items .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    _4_item                        shift and go to state 170
    expr                           shift and go to state 147
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 151

    (47) _4_items -> _4_item .
    (               reduce using rule 47 (_4_items -> _4_item .)
    -               reduce using rule 47 (_4_items -> _4_item .)
    [               reduce using rule 47 (_4_items -> _4_item .)
    IDENTIFIER      reduce using rule 47 (_4_items -> _4_item .)
    LET             reduce using rule 47 (_4_items -> _4_item .)
    CASE            reduce using rule 47 (_4_items -> _4_item .)
    IF              reduce using rule 47 (_4_items -> _4_item .)
    DEF             reduce using rule 47 (_4_items -> _4_item .)
    STRING          reduce using rule 47 (_4_items -> _4_item .)
    NUMBER          reduce using rule 47 (_4_items -> _4_item .)
    DO              reduce using rule 47 (_4_items -> _4_item .)
    EXTERNAL        reduce using rule 47 (_4_items -> _4_item .)
    TYPE_IDENTIFIER reduce using rule 47 (_4_items -> _4_item .)
    ELIF            reduce using rule 47 (_4_items -> _4_item .)
    ELSE            reduce using rule 47 (_4_items -> _4_item .)
    END             reduce using rule 47 (_4_items -> _4_item .)


state 152

    (95) _14_optional -> : type .
    (               reduce using rule 95 (_14_optional -> : type .)
    -               reduce using rule 95 (_14_optional -> : type .)
    [               reduce using rule 95 (_14_optional -> : type .)
    IDENTIFIER      reduce using rule 95 (_14_optional -> : type .)
    LET             reduce using rule 95 (_14_optional -> : type .)
    CASE            reduce using rule 95 (_14_optional -> : type .)
    IF              reduce using rule 95 (_14_optional -> : type .)
    DEF             reduce using rule 95 (_14_optional -> : type .)
    STRING          reduce using rule 95 (_14_optional -> : type .)
    NUMBER          reduce using rule 95 (_14_optional -> : type .)
    DO              reduce using rule 95 (_14_optional -> : type .)
    EXTERNAL        reduce using rule 95 (_14_optional -> : type .)
    TYPE_IDENTIFIER reduce using rule 95 (_14_optional -> : type .)
    ELIF            reduce using rule 95 (_14_optional -> : type .)
    ELSE            reduce using rule 95 (_14_optional -> : type .)
    END             reduce using rule 95 (_14_optional -> : type .)


state 153

    (91) param -> identifier _13_optional .
    ,               reduce using rule 91 (param -> identifier _13_optional .)
    )               reduce using rule 91 (param -> identifier _13_optional .)


state 154

    (92) _13_optional -> : . type
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 171
    type_identifier                shift and go to state 93

state 155

    (49) def_expr -> DEF identifier ( _5_optional _6_repeat . ) _7_optional do
    )               shift and go to state 172


state 156

    (52) _6_repeat -> _6_items .
    (54) _6_items -> _6_items . _6_item
    (56) _6_item -> . , param
    )               reduce using rule 52 (_6_repeat -> _6_items .)
    ,               shift and go to state 158

    _6_item                        shift and go to state 173

state 157

    (55) _6_items -> _6_item .
    ,               reduce using rule 55 (_6_items -> _6_item .)
    )               reduce using rule 55 (_6_items -> _6_item .)


state 158

    (56) _6_item -> , . param
    (91) param -> . identifier _13_optional
    (146) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 25

    param                          shift and go to state 174
    identifier                     shift and go to state 123

state 159

    (60) type -> type_identifier < type . _8_repeat >
    (61) _8_repeat -> . _8_items
    (62) _8_repeat -> .
    (63) _8_items -> . _8_items _8_item
    (64) _8_items -> . _8_item
    (65) _8_item -> . , type
    >               reduce using rule 62 (_8_repeat -> .)
    ,               shift and go to state 178

    _8_repeat                      shift and go to state 175
    _8_items                       shift and go to state 176
    _8_item                        shift and go to state 177

state 160

    (85) variant -> type_identifier ( type . _12_repeat )
    (86) _12_repeat -> . _12_items
    (87) _12_repeat -> .
    (88) _12_items -> . _12_items _12_item
    (89) _12_items -> . _12_item
    (90) _12_item -> . , type
    )               reduce using rule 87 (_12_repeat -> .)
    ,               shift and go to state 182

    _12_repeat                     shift and go to state 179
    _12_items                      shift and go to state 180
    _12_item                       shift and go to state 181

state 161

    (73) enum -> ENUM type_identifier < type_identifier _10_repeat > . { _11_repeat }
    {               shift and go to state 183


state 162

    (76) _10_items -> _10_items _10_item .
    ,               reduce using rule 76 (_10_items -> _10_items _10_item .)
    >               reduce using rule 76 (_10_items -> _10_items _10_item .)


state 163

    (78) _10_item -> , type_identifier .
    ,               reduce using rule 78 (_10_item -> , type_identifier .)
    >               reduce using rule 78 (_10_item -> , type_identifier .)


state 164

    (113) match_variant -> type_identifier ( _18_optional . _19_repeat )
    (116) _19_repeat -> . _19_items
    (117) _19_repeat -> .
    (118) _19_items -> . _19_items _19_item
    (119) _19_items -> . _19_item
    (120) _19_item -> . , pattern
    )               reduce using rule 117 (_19_repeat -> .)
    ,               shift and go to state 187

    _19_repeat                     shift and go to state 184
    _19_items                      shift and go to state 185
    _19_item                       shift and go to state 186

state 165

    (114) _18_optional -> pattern .
    ,               reduce using rule 114 (_18_optional -> pattern .)
    )               reduce using rule 114 (_18_optional -> pattern .)


state 166

    (94) if_expr -> IF expr THEN _14_optional block_statement _15_optional . END
    END             shift and go to state 188


state 167

    (97) _15_optional -> or_else .
    END             reduce using rule 97 (_15_optional -> or_else .)


state 168

    (99) or_else -> ELIF . expr THEN block_statement _16_optional
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 189
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 169

    (102) or_else -> ELSE . block_statement
    (43) block_statement -> . _4_repeat
    (44) _4_repeat -> . _4_items
    (45) _4_repeat -> .
    (46) _4_items -> . _4_items _4_item
    (47) _4_items -> . _4_item
    (48) _4_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 45 (_4_repeat -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    block_statement                shift and go to state 190
    _4_repeat                      shift and go to state 149
    _4_items                       shift and go to state 150
    _4_item                        shift and go to state 151
    expr                           shift and go to state 147
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 170

    (46) _4_items -> _4_items _4_item .
    (               reduce using rule 46 (_4_items -> _4_items _4_item .)
    -               reduce using rule 46 (_4_items -> _4_items _4_item .)
    [               reduce using rule 46 (_4_items -> _4_items _4_item .)
    IDENTIFIER      reduce using rule 46 (_4_items -> _4_items _4_item .)
    LET             reduce using rule 46 (_4_items -> _4_items _4_item .)
    CASE            reduce using rule 46 (_4_items -> _4_items _4_item .)
    IF              reduce using rule 46 (_4_items -> _4_items _4_item .)
    DEF             reduce using rule 46 (_4_items -> _4_items _4_item .)
    STRING          reduce using rule 46 (_4_items -> _4_items _4_item .)
    NUMBER          reduce using rule 46 (_4_items -> _4_items _4_item .)
    DO              reduce using rule 46 (_4_items -> _4_items _4_item .)
    EXTERNAL        reduce using rule 46 (_4_items -> _4_items _4_item .)
    TYPE_IDENTIFIER reduce using rule 46 (_4_items -> _4_items _4_item .)
    ELIF            reduce using rule 46 (_4_items -> _4_items _4_item .)
    ELSE            reduce using rule 46 (_4_items -> _4_items _4_item .)
    END             reduce using rule 46 (_4_items -> _4_items _4_item .)


state 171

    (92) _13_optional -> : type .
    ,               reduce using rule 92 (_13_optional -> : type .)
    )               reduce using rule 92 (_13_optional -> : type .)


state 172

    (49) def_expr -> DEF identifier ( _5_optional _6_repeat ) . _7_optional do
    (57) _7_optional -> . : type
    (58) _7_optional -> .
    :               shift and go to state 192
    DO              reduce using rule 58 (_7_optional -> .)

    _7_optional                    shift and go to state 191

state 173

    (54) _6_items -> _6_items _6_item .
    ,               reduce using rule 54 (_6_items -> _6_items _6_item .)
    )               reduce using rule 54 (_6_items -> _6_items _6_item .)


state 174

    (56) _6_item -> , param .
    ,               reduce using rule 56 (_6_item -> , param .)
    )               reduce using rule 56 (_6_item -> , param .)


state 175

    (60) type -> type_identifier < type _8_repeat . >
    >               shift and go to state 193


state 176

    (61) _8_repeat -> _8_items .
    (63) _8_items -> _8_items . _8_item
    (65) _8_item -> . , type
    >               reduce using rule 61 (_8_repeat -> _8_items .)
    ,               shift and go to state 178

    _8_item                        shift and go to state 194

state 177

    (64) _8_items -> _8_item .
    ,               reduce using rule 64 (_8_items -> _8_item .)
    >               reduce using rule 64 (_8_items -> _8_item .)


state 178

    (65) _8_item -> , . type
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 195
    type_identifier                shift and go to state 93

state 179

    (85) variant -> type_identifier ( type _12_repeat . )
    )               shift and go to state 196


state 180

    (86) _12_repeat -> _12_items .
    (88) _12_items -> _12_items . _12_item
    (90) _12_item -> . , type
    )               reduce using rule 86 (_12_repeat -> _12_items .)
    ,               shift and go to state 182

    _12_item                       shift and go to state 197

state 181

    (89) _12_items -> _12_item .
    ,               reduce using rule 89 (_12_items -> _12_item .)
    )               reduce using rule 89 (_12_items -> _12_item .)


state 182

    (90) _12_item -> , . type
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 198
    type_identifier                shift and go to state 93

state 183

    (73) enum -> ENUM type_identifier < type_identifier _10_repeat > { . _11_repeat }
    (79) _11_repeat -> . _11_items
    (80) _11_repeat -> .
    (81) _11_items -> . _11_items _11_item
    (82) _11_items -> . _11_item
    (83) _11_item -> . variant
    (84) variant -> . type_identifier
    (85) variant -> . type_identifier ( type _12_repeat )
    (147) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 80 (_11_repeat -> .)
    TYPE_IDENTIFIER shift and go to state 34

    type_identifier                shift and go to state 98
    _11_repeat                     shift and go to state 199
    _11_items                      shift and go to state 200
    _11_item                       shift and go to state 201
    variant                        shift and go to state 202

state 184

    (113) match_variant -> type_identifier ( _18_optional _19_repeat . )
    )               shift and go to state 203


state 185

    (116) _19_repeat -> _19_items .
    (118) _19_items -> _19_items . _19_item
    (120) _19_item -> . , pattern
    )               reduce using rule 116 (_19_repeat -> _19_items .)
    ,               shift and go to state 187

    _19_item                       shift and go to state 204

state 186

    (119) _19_items -> _19_item .
    ,               reduce using rule 119 (_19_items -> _19_item .)
    )               reduce using rule 119 (_19_items -> _19_item .)


state 187

    (120) _19_item -> , . pattern
    (109) pattern -> . match_variant
    (110) pattern -> . match_as
    (112) match_variant -> . type_identifier
    (113) match_variant -> . type_identifier ( _18_optional _19_repeat )
    (111) match_as -> . identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    (146) identifier -> . IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 34
    IDENTIFIER      shift and go to state 25

    pattern                        shift and go to state 205
    match_variant                  shift and go to state 117
    match_as                       shift and go to state 118
    type_identifier                shift and go to state 119
    identifier                     shift and go to state 120

state 188

    (94) if_expr -> IF expr THEN _14_optional block_statement _15_optional END .
    (               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    INT_DIV         reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    NOT_MORE        reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    NUM_NOT_EQUAL   reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    >               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    %               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    <               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    *               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    /               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    -               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    +               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    CONCAT          reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ENUM            reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    [               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    IDENTIFIER      reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    LET             reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    CASE            reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    IF              reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    DEF             reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    STRING          reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    NUMBER          reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    DO              reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    EXTERNAL        reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    TYPE_IDENTIFIER reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    $end            reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    )               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ,               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ]               reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    OF              reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    THEN            reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    END             reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ELIF            reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)
    ELSE            reduce using rule 94 (if_expr -> IF expr THEN _14_optional block_statement _15_optional END .)


state 189

    (99) or_else -> ELIF expr . THEN block_statement _16_optional
    (129) call -> expr . ( _22_optional _23_repeat )
    (24) binary_expr -> expr . INT_DIV expr
    (25) binary_expr -> expr . NOT_MORE expr
    (26) binary_expr -> expr . NUM_NOT_EQUAL expr
    (27) binary_expr -> expr . > expr
    (28) binary_expr -> expr . % expr
    (29) binary_expr -> expr . < expr
    (30) binary_expr -> expr . * expr
    (31) binary_expr -> expr . / expr
    (32) binary_expr -> expr . - expr
    (33) binary_expr -> expr . + expr
    (34) binary_expr -> expr . CONCAT expr
    THEN            shift and go to state 206
    (               shift and go to state 36
    INT_DIV         shift and go to state 37
    NOT_MORE        shift and go to state 38
    NUM_NOT_EQUAL   shift and go to state 39
    >               shift and go to state 40
    %               shift and go to state 41
    <               shift and go to state 42
    *               shift and go to state 43
    /               shift and go to state 44
    -               shift and go to state 45
    +               shift and go to state 46
    CONCAT          shift and go to state 47


state 190

    (102) or_else -> ELSE block_statement .
    END             reduce using rule 102 (or_else -> ELSE block_statement .)


state 191

    (49) def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional . do
    (35) do -> . DO _2_optional _3_repeat END
    DO              shift and go to state 32

    do                             shift and go to state 207

state 192

    (57) _7_optional -> : . type
    (59) type -> . GENERIC_IDENTIFIER
    (60) type -> . type_identifier < type _8_repeat >
    (66) type -> . type_identifier
    (147) type_identifier -> . TYPE_IDENTIFIER
    GENERIC_IDENTIFIER shift and go to state 92
    TYPE_IDENTIFIER shift and go to state 34

    type                           shift and go to state 208
    type_identifier                shift and go to state 93

state 193

    (60) type -> type_identifier < type _8_repeat > .
    (               reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    -               reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    [               reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    IDENTIFIER      reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    LET             reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    CASE            reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    IF              reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    DEF             reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    STRING          reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    NUMBER          reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    DO              reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    EXTERNAL        reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    TYPE_IDENTIFIER reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    END             reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    =               reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    ELIF            reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    ELSE            reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    ,               reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    >               reduce using rule 60 (type -> type_identifier < type _8_repeat > .)
    )               reduce using rule 60 (type -> type_identifier < type _8_repeat > .)


state 194

    (63) _8_items -> _8_items _8_item .
    ,               reduce using rule 63 (_8_items -> _8_items _8_item .)
    >               reduce using rule 63 (_8_items -> _8_items _8_item .)


state 195

    (65) _8_item -> , type .
    ,               reduce using rule 65 (_8_item -> , type .)
    >               reduce using rule 65 (_8_item -> , type .)


state 196

    (85) variant -> type_identifier ( type _12_repeat ) .
    TYPE_IDENTIFIER reduce using rule 85 (variant -> type_identifier ( type _12_repeat ) .)
    }               reduce using rule 85 (variant -> type_identifier ( type _12_repeat ) .)


state 197

    (88) _12_items -> _12_items _12_item .
    ,               reduce using rule 88 (_12_items -> _12_items _12_item .)
    )               reduce using rule 88 (_12_items -> _12_items _12_item .)


state 198

    (90) _12_item -> , type .
    ,               reduce using rule 90 (_12_item -> , type .)
    )               reduce using rule 90 (_12_item -> , type .)


state 199

    (73) enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat . }
    }               shift and go to state 209


state 200

    (79) _11_repeat -> _11_items .
    (81) _11_items -> _11_items . _11_item
    (83) _11_item -> . variant
    (84) variant -> . type_identifier
    (85) variant -> . type_identifier ( type _12_repeat )
    (147) type_identifier -> . TYPE_IDENTIFIER
    }               reduce using rule 79 (_11_repeat -> _11_items .)
    TYPE_IDENTIFIER shift and go to state 34

    _11_item                       shift and go to state 210
    variant                        shift and go to state 202
    type_identifier                shift and go to state 98

state 201

    (82) _11_items -> _11_item .
    TYPE_IDENTIFIER reduce using rule 82 (_11_items -> _11_item .)
    }               reduce using rule 82 (_11_items -> _11_item .)


state 202

    (83) _11_item -> variant .
    TYPE_IDENTIFIER reduce using rule 83 (_11_item -> variant .)
    }               reduce using rule 83 (_11_item -> variant .)


state 203

    (113) match_variant -> type_identifier ( _18_optional _19_repeat ) .
    DO              reduce using rule 113 (match_variant -> type_identifier ( _18_optional _19_repeat ) .)
    ,               reduce using rule 113 (match_variant -> type_identifier ( _18_optional _19_repeat ) .)
    )               reduce using rule 113 (match_variant -> type_identifier ( _18_optional _19_repeat ) .)


state 204

    (118) _19_items -> _19_items _19_item .
    ,               reduce using rule 118 (_19_items -> _19_items _19_item .)
    )               reduce using rule 118 (_19_items -> _19_items _19_item .)


state 205

    (120) _19_item -> , pattern .
    ,               reduce using rule 120 (_19_item -> , pattern .)
    )               reduce using rule 120 (_19_item -> , pattern .)


state 206

    (99) or_else -> ELIF expr THEN . block_statement _16_optional
    (43) block_statement -> . _4_repeat
    (44) _4_repeat -> . _4_items
    (45) _4_repeat -> .
    (46) _4_items -> . _4_items _4_item
    (47) _4_items -> . _4_item
    (48) _4_item -> . expr
    (9) expr -> . ( expr )
    (10) expr -> . - expr
    (11) expr -> . array
    (12) expr -> . variant_call
    (13) expr -> . identifier
    (14) expr -> . variable_declaration
    (15) expr -> . call
    (16) expr -> . case_of
    (17) expr -> . binary_expr
    (18) expr -> . if_expr
    (19) expr -> . def_expr
    (20) expr -> . literal
    (21) expr -> . do
    (22) expr -> . external
    (121) array -> . [ _20_optional _21_repeat ]
    (137) variant_call -> . type_identifier
    (138) variant_call -> . type_identifier ( _24_optional _25_repeat )
    (146) identifier -> . IDENTIFIER
    (148) variable_declaration -> . LET identifier _26_optional = expr
    (129) call -> . expr ( _22_optional _23_repeat )
    (103) case_of -> . CASE expr OF _17_repeat END
    (24) binary_expr -> . expr INT_DIV expr
    (25) binary_expr -> . expr NOT_MORE expr
    (26) binary_expr -> . expr NUM_NOT_EQUAL expr
    (27) binary_expr -> . expr > expr
    (28) binary_expr -> . expr % expr
    (29) binary_expr -> . expr < expr
    (30) binary_expr -> . expr * expr
    (31) binary_expr -> . expr / expr
    (32) binary_expr -> . expr - expr
    (33) binary_expr -> . expr + expr
    (34) binary_expr -> . expr CONCAT expr
    (94) if_expr -> . IF expr THEN _14_optional block_statement _15_optional END
    (49) def_expr -> . DEF identifier ( _5_optional _6_repeat ) _7_optional do
    (151) literal -> . STRING
    (152) literal -> . NUMBER
    (35) do -> . DO _2_optional _3_repeat END
    (23) external -> . EXTERNAL
    (147) type_identifier -> . TYPE_IDENTIFIER
    ELIF            reduce using rule 45 (_4_repeat -> .)
    ELSE            reduce using rule 45 (_4_repeat -> .)
    END             reduce using rule 45 (_4_repeat -> .)
    (               shift and go to state 10
    -               shift and go to state 11
    [               shift and go to state 24
    IDENTIFIER      shift and go to state 25
    LET             shift and go to state 26
    CASE            shift and go to state 27
    IF              shift and go to state 28
    DEF             shift and go to state 29
    STRING          shift and go to state 30
    NUMBER          shift and go to state 31
    DO              shift and go to state 32
    EXTERNAL        shift and go to state 33
    TYPE_IDENTIFIER shift and go to state 34

    expr                           shift and go to state 147
    block_statement                shift and go to state 211
    _4_repeat                      shift and go to state 149
    _4_items                       shift and go to state 150
    _4_item                        shift and go to state 151
    array                          shift and go to state 12
    variant_call                   shift and go to state 13
    identifier                     shift and go to state 14
    variable_declaration           shift and go to state 15
    call                           shift and go to state 16
    case_of                        shift and go to state 17
    binary_expr                    shift and go to state 18
    if_expr                        shift and go to state 19
    def_expr                       shift and go to state 20
    literal                        shift and go to state 21
    do                             shift and go to state 22
    external                       shift and go to state 23
    type_identifier                shift and go to state 9

state 207

    (49) def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .
    (               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    INT_DIV         reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    NOT_MORE        reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    NUM_NOT_EQUAL   reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    >               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    %               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    <               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    *               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    /               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    -               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    +               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    CONCAT          reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ENUM            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    [               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    IDENTIFIER      reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    LET             reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    CASE            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    IF              reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    DEF             reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    STRING          reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    NUMBER          reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    DO              reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    EXTERNAL        reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    TYPE_IDENTIFIER reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    $end            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    )               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ,               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ]               reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    OF              reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    THEN            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    END             reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ELIF            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)
    ELSE            reduce using rule 49 (def_expr -> DEF identifier ( _5_optional _6_repeat ) _7_optional do .)


state 208

    (57) _7_optional -> : type .
    DO              reduce using rule 57 (_7_optional -> : type .)


state 209

    (73) enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .
    ENUM            reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    (               reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    -               reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    [               reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    IDENTIFIER      reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    LET             reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    CASE            reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    IF              reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    DEF             reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    STRING          reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    NUMBER          reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    DO              reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    EXTERNAL        reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    TYPE_IDENTIFIER reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)
    $end            reduce using rule 73 (enum -> ENUM type_identifier < type_identifier _10_repeat > { _11_repeat } .)


state 210

    (81) _11_items -> _11_items _11_item .
    TYPE_IDENTIFIER reduce using rule 81 (_11_items -> _11_items _11_item .)
    }               reduce using rule 81 (_11_items -> _11_items _11_item .)


state 211

    (99) or_else -> ELIF expr THEN block_statement . _16_optional
    (100) _16_optional -> . or_else
    (101) _16_optional -> .
    (99) or_else -> . ELIF expr THEN block_statement _16_optional
    (102) or_else -> . ELSE block_statement
    END             reduce using rule 101 (_16_optional -> .)
    ELIF            shift and go to state 168
    ELSE            shift and go to state 169

    _16_optional                   shift and go to state 212
    or_else                        shift and go to state 213

state 212

    (99) or_else -> ELIF expr THEN block_statement _16_optional .
    END             reduce using rule 99 (or_else -> ELIF expr THEN block_statement _16_optional .)


state 213

    (100) _16_optional -> or_else .
    END             reduce using rule 100 (_16_optional -> or_else .)


Conflicts:

shift/reduce conflict for ( in state 7 resolved as shift
shift/reduce conflict for - in state 7 resolved as shift
shift/reduce conflict for ( in state 9 resolved as shift
shift/reduce conflict for ( in state 90 resolved as shift
shift/reduce conflict for - in state 90 resolved as shift
shift/reduce conflict for ( in state 147 resolved as shift
shift/reduce conflict for - in state 147 resolved as shift