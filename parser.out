Grammar:

Rule 0     S' -> program
Rule 1     program -> _1_repeat
Rule 2     _1_repeat -> _1_items
Rule 3     _1_repeat -> <empty>
Rule 4     _1_items -> _1_items _1_item
Rule 5     _1_items -> _1_item
Rule 6     _1_item -> _program
Rule 7     _program -> enum
Rule 8     _program -> struct
Rule 9     _program -> expr
Rule 10    expr -> ( expr )
Rule 11    expr -> - expr  [precedence=right, level=4]
Rule 12    expr -> tuple
Rule 13    expr -> array
Rule 14    expr -> binary_expr
Rule 15    expr -> variable_declaration
Rule 16    expr -> case_of
Rule 17    expr -> call
Rule 18    expr -> _if
Rule 19    expr -> _def
Rule 20    expr -> literal
Rule 21    expr -> identifier
Rule 22    expr -> do
Rule 23    binary_expr -> expr INT_DIV expr  [precedence=left, level=3]
Rule 24    binary_expr -> expr * expr  [precedence=left, level=3]
Rule 25    binary_expr -> expr / expr  [precedence=left, level=3]
Rule 26    binary_expr -> expr - expr  [precedence=left, level=2]
Rule 27    binary_expr -> expr + expr  [precedence=left, level=2]
Rule 28    binary_expr -> expr CONCAT expr  [precedence=left, level=1]
Rule 29    do -> DO _2_optional _3_repeat END
Rule 30    _2_optional -> type
Rule 31    _2_optional -> <empty>
Rule 32    _3_repeat -> _3_items
Rule 33    _3_repeat -> <empty>
Rule 34    _3_items -> _3_items _3_item
Rule 35    _3_items -> _3_item
Rule 36    _3_item -> expr
Rule 37    _def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do
Rule 38    _4_optional -> param
Rule 39    _4_optional -> <empty>
Rule 40    _5_repeat -> _5_items
Rule 41    _5_repeat -> <empty>
Rule 42    _5_items -> _5_items _5_item
Rule 43    _5_items -> _5_item
Rule 44    _5_item -> , param
Rule 45    _6_optional -> type
Rule 46    _6_optional -> <empty>
Rule 47    type -> : type_identifier _7_optional
Rule 48    _7_optional -> < identifier _8_repeat >
Rule 49    _8_repeat -> _8_items
Rule 50    _8_repeat -> <empty>
Rule 51    _8_items -> _8_items _8_item
Rule 52    _8_items -> _8_item
Rule 53    _8_item -> , identifier
Rule 54    _7_optional -> <empty>
Rule 55    struct -> STRUCT type_identifier _9_optional { _11_repeat }
Rule 56    _9_optional -> < identifier _10_repeat >
Rule 57    _10_repeat -> _10_items
Rule 58    _10_repeat -> <empty>
Rule 59    _10_items -> _10_items _10_item
Rule 60    _10_items -> _10_item
Rule 61    _10_item -> , identifier
Rule 62    _9_optional -> <empty>
Rule 63    _11_repeat -> _11_items
Rule 64    _11_repeat -> <empty>
Rule 65    _11_items -> _11_items _11_item
Rule 66    _11_items -> _11_item
Rule 67    _11_item -> identifier type
Rule 68    enum -> ENUM type_identifier _12_optional { _14_repeat }
Rule 69    _12_optional -> < identifier _13_repeat >
Rule 70    _13_repeat -> _13_items
Rule 71    _13_repeat -> <empty>
Rule 72    _13_items -> _13_items _13_item
Rule 73    _13_items -> _13_item
Rule 74    _13_item -> , identifier
Rule 75    _12_optional -> <empty>
Rule 76    _14_repeat -> _14_items
Rule 77    _14_repeat -> <empty>
Rule 78    _14_items -> _14_items _14_item
Rule 79    _14_items -> _14_item
Rule 80    _14_item -> enum_key
Rule 81    enum_key -> identifier _15_optional
Rule 82    _15_optional -> ( identifier _16_repeat )
Rule 83    _16_repeat -> _16_items
Rule 84    _16_repeat -> <empty>
Rule 85    _16_items -> _16_items _16_item
Rule 86    _16_items -> _16_item
Rule 87    _16_item -> , identifier
Rule 88    _15_optional -> <empty>
Rule 89    param -> identifier _17_optional
Rule 90    _17_optional -> type
Rule 91    _17_optional -> <empty>
Rule 92    _if -> IF expr DO _18_repeat _19_repeat _20_optional END
Rule 93    _18_repeat -> _18_items
Rule 94    _18_repeat -> <empty>
Rule 95    _18_items -> _18_items _18_item
Rule 96    _18_items -> _18_item
Rule 97    _18_item -> expr
Rule 98    _19_repeat -> _19_items
Rule 99    _19_repeat -> <empty>
Rule 100   _19_items -> _19_items _19_item
Rule 101   _19_items -> _19_item
Rule 102   _19_item -> _elif
Rule 103   _20_optional -> ELSE _21_repeat
Rule 104   _21_repeat -> _21_items
Rule 105   _21_repeat -> <empty>
Rule 106   _21_items -> _21_items _21_item
Rule 107   _21_items -> _21_item
Rule 108   _21_item -> expr
Rule 109   _20_optional -> <empty>
Rule 110   _elif -> ELIF expr DO _22_repeat
Rule 111   _22_repeat -> _22_items
Rule 112   _22_repeat -> <empty>
Rule 113   _22_items -> _22_items _22_item
Rule 114   _22_items -> _22_item
Rule 115   _22_item -> expr
Rule 116   case_of -> CASE expr OF case _23_repeat END
Rule 117   _23_repeat -> _23_items
Rule 118   _23_repeat -> <empty>
Rule 119   _23_items -> _23_items _23_item
Rule 120   _23_items -> _23_item
Rule 121   _23_item -> case
Rule 122   case -> pattern _24_repeat do
Rule 123   _24_repeat -> _24_items
Rule 124   _24_repeat -> <empty>
Rule 125   _24_items -> _24_items _24_item
Rule 126   _24_items -> _24_item
Rule 127   _24_item -> , pattern
Rule 128   pattern -> array_pattern
Rule 129   pattern -> tuple_pattern
Rule 130   pattern -> enum_pattern
Rule 131   array_pattern -> [ _25_repeat _26_optional ]
Rule 132   _25_repeat -> _25_items
Rule 133   _25_repeat -> <empty>
Rule 134   _25_items -> _25_items _25_item
Rule 135   _25_items -> _25_item
Rule 136   _25_item -> pattern ,
Rule 137   _26_optional -> SPREAD identifier _27_repeat
Rule 138   _27_repeat -> _27_items
Rule 139   _27_repeat -> <empty>
Rule 140   _27_items -> _27_items _27_item
Rule 141   _27_items -> _27_item
Rule 142   _27_item -> , pattern
Rule 143   _26_optional -> <empty>
Rule 144   enum_pattern -> type_identifier _28_optional
Rule 145   _28_optional -> ( pattern _29_repeat )
Rule 146   _29_repeat -> _29_items
Rule 147   _29_repeat -> <empty>
Rule 148   _29_items -> _29_items _29_item
Rule 149   _29_items -> _29_item
Rule 150   _29_item -> , pattern
Rule 151   _28_optional -> <empty>
Rule 152   tuple_pattern -> { _30_repeat _31_optional }
Rule 153   _30_repeat -> _30_items
Rule 154   _30_repeat -> <empty>
Rule 155   _30_items -> _30_items _30_item
Rule 156   _30_items -> _30_item
Rule 157   _30_item -> pattern ,
Rule 158   _31_optional -> SPREAD identifier _32_repeat
Rule 159   _32_repeat -> _32_items
Rule 160   _32_repeat -> <empty>
Rule 161   _32_items -> _32_items _32_item
Rule 162   _32_items -> _32_item
Rule 163   _32_item -> , pattern
Rule 164   _31_optional -> <empty>
Rule 165   array -> [ _33_optional _34_repeat ]
Rule 166   _33_optional -> expr
Rule 167   _33_optional -> <empty>
Rule 168   _34_repeat -> _34_items
Rule 169   _34_repeat -> <empty>
Rule 170   _34_items -> _34_items _34_item
Rule 171   _34_items -> _34_item
Rule 172   _34_item -> , expr
Rule 173   tuple -> { _35_optional _36_repeat }
Rule 174   _35_optional -> expr
Rule 175   _35_optional -> <empty>
Rule 176   _36_repeat -> _36_items
Rule 177   _36_repeat -> <empty>
Rule 178   _36_items -> _36_items _36_item
Rule 179   _36_items -> _36_item
Rule 180   _36_item -> , expr
Rule 181   call -> callee ( _37_optional _38_repeat )
Rule 182   _37_optional -> expr
Rule 183   _37_optional -> <empty>
Rule 184   _38_repeat -> _38_items
Rule 185   _38_repeat -> <empty>
Rule 186   _38_items -> _38_items _38_item
Rule 187   _38_items -> _38_item
Rule 188   _38_item -> , expr
Rule 189   callee -> identifier
Rule 190   identifier -> IDENTIFIER
Rule 191   type_identifier -> TYPE_IDENTIFIER
Rule 192   variable_declaration -> identifier _39_optional = expr
Rule 193   _39_optional -> type
Rule 194   _39_optional -> <empty>
Rule 195   literal -> NUMBER
Rule 196   literal -> STRING

Terminals, with rules where they appear:

(                    : 10 37 82 145 181
)                    : 10 37 82 145 181
*                    : 24
+                    : 27
,                    : 44 53 61 74 87 127 136 142 150 157 163 172 180 188
-                    : 11 26
/                    : 25
:                    : 47
<                    : 48 56 69
=                    : 192
>                    : 48 56 69
CASE                 : 116
CONCAT               : 28
DEF                  : 37
DO                   : 29 92 110
ELIF                 : 110
ELSE                 : 103
END                  : 29 92 116
ENUM                 : 68
IDENTIFIER           : 190
IF                   : 92
INT_DIV              : 23
NUMBER               : 195
OF                   : 116
SPREAD               : 137 158
STRING               : 196
STRUCT               : 55
TYPE_IDENTIFIER      : 191
[                    : 131 165
]                    : 131 165
error                : 
{                    : 55 68 152 173
}                    : 55 68 152 173

Nonterminals, with rules where they appear:

_10_item             : 59 60
_10_items            : 57 59
_10_repeat           : 56
_11_item             : 65 66
_11_items            : 63 65
_11_repeat           : 55
_12_optional         : 68
_13_item             : 72 73
_13_items            : 70 72
_13_repeat           : 69
_14_item             : 78 79
_14_items            : 76 78
_14_repeat           : 68
_15_optional         : 81
_16_item             : 85 86
_16_items            : 83 85
_16_repeat           : 82
_17_optional         : 89
_18_item             : 95 96
_18_items            : 93 95
_18_repeat           : 92
_19_item             : 100 101
_19_items            : 98 100
_19_repeat           : 92
_1_item              : 4 5
_1_items             : 2 4
_1_repeat            : 1
_20_optional         : 92
_21_item             : 106 107
_21_items            : 104 106
_21_repeat           : 103
_22_item             : 113 114
_22_items            : 111 113
_22_repeat           : 110
_23_item             : 119 120
_23_items            : 117 119
_23_repeat           : 116
_24_item             : 125 126
_24_items            : 123 125
_24_repeat           : 122
_25_item             : 134 135
_25_items            : 132 134
_25_repeat           : 131
_26_optional         : 131
_27_item             : 140 141
_27_items            : 138 140
_27_repeat           : 137
_28_optional         : 144
_29_item             : 148 149
_29_items            : 146 148
_29_repeat           : 145
_2_optional          : 29
_30_item             : 155 156
_30_items            : 153 155
_30_repeat           : 152
_31_optional         : 152
_32_item             : 161 162
_32_items            : 159 161
_32_repeat           : 158
_33_optional         : 165
_34_item             : 170 171
_34_items            : 168 170
_34_repeat           : 165
_35_optional         : 173
_36_item             : 178 179
_36_items            : 176 178
_36_repeat           : 173
_37_optional         : 181
_38_item             : 186 187
_38_items            : 184 186
_38_repeat           : 181
_39_optional         : 192
_3_item              : 34 35
_3_items             : 32 34
_3_repeat            : 29
_4_optional          : 37
_5_item              : 42 43
_5_items             : 40 42
_5_repeat            : 37
_6_optional          : 37
_7_optional          : 47
_8_item              : 51 52
_8_items             : 49 51
_8_repeat            : 48
_9_optional          : 55
_def                 : 19
_elif                : 102
_if                  : 18
_program             : 6
array                : 13
array_pattern        : 128
binary_expr          : 14
call                 : 17
callee               : 181
case                 : 116 121
case_of              : 16
do                   : 22 37 122
enum                 : 7
enum_key             : 80
enum_pattern         : 130
expr                 : 9 10 11 23 23 24 24 25 25 26 26 27 27 28 28 36 92 97 108 110 115 116 166 172 174 180 182 188 192
identifier           : 21 37 48 53 56 61 67 69 74 81 82 87 89 137 158 189 192
literal              : 20
param                : 38 44
pattern              : 122 127 136 142 145 150 157 163
program              : 0
struct               : 8
tuple                : 12
tuple_pattern        : 129
type                 : 30 45 67 90 193
type_identifier      : 47 55 68 144
variable_declaration : 15


state 0

    (0) S' -> . program
    (1) program -> . _1_repeat
    (2) _1_repeat -> . _1_items
    (3) _1_repeat -> .
    (4) _1_items -> . _1_items _1_item
    (5) _1_items -> . _1_item
    (6) _1_item -> . _program
    (7) _program -> . enum
    (8) _program -> . struct
    (9) _program -> . expr
    (68) enum -> . ENUM type_identifier _12_optional { _14_repeat }
    (55) struct -> . STRUCT type_identifier _9_optional { _11_repeat }
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    $end            reduce using rule 3 (_1_repeat -> .)
    ENUM            shift and go to state 9
    STRUCT          shift and go to state 11
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    program                        shift and go to state 1
    _1_repeat                      shift and go to state 2
    _1_items                       shift and go to state 3
    _1_item                        shift and go to state 4
    _program                       shift and go to state 5
    enum                           shift and go to state 6
    struct                         shift and go to state 7
    expr                           shift and go to state 8
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 1

    (0) S' -> program .


state 2

    (1) program -> _1_repeat .
    $end            reduce using rule 1 (program -> _1_repeat .)


state 3

    (2) _1_repeat -> _1_items .
    (4) _1_items -> _1_items . _1_item
    (6) _1_item -> . _program
    (7) _program -> . enum
    (8) _program -> . struct
    (9) _program -> . expr
    (68) enum -> . ENUM type_identifier _12_optional { _14_repeat }
    (55) struct -> . STRUCT type_identifier _9_optional { _11_repeat }
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    $end            reduce using rule 2 (_1_repeat -> _1_items .)
    ENUM            shift and go to state 9
    STRUCT          shift and go to state 11
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _1_item                        shift and go to state 34
    _program                       shift and go to state 5
    enum                           shift and go to state 6
    struct                         shift and go to state 7
    expr                           shift and go to state 8
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 4

    (5) _1_items -> _1_item .
    ENUM            reduce using rule 5 (_1_items -> _1_item .)
    STRUCT          reduce using rule 5 (_1_items -> _1_item .)
    (               reduce using rule 5 (_1_items -> _1_item .)
    -               reduce using rule 5 (_1_items -> _1_item .)
    {               reduce using rule 5 (_1_items -> _1_item .)
    [               reduce using rule 5 (_1_items -> _1_item .)
    CASE            reduce using rule 5 (_1_items -> _1_item .)
    IF              reduce using rule 5 (_1_items -> _1_item .)
    DEF             reduce using rule 5 (_1_items -> _1_item .)
    NUMBER          reduce using rule 5 (_1_items -> _1_item .)
    STRING          reduce using rule 5 (_1_items -> _1_item .)
    IDENTIFIER      reduce using rule 5 (_1_items -> _1_item .)
    DO              reduce using rule 5 (_1_items -> _1_item .)
    $end            reduce using rule 5 (_1_items -> _1_item .)


state 5

    (6) _1_item -> _program .
    ENUM            reduce using rule 6 (_1_item -> _program .)
    STRUCT          reduce using rule 6 (_1_item -> _program .)
    (               reduce using rule 6 (_1_item -> _program .)
    -               reduce using rule 6 (_1_item -> _program .)
    {               reduce using rule 6 (_1_item -> _program .)
    [               reduce using rule 6 (_1_item -> _program .)
    CASE            reduce using rule 6 (_1_item -> _program .)
    IF              reduce using rule 6 (_1_item -> _program .)
    DEF             reduce using rule 6 (_1_item -> _program .)
    NUMBER          reduce using rule 6 (_1_item -> _program .)
    STRING          reduce using rule 6 (_1_item -> _program .)
    IDENTIFIER      reduce using rule 6 (_1_item -> _program .)
    DO              reduce using rule 6 (_1_item -> _program .)
    $end            reduce using rule 6 (_1_item -> _program .)


state 6

    (7) _program -> enum .
    ENUM            reduce using rule 7 (_program -> enum .)
    STRUCT          reduce using rule 7 (_program -> enum .)
    (               reduce using rule 7 (_program -> enum .)
    -               reduce using rule 7 (_program -> enum .)
    {               reduce using rule 7 (_program -> enum .)
    [               reduce using rule 7 (_program -> enum .)
    CASE            reduce using rule 7 (_program -> enum .)
    IF              reduce using rule 7 (_program -> enum .)
    DEF             reduce using rule 7 (_program -> enum .)
    NUMBER          reduce using rule 7 (_program -> enum .)
    STRING          reduce using rule 7 (_program -> enum .)
    IDENTIFIER      reduce using rule 7 (_program -> enum .)
    DO              reduce using rule 7 (_program -> enum .)
    $end            reduce using rule 7 (_program -> enum .)


state 7

    (8) _program -> struct .
    ENUM            reduce using rule 8 (_program -> struct .)
    STRUCT          reduce using rule 8 (_program -> struct .)
    (               reduce using rule 8 (_program -> struct .)
    -               reduce using rule 8 (_program -> struct .)
    {               reduce using rule 8 (_program -> struct .)
    [               reduce using rule 8 (_program -> struct .)
    CASE            reduce using rule 8 (_program -> struct .)
    IF              reduce using rule 8 (_program -> struct .)
    DEF             reduce using rule 8 (_program -> struct .)
    NUMBER          reduce using rule 8 (_program -> struct .)
    STRING          reduce using rule 8 (_program -> struct .)
    IDENTIFIER      reduce using rule 8 (_program -> struct .)
    DO              reduce using rule 8 (_program -> struct .)
    $end            reduce using rule 8 (_program -> struct .)


state 8

    (9) _program -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for - resolved as shift
    ENUM            reduce using rule 9 (_program -> expr .)
    STRUCT          reduce using rule 9 (_program -> expr .)
    (               reduce using rule 9 (_program -> expr .)
    {               reduce using rule 9 (_program -> expr .)
    [               reduce using rule 9 (_program -> expr .)
    CASE            reduce using rule 9 (_program -> expr .)
    IF              reduce using rule 9 (_program -> expr .)
    DEF             reduce using rule 9 (_program -> expr .)
    NUMBER          reduce using rule 9 (_program -> expr .)
    STRING          reduce using rule 9 (_program -> expr .)
    IDENTIFIER      reduce using rule 9 (_program -> expr .)
    DO              reduce using rule 9 (_program -> expr .)
    $end            reduce using rule 9 (_program -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 9

    (68) enum -> ENUM . type_identifier _12_optional { _14_repeat }
    (191) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 42

    type_identifier                shift and go to state 41

state 10

    (173) tuple -> { . _35_optional _36_repeat }
    (174) _35_optional -> . expr
    (175) _35_optional -> .
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    ,               reduce using rule 175 (_35_optional -> .)
    }               reduce using rule 175 (_35_optional -> .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _35_optional                   shift and go to state 43
    expr                           shift and go to state 44
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 11

    (55) struct -> STRUCT . type_identifier _9_optional { _11_repeat }
    (191) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 42

    type_identifier                shift and go to state 45

state 12

    (10) expr -> ( . expr )
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 46
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 13

    (11) expr -> - . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 47
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 14

    (12) expr -> tuple .
    INT_DIV         reduce using rule 12 (expr -> tuple .)
    *               reduce using rule 12 (expr -> tuple .)
    /               reduce using rule 12 (expr -> tuple .)
    -               reduce using rule 12 (expr -> tuple .)
    +               reduce using rule 12 (expr -> tuple .)
    CONCAT          reduce using rule 12 (expr -> tuple .)
    ENUM            reduce using rule 12 (expr -> tuple .)
    STRUCT          reduce using rule 12 (expr -> tuple .)
    (               reduce using rule 12 (expr -> tuple .)
    {               reduce using rule 12 (expr -> tuple .)
    [               reduce using rule 12 (expr -> tuple .)
    CASE            reduce using rule 12 (expr -> tuple .)
    IF              reduce using rule 12 (expr -> tuple .)
    DEF             reduce using rule 12 (expr -> tuple .)
    NUMBER          reduce using rule 12 (expr -> tuple .)
    STRING          reduce using rule 12 (expr -> tuple .)
    IDENTIFIER      reduce using rule 12 (expr -> tuple .)
    DO              reduce using rule 12 (expr -> tuple .)
    $end            reduce using rule 12 (expr -> tuple .)
    ,               reduce using rule 12 (expr -> tuple .)
    }               reduce using rule 12 (expr -> tuple .)
    )               reduce using rule 12 (expr -> tuple .)
    ]               reduce using rule 12 (expr -> tuple .)
    OF              reduce using rule 12 (expr -> tuple .)
    END             reduce using rule 12 (expr -> tuple .)
    ELIF            reduce using rule 12 (expr -> tuple .)
    ELSE            reduce using rule 12 (expr -> tuple .)


state 15

    (13) expr -> array .
    INT_DIV         reduce using rule 13 (expr -> array .)
    *               reduce using rule 13 (expr -> array .)
    /               reduce using rule 13 (expr -> array .)
    -               reduce using rule 13 (expr -> array .)
    +               reduce using rule 13 (expr -> array .)
    CONCAT          reduce using rule 13 (expr -> array .)
    ENUM            reduce using rule 13 (expr -> array .)
    STRUCT          reduce using rule 13 (expr -> array .)
    (               reduce using rule 13 (expr -> array .)
    {               reduce using rule 13 (expr -> array .)
    [               reduce using rule 13 (expr -> array .)
    CASE            reduce using rule 13 (expr -> array .)
    IF              reduce using rule 13 (expr -> array .)
    DEF             reduce using rule 13 (expr -> array .)
    NUMBER          reduce using rule 13 (expr -> array .)
    STRING          reduce using rule 13 (expr -> array .)
    IDENTIFIER      reduce using rule 13 (expr -> array .)
    DO              reduce using rule 13 (expr -> array .)
    $end            reduce using rule 13 (expr -> array .)
    ,               reduce using rule 13 (expr -> array .)
    }               reduce using rule 13 (expr -> array .)
    )               reduce using rule 13 (expr -> array .)
    ]               reduce using rule 13 (expr -> array .)
    OF              reduce using rule 13 (expr -> array .)
    END             reduce using rule 13 (expr -> array .)
    ELIF            reduce using rule 13 (expr -> array .)
    ELSE            reduce using rule 13 (expr -> array .)


state 16

    (14) expr -> binary_expr .
    INT_DIV         reduce using rule 14 (expr -> binary_expr .)
    *               reduce using rule 14 (expr -> binary_expr .)
    /               reduce using rule 14 (expr -> binary_expr .)
    -               reduce using rule 14 (expr -> binary_expr .)
    +               reduce using rule 14 (expr -> binary_expr .)
    CONCAT          reduce using rule 14 (expr -> binary_expr .)
    ENUM            reduce using rule 14 (expr -> binary_expr .)
    STRUCT          reduce using rule 14 (expr -> binary_expr .)
    (               reduce using rule 14 (expr -> binary_expr .)
    {               reduce using rule 14 (expr -> binary_expr .)
    [               reduce using rule 14 (expr -> binary_expr .)
    CASE            reduce using rule 14 (expr -> binary_expr .)
    IF              reduce using rule 14 (expr -> binary_expr .)
    DEF             reduce using rule 14 (expr -> binary_expr .)
    NUMBER          reduce using rule 14 (expr -> binary_expr .)
    STRING          reduce using rule 14 (expr -> binary_expr .)
    IDENTIFIER      reduce using rule 14 (expr -> binary_expr .)
    DO              reduce using rule 14 (expr -> binary_expr .)
    $end            reduce using rule 14 (expr -> binary_expr .)
    ,               reduce using rule 14 (expr -> binary_expr .)
    }               reduce using rule 14 (expr -> binary_expr .)
    )               reduce using rule 14 (expr -> binary_expr .)
    ]               reduce using rule 14 (expr -> binary_expr .)
    OF              reduce using rule 14 (expr -> binary_expr .)
    END             reduce using rule 14 (expr -> binary_expr .)
    ELIF            reduce using rule 14 (expr -> binary_expr .)
    ELSE            reduce using rule 14 (expr -> binary_expr .)


state 17

    (15) expr -> variable_declaration .
    INT_DIV         reduce using rule 15 (expr -> variable_declaration .)
    *               reduce using rule 15 (expr -> variable_declaration .)
    /               reduce using rule 15 (expr -> variable_declaration .)
    -               reduce using rule 15 (expr -> variable_declaration .)
    +               reduce using rule 15 (expr -> variable_declaration .)
    CONCAT          reduce using rule 15 (expr -> variable_declaration .)
    ENUM            reduce using rule 15 (expr -> variable_declaration .)
    STRUCT          reduce using rule 15 (expr -> variable_declaration .)
    (               reduce using rule 15 (expr -> variable_declaration .)
    {               reduce using rule 15 (expr -> variable_declaration .)
    [               reduce using rule 15 (expr -> variable_declaration .)
    CASE            reduce using rule 15 (expr -> variable_declaration .)
    IF              reduce using rule 15 (expr -> variable_declaration .)
    DEF             reduce using rule 15 (expr -> variable_declaration .)
    NUMBER          reduce using rule 15 (expr -> variable_declaration .)
    STRING          reduce using rule 15 (expr -> variable_declaration .)
    IDENTIFIER      reduce using rule 15 (expr -> variable_declaration .)
    DO              reduce using rule 15 (expr -> variable_declaration .)
    $end            reduce using rule 15 (expr -> variable_declaration .)
    ,               reduce using rule 15 (expr -> variable_declaration .)
    }               reduce using rule 15 (expr -> variable_declaration .)
    )               reduce using rule 15 (expr -> variable_declaration .)
    ]               reduce using rule 15 (expr -> variable_declaration .)
    OF              reduce using rule 15 (expr -> variable_declaration .)
    END             reduce using rule 15 (expr -> variable_declaration .)
    ELIF            reduce using rule 15 (expr -> variable_declaration .)
    ELSE            reduce using rule 15 (expr -> variable_declaration .)


state 18

    (16) expr -> case_of .
    INT_DIV         reduce using rule 16 (expr -> case_of .)
    *               reduce using rule 16 (expr -> case_of .)
    /               reduce using rule 16 (expr -> case_of .)
    -               reduce using rule 16 (expr -> case_of .)
    +               reduce using rule 16 (expr -> case_of .)
    CONCAT          reduce using rule 16 (expr -> case_of .)
    ENUM            reduce using rule 16 (expr -> case_of .)
    STRUCT          reduce using rule 16 (expr -> case_of .)
    (               reduce using rule 16 (expr -> case_of .)
    {               reduce using rule 16 (expr -> case_of .)
    [               reduce using rule 16 (expr -> case_of .)
    CASE            reduce using rule 16 (expr -> case_of .)
    IF              reduce using rule 16 (expr -> case_of .)
    DEF             reduce using rule 16 (expr -> case_of .)
    NUMBER          reduce using rule 16 (expr -> case_of .)
    STRING          reduce using rule 16 (expr -> case_of .)
    IDENTIFIER      reduce using rule 16 (expr -> case_of .)
    DO              reduce using rule 16 (expr -> case_of .)
    $end            reduce using rule 16 (expr -> case_of .)
    ,               reduce using rule 16 (expr -> case_of .)
    }               reduce using rule 16 (expr -> case_of .)
    )               reduce using rule 16 (expr -> case_of .)
    ]               reduce using rule 16 (expr -> case_of .)
    OF              reduce using rule 16 (expr -> case_of .)
    END             reduce using rule 16 (expr -> case_of .)
    ELIF            reduce using rule 16 (expr -> case_of .)
    ELSE            reduce using rule 16 (expr -> case_of .)


state 19

    (17) expr -> call .
    INT_DIV         reduce using rule 17 (expr -> call .)
    *               reduce using rule 17 (expr -> call .)
    /               reduce using rule 17 (expr -> call .)
    -               reduce using rule 17 (expr -> call .)
    +               reduce using rule 17 (expr -> call .)
    CONCAT          reduce using rule 17 (expr -> call .)
    ENUM            reduce using rule 17 (expr -> call .)
    STRUCT          reduce using rule 17 (expr -> call .)
    (               reduce using rule 17 (expr -> call .)
    {               reduce using rule 17 (expr -> call .)
    [               reduce using rule 17 (expr -> call .)
    CASE            reduce using rule 17 (expr -> call .)
    IF              reduce using rule 17 (expr -> call .)
    DEF             reduce using rule 17 (expr -> call .)
    NUMBER          reduce using rule 17 (expr -> call .)
    STRING          reduce using rule 17 (expr -> call .)
    IDENTIFIER      reduce using rule 17 (expr -> call .)
    DO              reduce using rule 17 (expr -> call .)
    $end            reduce using rule 17 (expr -> call .)
    ,               reduce using rule 17 (expr -> call .)
    }               reduce using rule 17 (expr -> call .)
    )               reduce using rule 17 (expr -> call .)
    ]               reduce using rule 17 (expr -> call .)
    OF              reduce using rule 17 (expr -> call .)
    END             reduce using rule 17 (expr -> call .)
    ELIF            reduce using rule 17 (expr -> call .)
    ELSE            reduce using rule 17 (expr -> call .)


state 20

    (18) expr -> _if .
    INT_DIV         reduce using rule 18 (expr -> _if .)
    *               reduce using rule 18 (expr -> _if .)
    /               reduce using rule 18 (expr -> _if .)
    -               reduce using rule 18 (expr -> _if .)
    +               reduce using rule 18 (expr -> _if .)
    CONCAT          reduce using rule 18 (expr -> _if .)
    ENUM            reduce using rule 18 (expr -> _if .)
    STRUCT          reduce using rule 18 (expr -> _if .)
    (               reduce using rule 18 (expr -> _if .)
    {               reduce using rule 18 (expr -> _if .)
    [               reduce using rule 18 (expr -> _if .)
    CASE            reduce using rule 18 (expr -> _if .)
    IF              reduce using rule 18 (expr -> _if .)
    DEF             reduce using rule 18 (expr -> _if .)
    NUMBER          reduce using rule 18 (expr -> _if .)
    STRING          reduce using rule 18 (expr -> _if .)
    IDENTIFIER      reduce using rule 18 (expr -> _if .)
    DO              reduce using rule 18 (expr -> _if .)
    $end            reduce using rule 18 (expr -> _if .)
    ,               reduce using rule 18 (expr -> _if .)
    }               reduce using rule 18 (expr -> _if .)
    )               reduce using rule 18 (expr -> _if .)
    ]               reduce using rule 18 (expr -> _if .)
    OF              reduce using rule 18 (expr -> _if .)
    END             reduce using rule 18 (expr -> _if .)
    ELIF            reduce using rule 18 (expr -> _if .)
    ELSE            reduce using rule 18 (expr -> _if .)


state 21

    (19) expr -> _def .
    INT_DIV         reduce using rule 19 (expr -> _def .)
    *               reduce using rule 19 (expr -> _def .)
    /               reduce using rule 19 (expr -> _def .)
    -               reduce using rule 19 (expr -> _def .)
    +               reduce using rule 19 (expr -> _def .)
    CONCAT          reduce using rule 19 (expr -> _def .)
    ENUM            reduce using rule 19 (expr -> _def .)
    STRUCT          reduce using rule 19 (expr -> _def .)
    (               reduce using rule 19 (expr -> _def .)
    {               reduce using rule 19 (expr -> _def .)
    [               reduce using rule 19 (expr -> _def .)
    CASE            reduce using rule 19 (expr -> _def .)
    IF              reduce using rule 19 (expr -> _def .)
    DEF             reduce using rule 19 (expr -> _def .)
    NUMBER          reduce using rule 19 (expr -> _def .)
    STRING          reduce using rule 19 (expr -> _def .)
    IDENTIFIER      reduce using rule 19 (expr -> _def .)
    DO              reduce using rule 19 (expr -> _def .)
    $end            reduce using rule 19 (expr -> _def .)
    ,               reduce using rule 19 (expr -> _def .)
    }               reduce using rule 19 (expr -> _def .)
    )               reduce using rule 19 (expr -> _def .)
    ]               reduce using rule 19 (expr -> _def .)
    OF              reduce using rule 19 (expr -> _def .)
    END             reduce using rule 19 (expr -> _def .)
    ELIF            reduce using rule 19 (expr -> _def .)
    ELSE            reduce using rule 19 (expr -> _def .)


state 22

    (20) expr -> literal .
    INT_DIV         reduce using rule 20 (expr -> literal .)
    *               reduce using rule 20 (expr -> literal .)
    /               reduce using rule 20 (expr -> literal .)
    -               reduce using rule 20 (expr -> literal .)
    +               reduce using rule 20 (expr -> literal .)
    CONCAT          reduce using rule 20 (expr -> literal .)
    ENUM            reduce using rule 20 (expr -> literal .)
    STRUCT          reduce using rule 20 (expr -> literal .)
    (               reduce using rule 20 (expr -> literal .)
    {               reduce using rule 20 (expr -> literal .)
    [               reduce using rule 20 (expr -> literal .)
    CASE            reduce using rule 20 (expr -> literal .)
    IF              reduce using rule 20 (expr -> literal .)
    DEF             reduce using rule 20 (expr -> literal .)
    NUMBER          reduce using rule 20 (expr -> literal .)
    STRING          reduce using rule 20 (expr -> literal .)
    IDENTIFIER      reduce using rule 20 (expr -> literal .)
    DO              reduce using rule 20 (expr -> literal .)
    $end            reduce using rule 20 (expr -> literal .)
    ,               reduce using rule 20 (expr -> literal .)
    }               reduce using rule 20 (expr -> literal .)
    )               reduce using rule 20 (expr -> literal .)
    ]               reduce using rule 20 (expr -> literal .)
    OF              reduce using rule 20 (expr -> literal .)
    END             reduce using rule 20 (expr -> literal .)
    ELIF            reduce using rule 20 (expr -> literal .)
    ELSE            reduce using rule 20 (expr -> literal .)


state 23

    (21) expr -> identifier .
    (192) variable_declaration -> identifier . _39_optional = expr
    (189) callee -> identifier .
    (193) _39_optional -> . type
    (194) _39_optional -> .
    (47) type -> . : type_identifier _7_optional
  ! reduce/reduce conflict for ( resolved using rule 21 (expr -> identifier .)
    INT_DIV         reduce using rule 21 (expr -> identifier .)
    *               reduce using rule 21 (expr -> identifier .)
    /               reduce using rule 21 (expr -> identifier .)
    -               reduce using rule 21 (expr -> identifier .)
    +               reduce using rule 21 (expr -> identifier .)
    CONCAT          reduce using rule 21 (expr -> identifier .)
    ENUM            reduce using rule 21 (expr -> identifier .)
    STRUCT          reduce using rule 21 (expr -> identifier .)
    (               reduce using rule 21 (expr -> identifier .)
    {               reduce using rule 21 (expr -> identifier .)
    [               reduce using rule 21 (expr -> identifier .)
    CASE            reduce using rule 21 (expr -> identifier .)
    IF              reduce using rule 21 (expr -> identifier .)
    DEF             reduce using rule 21 (expr -> identifier .)
    NUMBER          reduce using rule 21 (expr -> identifier .)
    STRING          reduce using rule 21 (expr -> identifier .)
    IDENTIFIER      reduce using rule 21 (expr -> identifier .)
    DO              reduce using rule 21 (expr -> identifier .)
    $end            reduce using rule 21 (expr -> identifier .)
    ,               reduce using rule 21 (expr -> identifier .)
    }               reduce using rule 21 (expr -> identifier .)
    )               reduce using rule 21 (expr -> identifier .)
    ]               reduce using rule 21 (expr -> identifier .)
    OF              reduce using rule 21 (expr -> identifier .)
    END             reduce using rule 21 (expr -> identifier .)
    ELIF            reduce using rule 21 (expr -> identifier .)
    ELSE            reduce using rule 21 (expr -> identifier .)
    =               reduce using rule 194 (_39_optional -> .)
    :               shift and go to state 50

    _39_optional                   shift and go to state 48
    type                           shift and go to state 49

state 24

    (22) expr -> do .
    INT_DIV         reduce using rule 22 (expr -> do .)
    *               reduce using rule 22 (expr -> do .)
    /               reduce using rule 22 (expr -> do .)
    -               reduce using rule 22 (expr -> do .)
    +               reduce using rule 22 (expr -> do .)
    CONCAT          reduce using rule 22 (expr -> do .)
    ENUM            reduce using rule 22 (expr -> do .)
    STRUCT          reduce using rule 22 (expr -> do .)
    (               reduce using rule 22 (expr -> do .)
    {               reduce using rule 22 (expr -> do .)
    [               reduce using rule 22 (expr -> do .)
    CASE            reduce using rule 22 (expr -> do .)
    IF              reduce using rule 22 (expr -> do .)
    DEF             reduce using rule 22 (expr -> do .)
    NUMBER          reduce using rule 22 (expr -> do .)
    STRING          reduce using rule 22 (expr -> do .)
    IDENTIFIER      reduce using rule 22 (expr -> do .)
    DO              reduce using rule 22 (expr -> do .)
    $end            reduce using rule 22 (expr -> do .)
    ,               reduce using rule 22 (expr -> do .)
    }               reduce using rule 22 (expr -> do .)
    )               reduce using rule 22 (expr -> do .)
    ]               reduce using rule 22 (expr -> do .)
    OF              reduce using rule 22 (expr -> do .)
    END             reduce using rule 22 (expr -> do .)
    ELIF            reduce using rule 22 (expr -> do .)
    ELSE            reduce using rule 22 (expr -> do .)


state 25

    (165) array -> [ . _33_optional _34_repeat ]
    (166) _33_optional -> . expr
    (167) _33_optional -> .
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    ,               reduce using rule 167 (_33_optional -> .)
    ]               reduce using rule 167 (_33_optional -> .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _33_optional                   shift and go to state 51
    expr                           shift and go to state 52
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 26

    (116) case_of -> CASE . expr OF case _23_repeat END
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 53
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 27

    (181) call -> callee . ( _37_optional _38_repeat )
    (               shift and go to state 54


state 28

    (92) _if -> IF . expr DO _18_repeat _19_repeat _20_optional END
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 55
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 29

    (29) do -> DO . _2_optional _3_repeat END
    (30) _2_optional -> . type
    (31) _2_optional -> .
    (47) type -> . : type_identifier _7_optional
    (               reduce using rule 31 (_2_optional -> .)
    -               reduce using rule 31 (_2_optional -> .)
    {               reduce using rule 31 (_2_optional -> .)
    [               reduce using rule 31 (_2_optional -> .)
    CASE            reduce using rule 31 (_2_optional -> .)
    IF              reduce using rule 31 (_2_optional -> .)
    DEF             reduce using rule 31 (_2_optional -> .)
    NUMBER          reduce using rule 31 (_2_optional -> .)
    STRING          reduce using rule 31 (_2_optional -> .)
    IDENTIFIER      reduce using rule 31 (_2_optional -> .)
    DO              reduce using rule 31 (_2_optional -> .)
    END             reduce using rule 31 (_2_optional -> .)
    :               shift and go to state 50

    _2_optional                    shift and go to state 56
    type                           shift and go to state 57

state 30

    (37) _def -> DEF . identifier ( _4_optional _5_repeat ) _6_optional do
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 58

state 31

    (195) literal -> NUMBER .
    INT_DIV         reduce using rule 195 (literal -> NUMBER .)
    *               reduce using rule 195 (literal -> NUMBER .)
    /               reduce using rule 195 (literal -> NUMBER .)
    -               reduce using rule 195 (literal -> NUMBER .)
    +               reduce using rule 195 (literal -> NUMBER .)
    CONCAT          reduce using rule 195 (literal -> NUMBER .)
    ENUM            reduce using rule 195 (literal -> NUMBER .)
    STRUCT          reduce using rule 195 (literal -> NUMBER .)
    (               reduce using rule 195 (literal -> NUMBER .)
    {               reduce using rule 195 (literal -> NUMBER .)
    [               reduce using rule 195 (literal -> NUMBER .)
    CASE            reduce using rule 195 (literal -> NUMBER .)
    IF              reduce using rule 195 (literal -> NUMBER .)
    DEF             reduce using rule 195 (literal -> NUMBER .)
    NUMBER          reduce using rule 195 (literal -> NUMBER .)
    STRING          reduce using rule 195 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 195 (literal -> NUMBER .)
    DO              reduce using rule 195 (literal -> NUMBER .)
    $end            reduce using rule 195 (literal -> NUMBER .)
    ,               reduce using rule 195 (literal -> NUMBER .)
    }               reduce using rule 195 (literal -> NUMBER .)
    )               reduce using rule 195 (literal -> NUMBER .)
    ]               reduce using rule 195 (literal -> NUMBER .)
    OF              reduce using rule 195 (literal -> NUMBER .)
    END             reduce using rule 195 (literal -> NUMBER .)
    ELIF            reduce using rule 195 (literal -> NUMBER .)
    ELSE            reduce using rule 195 (literal -> NUMBER .)


state 32

    (196) literal -> STRING .
    INT_DIV         reduce using rule 196 (literal -> STRING .)
    *               reduce using rule 196 (literal -> STRING .)
    /               reduce using rule 196 (literal -> STRING .)
    -               reduce using rule 196 (literal -> STRING .)
    +               reduce using rule 196 (literal -> STRING .)
    CONCAT          reduce using rule 196 (literal -> STRING .)
    ENUM            reduce using rule 196 (literal -> STRING .)
    STRUCT          reduce using rule 196 (literal -> STRING .)
    (               reduce using rule 196 (literal -> STRING .)
    {               reduce using rule 196 (literal -> STRING .)
    [               reduce using rule 196 (literal -> STRING .)
    CASE            reduce using rule 196 (literal -> STRING .)
    IF              reduce using rule 196 (literal -> STRING .)
    DEF             reduce using rule 196 (literal -> STRING .)
    NUMBER          reduce using rule 196 (literal -> STRING .)
    STRING          reduce using rule 196 (literal -> STRING .)
    IDENTIFIER      reduce using rule 196 (literal -> STRING .)
    DO              reduce using rule 196 (literal -> STRING .)
    $end            reduce using rule 196 (literal -> STRING .)
    ,               reduce using rule 196 (literal -> STRING .)
    }               reduce using rule 196 (literal -> STRING .)
    )               reduce using rule 196 (literal -> STRING .)
    ]               reduce using rule 196 (literal -> STRING .)
    OF              reduce using rule 196 (literal -> STRING .)
    END             reduce using rule 196 (literal -> STRING .)
    ELIF            reduce using rule 196 (literal -> STRING .)
    ELSE            reduce using rule 196 (literal -> STRING .)


state 33

    (190) identifier -> IDENTIFIER .
    :               reduce using rule 190 (identifier -> IDENTIFIER .)
    =               reduce using rule 190 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 190 (identifier -> IDENTIFIER .)
    *               reduce using rule 190 (identifier -> IDENTIFIER .)
    /               reduce using rule 190 (identifier -> IDENTIFIER .)
    -               reduce using rule 190 (identifier -> IDENTIFIER .)
    +               reduce using rule 190 (identifier -> IDENTIFIER .)
    CONCAT          reduce using rule 190 (identifier -> IDENTIFIER .)
    ENUM            reduce using rule 190 (identifier -> IDENTIFIER .)
    STRUCT          reduce using rule 190 (identifier -> IDENTIFIER .)
    (               reduce using rule 190 (identifier -> IDENTIFIER .)
    {               reduce using rule 190 (identifier -> IDENTIFIER .)
    [               reduce using rule 190 (identifier -> IDENTIFIER .)
    CASE            reduce using rule 190 (identifier -> IDENTIFIER .)
    IF              reduce using rule 190 (identifier -> IDENTIFIER .)
    DEF             reduce using rule 190 (identifier -> IDENTIFIER .)
    NUMBER          reduce using rule 190 (identifier -> IDENTIFIER .)
    STRING          reduce using rule 190 (identifier -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 190 (identifier -> IDENTIFIER .)
    DO              reduce using rule 190 (identifier -> IDENTIFIER .)
    $end            reduce using rule 190 (identifier -> IDENTIFIER .)
    ,               reduce using rule 190 (identifier -> IDENTIFIER .)
    }               reduce using rule 190 (identifier -> IDENTIFIER .)
    )               reduce using rule 190 (identifier -> IDENTIFIER .)
    ]               reduce using rule 190 (identifier -> IDENTIFIER .)
    OF              reduce using rule 190 (identifier -> IDENTIFIER .)
    END             reduce using rule 190 (identifier -> IDENTIFIER .)
    ELIF            reduce using rule 190 (identifier -> IDENTIFIER .)
    ELSE            reduce using rule 190 (identifier -> IDENTIFIER .)
    >               reduce using rule 190 (identifier -> IDENTIFIER .)


state 34

    (4) _1_items -> _1_items _1_item .
    ENUM            reduce using rule 4 (_1_items -> _1_items _1_item .)
    STRUCT          reduce using rule 4 (_1_items -> _1_items _1_item .)
    (               reduce using rule 4 (_1_items -> _1_items _1_item .)
    -               reduce using rule 4 (_1_items -> _1_items _1_item .)
    {               reduce using rule 4 (_1_items -> _1_items _1_item .)
    [               reduce using rule 4 (_1_items -> _1_items _1_item .)
    CASE            reduce using rule 4 (_1_items -> _1_items _1_item .)
    IF              reduce using rule 4 (_1_items -> _1_items _1_item .)
    DEF             reduce using rule 4 (_1_items -> _1_items _1_item .)
    NUMBER          reduce using rule 4 (_1_items -> _1_items _1_item .)
    STRING          reduce using rule 4 (_1_items -> _1_items _1_item .)
    IDENTIFIER      reduce using rule 4 (_1_items -> _1_items _1_item .)
    DO              reduce using rule 4 (_1_items -> _1_items _1_item .)
    $end            reduce using rule 4 (_1_items -> _1_items _1_item .)


state 35

    (23) binary_expr -> expr INT_DIV . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 59
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 36

    (24) binary_expr -> expr * . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 60
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 37

    (25) binary_expr -> expr / . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 61
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 38

    (26) binary_expr -> expr - . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 62
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 39

    (27) binary_expr -> expr + . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 63
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 40

    (28) binary_expr -> expr CONCAT . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 64
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 41

    (68) enum -> ENUM type_identifier . _12_optional { _14_repeat }
    (69) _12_optional -> . < identifier _13_repeat >
    (75) _12_optional -> .
    <               shift and go to state 66
    {               reduce using rule 75 (_12_optional -> .)

    _12_optional                   shift and go to state 65

state 42

    (191) type_identifier -> TYPE_IDENTIFIER .
    <               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    {               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    =               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    (               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    -               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    [               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    CASE            reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    IF              reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    DEF             reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    NUMBER          reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    STRING          reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    IDENTIFIER      reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    DO              reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    END             reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    ,               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    )               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    }               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)
    ]               reduce using rule 191 (type_identifier -> TYPE_IDENTIFIER .)


state 43

    (173) tuple -> { _35_optional . _36_repeat }
    (176) _36_repeat -> . _36_items
    (177) _36_repeat -> .
    (178) _36_items -> . _36_items _36_item
    (179) _36_items -> . _36_item
    (180) _36_item -> . , expr
    }               reduce using rule 177 (_36_repeat -> .)
    ,               shift and go to state 70

    _36_repeat                     shift and go to state 67
    _36_items                      shift and go to state 68
    _36_item                       shift and go to state 69

state 44

    (174) _35_optional -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 174 (_35_optional -> expr .)
    }               reduce using rule 174 (_35_optional -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 45

    (55) struct -> STRUCT type_identifier . _9_optional { _11_repeat }
    (56) _9_optional -> . < identifier _10_repeat >
    (62) _9_optional -> .
    <               shift and go to state 72
    {               reduce using rule 62 (_9_optional -> .)

    _9_optional                    shift and go to state 71

state 46

    (10) expr -> ( expr . )
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    )               shift and go to state 73
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 47

    (11) expr -> - expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 11 (expr -> - expr .)
    *               reduce using rule 11 (expr -> - expr .)
    /               reduce using rule 11 (expr -> - expr .)
    -               reduce using rule 11 (expr -> - expr .)
    +               reduce using rule 11 (expr -> - expr .)
    CONCAT          reduce using rule 11 (expr -> - expr .)
    ENUM            reduce using rule 11 (expr -> - expr .)
    STRUCT          reduce using rule 11 (expr -> - expr .)
    (               reduce using rule 11 (expr -> - expr .)
    {               reduce using rule 11 (expr -> - expr .)
    [               reduce using rule 11 (expr -> - expr .)
    CASE            reduce using rule 11 (expr -> - expr .)
    IF              reduce using rule 11 (expr -> - expr .)
    DEF             reduce using rule 11 (expr -> - expr .)
    NUMBER          reduce using rule 11 (expr -> - expr .)
    STRING          reduce using rule 11 (expr -> - expr .)
    IDENTIFIER      reduce using rule 11 (expr -> - expr .)
    DO              reduce using rule 11 (expr -> - expr .)
    $end            reduce using rule 11 (expr -> - expr .)
    ,               reduce using rule 11 (expr -> - expr .)
    }               reduce using rule 11 (expr -> - expr .)
    )               reduce using rule 11 (expr -> - expr .)
    ]               reduce using rule 11 (expr -> - expr .)
    OF              reduce using rule 11 (expr -> - expr .)
    END             reduce using rule 11 (expr -> - expr .)
    ELIF            reduce using rule 11 (expr -> - expr .)
    ELSE            reduce using rule 11 (expr -> - expr .)


state 48

    (192) variable_declaration -> identifier _39_optional . = expr
    =               shift and go to state 74


state 49

    (193) _39_optional -> type .
    =               reduce using rule 193 (_39_optional -> type .)


state 50

    (47) type -> : . type_identifier _7_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    TYPE_IDENTIFIER shift and go to state 42

    type_identifier                shift and go to state 75

state 51

    (165) array -> [ _33_optional . _34_repeat ]
    (168) _34_repeat -> . _34_items
    (169) _34_repeat -> .
    (170) _34_items -> . _34_items _34_item
    (171) _34_items -> . _34_item
    (172) _34_item -> . , expr
    ]               reduce using rule 169 (_34_repeat -> .)
    ,               shift and go to state 79

    _34_repeat                     shift and go to state 76
    _34_items                      shift and go to state 77
    _34_item                       shift and go to state 78

state 52

    (166) _33_optional -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 166 (_33_optional -> expr .)
    ]               reduce using rule 166 (_33_optional -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 53

    (116) case_of -> CASE expr . OF case _23_repeat END
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    OF              shift and go to state 80
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 54

    (181) call -> callee ( . _37_optional _38_repeat )
    (182) _37_optional -> . expr
    (183) _37_optional -> .
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    ,               reduce using rule 183 (_37_optional -> .)
    )               reduce using rule 183 (_37_optional -> .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    callee                         shift and go to state 27
    _37_optional                   shift and go to state 81
    expr                           shift and go to state 82
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24

state 55

    (92) _if -> IF expr . DO _18_repeat _19_repeat _20_optional END
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    DO              shift and go to state 83
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 56

    (29) do -> DO _2_optional . _3_repeat END
    (32) _3_repeat -> . _3_items
    (33) _3_repeat -> .
    (34) _3_items -> . _3_items _3_item
    (35) _3_items -> . _3_item
    (36) _3_item -> . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    END             reduce using rule 33 (_3_repeat -> .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _3_repeat                      shift and go to state 84
    _3_items                       shift and go to state 85
    _3_item                        shift and go to state 86
    expr                           shift and go to state 87
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 57

    (30) _2_optional -> type .
    (               reduce using rule 30 (_2_optional -> type .)
    -               reduce using rule 30 (_2_optional -> type .)
    {               reduce using rule 30 (_2_optional -> type .)
    [               reduce using rule 30 (_2_optional -> type .)
    CASE            reduce using rule 30 (_2_optional -> type .)
    IF              reduce using rule 30 (_2_optional -> type .)
    DEF             reduce using rule 30 (_2_optional -> type .)
    NUMBER          reduce using rule 30 (_2_optional -> type .)
    STRING          reduce using rule 30 (_2_optional -> type .)
    IDENTIFIER      reduce using rule 30 (_2_optional -> type .)
    DO              reduce using rule 30 (_2_optional -> type .)
    END             reduce using rule 30 (_2_optional -> type .)


state 58

    (37) _def -> DEF identifier . ( _4_optional _5_repeat ) _6_optional do
    (               shift and go to state 88


state 59

    (23) binary_expr -> expr INT_DIV expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    *               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    /               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    -               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    +               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    CONCAT          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ENUM            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    STRUCT          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    (               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    {               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    [               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    CASE            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    IF              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    DEF             reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    NUMBER          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    STRING          reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    IDENTIFIER      reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    DO              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    $end            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ,               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    }               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    )               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ]               reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    OF              reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    END             reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ELIF            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)
    ELSE            reduce using rule 23 (binary_expr -> expr INT_DIV expr .)


state 60

    (24) binary_expr -> expr * expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 24 (binary_expr -> expr * expr .)
    *               reduce using rule 24 (binary_expr -> expr * expr .)
    /               reduce using rule 24 (binary_expr -> expr * expr .)
    -               reduce using rule 24 (binary_expr -> expr * expr .)
    +               reduce using rule 24 (binary_expr -> expr * expr .)
    CONCAT          reduce using rule 24 (binary_expr -> expr * expr .)
    ENUM            reduce using rule 24 (binary_expr -> expr * expr .)
    STRUCT          reduce using rule 24 (binary_expr -> expr * expr .)
    (               reduce using rule 24 (binary_expr -> expr * expr .)
    {               reduce using rule 24 (binary_expr -> expr * expr .)
    [               reduce using rule 24 (binary_expr -> expr * expr .)
    CASE            reduce using rule 24 (binary_expr -> expr * expr .)
    IF              reduce using rule 24 (binary_expr -> expr * expr .)
    DEF             reduce using rule 24 (binary_expr -> expr * expr .)
    NUMBER          reduce using rule 24 (binary_expr -> expr * expr .)
    STRING          reduce using rule 24 (binary_expr -> expr * expr .)
    IDENTIFIER      reduce using rule 24 (binary_expr -> expr * expr .)
    DO              reduce using rule 24 (binary_expr -> expr * expr .)
    $end            reduce using rule 24 (binary_expr -> expr * expr .)
    ,               reduce using rule 24 (binary_expr -> expr * expr .)
    }               reduce using rule 24 (binary_expr -> expr * expr .)
    )               reduce using rule 24 (binary_expr -> expr * expr .)
    ]               reduce using rule 24 (binary_expr -> expr * expr .)
    OF              reduce using rule 24 (binary_expr -> expr * expr .)
    END             reduce using rule 24 (binary_expr -> expr * expr .)
    ELIF            reduce using rule 24 (binary_expr -> expr * expr .)
    ELSE            reduce using rule 24 (binary_expr -> expr * expr .)


state 61

    (25) binary_expr -> expr / expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    INT_DIV         reduce using rule 25 (binary_expr -> expr / expr .)
    *               reduce using rule 25 (binary_expr -> expr / expr .)
    /               reduce using rule 25 (binary_expr -> expr / expr .)
    -               reduce using rule 25 (binary_expr -> expr / expr .)
    +               reduce using rule 25 (binary_expr -> expr / expr .)
    CONCAT          reduce using rule 25 (binary_expr -> expr / expr .)
    ENUM            reduce using rule 25 (binary_expr -> expr / expr .)
    STRUCT          reduce using rule 25 (binary_expr -> expr / expr .)
    (               reduce using rule 25 (binary_expr -> expr / expr .)
    {               reduce using rule 25 (binary_expr -> expr / expr .)
    [               reduce using rule 25 (binary_expr -> expr / expr .)
    CASE            reduce using rule 25 (binary_expr -> expr / expr .)
    IF              reduce using rule 25 (binary_expr -> expr / expr .)
    DEF             reduce using rule 25 (binary_expr -> expr / expr .)
    NUMBER          reduce using rule 25 (binary_expr -> expr / expr .)
    STRING          reduce using rule 25 (binary_expr -> expr / expr .)
    IDENTIFIER      reduce using rule 25 (binary_expr -> expr / expr .)
    DO              reduce using rule 25 (binary_expr -> expr / expr .)
    $end            reduce using rule 25 (binary_expr -> expr / expr .)
    ,               reduce using rule 25 (binary_expr -> expr / expr .)
    }               reduce using rule 25 (binary_expr -> expr / expr .)
    )               reduce using rule 25 (binary_expr -> expr / expr .)
    ]               reduce using rule 25 (binary_expr -> expr / expr .)
    OF              reduce using rule 25 (binary_expr -> expr / expr .)
    END             reduce using rule 25 (binary_expr -> expr / expr .)
    ELIF            reduce using rule 25 (binary_expr -> expr / expr .)
    ELSE            reduce using rule 25 (binary_expr -> expr / expr .)


state 62

    (26) binary_expr -> expr - expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    -               reduce using rule 26 (binary_expr -> expr - expr .)
    +               reduce using rule 26 (binary_expr -> expr - expr .)
    CONCAT          reduce using rule 26 (binary_expr -> expr - expr .)
    ENUM            reduce using rule 26 (binary_expr -> expr - expr .)
    STRUCT          reduce using rule 26 (binary_expr -> expr - expr .)
    (               reduce using rule 26 (binary_expr -> expr - expr .)
    {               reduce using rule 26 (binary_expr -> expr - expr .)
    [               reduce using rule 26 (binary_expr -> expr - expr .)
    CASE            reduce using rule 26 (binary_expr -> expr - expr .)
    IF              reduce using rule 26 (binary_expr -> expr - expr .)
    DEF             reduce using rule 26 (binary_expr -> expr - expr .)
    NUMBER          reduce using rule 26 (binary_expr -> expr - expr .)
    STRING          reduce using rule 26 (binary_expr -> expr - expr .)
    IDENTIFIER      reduce using rule 26 (binary_expr -> expr - expr .)
    DO              reduce using rule 26 (binary_expr -> expr - expr .)
    $end            reduce using rule 26 (binary_expr -> expr - expr .)
    ,               reduce using rule 26 (binary_expr -> expr - expr .)
    }               reduce using rule 26 (binary_expr -> expr - expr .)
    )               reduce using rule 26 (binary_expr -> expr - expr .)
    ]               reduce using rule 26 (binary_expr -> expr - expr .)
    OF              reduce using rule 26 (binary_expr -> expr - expr .)
    END             reduce using rule 26 (binary_expr -> expr - expr .)
    ELIF            reduce using rule 26 (binary_expr -> expr - expr .)
    ELSE            reduce using rule 26 (binary_expr -> expr - expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37


state 63

    (27) binary_expr -> expr + expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    -               reduce using rule 27 (binary_expr -> expr + expr .)
    +               reduce using rule 27 (binary_expr -> expr + expr .)
    CONCAT          reduce using rule 27 (binary_expr -> expr + expr .)
    ENUM            reduce using rule 27 (binary_expr -> expr + expr .)
    STRUCT          reduce using rule 27 (binary_expr -> expr + expr .)
    (               reduce using rule 27 (binary_expr -> expr + expr .)
    {               reduce using rule 27 (binary_expr -> expr + expr .)
    [               reduce using rule 27 (binary_expr -> expr + expr .)
    CASE            reduce using rule 27 (binary_expr -> expr + expr .)
    IF              reduce using rule 27 (binary_expr -> expr + expr .)
    DEF             reduce using rule 27 (binary_expr -> expr + expr .)
    NUMBER          reduce using rule 27 (binary_expr -> expr + expr .)
    STRING          reduce using rule 27 (binary_expr -> expr + expr .)
    IDENTIFIER      reduce using rule 27 (binary_expr -> expr + expr .)
    DO              reduce using rule 27 (binary_expr -> expr + expr .)
    $end            reduce using rule 27 (binary_expr -> expr + expr .)
    ,               reduce using rule 27 (binary_expr -> expr + expr .)
    }               reduce using rule 27 (binary_expr -> expr + expr .)
    )               reduce using rule 27 (binary_expr -> expr + expr .)
    ]               reduce using rule 27 (binary_expr -> expr + expr .)
    OF              reduce using rule 27 (binary_expr -> expr + expr .)
    END             reduce using rule 27 (binary_expr -> expr + expr .)
    ELIF            reduce using rule 27 (binary_expr -> expr + expr .)
    ELSE            reduce using rule 27 (binary_expr -> expr + expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37


state 64

    (28) binary_expr -> expr CONCAT expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    CONCAT          reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ENUM            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    STRUCT          reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    (               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    {               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    [               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    CASE            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    IF              reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    DEF             reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    NUMBER          reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    STRING          reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    IDENTIFIER      reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    DO              reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    $end            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ,               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    }               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    )               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ]               reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    OF              reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    END             reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ELIF            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    ELSE            reduce using rule 28 (binary_expr -> expr CONCAT expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39


state 65

    (68) enum -> ENUM type_identifier _12_optional . { _14_repeat }
    {               shift and go to state 89


state 66

    (69) _12_optional -> < . identifier _13_repeat >
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 90

state 67

    (173) tuple -> { _35_optional _36_repeat . }
    }               shift and go to state 91


state 68

    (176) _36_repeat -> _36_items .
    (178) _36_items -> _36_items . _36_item
    (180) _36_item -> . , expr
    }               reduce using rule 176 (_36_repeat -> _36_items .)
    ,               shift and go to state 70

    _36_item                       shift and go to state 92

state 69

    (179) _36_items -> _36_item .
    ,               reduce using rule 179 (_36_items -> _36_item .)
    }               reduce using rule 179 (_36_items -> _36_item .)


state 70

    (180) _36_item -> , . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 93
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 71

    (55) struct -> STRUCT type_identifier _9_optional . { _11_repeat }
    {               shift and go to state 94


state 72

    (56) _9_optional -> < . identifier _10_repeat >
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 95

state 73

    (10) expr -> ( expr ) .
    INT_DIV         reduce using rule 10 (expr -> ( expr ) .)
    *               reduce using rule 10 (expr -> ( expr ) .)
    /               reduce using rule 10 (expr -> ( expr ) .)
    -               reduce using rule 10 (expr -> ( expr ) .)
    +               reduce using rule 10 (expr -> ( expr ) .)
    CONCAT          reduce using rule 10 (expr -> ( expr ) .)
    ENUM            reduce using rule 10 (expr -> ( expr ) .)
    STRUCT          reduce using rule 10 (expr -> ( expr ) .)
    (               reduce using rule 10 (expr -> ( expr ) .)
    {               reduce using rule 10 (expr -> ( expr ) .)
    [               reduce using rule 10 (expr -> ( expr ) .)
    CASE            reduce using rule 10 (expr -> ( expr ) .)
    IF              reduce using rule 10 (expr -> ( expr ) .)
    DEF             reduce using rule 10 (expr -> ( expr ) .)
    NUMBER          reduce using rule 10 (expr -> ( expr ) .)
    STRING          reduce using rule 10 (expr -> ( expr ) .)
    IDENTIFIER      reduce using rule 10 (expr -> ( expr ) .)
    DO              reduce using rule 10 (expr -> ( expr ) .)
    $end            reduce using rule 10 (expr -> ( expr ) .)
    ,               reduce using rule 10 (expr -> ( expr ) .)
    }               reduce using rule 10 (expr -> ( expr ) .)
    )               reduce using rule 10 (expr -> ( expr ) .)
    ]               reduce using rule 10 (expr -> ( expr ) .)
    OF              reduce using rule 10 (expr -> ( expr ) .)
    END             reduce using rule 10 (expr -> ( expr ) .)
    ELIF            reduce using rule 10 (expr -> ( expr ) .)
    ELSE            reduce using rule 10 (expr -> ( expr ) .)


state 74

    (192) variable_declaration -> identifier _39_optional = . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    identifier                     shift and go to state 23
    expr                           shift and go to state 96
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 75

    (47) type -> : type_identifier . _7_optional
    (48) _7_optional -> . < identifier _8_repeat >
    (54) _7_optional -> .
    <               shift and go to state 98
    =               reduce using rule 54 (_7_optional -> .)
    (               reduce using rule 54 (_7_optional -> .)
    -               reduce using rule 54 (_7_optional -> .)
    {               reduce using rule 54 (_7_optional -> .)
    [               reduce using rule 54 (_7_optional -> .)
    CASE            reduce using rule 54 (_7_optional -> .)
    IF              reduce using rule 54 (_7_optional -> .)
    DEF             reduce using rule 54 (_7_optional -> .)
    NUMBER          reduce using rule 54 (_7_optional -> .)
    STRING          reduce using rule 54 (_7_optional -> .)
    IDENTIFIER      reduce using rule 54 (_7_optional -> .)
    DO              reduce using rule 54 (_7_optional -> .)
    END             reduce using rule 54 (_7_optional -> .)
    ,               reduce using rule 54 (_7_optional -> .)
    )               reduce using rule 54 (_7_optional -> .)
    }               reduce using rule 54 (_7_optional -> .)

    _7_optional                    shift and go to state 97

state 76

    (165) array -> [ _33_optional _34_repeat . ]
    ]               shift and go to state 99


state 77

    (168) _34_repeat -> _34_items .
    (170) _34_items -> _34_items . _34_item
    (172) _34_item -> . , expr
    ]               reduce using rule 168 (_34_repeat -> _34_items .)
    ,               shift and go to state 79

    _34_item                       shift and go to state 100

state 78

    (171) _34_items -> _34_item .
    ,               reduce using rule 171 (_34_items -> _34_item .)
    ]               reduce using rule 171 (_34_items -> _34_item .)


state 79

    (172) _34_item -> , . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 101
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 80

    (116) case_of -> CASE expr OF . case _23_repeat END
    (122) case -> . pattern _24_repeat do
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    case                           shift and go to state 102
    pattern                        shift and go to state 103
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 81

    (181) call -> callee ( _37_optional . _38_repeat )
    (184) _38_repeat -> . _38_items
    (185) _38_repeat -> .
    (186) _38_items -> . _38_items _38_item
    (187) _38_items -> . _38_item
    (188) _38_item -> . , expr
    )               reduce using rule 185 (_38_repeat -> .)
    ,               shift and go to state 113

    _38_repeat                     shift and go to state 110
    _38_items                      shift and go to state 111
    _38_item                       shift and go to state 112

state 82

    (182) _37_optional -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 182 (_37_optional -> expr .)
    )               reduce using rule 182 (_37_optional -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 83

    (92) _if -> IF expr DO . _18_repeat _19_repeat _20_optional END
    (93) _18_repeat -> . _18_items
    (94) _18_repeat -> .
    (95) _18_items -> . _18_items _18_item
    (96) _18_items -> . _18_item
    (97) _18_item -> . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    ELIF            reduce using rule 94 (_18_repeat -> .)
    ELSE            reduce using rule 94 (_18_repeat -> .)
    END             reduce using rule 94 (_18_repeat -> .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 114
    _18_repeat                     shift and go to state 115
    _18_items                      shift and go to state 116
    _18_item                       shift and go to state 117
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 84

    (29) do -> DO _2_optional _3_repeat . END
    END             shift and go to state 118


state 85

    (32) _3_repeat -> _3_items .
    (34) _3_items -> _3_items . _3_item
    (36) _3_item -> . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    END             reduce using rule 32 (_3_repeat -> _3_items .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _3_item                        shift and go to state 119
    expr                           shift and go to state 87
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 86

    (35) _3_items -> _3_item .
    (               reduce using rule 35 (_3_items -> _3_item .)
    -               reduce using rule 35 (_3_items -> _3_item .)
    {               reduce using rule 35 (_3_items -> _3_item .)
    [               reduce using rule 35 (_3_items -> _3_item .)
    CASE            reduce using rule 35 (_3_items -> _3_item .)
    IF              reduce using rule 35 (_3_items -> _3_item .)
    DEF             reduce using rule 35 (_3_items -> _3_item .)
    NUMBER          reduce using rule 35 (_3_items -> _3_item .)
    STRING          reduce using rule 35 (_3_items -> _3_item .)
    IDENTIFIER      reduce using rule 35 (_3_items -> _3_item .)
    DO              reduce using rule 35 (_3_items -> _3_item .)
    END             reduce using rule 35 (_3_items -> _3_item .)


state 87

    (36) _3_item -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for - resolved as shift
    (               reduce using rule 36 (_3_item -> expr .)
    {               reduce using rule 36 (_3_item -> expr .)
    [               reduce using rule 36 (_3_item -> expr .)
    CASE            reduce using rule 36 (_3_item -> expr .)
    IF              reduce using rule 36 (_3_item -> expr .)
    DEF             reduce using rule 36 (_3_item -> expr .)
    NUMBER          reduce using rule 36 (_3_item -> expr .)
    STRING          reduce using rule 36 (_3_item -> expr .)
    IDENTIFIER      reduce using rule 36 (_3_item -> expr .)
    DO              reduce using rule 36 (_3_item -> expr .)
    END             reduce using rule 36 (_3_item -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 88

    (37) _def -> DEF identifier ( . _4_optional _5_repeat ) _6_optional do
    (38) _4_optional -> . param
    (39) _4_optional -> .
    (89) param -> . identifier _17_optional
    (190) identifier -> . IDENTIFIER
    ,               reduce using rule 39 (_4_optional -> .)
    )               reduce using rule 39 (_4_optional -> .)
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 120
    _4_optional                    shift and go to state 121
    param                          shift and go to state 122

state 89

    (68) enum -> ENUM type_identifier _12_optional { . _14_repeat }
    (76) _14_repeat -> . _14_items
    (77) _14_repeat -> .
    (78) _14_items -> . _14_items _14_item
    (79) _14_items -> . _14_item
    (80) _14_item -> . enum_key
    (81) enum_key -> . identifier _15_optional
    (190) identifier -> . IDENTIFIER
    }               reduce using rule 77 (_14_repeat -> .)
    IDENTIFIER      shift and go to state 33

    _14_repeat                     shift and go to state 123
    _14_items                      shift and go to state 124
    _14_item                       shift and go to state 125
    enum_key                       shift and go to state 126
    identifier                     shift and go to state 127

state 90

    (69) _12_optional -> < identifier . _13_repeat >
    (70) _13_repeat -> . _13_items
    (71) _13_repeat -> .
    (72) _13_items -> . _13_items _13_item
    (73) _13_items -> . _13_item
    (74) _13_item -> . , identifier
    >               reduce using rule 71 (_13_repeat -> .)
    ,               shift and go to state 131

    _13_repeat                     shift and go to state 128
    _13_items                      shift and go to state 129
    _13_item                       shift and go to state 130

state 91

    (173) tuple -> { _35_optional _36_repeat } .
    INT_DIV         reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    *               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    /               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    -               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    +               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    CONCAT          reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    ENUM            reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    STRUCT          reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    (               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    {               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    [               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    CASE            reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    IF              reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    DEF             reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    NUMBER          reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    STRING          reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    IDENTIFIER      reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    DO              reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    $end            reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    ,               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    }               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    )               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    ]               reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    OF              reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    END             reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    ELIF            reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)
    ELSE            reduce using rule 173 (tuple -> { _35_optional _36_repeat } .)


state 92

    (178) _36_items -> _36_items _36_item .
    ,               reduce using rule 178 (_36_items -> _36_items _36_item .)
    }               reduce using rule 178 (_36_items -> _36_items _36_item .)


state 93

    (180) _36_item -> , expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 180 (_36_item -> , expr .)
    }               reduce using rule 180 (_36_item -> , expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 94

    (55) struct -> STRUCT type_identifier _9_optional { . _11_repeat }
    (63) _11_repeat -> . _11_items
    (64) _11_repeat -> .
    (65) _11_items -> . _11_items _11_item
    (66) _11_items -> . _11_item
    (67) _11_item -> . identifier type
    (190) identifier -> . IDENTIFIER
    }               reduce using rule 64 (_11_repeat -> .)
    IDENTIFIER      shift and go to state 33

    _11_repeat                     shift and go to state 132
    _11_items                      shift and go to state 133
    _11_item                       shift and go to state 134
    identifier                     shift and go to state 135

state 95

    (56) _9_optional -> < identifier . _10_repeat >
    (57) _10_repeat -> . _10_items
    (58) _10_repeat -> .
    (59) _10_items -> . _10_items _10_item
    (60) _10_items -> . _10_item
    (61) _10_item -> . , identifier
    >               reduce using rule 58 (_10_repeat -> .)
    ,               shift and go to state 139

    _10_repeat                     shift and go to state 136
    _10_items                      shift and go to state 137
    _10_item                       shift and go to state 138

state 96

    (192) variable_declaration -> identifier _39_optional = expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for INT_DIV resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for CONCAT resolved as shift
    ENUM            reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    STRUCT          reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    (               reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    {               reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    [               reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    CASE            reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    IF              reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    DEF             reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    NUMBER          reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    STRING          reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    IDENTIFIER      reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    DO              reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    $end            reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    ,               reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    }               reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    )               reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    ]               reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    OF              reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    END             reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    ELIF            reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    ELSE            reduce using rule 192 (variable_declaration -> identifier _39_optional = expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 97

    (47) type -> : type_identifier _7_optional .
    =               reduce using rule 47 (type -> : type_identifier _7_optional .)
    (               reduce using rule 47 (type -> : type_identifier _7_optional .)
    -               reduce using rule 47 (type -> : type_identifier _7_optional .)
    {               reduce using rule 47 (type -> : type_identifier _7_optional .)
    [               reduce using rule 47 (type -> : type_identifier _7_optional .)
    CASE            reduce using rule 47 (type -> : type_identifier _7_optional .)
    IF              reduce using rule 47 (type -> : type_identifier _7_optional .)
    DEF             reduce using rule 47 (type -> : type_identifier _7_optional .)
    NUMBER          reduce using rule 47 (type -> : type_identifier _7_optional .)
    STRING          reduce using rule 47 (type -> : type_identifier _7_optional .)
    IDENTIFIER      reduce using rule 47 (type -> : type_identifier _7_optional .)
    DO              reduce using rule 47 (type -> : type_identifier _7_optional .)
    END             reduce using rule 47 (type -> : type_identifier _7_optional .)
    ,               reduce using rule 47 (type -> : type_identifier _7_optional .)
    )               reduce using rule 47 (type -> : type_identifier _7_optional .)
    }               reduce using rule 47 (type -> : type_identifier _7_optional .)


state 98

    (48) _7_optional -> < . identifier _8_repeat >
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 140

state 99

    (165) array -> [ _33_optional _34_repeat ] .
    INT_DIV         reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    *               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    /               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    -               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    +               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    CONCAT          reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    ENUM            reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    STRUCT          reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    (               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    {               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    [               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    CASE            reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    IF              reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    DEF             reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    NUMBER          reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    STRING          reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    IDENTIFIER      reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    DO              reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    $end            reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    ,               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    }               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    )               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    ]               reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    OF              reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    END             reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    ELIF            reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)
    ELSE            reduce using rule 165 (array -> [ _33_optional _34_repeat ] .)


state 100

    (170) _34_items -> _34_items _34_item .
    ,               reduce using rule 170 (_34_items -> _34_items _34_item .)
    ]               reduce using rule 170 (_34_items -> _34_items _34_item .)


state 101

    (172) _34_item -> , expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 172 (_34_item -> , expr .)
    ]               reduce using rule 172 (_34_item -> , expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 102

    (116) case_of -> CASE expr OF case . _23_repeat END
    (117) _23_repeat -> . _23_items
    (118) _23_repeat -> .
    (119) _23_items -> . _23_items _23_item
    (120) _23_items -> . _23_item
    (121) _23_item -> . case
    (122) case -> . pattern _24_repeat do
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 118 (_23_repeat -> .)
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    case                           shift and go to state 141
    _23_repeat                     shift and go to state 142
    _23_items                      shift and go to state 143
    _23_item                       shift and go to state 144
    pattern                        shift and go to state 103
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 103

    (122) case -> pattern . _24_repeat do
    (123) _24_repeat -> . _24_items
    (124) _24_repeat -> .
    (125) _24_items -> . _24_items _24_item
    (126) _24_items -> . _24_item
    (127) _24_item -> . , pattern
    DO              reduce using rule 124 (_24_repeat -> .)
    ,               shift and go to state 148

    _24_repeat                     shift and go to state 145
    _24_items                      shift and go to state 146
    _24_item                       shift and go to state 147

state 104

    (128) pattern -> array_pattern .
    ,               reduce using rule 128 (pattern -> array_pattern .)
    DO              reduce using rule 128 (pattern -> array_pattern .)
    )               reduce using rule 128 (pattern -> array_pattern .)
    ]               reduce using rule 128 (pattern -> array_pattern .)
    }               reduce using rule 128 (pattern -> array_pattern .)


state 105

    (129) pattern -> tuple_pattern .
    ,               reduce using rule 129 (pattern -> tuple_pattern .)
    DO              reduce using rule 129 (pattern -> tuple_pattern .)
    )               reduce using rule 129 (pattern -> tuple_pattern .)
    ]               reduce using rule 129 (pattern -> tuple_pattern .)
    }               reduce using rule 129 (pattern -> tuple_pattern .)


state 106

    (130) pattern -> enum_pattern .
    ,               reduce using rule 130 (pattern -> enum_pattern .)
    DO              reduce using rule 130 (pattern -> enum_pattern .)
    )               reduce using rule 130 (pattern -> enum_pattern .)
    ]               reduce using rule 130 (pattern -> enum_pattern .)
    }               reduce using rule 130 (pattern -> enum_pattern .)


state 107

    (131) array_pattern -> [ . _25_repeat _26_optional ]
    (132) _25_repeat -> . _25_items
    (133) _25_repeat -> .
    (134) _25_items -> . _25_items _25_item
    (135) _25_items -> . _25_item
    (136) _25_item -> . pattern ,
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    SPREAD          reduce using rule 133 (_25_repeat -> .)
    ]               reduce using rule 133 (_25_repeat -> .)
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    _25_repeat                     shift and go to state 149
    _25_items                      shift and go to state 150
    _25_item                       shift and go to state 151
    pattern                        shift and go to state 152
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 108

    (152) tuple_pattern -> { . _30_repeat _31_optional }
    (153) _30_repeat -> . _30_items
    (154) _30_repeat -> .
    (155) _30_items -> . _30_items _30_item
    (156) _30_items -> . _30_item
    (157) _30_item -> . pattern ,
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    SPREAD          reduce using rule 154 (_30_repeat -> .)
    }               reduce using rule 154 (_30_repeat -> .)
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    _30_repeat                     shift and go to state 153
    _30_items                      shift and go to state 154
    _30_item                       shift and go to state 155
    pattern                        shift and go to state 156
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 109

    (144) enum_pattern -> type_identifier . _28_optional
    (145) _28_optional -> . ( pattern _29_repeat )
    (151) _28_optional -> .
    (               shift and go to state 158
    ,               reduce using rule 151 (_28_optional -> .)
    DO              reduce using rule 151 (_28_optional -> .)
    )               reduce using rule 151 (_28_optional -> .)
    ]               reduce using rule 151 (_28_optional -> .)
    }               reduce using rule 151 (_28_optional -> .)

    _28_optional                   shift and go to state 157

state 110

    (181) call -> callee ( _37_optional _38_repeat . )
    )               shift and go to state 159


state 111

    (184) _38_repeat -> _38_items .
    (186) _38_items -> _38_items . _38_item
    (188) _38_item -> . , expr
    )               reduce using rule 184 (_38_repeat -> _38_items .)
    ,               shift and go to state 113

    _38_item                       shift and go to state 160

state 112

    (187) _38_items -> _38_item .
    ,               reduce using rule 187 (_38_items -> _38_item .)
    )               reduce using rule 187 (_38_items -> _38_item .)


state 113

    (188) _38_item -> , . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 161
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 114

    (97) _18_item -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for - resolved as shift
    (               reduce using rule 97 (_18_item -> expr .)
    {               reduce using rule 97 (_18_item -> expr .)
    [               reduce using rule 97 (_18_item -> expr .)
    CASE            reduce using rule 97 (_18_item -> expr .)
    IF              reduce using rule 97 (_18_item -> expr .)
    DEF             reduce using rule 97 (_18_item -> expr .)
    NUMBER          reduce using rule 97 (_18_item -> expr .)
    STRING          reduce using rule 97 (_18_item -> expr .)
    IDENTIFIER      reduce using rule 97 (_18_item -> expr .)
    DO              reduce using rule 97 (_18_item -> expr .)
    ELIF            reduce using rule 97 (_18_item -> expr .)
    ELSE            reduce using rule 97 (_18_item -> expr .)
    END             reduce using rule 97 (_18_item -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 115

    (92) _if -> IF expr DO _18_repeat . _19_repeat _20_optional END
    (98) _19_repeat -> . _19_items
    (99) _19_repeat -> .
    (100) _19_items -> . _19_items _19_item
    (101) _19_items -> . _19_item
    (102) _19_item -> . _elif
    (110) _elif -> . ELIF expr DO _22_repeat
    ELSE            reduce using rule 99 (_19_repeat -> .)
    END             reduce using rule 99 (_19_repeat -> .)
    ELIF            shift and go to state 166

    _19_repeat                     shift and go to state 162
    _19_items                      shift and go to state 163
    _19_item                       shift and go to state 164
    _elif                          shift and go to state 165

state 116

    (93) _18_repeat -> _18_items .
    (95) _18_items -> _18_items . _18_item
    (97) _18_item -> . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    ELIF            reduce using rule 93 (_18_repeat -> _18_items .)
    ELSE            reduce using rule 93 (_18_repeat -> _18_items .)
    END             reduce using rule 93 (_18_repeat -> _18_items .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _18_item                       shift and go to state 167
    expr                           shift and go to state 114
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 117

    (96) _18_items -> _18_item .
    (               reduce using rule 96 (_18_items -> _18_item .)
    -               reduce using rule 96 (_18_items -> _18_item .)
    {               reduce using rule 96 (_18_items -> _18_item .)
    [               reduce using rule 96 (_18_items -> _18_item .)
    CASE            reduce using rule 96 (_18_items -> _18_item .)
    IF              reduce using rule 96 (_18_items -> _18_item .)
    DEF             reduce using rule 96 (_18_items -> _18_item .)
    NUMBER          reduce using rule 96 (_18_items -> _18_item .)
    STRING          reduce using rule 96 (_18_items -> _18_item .)
    IDENTIFIER      reduce using rule 96 (_18_items -> _18_item .)
    DO              reduce using rule 96 (_18_items -> _18_item .)
    ELIF            reduce using rule 96 (_18_items -> _18_item .)
    ELSE            reduce using rule 96 (_18_items -> _18_item .)
    END             reduce using rule 96 (_18_items -> _18_item .)


state 118

    (29) do -> DO _2_optional _3_repeat END .
    INT_DIV         reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    *               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    /               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    -               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    +               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    CONCAT          reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    ENUM            reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    STRUCT          reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    (               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    {               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    [               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    CASE            reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    IF              reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    DEF             reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    NUMBER          reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    STRING          reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    IDENTIFIER      reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    DO              reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    $end            reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    ,               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    }               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    )               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    ]               reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    OF              reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    END             reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    ELIF            reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    ELSE            reduce using rule 29 (do -> DO _2_optional _3_repeat END .)
    TYPE_IDENTIFIER reduce using rule 29 (do -> DO _2_optional _3_repeat END .)


state 119

    (34) _3_items -> _3_items _3_item .
    (               reduce using rule 34 (_3_items -> _3_items _3_item .)
    -               reduce using rule 34 (_3_items -> _3_items _3_item .)
    {               reduce using rule 34 (_3_items -> _3_items _3_item .)
    [               reduce using rule 34 (_3_items -> _3_items _3_item .)
    CASE            reduce using rule 34 (_3_items -> _3_items _3_item .)
    IF              reduce using rule 34 (_3_items -> _3_items _3_item .)
    DEF             reduce using rule 34 (_3_items -> _3_items _3_item .)
    NUMBER          reduce using rule 34 (_3_items -> _3_items _3_item .)
    STRING          reduce using rule 34 (_3_items -> _3_items _3_item .)
    IDENTIFIER      reduce using rule 34 (_3_items -> _3_items _3_item .)
    DO              reduce using rule 34 (_3_items -> _3_items _3_item .)
    END             reduce using rule 34 (_3_items -> _3_items _3_item .)


state 120

    (89) param -> identifier . _17_optional
    (90) _17_optional -> . type
    (91) _17_optional -> .
    (47) type -> . : type_identifier _7_optional
    ,               reduce using rule 91 (_17_optional -> .)
    )               reduce using rule 91 (_17_optional -> .)
    :               shift and go to state 50

    _17_optional                   shift and go to state 168
    type                           shift and go to state 169

state 121

    (37) _def -> DEF identifier ( _4_optional . _5_repeat ) _6_optional do
    (40) _5_repeat -> . _5_items
    (41) _5_repeat -> .
    (42) _5_items -> . _5_items _5_item
    (43) _5_items -> . _5_item
    (44) _5_item -> . , param
    )               reduce using rule 41 (_5_repeat -> .)
    ,               shift and go to state 173

    _5_repeat                      shift and go to state 170
    _5_items                       shift and go to state 171
    _5_item                        shift and go to state 172

state 122

    (38) _4_optional -> param .
    ,               reduce using rule 38 (_4_optional -> param .)
    )               reduce using rule 38 (_4_optional -> param .)


state 123

    (68) enum -> ENUM type_identifier _12_optional { _14_repeat . }
    }               shift and go to state 174


state 124

    (76) _14_repeat -> _14_items .
    (78) _14_items -> _14_items . _14_item
    (80) _14_item -> . enum_key
    (81) enum_key -> . identifier _15_optional
    (190) identifier -> . IDENTIFIER
    }               reduce using rule 76 (_14_repeat -> _14_items .)
    IDENTIFIER      shift and go to state 33

    _14_item                       shift and go to state 175
    enum_key                       shift and go to state 126
    identifier                     shift and go to state 127

state 125

    (79) _14_items -> _14_item .
    IDENTIFIER      reduce using rule 79 (_14_items -> _14_item .)
    }               reduce using rule 79 (_14_items -> _14_item .)


state 126

    (80) _14_item -> enum_key .
    IDENTIFIER      reduce using rule 80 (_14_item -> enum_key .)
    }               reduce using rule 80 (_14_item -> enum_key .)


state 127

    (81) enum_key -> identifier . _15_optional
    (82) _15_optional -> . ( identifier _16_repeat )
    (88) _15_optional -> .
    (               shift and go to state 177
    IDENTIFIER      reduce using rule 88 (_15_optional -> .)
    }               reduce using rule 88 (_15_optional -> .)

    _15_optional                   shift and go to state 176

state 128

    (69) _12_optional -> < identifier _13_repeat . >
    >               shift and go to state 178


state 129

    (70) _13_repeat -> _13_items .
    (72) _13_items -> _13_items . _13_item
    (74) _13_item -> . , identifier
    >               reduce using rule 70 (_13_repeat -> _13_items .)
    ,               shift and go to state 131

    _13_item                       shift and go to state 179

state 130

    (73) _13_items -> _13_item .
    ,               reduce using rule 73 (_13_items -> _13_item .)
    >               reduce using rule 73 (_13_items -> _13_item .)


state 131

    (74) _13_item -> , . identifier
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 180

state 132

    (55) struct -> STRUCT type_identifier _9_optional { _11_repeat . }
    }               shift and go to state 181


state 133

    (63) _11_repeat -> _11_items .
    (65) _11_items -> _11_items . _11_item
    (67) _11_item -> . identifier type
    (190) identifier -> . IDENTIFIER
    }               reduce using rule 63 (_11_repeat -> _11_items .)
    IDENTIFIER      shift and go to state 33

    _11_item                       shift and go to state 182
    identifier                     shift and go to state 135

state 134

    (66) _11_items -> _11_item .
    IDENTIFIER      reduce using rule 66 (_11_items -> _11_item .)
    }               reduce using rule 66 (_11_items -> _11_item .)


state 135

    (67) _11_item -> identifier . type
    (47) type -> . : type_identifier _7_optional
    :               shift and go to state 50

    type                           shift and go to state 183

state 136

    (56) _9_optional -> < identifier _10_repeat . >
    >               shift and go to state 184


state 137

    (57) _10_repeat -> _10_items .
    (59) _10_items -> _10_items . _10_item
    (61) _10_item -> . , identifier
    >               reduce using rule 57 (_10_repeat -> _10_items .)
    ,               shift and go to state 139

    _10_item                       shift and go to state 185

state 138

    (60) _10_items -> _10_item .
    ,               reduce using rule 60 (_10_items -> _10_item .)
    >               reduce using rule 60 (_10_items -> _10_item .)


state 139

    (61) _10_item -> , . identifier
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 186

state 140

    (48) _7_optional -> < identifier . _8_repeat >
    (49) _8_repeat -> . _8_items
    (50) _8_repeat -> .
    (51) _8_items -> . _8_items _8_item
    (52) _8_items -> . _8_item
    (53) _8_item -> . , identifier
    >               reduce using rule 50 (_8_repeat -> .)
    ,               shift and go to state 190

    _8_repeat                      shift and go to state 187
    _8_items                       shift and go to state 188
    _8_item                        shift and go to state 189

state 141

    (121) _23_item -> case .
    [               reduce using rule 121 (_23_item -> case .)
    {               reduce using rule 121 (_23_item -> case .)
    TYPE_IDENTIFIER reduce using rule 121 (_23_item -> case .)
    END             reduce using rule 121 (_23_item -> case .)


state 142

    (116) case_of -> CASE expr OF case _23_repeat . END
    END             shift and go to state 191


state 143

    (117) _23_repeat -> _23_items .
    (119) _23_items -> _23_items . _23_item
    (121) _23_item -> . case
    (122) case -> . pattern _24_repeat do
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    END             reduce using rule 117 (_23_repeat -> _23_items .)
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    _23_item                       shift and go to state 192
    case                           shift and go to state 141
    pattern                        shift and go to state 103
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 144

    (120) _23_items -> _23_item .
    [               reduce using rule 120 (_23_items -> _23_item .)
    {               reduce using rule 120 (_23_items -> _23_item .)
    TYPE_IDENTIFIER reduce using rule 120 (_23_items -> _23_item .)
    END             reduce using rule 120 (_23_items -> _23_item .)


state 145

    (122) case -> pattern _24_repeat . do
    (29) do -> . DO _2_optional _3_repeat END
    DO              shift and go to state 29

    do                             shift and go to state 193

state 146

    (123) _24_repeat -> _24_items .
    (125) _24_items -> _24_items . _24_item
    (127) _24_item -> . , pattern
    DO              reduce using rule 123 (_24_repeat -> _24_items .)
    ,               shift and go to state 148

    _24_item                       shift and go to state 194

state 147

    (126) _24_items -> _24_item .
    ,               reduce using rule 126 (_24_items -> _24_item .)
    DO              reduce using rule 126 (_24_items -> _24_item .)


state 148

    (127) _24_item -> , . pattern
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    pattern                        shift and go to state 195
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 149

    (131) array_pattern -> [ _25_repeat . _26_optional ]
    (137) _26_optional -> . SPREAD identifier _27_repeat
    (143) _26_optional -> .
    SPREAD          shift and go to state 197
    ]               reduce using rule 143 (_26_optional -> .)

    _26_optional                   shift and go to state 196

state 150

    (132) _25_repeat -> _25_items .
    (134) _25_items -> _25_items . _25_item
    (136) _25_item -> . pattern ,
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    SPREAD          reduce using rule 132 (_25_repeat -> _25_items .)
    ]               reduce using rule 132 (_25_repeat -> _25_items .)
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    _25_item                       shift and go to state 198
    pattern                        shift and go to state 152
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 151

    (135) _25_items -> _25_item .
    [               reduce using rule 135 (_25_items -> _25_item .)
    {               reduce using rule 135 (_25_items -> _25_item .)
    TYPE_IDENTIFIER reduce using rule 135 (_25_items -> _25_item .)
    SPREAD          reduce using rule 135 (_25_items -> _25_item .)
    ]               reduce using rule 135 (_25_items -> _25_item .)


state 152

    (136) _25_item -> pattern . ,
    ,               shift and go to state 199


state 153

    (152) tuple_pattern -> { _30_repeat . _31_optional }
    (158) _31_optional -> . SPREAD identifier _32_repeat
    (164) _31_optional -> .
    SPREAD          shift and go to state 201
    }               reduce using rule 164 (_31_optional -> .)

    _31_optional                   shift and go to state 200

state 154

    (153) _30_repeat -> _30_items .
    (155) _30_items -> _30_items . _30_item
    (157) _30_item -> . pattern ,
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    SPREAD          reduce using rule 153 (_30_repeat -> _30_items .)
    }               reduce using rule 153 (_30_repeat -> _30_items .)
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    _30_item                       shift and go to state 202
    pattern                        shift and go to state 156
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 155

    (156) _30_items -> _30_item .
    [               reduce using rule 156 (_30_items -> _30_item .)
    {               reduce using rule 156 (_30_items -> _30_item .)
    TYPE_IDENTIFIER reduce using rule 156 (_30_items -> _30_item .)
    SPREAD          reduce using rule 156 (_30_items -> _30_item .)
    }               reduce using rule 156 (_30_items -> _30_item .)


state 156

    (157) _30_item -> pattern . ,
    ,               shift and go to state 203


state 157

    (144) enum_pattern -> type_identifier _28_optional .
    ,               reduce using rule 144 (enum_pattern -> type_identifier _28_optional .)
    DO              reduce using rule 144 (enum_pattern -> type_identifier _28_optional .)
    )               reduce using rule 144 (enum_pattern -> type_identifier _28_optional .)
    ]               reduce using rule 144 (enum_pattern -> type_identifier _28_optional .)
    }               reduce using rule 144 (enum_pattern -> type_identifier _28_optional .)


state 158

    (145) _28_optional -> ( . pattern _29_repeat )
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    pattern                        shift and go to state 204
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 159

    (181) call -> callee ( _37_optional _38_repeat ) .
    INT_DIV         reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    *               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    /               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    -               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    +               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    CONCAT          reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    ENUM            reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    STRUCT          reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    (               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    {               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    [               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    CASE            reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    IF              reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    DEF             reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    NUMBER          reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    STRING          reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    IDENTIFIER      reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    DO              reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    $end            reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    ,               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    }               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    )               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    ]               reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    OF              reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    END             reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    ELIF            reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)
    ELSE            reduce using rule 181 (call -> callee ( _37_optional _38_repeat ) .)


state 160

    (186) _38_items -> _38_items _38_item .
    ,               reduce using rule 186 (_38_items -> _38_items _38_item .)
    )               reduce using rule 186 (_38_items -> _38_items _38_item .)


state 161

    (188) _38_item -> , expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    ,               reduce using rule 188 (_38_item -> , expr .)
    )               reduce using rule 188 (_38_item -> , expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 162

    (92) _if -> IF expr DO _18_repeat _19_repeat . _20_optional END
    (103) _20_optional -> . ELSE _21_repeat
    (109) _20_optional -> .
    ELSE            shift and go to state 206
    END             reduce using rule 109 (_20_optional -> .)

    _20_optional                   shift and go to state 205

state 163

    (98) _19_repeat -> _19_items .
    (100) _19_items -> _19_items . _19_item
    (102) _19_item -> . _elif
    (110) _elif -> . ELIF expr DO _22_repeat
    ELSE            reduce using rule 98 (_19_repeat -> _19_items .)
    END             reduce using rule 98 (_19_repeat -> _19_items .)
    ELIF            shift and go to state 166

    _19_item                       shift and go to state 207
    _elif                          shift and go to state 165

state 164

    (101) _19_items -> _19_item .
    ELIF            reduce using rule 101 (_19_items -> _19_item .)
    ELSE            reduce using rule 101 (_19_items -> _19_item .)
    END             reduce using rule 101 (_19_items -> _19_item .)


state 165

    (102) _19_item -> _elif .
    ELIF            reduce using rule 102 (_19_item -> _elif .)
    ELSE            reduce using rule 102 (_19_item -> _elif .)
    END             reduce using rule 102 (_19_item -> _elif .)


state 166

    (110) _elif -> ELIF . expr DO _22_repeat
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 208
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 167

    (95) _18_items -> _18_items _18_item .
    (               reduce using rule 95 (_18_items -> _18_items _18_item .)
    -               reduce using rule 95 (_18_items -> _18_items _18_item .)
    {               reduce using rule 95 (_18_items -> _18_items _18_item .)
    [               reduce using rule 95 (_18_items -> _18_items _18_item .)
    CASE            reduce using rule 95 (_18_items -> _18_items _18_item .)
    IF              reduce using rule 95 (_18_items -> _18_items _18_item .)
    DEF             reduce using rule 95 (_18_items -> _18_items _18_item .)
    NUMBER          reduce using rule 95 (_18_items -> _18_items _18_item .)
    STRING          reduce using rule 95 (_18_items -> _18_items _18_item .)
    IDENTIFIER      reduce using rule 95 (_18_items -> _18_items _18_item .)
    DO              reduce using rule 95 (_18_items -> _18_items _18_item .)
    ELIF            reduce using rule 95 (_18_items -> _18_items _18_item .)
    ELSE            reduce using rule 95 (_18_items -> _18_items _18_item .)
    END             reduce using rule 95 (_18_items -> _18_items _18_item .)


state 168

    (89) param -> identifier _17_optional .
    ,               reduce using rule 89 (param -> identifier _17_optional .)
    )               reduce using rule 89 (param -> identifier _17_optional .)


state 169

    (90) _17_optional -> type .
    ,               reduce using rule 90 (_17_optional -> type .)
    )               reduce using rule 90 (_17_optional -> type .)


state 170

    (37) _def -> DEF identifier ( _4_optional _5_repeat . ) _6_optional do
    )               shift and go to state 209


state 171

    (40) _5_repeat -> _5_items .
    (42) _5_items -> _5_items . _5_item
    (44) _5_item -> . , param
    )               reduce using rule 40 (_5_repeat -> _5_items .)
    ,               shift and go to state 173

    _5_item                        shift and go to state 210

state 172

    (43) _5_items -> _5_item .
    ,               reduce using rule 43 (_5_items -> _5_item .)
    )               reduce using rule 43 (_5_items -> _5_item .)


state 173

    (44) _5_item -> , . param
    (89) param -> . identifier _17_optional
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    param                          shift and go to state 211
    identifier                     shift and go to state 120

state 174

    (68) enum -> ENUM type_identifier _12_optional { _14_repeat } .
    ENUM            reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    STRUCT          reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    (               reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    -               reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    {               reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    [               reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    CASE            reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    IF              reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    DEF             reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    NUMBER          reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    STRING          reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    IDENTIFIER      reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    DO              reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)
    $end            reduce using rule 68 (enum -> ENUM type_identifier _12_optional { _14_repeat } .)


state 175

    (78) _14_items -> _14_items _14_item .
    IDENTIFIER      reduce using rule 78 (_14_items -> _14_items _14_item .)
    }               reduce using rule 78 (_14_items -> _14_items _14_item .)


state 176

    (81) enum_key -> identifier _15_optional .
    IDENTIFIER      reduce using rule 81 (enum_key -> identifier _15_optional .)
    }               reduce using rule 81 (enum_key -> identifier _15_optional .)


state 177

    (82) _15_optional -> ( . identifier _16_repeat )
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 212

state 178

    (69) _12_optional -> < identifier _13_repeat > .
    {               reduce using rule 69 (_12_optional -> < identifier _13_repeat > .)


state 179

    (72) _13_items -> _13_items _13_item .
    ,               reduce using rule 72 (_13_items -> _13_items _13_item .)
    >               reduce using rule 72 (_13_items -> _13_items _13_item .)


state 180

    (74) _13_item -> , identifier .
    ,               reduce using rule 74 (_13_item -> , identifier .)
    >               reduce using rule 74 (_13_item -> , identifier .)


state 181

    (55) struct -> STRUCT type_identifier _9_optional { _11_repeat } .
    ENUM            reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    STRUCT          reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    (               reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    -               reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    {               reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    [               reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    CASE            reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    IF              reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    DEF             reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    NUMBER          reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    STRING          reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    IDENTIFIER      reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    DO              reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)
    $end            reduce using rule 55 (struct -> STRUCT type_identifier _9_optional { _11_repeat } .)


state 182

    (65) _11_items -> _11_items _11_item .
    IDENTIFIER      reduce using rule 65 (_11_items -> _11_items _11_item .)
    }               reduce using rule 65 (_11_items -> _11_items _11_item .)


state 183

    (67) _11_item -> identifier type .
    IDENTIFIER      reduce using rule 67 (_11_item -> identifier type .)
    }               reduce using rule 67 (_11_item -> identifier type .)


state 184

    (56) _9_optional -> < identifier _10_repeat > .
    {               reduce using rule 56 (_9_optional -> < identifier _10_repeat > .)


state 185

    (59) _10_items -> _10_items _10_item .
    ,               reduce using rule 59 (_10_items -> _10_items _10_item .)
    >               reduce using rule 59 (_10_items -> _10_items _10_item .)


state 186

    (61) _10_item -> , identifier .
    ,               reduce using rule 61 (_10_item -> , identifier .)
    >               reduce using rule 61 (_10_item -> , identifier .)


state 187

    (48) _7_optional -> < identifier _8_repeat . >
    >               shift and go to state 213


state 188

    (49) _8_repeat -> _8_items .
    (51) _8_items -> _8_items . _8_item
    (53) _8_item -> . , identifier
    >               reduce using rule 49 (_8_repeat -> _8_items .)
    ,               shift and go to state 190

    _8_item                        shift and go to state 214

state 189

    (52) _8_items -> _8_item .
    ,               reduce using rule 52 (_8_items -> _8_item .)
    >               reduce using rule 52 (_8_items -> _8_item .)


state 190

    (53) _8_item -> , . identifier
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 215

state 191

    (116) case_of -> CASE expr OF case _23_repeat END .
    INT_DIV         reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    *               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    /               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    -               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    +               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    CONCAT          reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    ENUM            reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    STRUCT          reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    (               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    {               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    [               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    CASE            reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    IF              reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    DEF             reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    NUMBER          reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    STRING          reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    IDENTIFIER      reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    DO              reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    $end            reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    ,               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    }               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    )               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    ]               reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    OF              reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    END             reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    ELIF            reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)
    ELSE            reduce using rule 116 (case_of -> CASE expr OF case _23_repeat END .)


state 192

    (119) _23_items -> _23_items _23_item .
    [               reduce using rule 119 (_23_items -> _23_items _23_item .)
    {               reduce using rule 119 (_23_items -> _23_items _23_item .)
    TYPE_IDENTIFIER reduce using rule 119 (_23_items -> _23_items _23_item .)
    END             reduce using rule 119 (_23_items -> _23_items _23_item .)


state 193

    (122) case -> pattern _24_repeat do .
    [               reduce using rule 122 (case -> pattern _24_repeat do .)
    {               reduce using rule 122 (case -> pattern _24_repeat do .)
    TYPE_IDENTIFIER reduce using rule 122 (case -> pattern _24_repeat do .)
    END             reduce using rule 122 (case -> pattern _24_repeat do .)


state 194

    (125) _24_items -> _24_items _24_item .
    ,               reduce using rule 125 (_24_items -> _24_items _24_item .)
    DO              reduce using rule 125 (_24_items -> _24_items _24_item .)


state 195

    (127) _24_item -> , pattern .
    ,               reduce using rule 127 (_24_item -> , pattern .)
    DO              reduce using rule 127 (_24_item -> , pattern .)


state 196

    (131) array_pattern -> [ _25_repeat _26_optional . ]
    ]               shift and go to state 216


state 197

    (137) _26_optional -> SPREAD . identifier _27_repeat
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 217

state 198

    (134) _25_items -> _25_items _25_item .
    [               reduce using rule 134 (_25_items -> _25_items _25_item .)
    {               reduce using rule 134 (_25_items -> _25_items _25_item .)
    TYPE_IDENTIFIER reduce using rule 134 (_25_items -> _25_items _25_item .)
    SPREAD          reduce using rule 134 (_25_items -> _25_items _25_item .)
    ]               reduce using rule 134 (_25_items -> _25_items _25_item .)


state 199

    (136) _25_item -> pattern , .
    [               reduce using rule 136 (_25_item -> pattern , .)
    {               reduce using rule 136 (_25_item -> pattern , .)
    TYPE_IDENTIFIER reduce using rule 136 (_25_item -> pattern , .)
    SPREAD          reduce using rule 136 (_25_item -> pattern , .)
    ]               reduce using rule 136 (_25_item -> pattern , .)


state 200

    (152) tuple_pattern -> { _30_repeat _31_optional . }
    }               shift and go to state 218


state 201

    (158) _31_optional -> SPREAD . identifier _32_repeat
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 219

state 202

    (155) _30_items -> _30_items _30_item .
    [               reduce using rule 155 (_30_items -> _30_items _30_item .)
    {               reduce using rule 155 (_30_items -> _30_items _30_item .)
    TYPE_IDENTIFIER reduce using rule 155 (_30_items -> _30_items _30_item .)
    SPREAD          reduce using rule 155 (_30_items -> _30_items _30_item .)
    }               reduce using rule 155 (_30_items -> _30_items _30_item .)


state 203

    (157) _30_item -> pattern , .
    [               reduce using rule 157 (_30_item -> pattern , .)
    {               reduce using rule 157 (_30_item -> pattern , .)
    TYPE_IDENTIFIER reduce using rule 157 (_30_item -> pattern , .)
    SPREAD          reduce using rule 157 (_30_item -> pattern , .)
    }               reduce using rule 157 (_30_item -> pattern , .)


state 204

    (145) _28_optional -> ( pattern . _29_repeat )
    (146) _29_repeat -> . _29_items
    (147) _29_repeat -> .
    (148) _29_items -> . _29_items _29_item
    (149) _29_items -> . _29_item
    (150) _29_item -> . , pattern
    )               reduce using rule 147 (_29_repeat -> .)
    ,               shift and go to state 223

    _29_repeat                     shift and go to state 220
    _29_items                      shift and go to state 221
    _29_item                       shift and go to state 222

state 205

    (92) _if -> IF expr DO _18_repeat _19_repeat _20_optional . END
    END             shift and go to state 224


state 206

    (103) _20_optional -> ELSE . _21_repeat
    (104) _21_repeat -> . _21_items
    (105) _21_repeat -> .
    (106) _21_items -> . _21_items _21_item
    (107) _21_items -> . _21_item
    (108) _21_item -> . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    END             reduce using rule 105 (_21_repeat -> .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _21_repeat                     shift and go to state 225
    _21_items                      shift and go to state 226
    _21_item                       shift and go to state 227
    expr                           shift and go to state 228
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 207

    (100) _19_items -> _19_items _19_item .
    ELIF            reduce using rule 100 (_19_items -> _19_items _19_item .)
    ELSE            reduce using rule 100 (_19_items -> _19_items _19_item .)
    END             reduce using rule 100 (_19_items -> _19_items _19_item .)


state 208

    (110) _elif -> ELIF expr . DO _22_repeat
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
    DO              shift and go to state 229
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 209

    (37) _def -> DEF identifier ( _4_optional _5_repeat ) . _6_optional do
    (45) _6_optional -> . type
    (46) _6_optional -> .
    (47) type -> . : type_identifier _7_optional
    DO              reduce using rule 46 (_6_optional -> .)
    :               shift and go to state 50

    _6_optional                    shift and go to state 230
    type                           shift and go to state 231

state 210

    (42) _5_items -> _5_items _5_item .
    ,               reduce using rule 42 (_5_items -> _5_items _5_item .)
    )               reduce using rule 42 (_5_items -> _5_items _5_item .)


state 211

    (44) _5_item -> , param .
    ,               reduce using rule 44 (_5_item -> , param .)
    )               reduce using rule 44 (_5_item -> , param .)


state 212

    (82) _15_optional -> ( identifier . _16_repeat )
    (83) _16_repeat -> . _16_items
    (84) _16_repeat -> .
    (85) _16_items -> . _16_items _16_item
    (86) _16_items -> . _16_item
    (87) _16_item -> . , identifier
    )               reduce using rule 84 (_16_repeat -> .)
    ,               shift and go to state 235

    _16_repeat                     shift and go to state 232
    _16_items                      shift and go to state 233
    _16_item                       shift and go to state 234

state 213

    (48) _7_optional -> < identifier _8_repeat > .
    =               reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    (               reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    -               reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    {               reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    [               reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    CASE            reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    IF              reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    DEF             reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    NUMBER          reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    STRING          reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    IDENTIFIER      reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    DO              reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    END             reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    ,               reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    )               reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)
    }               reduce using rule 48 (_7_optional -> < identifier _8_repeat > .)


state 214

    (51) _8_items -> _8_items _8_item .
    ,               reduce using rule 51 (_8_items -> _8_items _8_item .)
    >               reduce using rule 51 (_8_items -> _8_items _8_item .)


state 215

    (53) _8_item -> , identifier .
    ,               reduce using rule 53 (_8_item -> , identifier .)
    >               reduce using rule 53 (_8_item -> , identifier .)


state 216

    (131) array_pattern -> [ _25_repeat _26_optional ] .
    ,               reduce using rule 131 (array_pattern -> [ _25_repeat _26_optional ] .)
    DO              reduce using rule 131 (array_pattern -> [ _25_repeat _26_optional ] .)
    )               reduce using rule 131 (array_pattern -> [ _25_repeat _26_optional ] .)
    ]               reduce using rule 131 (array_pattern -> [ _25_repeat _26_optional ] .)
    }               reduce using rule 131 (array_pattern -> [ _25_repeat _26_optional ] .)


state 217

    (137) _26_optional -> SPREAD identifier . _27_repeat
    (138) _27_repeat -> . _27_items
    (139) _27_repeat -> .
    (140) _27_items -> . _27_items _27_item
    (141) _27_items -> . _27_item
    (142) _27_item -> . , pattern
    ]               reduce using rule 139 (_27_repeat -> .)
    ,               shift and go to state 239

    _27_repeat                     shift and go to state 236
    _27_items                      shift and go to state 237
    _27_item                       shift and go to state 238

state 218

    (152) tuple_pattern -> { _30_repeat _31_optional } .
    ,               reduce using rule 152 (tuple_pattern -> { _30_repeat _31_optional } .)
    DO              reduce using rule 152 (tuple_pattern -> { _30_repeat _31_optional } .)
    )               reduce using rule 152 (tuple_pattern -> { _30_repeat _31_optional } .)
    ]               reduce using rule 152 (tuple_pattern -> { _30_repeat _31_optional } .)
    }               reduce using rule 152 (tuple_pattern -> { _30_repeat _31_optional } .)


state 219

    (158) _31_optional -> SPREAD identifier . _32_repeat
    (159) _32_repeat -> . _32_items
    (160) _32_repeat -> .
    (161) _32_items -> . _32_items _32_item
    (162) _32_items -> . _32_item
    (163) _32_item -> . , pattern
    }               reduce using rule 160 (_32_repeat -> .)
    ,               shift and go to state 243

    _32_repeat                     shift and go to state 240
    _32_items                      shift and go to state 241
    _32_item                       shift and go to state 242

state 220

    (145) _28_optional -> ( pattern _29_repeat . )
    )               shift and go to state 244


state 221

    (146) _29_repeat -> _29_items .
    (148) _29_items -> _29_items . _29_item
    (150) _29_item -> . , pattern
    )               reduce using rule 146 (_29_repeat -> _29_items .)
    ,               shift and go to state 223

    _29_item                       shift and go to state 245

state 222

    (149) _29_items -> _29_item .
    ,               reduce using rule 149 (_29_items -> _29_item .)
    )               reduce using rule 149 (_29_items -> _29_item .)


state 223

    (150) _29_item -> , . pattern
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    pattern                        shift and go to state 246
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 224

    (92) _if -> IF expr DO _18_repeat _19_repeat _20_optional END .
    INT_DIV         reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    *               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    /               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    -               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    +               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    CONCAT          reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    ENUM            reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    STRUCT          reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    (               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    {               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    [               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    CASE            reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    IF              reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    DEF             reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    NUMBER          reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    STRING          reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    IDENTIFIER      reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    DO              reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    $end            reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    ,               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    }               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    )               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    ]               reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    OF              reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    END             reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    ELIF            reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)
    ELSE            reduce using rule 92 (_if -> IF expr DO _18_repeat _19_repeat _20_optional END .)


state 225

    (103) _20_optional -> ELSE _21_repeat .
    END             reduce using rule 103 (_20_optional -> ELSE _21_repeat .)


state 226

    (104) _21_repeat -> _21_items .
    (106) _21_items -> _21_items . _21_item
    (108) _21_item -> . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    END             reduce using rule 104 (_21_repeat -> _21_items .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _21_item                       shift and go to state 247
    expr                           shift and go to state 228
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 227

    (107) _21_items -> _21_item .
    (               reduce using rule 107 (_21_items -> _21_item .)
    -               reduce using rule 107 (_21_items -> _21_item .)
    {               reduce using rule 107 (_21_items -> _21_item .)
    [               reduce using rule 107 (_21_items -> _21_item .)
    CASE            reduce using rule 107 (_21_items -> _21_item .)
    IF              reduce using rule 107 (_21_items -> _21_item .)
    DEF             reduce using rule 107 (_21_items -> _21_item .)
    NUMBER          reduce using rule 107 (_21_items -> _21_item .)
    STRING          reduce using rule 107 (_21_items -> _21_item .)
    IDENTIFIER      reduce using rule 107 (_21_items -> _21_item .)
    DO              reduce using rule 107 (_21_items -> _21_item .)
    END             reduce using rule 107 (_21_items -> _21_item .)


state 228

    (108) _21_item -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for - resolved as shift
    (               reduce using rule 108 (_21_item -> expr .)
    {               reduce using rule 108 (_21_item -> expr .)
    [               reduce using rule 108 (_21_item -> expr .)
    CASE            reduce using rule 108 (_21_item -> expr .)
    IF              reduce using rule 108 (_21_item -> expr .)
    DEF             reduce using rule 108 (_21_item -> expr .)
    NUMBER          reduce using rule 108 (_21_item -> expr .)
    STRING          reduce using rule 108 (_21_item -> expr .)
    IDENTIFIER      reduce using rule 108 (_21_item -> expr .)
    DO              reduce using rule 108 (_21_item -> expr .)
    END             reduce using rule 108 (_21_item -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 229

    (110) _elif -> ELIF expr DO . _22_repeat
    (111) _22_repeat -> . _22_items
    (112) _22_repeat -> .
    (113) _22_items -> . _22_items _22_item
    (114) _22_items -> . _22_item
    (115) _22_item -> . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    ELIF            reduce using rule 112 (_22_repeat -> .)
    ELSE            reduce using rule 112 (_22_repeat -> .)
    END             reduce using rule 112 (_22_repeat -> .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    expr                           shift and go to state 248
    _22_repeat                     shift and go to state 249
    _22_items                      shift and go to state 250
    _22_item                       shift and go to state 251
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 230

    (37) _def -> DEF identifier ( _4_optional _5_repeat ) _6_optional . do
    (29) do -> . DO _2_optional _3_repeat END
    DO              shift and go to state 29

    do                             shift and go to state 252

state 231

    (45) _6_optional -> type .
    DO              reduce using rule 45 (_6_optional -> type .)


state 232

    (82) _15_optional -> ( identifier _16_repeat . )
    )               shift and go to state 253


state 233

    (83) _16_repeat -> _16_items .
    (85) _16_items -> _16_items . _16_item
    (87) _16_item -> . , identifier
    )               reduce using rule 83 (_16_repeat -> _16_items .)
    ,               shift and go to state 235

    _16_item                       shift and go to state 254

state 234

    (86) _16_items -> _16_item .
    ,               reduce using rule 86 (_16_items -> _16_item .)
    )               reduce using rule 86 (_16_items -> _16_item .)


state 235

    (87) _16_item -> , . identifier
    (190) identifier -> . IDENTIFIER
    IDENTIFIER      shift and go to state 33

    identifier                     shift and go to state 255

state 236

    (137) _26_optional -> SPREAD identifier _27_repeat .
    ]               reduce using rule 137 (_26_optional -> SPREAD identifier _27_repeat .)


state 237

    (138) _27_repeat -> _27_items .
    (140) _27_items -> _27_items . _27_item
    (142) _27_item -> . , pattern
    ]               reduce using rule 138 (_27_repeat -> _27_items .)
    ,               shift and go to state 239

    _27_item                       shift and go to state 256

state 238

    (141) _27_items -> _27_item .
    ,               reduce using rule 141 (_27_items -> _27_item .)
    ]               reduce using rule 141 (_27_items -> _27_item .)


state 239

    (142) _27_item -> , . pattern
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    pattern                        shift and go to state 257
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 240

    (158) _31_optional -> SPREAD identifier _32_repeat .
    }               reduce using rule 158 (_31_optional -> SPREAD identifier _32_repeat .)


state 241

    (159) _32_repeat -> _32_items .
    (161) _32_items -> _32_items . _32_item
    (163) _32_item -> . , pattern
    }               reduce using rule 159 (_32_repeat -> _32_items .)
    ,               shift and go to state 243

    _32_item                       shift and go to state 258

state 242

    (162) _32_items -> _32_item .
    ,               reduce using rule 162 (_32_items -> _32_item .)
    }               reduce using rule 162 (_32_items -> _32_item .)


state 243

    (163) _32_item -> , . pattern
    (128) pattern -> . array_pattern
    (129) pattern -> . tuple_pattern
    (130) pattern -> . enum_pattern
    (131) array_pattern -> . [ _25_repeat _26_optional ]
    (152) tuple_pattern -> . { _30_repeat _31_optional }
    (144) enum_pattern -> . type_identifier _28_optional
    (191) type_identifier -> . TYPE_IDENTIFIER
    [               shift and go to state 107
    {               shift and go to state 108
    TYPE_IDENTIFIER shift and go to state 42

    pattern                        shift and go to state 259
    array_pattern                  shift and go to state 104
    tuple_pattern                  shift and go to state 105
    enum_pattern                   shift and go to state 106
    type_identifier                shift and go to state 109

state 244

    (145) _28_optional -> ( pattern _29_repeat ) .
    ,               reduce using rule 145 (_28_optional -> ( pattern _29_repeat ) .)
    DO              reduce using rule 145 (_28_optional -> ( pattern _29_repeat ) .)
    )               reduce using rule 145 (_28_optional -> ( pattern _29_repeat ) .)
    ]               reduce using rule 145 (_28_optional -> ( pattern _29_repeat ) .)
    }               reduce using rule 145 (_28_optional -> ( pattern _29_repeat ) .)


state 245

    (148) _29_items -> _29_items _29_item .
    ,               reduce using rule 148 (_29_items -> _29_items _29_item .)
    )               reduce using rule 148 (_29_items -> _29_items _29_item .)


state 246

    (150) _29_item -> , pattern .
    ,               reduce using rule 150 (_29_item -> , pattern .)
    )               reduce using rule 150 (_29_item -> , pattern .)


state 247

    (106) _21_items -> _21_items _21_item .
    (               reduce using rule 106 (_21_items -> _21_items _21_item .)
    -               reduce using rule 106 (_21_items -> _21_items _21_item .)
    {               reduce using rule 106 (_21_items -> _21_items _21_item .)
    [               reduce using rule 106 (_21_items -> _21_items _21_item .)
    CASE            reduce using rule 106 (_21_items -> _21_items _21_item .)
    IF              reduce using rule 106 (_21_items -> _21_items _21_item .)
    DEF             reduce using rule 106 (_21_items -> _21_items _21_item .)
    NUMBER          reduce using rule 106 (_21_items -> _21_items _21_item .)
    STRING          reduce using rule 106 (_21_items -> _21_items _21_item .)
    IDENTIFIER      reduce using rule 106 (_21_items -> _21_items _21_item .)
    DO              reduce using rule 106 (_21_items -> _21_items _21_item .)
    END             reduce using rule 106 (_21_items -> _21_items _21_item .)


state 248

    (115) _22_item -> expr .
    (23) binary_expr -> expr . INT_DIV expr
    (24) binary_expr -> expr . * expr
    (25) binary_expr -> expr . / expr
    (26) binary_expr -> expr . - expr
    (27) binary_expr -> expr . + expr
    (28) binary_expr -> expr . CONCAT expr
  ! shift/reduce conflict for - resolved as shift
    (               reduce using rule 115 (_22_item -> expr .)
    {               reduce using rule 115 (_22_item -> expr .)
    [               reduce using rule 115 (_22_item -> expr .)
    CASE            reduce using rule 115 (_22_item -> expr .)
    IF              reduce using rule 115 (_22_item -> expr .)
    DEF             reduce using rule 115 (_22_item -> expr .)
    NUMBER          reduce using rule 115 (_22_item -> expr .)
    STRING          reduce using rule 115 (_22_item -> expr .)
    IDENTIFIER      reduce using rule 115 (_22_item -> expr .)
    DO              reduce using rule 115 (_22_item -> expr .)
    ELIF            reduce using rule 115 (_22_item -> expr .)
    ELSE            reduce using rule 115 (_22_item -> expr .)
    END             reduce using rule 115 (_22_item -> expr .)
    INT_DIV         shift and go to state 35
    *               shift and go to state 36
    /               shift and go to state 37
    -               shift and go to state 38
    +               shift and go to state 39
    CONCAT          shift and go to state 40


state 249

    (110) _elif -> ELIF expr DO _22_repeat .
    ELIF            reduce using rule 110 (_elif -> ELIF expr DO _22_repeat .)
    ELSE            reduce using rule 110 (_elif -> ELIF expr DO _22_repeat .)
    END             reduce using rule 110 (_elif -> ELIF expr DO _22_repeat .)


state 250

    (111) _22_repeat -> _22_items .
    (113) _22_items -> _22_items . _22_item
    (115) _22_item -> . expr
    (10) expr -> . ( expr )
    (11) expr -> . - expr
    (12) expr -> . tuple
    (13) expr -> . array
    (14) expr -> . binary_expr
    (15) expr -> . variable_declaration
    (16) expr -> . case_of
    (17) expr -> . call
    (18) expr -> . _if
    (19) expr -> . _def
    (20) expr -> . literal
    (21) expr -> . identifier
    (22) expr -> . do
    (173) tuple -> . { _35_optional _36_repeat }
    (165) array -> . [ _33_optional _34_repeat ]
    (23) binary_expr -> . expr INT_DIV expr
    (24) binary_expr -> . expr * expr
    (25) binary_expr -> . expr / expr
    (26) binary_expr -> . expr - expr
    (27) binary_expr -> . expr + expr
    (28) binary_expr -> . expr CONCAT expr
    (192) variable_declaration -> . identifier _39_optional = expr
    (116) case_of -> . CASE expr OF case _23_repeat END
    (181) call -> . callee ( _37_optional _38_repeat )
    (92) _if -> . IF expr DO _18_repeat _19_repeat _20_optional END
    (37) _def -> . DEF identifier ( _4_optional _5_repeat ) _6_optional do
    (195) literal -> . NUMBER
    (196) literal -> . STRING
    (190) identifier -> . IDENTIFIER
    (29) do -> . DO _2_optional _3_repeat END
    (189) callee -> . identifier
    ELIF            reduce using rule 111 (_22_repeat -> _22_items .)
    ELSE            reduce using rule 111 (_22_repeat -> _22_items .)
    END             reduce using rule 111 (_22_repeat -> _22_items .)
    (               shift and go to state 12
    -               shift and go to state 13
    {               shift and go to state 10
    [               shift and go to state 25
    CASE            shift and go to state 26
    IF              shift and go to state 28
    DEF             shift and go to state 30
    NUMBER          shift and go to state 31
    STRING          shift and go to state 32
    IDENTIFIER      shift and go to state 33
    DO              shift and go to state 29

    _22_item                       shift and go to state 260
    expr                           shift and go to state 248
    tuple                          shift and go to state 14
    array                          shift and go to state 15
    binary_expr                    shift and go to state 16
    variable_declaration           shift and go to state 17
    case_of                        shift and go to state 18
    call                           shift and go to state 19
    _if                            shift and go to state 20
    _def                           shift and go to state 21
    literal                        shift and go to state 22
    identifier                     shift and go to state 23
    do                             shift and go to state 24
    callee                         shift and go to state 27

state 251

    (114) _22_items -> _22_item .
    (               reduce using rule 114 (_22_items -> _22_item .)
    -               reduce using rule 114 (_22_items -> _22_item .)
    {               reduce using rule 114 (_22_items -> _22_item .)
    [               reduce using rule 114 (_22_items -> _22_item .)
    CASE            reduce using rule 114 (_22_items -> _22_item .)
    IF              reduce using rule 114 (_22_items -> _22_item .)
    DEF             reduce using rule 114 (_22_items -> _22_item .)
    NUMBER          reduce using rule 114 (_22_items -> _22_item .)
    STRING          reduce using rule 114 (_22_items -> _22_item .)
    IDENTIFIER      reduce using rule 114 (_22_items -> _22_item .)
    DO              reduce using rule 114 (_22_items -> _22_item .)
    ELIF            reduce using rule 114 (_22_items -> _22_item .)
    ELSE            reduce using rule 114 (_22_items -> _22_item .)
    END             reduce using rule 114 (_22_items -> _22_item .)


state 252

    (37) _def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .
    INT_DIV         reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    *               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    /               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    -               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    +               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    CONCAT          reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    ENUM            reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    STRUCT          reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    (               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    {               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    [               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    CASE            reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    IF              reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    DEF             reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    NUMBER          reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    STRING          reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    IDENTIFIER      reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    DO              reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    $end            reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    ,               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    }               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    )               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    ]               reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    OF              reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    END             reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    ELIF            reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)
    ELSE            reduce using rule 37 (_def -> DEF identifier ( _4_optional _5_repeat ) _6_optional do .)


state 253

    (82) _15_optional -> ( identifier _16_repeat ) .
    IDENTIFIER      reduce using rule 82 (_15_optional -> ( identifier _16_repeat ) .)
    }               reduce using rule 82 (_15_optional -> ( identifier _16_repeat ) .)


state 254

    (85) _16_items -> _16_items _16_item .
    ,               reduce using rule 85 (_16_items -> _16_items _16_item .)
    )               reduce using rule 85 (_16_items -> _16_items _16_item .)


state 255

    (87) _16_item -> , identifier .
    ,               reduce using rule 87 (_16_item -> , identifier .)
    )               reduce using rule 87 (_16_item -> , identifier .)


state 256

    (140) _27_items -> _27_items _27_item .
    ,               reduce using rule 140 (_27_items -> _27_items _27_item .)
    ]               reduce using rule 140 (_27_items -> _27_items _27_item .)


state 257

    (142) _27_item -> , pattern .
    ,               reduce using rule 142 (_27_item -> , pattern .)
    ]               reduce using rule 142 (_27_item -> , pattern .)


state 258

    (161) _32_items -> _32_items _32_item .
    ,               reduce using rule 161 (_32_items -> _32_items _32_item .)
    }               reduce using rule 161 (_32_items -> _32_items _32_item .)


state 259

    (163) _32_item -> , pattern .
    ,               reduce using rule 163 (_32_item -> , pattern .)
    }               reduce using rule 163 (_32_item -> , pattern .)


state 260

    (113) _22_items -> _22_items _22_item .
    (               reduce using rule 113 (_22_items -> _22_items _22_item .)
    -               reduce using rule 113 (_22_items -> _22_items _22_item .)
    {               reduce using rule 113 (_22_items -> _22_items _22_item .)
    [               reduce using rule 113 (_22_items -> _22_items _22_item .)
    CASE            reduce using rule 113 (_22_items -> _22_items _22_item .)
    IF              reduce using rule 113 (_22_items -> _22_items _22_item .)
    DEF             reduce using rule 113 (_22_items -> _22_items _22_item .)
    NUMBER          reduce using rule 113 (_22_items -> _22_items _22_item .)
    STRING          reduce using rule 113 (_22_items -> _22_items _22_item .)
    IDENTIFIER      reduce using rule 113 (_22_items -> _22_items _22_item .)
    DO              reduce using rule 113 (_22_items -> _22_items _22_item .)
    ELIF            reduce using rule 113 (_22_items -> _22_items _22_item .)
    ELSE            reduce using rule 113 (_22_items -> _22_items _22_item .)
    END             reduce using rule 113 (_22_items -> _22_items _22_item .)


Conflicts:

shift/reduce conflict for - in state 8 resolved as shift
shift/reduce conflict for - in state 87 resolved as shift
shift/reduce conflict for INT_DIV in state 96 resolved as shift
shift/reduce conflict for * in state 96 resolved as shift
shift/reduce conflict for / in state 96 resolved as shift
shift/reduce conflict for - in state 96 resolved as shift
shift/reduce conflict for + in state 96 resolved as shift
shift/reduce conflict for CONCAT in state 96 resolved as shift
shift/reduce conflict for - in state 114 resolved as shift
shift/reduce conflict for - in state 228 resolved as shift
shift/reduce conflict for - in state 248 resolved as shift
reduce/reduce conflict in state 23 resolved using rule expr -> identifier
rejected rule (callee -> identifier) in state 23
Rule (callee -> identifier) is never reduced