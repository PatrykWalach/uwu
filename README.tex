% !TeX root = README.tex
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{minted}


% \usemintedstyle{one-dark}
% \setminted{bgcolor=mygray}

\setminted{linenos=true}

\title{Tytuł}
\author{Patryk Wałach}
\date{January 2022}

\begin{document}



\maketitle

\section{[Wstęp]}

\section{Ogólne wprowadzenie}
\subsection{Parsowanie i tokenkizowanie}
\subsection{Co to typy?}
\section{Inferencja typów w teori}
\subsection{System typów Hindley–Milner}
\subsection{Algorytm W}
\section{Rescript/ReasonML jako języki realizujące podobne zadania}
\newpage
\section{Założenia i priorytety opracowanej aplikacji}
Tworząc aplikację, chciałem, by język posiadał podstawowe typy danych (liczby, stringi, wartość logiczna), kilka typów generycznych (funkcje, tablice), typ `Option', oraz możliwość tworzenia własnych typów.
Dodatkowo nie powinno być potrzeby podawania typów zmiennych w większości przypadków, kompilator sam powinien wykrywać typy zmiennych na podstawie ich użycia.


Język poza zmiennymi, potrzebuje możliwości wykonywania operacji na danych, dlatego ważne było dla mnie, by zaimplementować operatory binarane, oraz unarne. Operatory te miały też spełniać ważną rolą w trakcie inferencji typów. W języku javascript operator `+' może być wykorzystywany do dodawania liczb jak i konkatenacji stringów, ważne więc było by stworzyć dwa oddzielne operatory.

Prymitywne typy danych:
\begin{itemize}
  \item string
        \inputminted{uwu.py -x}{examples/string.uwu}
        Do konkatenacji stringów służy operator \mintinline{uwu.py -x}{++}
  \item Wartość logiczna ma typ \mintinline{uwu.py -x}{Bool} i wartość \mintinline{uwu.py -x}!True! lub \mintinline{uwu.py -x}{False}.
        Powiązane operacje:
        \begin{itemize}
          \item \mintinline{uwu.py -x}{<>}, równość pomiędzy dwiema liczbami
          \item \mintinline{uwu.py -x}{>}, \mintinline{uwu.py -x}{}!
          \item \mintinline{uwu.py -x}{!=} równość
        \end{itemize}
  \item liczby
        Powiązane operacje: \mintinline{uwu.py -x}{+}, \mintinline{uwu.py -x}{-}, \mintinline{uwu.py -x}{*}, \mintinline{uwu.py -x}{/}, \mintinline{uwu.py -x}{*}, \mintinline{uwu.py -x}{}, \mintinline{uwu.py -x}{//}
\end{itemize}

\newpage
Chciałem również by funkcje wieloargumentowe kompilowane były jako funkcje jednoargumentowe zwracające kolejne funkcje, co pozwala na wywoływanie funkcji bez wszystkich argumentów w celu zwrócenia funkcji przyjmującej resztę argumentów tzw. currying.

\inputminted[firstline=15]{uwu.py -x}{examples/currying.uwu}
\inputminted[firstline=15]{javascript}{examples/currying.uwu.js}


Jednym z ważniejszych elemenów każdego języka jest możliwość wykonywania różnego zbioru instrukcji, warunkowo. W tym celu planowałem zaimplementowanie instrukcji `if', oraz `case'. Instrukcja `case' wykonywać ma dopasowanie do wzorca (tzw. pattern-matching), wykonywać, odpowiedni zbiór instrukcji zależnie od wprowadzonych danych. Kompilator, powinien ostrzegać, jeżeli ścieżka dla jednego z typów danych nie została zaimplementowana.

\begin{itemize}
  \newpage
  \item Przykład - funkcja łącząca dwie posortowane tablice
        \inputminted[firstline=25]{uwu.py -x}{examples/merge.uwu}
        \inputminted[firstline=20]{javascript}{examples/merge.uwu.js}
\end{itemize}


\newpage
Kolejnym dość ważnym elementem języka jest brak wyrażenia `return', które jest wykorzystywane do zwrócenia wartości z funkcji. Zamiast tego każdy bloku instrukcji powinien zwracać ostatnie wyrażenie. Pozwoli to na łatwiejsze inicjowanie zmiennych, w przypadku gdy inicializacja wymaga więcej niż jedenej linii kodu.


\begin{itemize}
  \item Przykład
        \inputminted[firstline=15]{uwu.py -x}{examples/return.uwu}
        \inputminted[firstline=15]{javascript}{examples/return.uwu.js}
\end{itemize}
\subsection{Opis formaly składni języka}
%  notacja wirta
\section{Narzędzia}
\subsection{Język python}
\subsection{Parsowanie i tokenizowanie przy użyciu biblioteki sly}
\subsection{Środowisko nodejs do uruchomienia skompilowanego kodu}
\section{Implementacja}
\subsection{lexer}
\subsection{parser}
\subsection{inferencja typów}
\subsection{kompilacja}
\section{Opis działania}
\subsection{Co działa}
\subsection{Uwagi co do obsługi błędów}
\section{[Podsumowanie]}
\section{[spisy -- rysunków, tabel, listingów ipt.]}


% \cite{texbook}
% \bibitem{texbook}

\end{document}


