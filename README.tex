% !TeX root = README.tex
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{listings}
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
\lstset{
  language=JavaScript,
  extendedchars=true,
  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,
  showspaces=false,
  numbers=left,
  numberstyle=\footnotesize,
  numbersep=9pt,
  tabsize=2,
  breaklines=true,
  showtabs=false,
  captionpos=b
  }

\title{Tytuł}
\author{Patryk Wałach}
\date{January 2022}

\begin{document}

\maketitle

\section{[Wstęp]}

\section{Ogólne wprowadzenie}
\subsection{Parsowanie i tokenkizowanie}
Tokenizowanie polega na podzieleniu ciągu znaków na tokeny poprzez matchowania początku ciągu za pomocą wyrażeń regularnych różnych typów.
\subsection{Co to typy?}
\section{Inferencja typów w teori}
\subsection{System typów Hindley–Milner}
\subsection{Algorytm W}
\section{Rescript/ReasonML jako języki realizujące podobne zadania}
\newpage
\section{Założenia i priorytety opracowanej aplikacji}
Tworząc aplikację, chciałem, by język posiadał podstawowe typy danych (liczby, stringi, wartość logiczna), kilka typów generycznych (funkcje, tablice), typ `Option', oraz możliwość tworzenia własnych typów.
Dodatkowo nie powinno być potrzeby podawania typów zmiennych w większości przypadków, kompilator sam powinien wykrywać typy zmiennych na podstawie ich użycia.


Język poza zmiennymi, potrzebuje możliwości wykonywania operacji na danych, dlatego ważne było dla mnie, by zaimplementować operatory binarane, oraz unarne. Operatory te miały też spełniać ważną rolą w trakcie inferencji typów. W języku javascript operator `+' może być wykorzystywany do dodawania liczb jak i konkatenacji stringów, ważne więc było by stworzyć dwa oddzielne operatory.

Prymitywne typy danych:
\begin{itemize}
  \item string
  \lstinputlisting{examples/string.uwu}
  Do konkatenacji stringów służy operator \lstinline!++!
  \item Wartość logiczna ma typ \lstinline!Bool! i wartość \lstinline!True! lub \lstinline!False!.
  Powiązane operacje:
    \begin{itemize}
      \item \lstinline!<>!, równość pomiędzy dwiema liczbami
      \item \lstinline!>!, \lstinline!<!
      \item \lstinline|!=| równość
    \end{itemize}
    \item liczby
    Powiązane operacje: \lstinline!+!, \lstinline!-!, \lstinline!*!, \lstinline!/!, \lstinline!*!, \lstinline!%!, \lstinline!//!
\end{itemize}

% typing.Literal["|", "!=", "=="]

\newpage
Chciałem również by funkcje wieloargumentowe kompilowane były jako funkcje jednoargumentowe zwracające kolejne funkcje, co pozwala na wywoływanie funkcji bez wszystkich argumentów w celu zwrócenia funkcji przyjmującej resztę argumentów tzw. currying.

\lstinputlisting[firstline=15]{examples/currying.uwu}
\lstinputlisting[firstline=15]{examples/currying.uwu.js}


Jednym z ważniejszych elemenów każdego języka jest możliwość wykonywania różnego zbioru instrukcji, warunkowo. W tym celu planowałem zaimplementowanie instrukcji `if', oraz `case'. Instrukcja `case' wykonywać ma dopasowanie do wzorca (tzw. pattern-matching), wykonywać, odpowiedni zbiór instrukcji zależnie od wprowadzonych danych. Kompilator, powinien ostrzegać, jeżeli ścieżka dla jednego z typów danych nie została zaimplementowana.

\begin{itemize}
  \newpage
  \item Przykład - funkcja łącząca dwie posortowane tablice
        \lstinputlisting[firstline=25]{examples/merge.uwu}
        \lstinputlisting[firstline=20]{examples/merge.uwu.js}
\end{itemize}

\newpage
Kolejnym dość ważnym elementem języka jest brak wyrażenia `return', które jest wykorzystywane do zwrócenia wartości z funkcji. Zamiast tego każdy bloku instrukcji powinien zwracać ostatnie wyrażenie. Pozwoli to na łatwiejsze inicjowanie zmiennych, w przypadku gdy inicializacja wymaga więcej niż jedenej linii kodu.


\begin{itemize}
  \item Przykład
  % \begin{minted}{pygments.py:UwUPygments -x}
    \lstinputlisting[firstline=15]{examples/return.uwu}
    \lstinputlisting[firstline=15]{examples/return.uwu.js}
\end{itemize}
\subsection{Opis formaly składni języka}
%  notacja wirta
\section{Narzędzia}
\subsection{Język python}
\subsection{Parsowanie i tokenizowanie przy użyciu biblioteki sly}
\subsection{Środowisko nodejs do uruchomienia skompilowanego kodu}
\section{Implementacja}
\subsection{lexer}
\subsection{parser}
\subsection{inferencja typów}
\subsection{kompilacja}
\section{Opis działania}
\subsection{Co działa}
\subsection{Uwagi co do obsługi błędów}
\section{[Podsumowanie]}
\section{[spisy -- rysunków, tabel, listingów ipt.]}


% \cite{texbook}
% \bibitem{texbook}

\end{document}


